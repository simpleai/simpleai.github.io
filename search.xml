<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BigDecimal精度</title>
    <url>/2021/06/10/BigDecimal%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<p>BigDecimal精度</p>
<span id="more"></span>
<h1 id="BigDecimal精度"><a href="#BigDecimal精度" class="headerlink" title="BigDecimal精度"></a>BigDecimal精度</h1><p>丢失精度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new BigDecimal(12.10)；</span><br></pre></td></tr></table></figure>

<p>不丢失精度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new BigDecimal(&quot;12.10&quot;)；</span><br></pre></td></tr></table></figure>

<p>错误使用：</p>
<p>double存储时已经丢失精度了。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oWazuIEJ79BDpxC.png" alt="image-20210115142405701"></p>
<p>正确使用：</p>
<p>double转string</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Double d = new Double(5.1);</span><br><span class="line">String s = d.toString();</span><br><span class="line">BigDecimal b = new BigDecimal(s);</span><br></pre></td></tr></table></figure>

<p>保留1位小数，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bigDecimal.setScale(1,BigDecimal.ROUND_HALF_UP)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>BigDecimal精度</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>BootStrap-Table-树</title>
    <url>/2020/07/27/Bootstrap-table-%E6%A0%91/</url>
    <content><![CDATA[<p>BootStrap-Table树形显示，包含js请求后端的代码</p>
<span id="more"></span>

<h1 id="BootStrap-Table-树"><a href="#BootStrap-Table-树" class="headerlink" title="BootStrap-Table-树"></a>BootStrap-Table-树</h1><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WVJLnlT3ZRU4or5.png" alt="image-20200729155605576"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cn&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width,initial-scale=1.0&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;</span><br><span class="line">    &lt;title&gt;系统管理&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap-table/1.11.1/bootstrap-table.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/css/jquery.treegrid.min.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h1&gt;树形表格 ： Table Treegrid&lt;/h1&gt;</span><br><span class="line">    &lt;table id=&quot;table&quot;&gt;&lt;/table&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;button onclick=&quot;test()&quot;&gt;选择&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.1/bootstrap-table.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.0/extensions/treegrid/bootstrap-table-treegrid.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/js/jquery.treegrid.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var $table = $(&#x27;#table&#x27;);</span><br><span class="line">    var data = JSON.parse(</span><br><span class="line">        &#x27;[&#123;&quot;id&quot;:1,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;用户管理&quot;,&quot;permissionValue&quot;:&quot;open:user:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:2,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;系统管理&quot;,&quot;permissionValue&quot;:&quot;open:system:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:3,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;新增用户&quot;,&quot;permissionValue&quot;:&quot;open:user:add&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:4,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;修改用户&quot;,&quot;permissionValue&quot;:&quot;open:user:edit&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:5,&quot;pid&quot;:1,&quot;status&quot;:0,&quot;name&quot;:&quot;删除用户&quot;,&quot;permissionValue&quot;:&quot;open:user:del&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:6,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统配置管理&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:7,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;新增配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:add&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:8,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;修改配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:edit&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:9,&quot;pid&quot;:6,&quot;status&quot;:0,&quot;name&quot;:&quot;删除配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:del&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:10,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统日志管理&quot;,&quot;permissionValue&quot;:&quot;open:log:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:11,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;新增日志&quot;,&quot;permissionValue&quot;:&quot;open:log:add&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:12,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;修改日志&quot;,&quot;permissionValue&quot;:&quot;open:log:edit&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:13,&quot;pid&quot;:10,&quot;status&quot;:0,&quot;name&quot;:&quot;删除日志&quot;,&quot;permissionValue&quot;:&quot;open:log:del&quot;&#125;]&#x27;);</span><br><span class="line"></span><br><span class="line">    $(function() &#123;</span><br><span class="line"></span><br><span class="line">        //控制台输出一下数据</span><br><span class="line">        console.log(data);</span><br><span class="line"></span><br><span class="line">        $table.bootstrapTable(&#123;</span><br><span class="line">            data:data,</span><br><span class="line">            idField: &#x27;id&#x27;,</span><br><span class="line">            dataType:&#x27;jsonp&#x27;,//json也可以</span><br><span class="line">			/*访问后台 访问后端时不需要data属性</span><br><span class="line">			responseHandler: function(res) &#123;</span><br><span class="line">				console.log(res);</span><br><span class="line">				if (res.meta.code == 200) &#123;</span><br><span class="line">					var mydata = res.data.menuTree;</span><br><span class="line">					return &#123;</span><br><span class="line">						&quot;data&quot;: mydata//注意这里</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;,</span><br><span class="line">			*/</span><br><span class="line">            columns: [</span><br><span class="line">                &#123; field: &#x27;check&#x27;,  checkbox: true, formatter: function (value, row, index) &#123;</span><br><span class="line">                        if (row.check == true) &#123;</span><br><span class="line">                           // console.log(row.serverName);</span><br><span class="line">                            //设置选中</span><br><span class="line">                            return &#123;  checked: true &#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123; field: &#x27;name&#x27;,  title: &#x27;名称&#x27; &#125;,</span><br><span class="line">               // &#123;field: &#x27;id&#x27;, title: &#x27;编号&#x27;, sortable: true, align: &#x27;center&#x27;&#125;,</span><br><span class="line">               // &#123;field: &#x27;pid&#x27;, title: &#x27;所属上级&#x27;&#125;,</span><br><span class="line">                &#123; field: &#x27;status&#x27;,  title: &#x27;状态&#x27;, sortable: true,  align: &#x27;center&#x27;, formatter: &#x27;statusFormatter&#x27;  &#125;,</span><br><span class="line">                &#123; field: &#x27;permissionValue&#x27;, title: &#x27;权限值&#x27;  &#125;,</span><br><span class="line">                &#123; field: &#x27;operate&#x27;, title: &#x27;操作&#x27;, align: &#x27;center&#x27;, events : operateEvents, formatter: &#x27;operateFormatter&#x27; &#125;,</span><br><span class="line">            ],</span><br><span class="line"></span><br><span class="line">            // bootstrap-table-treegrid.js 插件配置 -- start</span><br><span class="line"></span><br><span class="line">            //在哪一列展开树形</span><br><span class="line">            treeShowField: &#x27;name&#x27;,</span><br><span class="line">            //指定父id列</span><br><span class="line">            parentIdField: &#x27;pid&#x27;,//pid&gt;=0 小于0时不显示</span><br><span class="line">            </span><br><span class="line">            onResetView: function(data) &#123;</span><br><span class="line">                //console.log(&#x27;load&#x27;);</span><br><span class="line">                $table.treegrid(&#123;</span><br><span class="line">                    initialState: &#x27;collapsed&#x27;,// 所有节点都折叠</span><br><span class="line">                    // initialState: &#x27;expanded&#x27;,// 所有节点都展开，默认展开</span><br><span class="line">                    treeColumn: 1,//第几列折叠</span><br><span class="line">                    // expanderExpandedClass: &#x27;glyphicon glyphicon-minus&#x27;,  //图标样式</span><br><span class="line">                    // expanderCollapsedClass: &#x27;glyphicon glyphicon-plus&#x27;,</span><br><span class="line">                    onChange: function() &#123;</span><br><span class="line">                        $table.bootstrapTable(&#x27;resetWidth&#x27;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                //只展开树形的第一级节点</span><br><span class="line">                $table.treegrid(&#x27;getRootNodes&#x27;).treegrid(&#x27;expand&#x27;);</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            onCheck:function(row)&#123;</span><br><span class="line">                var datas = $table.bootstrapTable(&#x27;getData&#x27;);</span><br><span class="line">                // 勾选子类</span><br><span class="line">                selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,true);</span><br><span class="line"></span><br><span class="line">                // 勾选父类</span><br><span class="line">                selectParentChecked(datas,row,&quot;id&quot;,&quot;pid&quot;)</span><br><span class="line"></span><br><span class="line">                // 刷新数据</span><br><span class="line">                $table.bootstrapTable(&#x27;load&#x27;, datas);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            //onUncheck:function(row)&#123;</span><br><span class="line">            //    var datas = $table.bootstrapTable(&#x27;getData&#x27;);</span><br><span class="line">            //    selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,false);</span><br><span class="line">            //    $table.bootstrapTable(&#x27;load&#x27;, datas);</span><br><span class="line">            //&#125;,</span><br><span class="line">            // bootstrap-table-treetreegrid.js 插件配置 -- end</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 格式化按钮</span><br><span class="line">    function operateFormatter(value, row, index) &#123;</span><br><span class="line">        return [</span><br><span class="line">            &#x27;&lt;button type=&quot;button&quot; class=&quot;RoleOfadd btn-small  btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; &gt;&lt;/i&gt;&amp;nbsp;新增&lt;/button&gt;&#x27;,</span><br><span class="line">            &#x27;&lt;button type=&quot;button&quot; class=&quot;RoleOfedit btn-small   btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-pencil-square-o&quot; &gt;&lt;/i&gt;&amp;nbsp;修改&lt;/button&gt;&#x27;,</span><br><span class="line">            &#x27;&lt;button type=&quot;button&quot; class=&quot;RoleOfdelete btn-small   btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot; &gt;&lt;/i&gt;&amp;nbsp;删除&lt;/button&gt;&#x27;</span><br><span class="line">        ].join(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 格式化类型</span><br><span class="line">    function typeFormatter(value, row, index) &#123;</span><br><span class="line">        if (value === &#x27;menu&#x27;) &#123;  return &#x27;菜单&#x27;;  &#125;</span><br><span class="line">        if (value === &#x27;button&#x27;) &#123;  return &#x27;按钮&#x27;; &#125;</span><br><span class="line">        if (value === &#x27;api&#x27;) &#123;  return &#x27;接口&#x27;; &#125;</span><br><span class="line">        return &#x27;-&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 格式化状态</span><br><span class="line">    function statusFormatter(value, row, index) &#123;</span><br><span class="line">        if (value === 1) &#123;</span><br><span class="line">            return &#x27;&lt;span class=&quot;label label-success&quot;&gt;正常&lt;/span&gt;&#x27;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#x27;&lt;span class=&quot;label label-default&quot;&gt;锁定&lt;/span&gt;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化操作按钮的方法</span><br><span class="line">    window.operateEvents = &#123;</span><br><span class="line">        &#x27;click .RoleOfadd&#x27;: function (e, value, row, index) &#123;</span><br><span class="line">            add(row.id);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;click .RoleOfdelete&#x27;: function (e, value, row, index) &#123;</span><br><span class="line">            del(row.id);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;click .RoleOfedit&#x27;: function (e, value, row, index) &#123;</span><br><span class="line">            update(row.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /**</span><br><span class="line">     * 选中父项时，同时选中子项</span><br><span class="line">     * @param datas 所有的数据</span><br><span class="line">     * @param row 当前数据</span><br><span class="line">     * @param id id 字段名</span><br><span class="line">     * @param pid 父id字段名</span><br><span class="line">     */</span><br><span class="line">    function selectChilds(datas,row,id,pid,checked) &#123;</span><br><span class="line">        for(var i in datas)&#123;</span><br><span class="line">            if(datas[i][pid] == row[id])&#123;</span><br><span class="line">                datas[i].check=checked;</span><br><span class="line">                selectChilds(datas,datas[i],id,pid,checked);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function selectParentChecked(datas,row,id,pid)&#123;</span><br><span class="line">        for(var i in datas)&#123;</span><br><span class="line">            if(datas[i][id] == row[pid])&#123;</span><br><span class="line">                datas[i].check=true;</span><br><span class="line">                selectParentChecked(datas,datas[i],id,pid);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() &#123;</span><br><span class="line">        var selRows = $table.bootstrapTable(&quot;getSelections&quot;);</span><br><span class="line">        if(selRows.length == 0)&#123;</span><br><span class="line">            alert(&quot;请至少选择一行&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var postData = &quot;&quot;;</span><br><span class="line">        $.each(selRows,function(i) &#123;</span><br><span class="line">            postData +=  this.id;</span><br><span class="line">            if (i &lt; selRows.length - 1) &#123;</span><br><span class="line">                postData += &quot;， &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        alert(&quot;你选中行的 id 为：&quot;+postData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(id) &#123;</span><br><span class="line">        alert(&quot;add 方法 , id = &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">    function del(id) &#123;</span><br><span class="line">        alert(&quot;del 方法 , id = &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">    function update(id) &#123;</span><br><span class="line">        alert(&quot;update 方法 , id = &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>pid 大于等于0，pid为负数时无法显示。</p>
<p>返回数据格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;&quot;data&quot;: mydata//注意这里&#125;</span><br></pre></td></tr></table></figure>

<p>没找到分页的办法</p>
]]></content>
      <categories>
        <category>BootStrap</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
        <tag>前端</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title>Exception-HeadlessException</title>
    <url>/2020/09/21/Exception-HeadlessException/</url>
    <content><![CDATA[<p>以jar启动项目，访问接口时报java.awt.HeadlessException</p>
<span id="more"></span>

<h1 id="Exception-HeadlessException"><a href="#Exception-HeadlessException" class="headerlink" title="Exception-HeadlessException"></a>Exception-HeadlessException</h1><p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CST ERROR com.towery.support.GlobalExceptionHandler 54 notFoundException - 运行时异常: java.awt.HeadlessException: null</span><br><span class="line">	at sun.awt.HeadlessToolkit.getScreenSize(HeadlessToolkit.java:284) ~[?:1.8.0_121]</span><br><span class="line">	at com.towery.util.ResolutionUtil.getScreenSize(ResolutionUtil.java:22) ~[classes!/:0.0.1]</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目开启了Headless模式，在这种模式下系统缺少其他设备的支持，会报错。比如：显示设备、键盘、鼠标等外设。Headless模式在服务端是很常用的，因为大多数服务器就是运行在没有前述设备支持的情况下。</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>jar启动项目时，添加参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Djava.awt.headless=true -jar test.jar</span><br></pre></td></tr></table></figure>

<p>tomcat启动项目，提前在<code>catalina.sh</code>第一行添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Exception</category>
      </categories>
  </entry>
  <entry>
    <title>Exception-Mybatis-BindingException</title>
    <url>/2020/08/12/Exception-Mybatis-BindingException/</url>
    <content><![CDATA[<p>Mybatis的BindingException异常解决</p>
<span id="more"></span>

<h1 id="Mybatis-BindingException"><a href="#Mybatis-BindingException" class="headerlink" title="Mybatis-BindingException"></a>Mybatis-BindingException</h1><p>来自 ：<a href="https://blog.csdn.net/weixin_42230885/article/details/84855041">https://blog.csdn.net/weixin_42230885/article/details/84855041</a></p>
<p>本地idea运行可以，服务器端jar包部署运行错误。</p>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter &#x27;id&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br></pre></td></tr></table></figure>



<p>注解SQL错误写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertObject</span><span class="params">(Integer userId,Integer[] roleIds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注解SQL正确写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertObject</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span>Integer userId,<span class="meta">@Param(&quot;roleIds&quot;)</span>Integer[] roleIds)</span></span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Exception</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP-基础</title>
    <url>/2020/09/09/HTTP-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>HTTP-基础</p>
<span id="more"></span>

<h1 id="HTTP-基础"><a href="#HTTP-基础" class="headerlink" title="HTTP-基础"></a>HTTP-基础</h1><p><strong>参考：</strong><a href="https://www.w3.org/Protocols/">https://www.w3.org/Protocols/</a></p>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>规定了一种客户端与服务器端传输数据的方式。</p>
<ul>
<li><p>超文本传输协议</p>
</li>
<li><p>无状态</p>
</li>
<li><p>基于TCP/IP</p>
</li>
</ul>
<p>1.0有三种请求方法。1.1增加了5种。</p>
<h2 id="HTTP1-1内容"><a href="#HTTP1-1内容" class="headerlink" title="HTTP1.1内容"></a>HTTP1.1内容</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/FqlurVyMwJ17DCt.png" alt="image-20200907183947988"></p>
<h2 id="http请求request"><a href="#http请求request" class="headerlink" title="http请求request"></a>http请求request</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client request:</span><br><span class="line"></span><br><span class="line">     GET /hello.txt HTTP/1.1</span><br><span class="line">     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</span><br><span class="line">     Host: www.example.com</span><br><span class="line">     Accept-Language: en, mi</span><br></pre></td></tr></table></figure>

<p>方法名称 /虚拟目录/文件名 协议名称/协议版本</p>
<p>用户代理：操作系统类型、版本，CPU类型，浏览器类型、版本，浏览器渲染引擎、浏览器语言</p>
<h2 id="http响应response"><a href="#http响应response" class="headerlink" title="http响应response"></a>http响应response</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server response:</span><br><span class="line"></span><br><span class="line">     HTTP/1.1 200 OK</span><br><span class="line">     Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">     Server: Apache</span><br><span class="line">     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">     ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">     Accept-Ranges: bytes</span><br><span class="line">     Content-Length: 51</span><br><span class="line">     Vary: Accept-Encoding</span><br><span class="line">     Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<p>协议名称/版本 状态码</p>
<p>时间</p>
<p>服务器类型</p>
<p>最后修改时间</p>
<p>可用来查看访问资源是否改变</p>
<p>支持部分请求的标志</p>
<p>响应的字节长度</p>
<p>…</p>
<p>响应体类型</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<p><a href="http://blog.xiaoruiit.com/categories/git.html?id=1&amp;page=1#name">http://blog.xiaoruiit.com:80/categories/git.html?id=1&amp;page=1#name</a></p>
<ul>
<li>协议 http://</li>
<li>域名或IP地址 blog.xiaoruiit.com</li>
<li>端口 80</li>
<li>虚拟目录 categories</li>
<li>文件名 git.html</li>
<li>参数 id=1&amp;page=1</li>
<li>锚 #name</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>2×× 成功</p>
<p>4×× 客户端找不到服务器</p>
<p>5×× 服务器端异常</p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>GET 查</p>
<p>POST 增</p>
<p>PUT 改</p>
<p>DELETE 删</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>客户端连接到Web服务器</li>
<li>发送http请求</li>
<li>服务器接收请求并响应</li>
<li>释放连接</li>
<li>客户端解析响应的html内容</li>
</ol>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客进阶：图片、主题、域名</title>
    <url>/2018/04/12/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>hexo搭建的个人博客上传图片,主题更换,域名固定</p>
<span id="more"></span>
<h1 id="hexo搭建的个人博客上传图片"><a href="#hexo搭建的个人博客上传图片" class="headerlink" title="hexo搭建的个人博客上传图片"></a>hexo搭建的个人博客上传图片</h1><p>本方法为直接上传图片到GitHub，省事但是占用GitHub空间，如果怕GitHub（免费使用300M）以后空间不够用，可以用七牛（免费10G）当图片空间。<br>1.将站点配置文件_config.yml (刚进入博客文件夹)里的post_asset_folder:选项设置为true<br><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/1-1.jpg"></p>
<p>2.下载安装一个可以上传本地图片的插件,在你的blog目录下点击鼠标右键，再点击git bash here，然后输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个xxxx文件夹。<br><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/1-2.png"></p>
<p>在xxxx.md中想插入图片时，先把图片放到到xxxx这个文件夹中，然后在xxxx.md中按照markdown的格式引入图片：<br><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<h1 id="主题更换，示例next主题"><a href="#主题更换，示例next主题" class="headerlink" title="主题更换，示例next主题"></a>主题更换，示例next主题</h1><h2 id="下载next主题"><a href="#下载next主题" class="headerlink" title="下载next主题"></a>下载next主题</h2><p>在blog文件夹中点击鼠标右键，再点击git bash here，然后输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/2-1.png"></p>
<p>克隆完成之后，打开你的本地博客文件夹下的theme文件夹就可以看到刚刚下载的next主题。</p>
<h2 id="修改博客的配置文件"><a href="#修改博客的配置文件" class="headerlink" title="修改博客的配置文件"></a>修改博客的配置文件</h2><p>打开博客目录下的站点配置文件_config.yml 把主题切换为next。<br><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/2-2.png"><br>完成之后主题就可以用了。<br>输入命令<br><code>hexo s </code><br>本地测试，可以在 localhost:4000 查看效果</p>
<p>配置文件_config.yml在网站中中文显示乱码<br>可以使用notepad++将配置文件转为utf-8编码</p>
<h1 id="域名固定"><a href="#域名固定" class="headerlink" title="域名固定"></a>域名固定</h1><p>上一篇绑定域名后，每次部署本地文件到GitHub，都需要到GitHub的setting中重写保存自己绑定的域名。<br>只保存一次的解决方法：到blog本地目录 source 文件夹下面新建一个文件，取名为 CNAME (无后缀)，内容就是上面所说到的自己的域名如下：<br>blog.xiaoruiit.com<br>就可以了。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>设置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2018/04/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo搭建博客并部署在GitHub上，以及绑定域名，以后如何发布文章。</p>
<span id="more"></span>
<h1 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h1><p>安装过程会自动配置系统环境变量。（安装之后尽量不要更改文件夹名称，修改文件夹名称系统环境变量不会自动跟随改变，使用软件会出错）</p>
<h1 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h1><p>很简单，安装对应自己机器位数的git即可</p>
<h1 id="3-安装hexo（需要先安装好node-js和git"><a href="#3-安装hexo（需要先安装好node-js和git" class="headerlink" title="3.安装hexo（需要先安装好node.js和git)"></a>3.安装hexo（需要先安装好node.js和git)</h1><p>需要在联网状态下进行,下图红色的Err!是未联网下安装的报错结果。<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/3-1.png"></p>
<h1 id="4-建立站点"><a href="#4-建立站点" class="headerlink" title="4.建立站点"></a>4.建立站点</h1><ul>
<li>(1)先在电脑中的某一位置建立好 <em>your_name.github.io</em> 文件夹，比如          E:\your_name.github.io；</li>
<li>(2)在终端中切换到用cd命令 <em>your_name.github.io</em> 文件夹所在的路径。</li>
<li>(3)根据hexo的官方文档 <a href="https://hexo.io/zh-cn/docs/setup.html">开始使用 — 建站</a>，依次执行以下两条命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-1.png"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-2.png"></p>
<p>安装完成后simpleai.github.io目录下的内容：<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-3.png"></p>
<p>  ● <em>_config.yml</em> 文件存放着网站的配置信息，可以在这里配置大部分的参数。<br>  ● <em>package.json</em> 文件存放着插件信息，从中可以查看那些插件已经安装。<br>  ● <em>scaffolds</em> 是模板文件夹，新建文章时，Hexo 会根据 <em>scaffold</em> 来建立文件，不过这个模板和后面的主题里指的模板不一样。<br>  ● <em>source</em> 是存放用户资源的地方的文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线) 的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（别急，等下会生成的），而其他文件会被拷贝过去。<br>  ● <em>themes</em> 主题文件夹，Hexo 会根据主题来生成静态页面，我们以后自己安装的主题也都会放在这个文件夹下面，默认的 landscape 主题已经在里面了。<br>（4） 根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/commands.html">开始使用 — 命令</a>，在终端中敲入 （确保路径仍在 your_name.github.io 下；防火墙可能会阻止，点击允许。），</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-4.png"></p>
<p>可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 中看到我们网站默认的样子了。<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-5.png"></p>
<h1 id="5-配置站点"><a href="#5-配置站点" class="headerlink" title="5.配置站点"></a>5.配置站点</h1><p>在 <em>_config.yml</em> 中，我们可以修改大部份的配置，里面每一个参数的含义可以查看 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/configuration.html">开始使用 — 配置</a> ，这里我暂且只修改了 title，subtitle 和 author，替换成自己网站的名字和作者名即可。per_page 决定首页显示多少篇文章，默认的 10 篇有点多，我改成了 5 篇。其余的设置，比如 theme，deploy 我们用到了再来更改。</p>
<h1 id="6-生成自己的内容"><a href="#6-生成自己的内容" class="headerlink" title="6.生成自己的内容"></a>6.生成自己的内容</h1><p>在 _posts 文件夹下，新建一个 Markdown 文件(.md文件)，或者把以前有的 Markdown 文件复制进来，根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/front-matter.html">基本操作 — Front-matter</a> ，写好你的第一篇文章，比如：<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/6-1.png"></p>
<p>这里，Front-matter 是文件最上方以 — 分隔的区域，用于指定文章的标题、建立日期、更新日期等，如果主题模板还支持分类和标签的话（比如默认的 landscape 主题），还可以指定分类和标签。根据 Hexo 的官方文档 基本操作 — 生成文件，在终端中敲入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>Hexo 会替我们刚加入到 _posts 文件夹下的 markdown 文件生成静态文件。接着输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p> 就可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 中看到我们新添加的网页内容了。至此，我们采用默认主题 landscape 的网站已经生成了，且相信你已经掌握了关于 Hexo 的大部分操作，如果自感还不熟悉，可以再看看 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/commands.html">开始使用 — 命令</a>，主要是下面几个命令：<br>  ● <code>hexo init</code> [folder]: 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站；<br>  ● <code>hexo generate</code>: 生成静态文件；<br>  ● <code>hexo server</code>: 启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%EF%BC%9B">http://localhost:4000/；</a><br>  ● <code>hexo deploy</code>: 部署本地文件到网站（后文会用得）；<br>  ● <code>hexo clean</code>: 清除缓存文件 (db.json) 和 public 文件夹下已生成的静态文件。</p>
<h1 id="7部署到GitHub"><a href="#7部署到GitHub" class="headerlink" title="7部署到GitHub"></a>7部署到GitHub</h1><h2 id="7-1注册账号"><a href="#7-1注册账号" class="headerlink" title="7.1注册账号"></a>7.1注册账号</h2><h2 id="7-2github中创建项目"><a href="#7-2github中创建项目" class="headerlink" title="7.2github中创建项目"></a>7.2github中创建项目</h2><p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-1.png"></p>
<p>Github 的官方文档 <a href="https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github">Create a new repository on GitHub</a> 已经图文并茂将如何建立一个 repository 交待得非常清楚明白了（英文），唯一要注意的是，第二步里的 Repository name 一定要是 your_name.github.io ，your_name 是 Github 用户名。</p>
<h2 id="7-3配置Git"><a href="#7-3配置Git" class="headerlink" title="7.3配置Git"></a>7.3配置Git</h2><p>根据 Github 的官方文档 <a href="https://help.github.com/articles/set-up-git/#setting-up-git">Setting up Git</a>，这一操作的目的是 告诉版本控制软件 Git 接下来这台电脑上提交的文件是 E-mail 地址是什么的某人提交的。在 Git Bash 中执行如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;YOUR NAME&quot;</span><br><span class="line">git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;</span><br></pre></td></tr></table></figure>
<p>其中，YOUR NAME 是自己取的名字，YOUR EMAIL ADDRESS 是自己的邮箱。由于自己的博客网站就自己一个人提交，所以就都设置成跟 Github 用户名和邮箱相同了。但其实是可以不同，因为对于很多项目，并不只有一个开发者，Github 允许多人向同一个 Repo 提交，这里提供用户名和邮箱，只是为了搞清楚哪些代码是谁提交的。</p>
<h2 id="7-4Git-与-Github-进行身份验证"><a href="#7-4Git-与-Github-进行身份验证" class="headerlink" title="7.4Git 与 Github 进行身份验证"></a>7.4Git 与 Github 进行身份验证</h2><p>这一整章，我们的最终目的是实现在终端中敲入 hexo deploy （部署本地文件到网站）后，Hexo 会将我们本地的 public 文件夹下的东西上传到 Github 服务器，这样我们就可以通过 <em>your_name.github.io</em> 这个域名（your_name 是你的 Github 用户名）看到我们已经上网的博客网站了。为了实现这个目的，首先我们先要让本地的电脑和 Github 服务器建立起某种联系，也就是让 Github 服务器信任由我这台电脑提交的东西，接受，并存放到 your_name.github.io 这个 Repo 下面，与 Github 服务器建立信任的这个环节就是身份认证（Authenticating ）。根据 Github 的官方文档 <a href="https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git">Authenticating with GitHub from Git</a> 这里，我们选择 <a href="https://help.github.com/articles/set-up-git/#connecting-over-ssh">Connecting over SSH</a> 这一种方式。在 Github 的官方文档 <a href="https://help.github.com/categories/ssh/">Categories / SSH</a> 下，我们能找到关于 Github 与 SSH 的资料。</p>
<h3 id="7-4-1-生成新的-SSH-key"><a href="#7-4-1-生成新的-SSH-key" class="headerlink" title="7.4.1 生成新的 SSH key"></a>7.4.1 生成新的 SSH key</h3><p>根据 Github 的官方文档 <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key">Generating a new SSH key</a> ， 我们在 Git Bash 下执行如下命令，生成 SSH key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>其中，<a href="mailto:&#x79;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#x61;&#105;&#108;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#x79;&#x6f;&#117;&#x72;&#x5f;&#x65;&#109;&#x61;&#105;&#108;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#109;</a> 是你的 Github 注册邮箱。然后，Git Bash 中会出现<em>Generating public/private rsa key pair.</em></p>
<p>表示新的 SSH 已经生成了。随后会出现<br><em>Enter file in which to save the key (/c/Users/han/.ssh/id_rsa):</em><br>*Created directory ‘/c/Users/han/.ssh’.*这里 <em>id_rsa</em>是生成的 key 文件的文件名，默认都是这个；如果不是，在后面用到 <em>id_rsa</em> 的地方请替换成出现的名字。这条信息是让你选择 SSH key 存放的地点，按回车选择默认的即可。回车后，还会出现<br><em>Enter passphrase (empty for no passphrase):</em><br><em>Enter same passphrase again:</em><br>让你设置使用 SSH 密钥时的密码，由于我们都是在自己个人的电脑上操作，所以仍然回车，不设置密码即可。<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-2.png"></p>
<h3 id="7-4-2-将-SSH-key-添加到-ssh-agent"><a href="#7-4-2-将-SSH-key-添加到-ssh-agent" class="headerlink" title="7.4.2 将 SSH key 添加到 ssh-agent"></a>7.4.2 将 SSH key 添加到 ssh-agent</h3><p>根据 Wikipedia，ssh-agent 是一个在本地登录会话持续时间内，将未加密的密钥存储在内存中，并使用 Unix 域套接字与 SSH 客户端进行通信的程序。根据 Github 的官方文档 <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent">Adding your SSH key to the ssh-agent</a> ， 我们在 Git Bash 下执行如下命令，开启 ssh-agent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-3.png"></p>
<p>然后我们要将这个 SSH key 添加到 ssh-agent 里去，运行如下命令，其中<em>id_rsa</em> 是你的 key 文件的文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-4.png"></p>
<h3 id="7-4-3-将-SSH-key-添加到-Github-账户"><a href="#7-4-3-将-SSH-key-添加到-Github-账户" class="headerlink" title="7.4.3 将 SSH key 添加到 Github 账户"></a>7.4.3 将 SSH key 添加到 Github 账户</h3><p>Github 的官方文档 <a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/">Adding a new SSH key to your GitHub account</a> 已经图文并茂将如何在 Github<br>帐号中添加 SSH 介绍的非常清楚了。先是在 Git Bash 中将 SSH Key 拷贝出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br><span class="line">$ #Copies the contents of the id_rsa.pub file to your clipboard</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-5.png"><br>id_rsa 是你刚才的 SSH Key 文件。此时，SSH Key 已经在我们的剪切板里了。然后登录 Github 帐号，依次点击自己的头像，Settings，SSH and GPG keys，New SSH key 或者 Add SSH key， 在 Title 这里输入 Key 的label，比如 your_name - PC，然后在 Key 里面把 SSH Key 粘贴进去，点击 Add SSH key 大功告成。<br>我们做了身份认证的凭证 SSH key，分别放在自己本地电脑和 Github 服务器上，以后向 Github 提交内容的时候，两者的 Key 匹配就可以了，不需要每次输密码。</p>
<h3 id="7-4-4-测试-SSH-连接"><a href="#7-4-4-测试-SSH-连接" class="headerlink" title="7.4.4 测试 SSH 连接"></a>7.4.4 测试 SSH 连接</h3><p>在大功告成之前，为了稳妥起见，我们来测试一下自己跟 Github 服务器 SSH 连接是否已经建立起来了。Github 的官方文档 <a href="https://help.github.com/articles/testing-your-ssh-connection/">Testing your SSH connection</a> 将这个环节介绍得非常详细。我们要做得就是在 Git Bash 中敲入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>你可能会看到类似于<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-6.png"><br>没关系，输入 yes 敲回车，就可以看到如下的成功信息了<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-7.png"><br>至此为止，我们已经建立起了跟 Github 服务器的连接。其实我们也可以用 git push 命令，提交 public 文件夹下面的内容，不过 Hexo 更我们提供了更方便的途径。</p>
<h2 id="7-5-Hexo-部署"><a href="#7-5-Hexo-部署" class="headerlink" title="7.5 Hexo 部署"></a>7.5 Hexo 部署</h2><p>Hexo 提供了 hexo deploy 命令，可以方便地将整个 public 文件夹部署到 Github 服务器上去。根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/deployment.html">基本操作 — 部署</a> 我们只需要做以下两步：</p>
<h3 id="7-5-1-在终端中运行如下命令，安装-hexo-deployer-git-插件："><a href="#7-5-1-在终端中运行如下命令，安装-hexo-deployer-git-插件：" class="headerlink" title="7.5.1: 在终端中运行如下命令，安装 hexo-deployer-git 插件："></a>7.5.1: 在终端中运行如下命令，安装 hexo-deployer-git 插件：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-8.png"></p>
<h3 id="7-5-2-在-config-yml-中修改参数，如下所示："><a href="#7-5-2-在-config-yml-中修改参数，如下所示：" class="headerlink" title="7.5.2: 在 _config.yml 中修改参数，如下所示："></a>7.5.2: 在 _config.yml 中修改参数，如下所示：</h3><p>deploy:<br>    type: git<br>    repo: <a href="https://github.com/simpleai/simpleai.github.io.git">https://github.com/simpleai/simpleai.github.io.git</a><br>    branch: master<br>其中，<em>your_name</em> 是你的 Github 帐号名。repo 对应的是你 <em>your_name.github.io</em> 这个项目的库（Repository）地址，进入这个项目的主页，点击 Clone or download 下拉菜单也能看到。branch 是分支名称，如果使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测，通常都是 master。 注意，repo冒号后的空格非常重要，一定要有！<br>至此，在终端执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<p>就可以把我们的本地文件部署到 Github 服务器上。在第一次部署的时候，Github 还会跳出来一个小窗口，让输入 Github 帐号和密码，输入即可。等待 20分钟的样子，就可以通过 <em>your_name.github.io</em> （your_name 是你的 Github 用户名）来访问自己的网站了。</p>
<h1 id="8-独立域名与GitHub域名绑定"><a href="#8-独立域名与GitHub域名绑定" class="headerlink" title="8.独立域名与GitHub域名绑定"></a>8.独立域名与GitHub域名绑定</h1><h2 id="8-1阿里云购买域名"><a href="#8-1阿里云购买域名" class="headerlink" title="8.1阿里云购买域名"></a>8.1阿里云购买域名</h2><h2 id="8-2解析域名"><a href="#8-2解析域名" class="headerlink" title="8.2解析域名"></a>8.2解析域名</h2><p>在cmd命令框中ping自己的博客网址(联网状态下)，ping yourname.github.io如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping simpleai.github.io</span><br></pre></td></tr></table></figure>
<p>得到数字地址如：151.101.73.147<br>在域名解析中添加两条记录：我这里设置了一个三级域名blog，<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8-1.png"><br>www 指定的记录是你在 github 创建的仓库。<br>如博客不能登录，有可能是 github 更改了空间服务的 ip 地址，记得及时查看最新的ip即可</p>
<h2 id="8-3更改博客对应的域名"><a href="#8-3更改博客对应的域名" class="headerlink" title="8.3更改博客对应的域名"></a>8.3更改博客对应的域名</h2><p>点击右上角Settings<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8-2.png"><br>更改并保存自己的域名<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8-3.png"></p>
<h1 id="以后如何写博客，提供两种方法"><a href="#以后如何写博客，提供两种方法" class="headerlink" title="以后如何写博客，提供两种方法"></a>以后如何写博客，提供两种方法</h1><h2 id="1-在当初建的博客站点文件夹下的source-posts目录下，建立-md文件，一个md文件对应一篇博客文章。"><a href="#1-在当初建的博客站点文件夹下的source-posts目录下，建立-md文件，一个md文件对应一篇博客文章。" class="headerlink" title="1.在当初建的博客站点文件夹下的source\ _posts目录下，建立.md文件，一个md文件对应一篇博客文章。"></a>1.在当初建的博客站点文件夹下的source\ _posts目录下，建立.md文件，一个md文件对应一篇博客文章。</h2><p>写好之后在你博客站点文件夹下右键空白处，选择Git Bash Here，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态页面，再输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>然后到localhost:4000预览博客效果，<br>最后输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>同步到github上去就行了。</p>
<h2 id="2-使用在线使用CSDN的markdown编辑器"><a href="#2-使用在线使用CSDN的markdown编辑器" class="headerlink" title="2.使用在线使用CSDN的markdown编辑器"></a>2.使用在线使用CSDN的markdown编辑器</h2><p>注册登录CSDN，更改设置，使用Markdown编辑器。<br>编辑好文章后导出文件，复制到source\ _posts目录下，之后操作同1。</p>
<h1 id="文章乱码问题"><a href="#文章乱码问题" class="headerlink" title="文章乱码问题"></a>文章乱码问题</h1><p>以txt方式打开文件，然后另存为的时候，以utf-8的编码格式保存。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA-EasyCode使用</title>
    <url>/2021/06/10/IDEA-EasyCode/</url>
    <content><![CDATA[<p>IDEA-EasyCode使用</p>
<span id="more"></span>
<h1 id="IDEA-EasyCode使用"><a href="#IDEA-EasyCode使用" class="headerlink" title="IDEA-EasyCode使用"></a>IDEA-EasyCode使用</h1><p>一键生成单表后端代码，包括entity,controller,service,serviceImpl,dao,mapper</p>
<h2 id="1-安装idea插件"><a href="#1-安装idea插件" class="headerlink" title="1.安装idea插件"></a>1.安装idea插件</h2><ol>
<li>打开设置中的<code>plugins</code></li>
<li>搜索安装<code>EasyCode</code><ul>
<li>版本： <code>v1.2.3-RELEASE</code></li>
</ul>
</li>
<li>搜索安装<code>lombok</code></li>
<li>重启<code>idea</code></li>
</ol>
<h2 id="2-使用Database连接数据库"><a href="#2-使用Database连接数据库" class="headerlink" title="2.使用Database连接数据库"></a>2.使用Database连接数据库</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tQeLBPh9gC8jb2U.png" alt="image-20201219135638858"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>连接中多个数据库的，在Database中指定数据库</li>
<li>修改数据库字段后，需同步表。右击表，点击<code>synchronize</code></li>
</ul>
<h2 id="3-EasyCode生成代码"><a href="#3-EasyCode生成代码" class="headerlink" title="3.EasyCode生成代码"></a>3.EasyCode生成代码</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WoSlC9bfeBxE4wp.png" alt="image-20201219135505403"></p>
<h3 id="自定义模板配置"><a href="#自定义模板配置" class="headerlink" title="自定义模板配置"></a>自定义模板配置</h3><h4 id="Type-Mapper"><a href="#Type-Mapper" class="headerlink" title="Type Mapper"></a>Type Mapper</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XzNDSKAaQtl7Hrf.png" alt="image-20201219141100298"></p>
<h4 id="Template-Setting"><a href="#Template-Setting" class="headerlink" title="Template Setting"></a>Template Setting</h4><h4 id="Table-Editor-Config"><a href="#Table-Editor-Config" class="headerlink" title="Table Editor Config"></a>Table Editor Config</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/VvLzBsEH7rxlZOo.png" alt="image-20201219143546075"></p>
<h5 id="entity-java"><a href="#entity-java" class="headerlink" title="entity.java"></a>entity.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##使用宏定义设置回调（保存位置与文件后缀）</span><br><span class="line">#save(&quot;/entity&quot;, &quot;.java&quot;)</span><br><span class="line"></span><br><span class="line">##使用宏定义设置包后缀</span><br><span class="line">#setPackageSuffix(&quot;entity&quot;)</span><br><span class="line"></span><br><span class="line">##使用全局变量实现默认包导入</span><br><span class="line">$!autoImport</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;实体类&quot;)</span><br><span class="line">@Data</span><br><span class="line">@ApiModel</span><br><span class="line">public class $!&#123;tableInfo.name&#125; implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = $!tool.serial();</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line"></span><br><span class="line">    #if($&#123;column.comment&#125;)@ApiModelProperty(value = &quot;$&#123;column.comment&#125;&quot;)</span><br><span class="line">    #end</span><br><span class="line">private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#*#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">##使用宏定义实现get,set方法</span><br><span class="line">#getSetMethod($column)</span><br><span class="line">#end*#</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="dao-java"><a href="#dao-java" class="headerlink" title="dao.java"></a>dao.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Dao&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/dao&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;dao;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import org.apache.ibatis.annotations.Param;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表数据库访问层&quot;)</span><br><span class="line">public interface $!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过实体作为筛选条件查询</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 对象列表</span><br><span class="line">     */</span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryAll($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int deleteById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="service-java"><a href="#service-java" class="headerlink" title="service.java"></a>service.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Service&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/service&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表服务接口&quot;)</span><br><span class="line">public interface $!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 是否成功</span><br><span class="line">     */</span><br><span class="line">    boolean deleteById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="serviceImpl-java"><a href="#serviceImpl-java" class="headerlink" title="serviceImpl.java"></a>serviceImpl.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;ServiceImpl&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/service/impl&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.dao.$!&#123;tableInfo.name&#125;Dao;</span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表服务实现类&quot;)</span><br><span class="line">@Service(&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Service&quot;)</span><br><span class="line">public class $!&#123;tableName&#125; implements $!&#123;tableInfo.name&#125;Service &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private $!&#123;tableInfo.name&#125;Dao $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Dao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name) &#123;</span><br><span class="line">        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.queryById($!pk.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public $!&#123;tableInfo.name&#125; insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;</span><br><span class="line">        this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.insert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">        return $!tool.firstLowerCase($!&#123;tableInfo.name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public $!&#123;tableInfo.name&#125; update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;</span><br><span class="line">        this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.update($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">        return this.queryById($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;.get$!tool.firstUpperCase($pk.name)());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 是否成功</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean deleteById($!pk.shortType $!pk.name) &#123;</span><br><span class="line">        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.deleteById($!pk.name) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="controller-java"><a href="#controller-java" class="headerlink" title="controller.java"></a>controller.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Controller&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/controller&quot;))</span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;controller;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表控制层&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;$!tool.firstLowerCase($tableInfo.name)&quot;)</span><br><span class="line">public class $!&#123;tableName&#125; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 服务对象</span><br><span class="line">     */</span><br><span class="line">    @Resource</span><br><span class="line">    private $!&#123;tableInfo.name&#125;Service $!tool.firstLowerCase($tableInfo.name)Service;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param id 主键</span><br><span class="line">     * @return 单条数据</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;selectOne&quot;)</span><br><span class="line">    public $!&#123;tableInfo.name&#125; selectOne($!pk.shortType id) &#123;</span><br><span class="line">        return this.$!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入mybatis支持</span><br><span class="line">$!mybatisSupport</span><br><span class="line"></span><br><span class="line">##设置保存名称与保存位置</span><br><span class="line">$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, &quot;Dao.xml&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($modulePath, &quot;/src/main/resources/mapper&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;$!&#123;tableInfo.savePackageName&#125;.dao.$!&#123;tableInfo.name&#125;Dao&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;&gt;</span><br><span class="line">        &lt;!--@Table $!&#123;tableInfo.originTableName&#125;--&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">        &lt;result property=&quot;$!column.name&quot; column=&quot;$!column.obj.name&quot; jdbcType=&quot;$!column.ext.jdbcType&quot;/&gt;</span><br><span class="line">#end</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询单个--&gt;</span><br><span class="line">    &lt;select id=&quot;queryById&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">          #allSqlColumn()</span><br><span class="line"></span><br><span class="line">        from $!&#123;tableInfo.obj.parent.name&#125;.$!tableInfo.obj.name</span><br><span class="line">        where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过实体作为筛选条件查询--&gt;</span><br><span class="line">    &lt;select id=&quot;queryAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">          #allSqlColumn()</span><br><span class="line"></span><br><span class="line">        from $!&#123;tableInfo.obj.parent.name&#125;.$!tableInfo.obj.name</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                and $!column.obj.name = #&#123;$!column.name&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--新增所有列--&gt;</span><br><span class="line">    &lt;insert id=&quot;insert&quot; keyProperty=&quot;$!pk.name&quot; useGeneratedKeys=&quot;true&quot;&gt;</span><br><span class="line">        insert into $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#if($velocityHasNext), #end#end)</span><br><span class="line">        values (#foreach($column in $tableInfo.otherColumn)#&#123;$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键修改数据--&gt;</span><br><span class="line">    &lt;update id=&quot;update&quot;&gt;</span><br><span class="line">        update $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">#foreach($column in $tableInfo.otherColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                $!column.obj.name = #&#123;$!column.name&#125;,</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">        where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键删除--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteById&quot;&gt;</span><br><span class="line">        delete from $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125; where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="RespVO-java"><a href="#RespVO-java" class="headerlink" title="RespVO.java"></a>RespVO.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##使用宏定义设置回调（保存位置与文件后缀）</span><br><span class="line">#save(&quot;/entity/vo&quot;, &quot;RespVO.java&quot;)</span><br><span class="line"></span><br><span class="line">##使用宏定义设置包后缀</span><br><span class="line">#setPackageSuffix(&quot;entity.vo&quot;)</span><br><span class="line"></span><br><span class="line">##使用全局变量实现默认包导入</span><br><span class="line">$!autoImport</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;返回传输类&quot;)</span><br><span class="line">@Data</span><br><span class="line">@ApiModel</span><br><span class="line">public class $!&#123;tableInfo.name&#125;RespVO implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = $!tool.serial();</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line"></span><br><span class="line">    #if($&#123;column.name&#125; != &quot;isDel&quot; &amp;&amp; $&#123;column.name&#125; != &quot;creator&quot; &amp;&amp; $&#123;column.name&#125; != &quot;createTime&quot; &amp;&amp; $&#123;column.name&#125; != &quot;modifier&quot; &amp;&amp; $&#123;column.name&#125; != &quot;modifiTime&quot;)</span><br><span class="line">    #if($&#123;column.comment&#125;)@ApiModelProperty(value = &quot;$&#123;column.comment&#125;&quot;)</span><br><span class="line">    #end</span><br><span class="line">    private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">    #end</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Global-Config"><a href="#Global-Config" class="headerlink" title="Global Config"></a>Global Config</h4><h5 id="mybatisSupport"><a href="#mybatisSupport" class="headerlink" title="mybatisSupport"></a>mybatisSupport</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##针对Mybatis 进行支持，主要用于生成xml文件</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">    ##储存列类型</span><br><span class="line">    $tool.call($column.ext.put(&quot;sqlType&quot;, $tool.getField($column.obj.dataType, &quot;typeName&quot;)))</span><br><span class="line">    #if($tool.newHashSet(&quot;java.lang.String&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;VARCHAR&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Boolean&quot;, &quot;boolean&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;BOOLEAN&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Byte&quot;, &quot;byte&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;TINYINT&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Integer&quot;, &quot;int&quot;, &quot;java.lang.Short&quot;, &quot;short&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;INTEGER&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Long&quot;, &quot;long&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;BIGINT&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Float&quot;, &quot;float&quot;, &quot;java.lang.Double&quot;, &quot;double&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;NUMERIC&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.sql.Date&quot;, &quot;java.time.LocalDateTime&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;TIMESTAMP&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.math.BigDecimal&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;DECIMAL&quot;)</span><br><span class="line">    #else</span><br><span class="line">        ##其他类型</span><br><span class="line">        #set($jdbcType=&quot;OTHER&quot;)</span><br><span class="line">    #end</span><br><span class="line">    $tool.call($column.ext.put(&quot;jdbcType&quot;, $jdbcType))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">##定义宏，查询所有列</span><br><span class="line">#macro(allSqlColumn)#foreach($column in $tableInfo.fullColumn)$column.obj.name#if($velocityHasNext), #end#end#end</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA-调试</title>
    <url>/2021/05/31/IDEA-%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>查询慢查询日志</p>
<span id="more"></span>

<h1 id="IDEA-调试"><a href="#IDEA-调试" class="headerlink" title="IDEA-调试"></a>IDEA-调试</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>下一步，跳入，强制跳入，跳出，回到初始断点处，运行到指定代码处，表达式计算，线程</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uhgEFic8QOAVN3x.png" alt="image-20210531155859215"></p>
<h2 id="回到初始断点处"><a href="#回到初始断点处" class="headerlink" title="回到初始断点处"></a>回到初始断点处</h2><p>注意：遇到分页插件之后断点，使用此功能会清除分页参数，导致查询全部。数据量大的情况下，idea会卡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (data.getPageNum() != null &amp;&amp; data.getPageSize() != null) &#123;</span><br><span class="line">	PageHelper.startPage(data.getPageNum(), data.getPageSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行到指定代码处"><a href="#运行到指定代码处" class="headerlink" title="运行到指定代码处"></a>运行到指定代码处</h2><p>运行到鼠标所在代码行处。</p>
<h2 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h2><p>for循环中此功能好用</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SJ7lYF2nadpyPio.png" alt="image-20210531160203192"></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA导入Eclipse项目</title>
    <url>/2019/05/31/IDEA%E5%AF%BC%E5%85%A5Eclipse%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>IDEA导入Eclipse项目</p>
<span id="more"></span>
<p>背景：网上有很多教程，看了很多博客自己导入时有其他问题，在一个博客基础上做了完善。<a href="https://blog.csdn.net/zeal9s/article/details/90690524">https://blog.csdn.net/zeal9s/article/details/90690524</a><br>版本：2018.3.3</p>
<h2 id="1-新建一个文件夹-idea打开这个空文件夹"><a href="#1-新建一个文件夹-idea打开这个空文件夹" class="headerlink" title="1.新建一个文件夹,idea打开这个空文件夹"></a>1.新建一个文件夹,idea打开这个空文件夹</h2><h2 id="2-将项目导入"><a href="#2-将项目导入" class="headerlink" title="2.将项目导入"></a>2.将项目导入</h2><p><img src="https://img-blog.csdnimg.cn/2020033115122176.png" alt="如图"><img src="https://img-blog.csdnimg.cn/20200331151331941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="点击OK"><img src="https://img-blog.csdnimg.cn/20200331151359494.png" alt="点击next"><br><img src="https://img-blog.csdnimg.cn/20200331151711595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="点击next"><img src="https://img-blog.csdnimg.cn/20200331151737354.png" alt="点击next"><img src="https://img-blog.csdnimg.cn/20200331151758837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="点击next"><img src="https://img-blog.csdnimg.cn/20200331151844698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="选择jdk">  </p>
<h2 id="3-等待编译完成"><a href="#3-等待编译完成" class="headerlink" title="3.等待编译完成"></a>3.等待编译完成</h2><p><img src="https://img-blog.csdnimg.cn/20200331154433717.png" alt="在这里插入图片描述"></p>
<h2 id="4-配置项目环境"><a href="#4-配置项目环境" class="headerlink" title="4.配置项目环境"></a>4.配置项目环境</h2><p><img src="https://img-blog.csdnimg.cn/2020033115470628.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331154756856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331154958297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155059452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155313320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155401258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155457908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包"><a href="#5-小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包" class="headerlink" title="5.小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包"></a>5.小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包</h2><p><img src="https://img-blog.csdnimg.cn/20200331155812848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200331155737577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-配置Tomcat"><a href="#6-配置Tomcat" class="headerlink" title="6.配置Tomcat"></a>6.配置Tomcat</h2><p><img src="https://img-blog.csdnimg.cn/20200331160106981.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160140962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160201840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160245239.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160357364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="7-重新编译项目，编译完成后启动项目"><a href="#7-重新编译项目，编译完成后启动项目" class="headerlink" title="7.重新编译项目，编译完成后启动项目"></a>7.重新编译项目，编译完成后启动项目</h2><p><img src="https://img-blog.csdnimg.cn/20200331161455184.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331161508831.png" alt="在这里插入图片描述"></p>
<h2 id="8-注意tomcat引入jar包的配置"><a href="#8-注意tomcat引入jar包的配置" class="headerlink" title="8.注意tomcat引入jar包的配置"></a>8.注意tomcat引入jar包的配置</h2><p>我自己在这出错了。之前tomcat中的包和项目包有冲突，我只引入了tomcat中的两个包，导入这个项目时，项目又缺少了tomcat中包含的包，就把tomcat中的包都导入了<br><img src="https://img-blog.csdnimg.cn/20200331160801302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-获取url参数</title>
    <url>/2020/08/12/JS-%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>window.location.href携带参数到test.html页面。test.html页面获取携带的参数。</p>
<span id="more"></span>

<h1 id="JS-获取url参数"><a href="#JS-获取url参数" class="headerlink" title="JS-获取url参数"></a>JS-获取url参数</h1><p>window.location.href携带参数到test.html页面。test.html页面获取携带的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		// 前一个页面跳转到test.html并传递参数 </span><br><span class="line">		// window.location.href = &quot;http://127.0.0.1:8848/a/test.html?pdfId=1&quot;;</span><br><span class="line">		</span><br><span class="line">		// test.html获取参数</span><br><span class="line">		var pdfId = getQueryString(&quot;pdfId&quot;);</span><br><span class="line">		console.log(pdfId);</span><br><span class="line"></span><br><span class="line">		function getQueryString(name) &#123;</span><br><span class="line">			var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">			var r = window.location.search.substr(1).match(reg);</span><br><span class="line">			if (r != null) return unescape(r[2]);</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-入门</title>
    <url>/2020/11/11/JVM-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>JVM-入门</p>
<span id="more"></span>

<h1 id="JVM-入门"><a href="#JVM-入门" class="headerlink" title="JVM-入门"></a>JVM-入门</h1><p>类加载器，内存空间，垃圾收集器。</p>
<p>内存空间：方法区，堆，栈。</p>
<h2 id="堆、栈、方法区"><a href="#堆、栈、方法区" class="headerlink" title="堆、栈、方法区"></a>堆、栈、方法区</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>存放由new创建的对象和数组。堆中分配的内存，由java虚拟机自动垃圾回收器来管理。</p>
<p>根据垃圾回收机制的不同，Java堆有可能拥有不同的结构。最为常见的就是将整个Java堆分为<br> 新生代和老年代。</p>
<h4 id="参数调节"><a href="#参数调节" class="headerlink" title="参数调节"></a>参数调节</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC 每次触发GC的时候打印相关日志</span><br><span class="line">-XX:+UseSerialGC 串行回收</span><br><span class="line">-XX:+PrintGCDetails 更详细的GC日志</span><br><span class="line"></span><br><span class="line">-Xms 堆初始值</span><br><span class="line">-Xmx 堆最大可用值</span><br><span class="line">-Xmn 新生代堆最大可用值</span><br><span class="line">-XX:NewRatio 新生代与老年代的比例 例如： –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</span><br><span class="line">-XX:SurvivorRatio 用来设置新生代中 Eden 与 Survivor 的比值</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms 5m -Xmx 20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Java栈是一块线程私有的空间，一个栈，一般由三部分组成:局部变量表、操作数据栈和帧数据区。</p>
<h3 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h3><p>Java方法区和堆一样，方法区是一块所有线程共享的内存区域，他保存系统的类信息。<br> 比如类的字段、方法、常量池等。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>FullGC:年老代的回收</p>
<h2 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h2><h3 id="调优目标"><a href="#调优目标" class="headerlink" title="调优目标"></a>调优目标</h3><ol>
<li>GC的时间足够的小</li>
<li>GC的次数足够的少</li>
<li>发生Full GC的周期足够的长</li>
</ol>
<h3 id="年轻代和年老代不同大小的影响"><a href="#年轻代和年老代不同大小的影响" class="headerlink" title="年轻代和年老代不同大小的影响"></a>年轻代和年老代不同大小的影响</h3><ul>
<li><p>大年轻代小年老代：大的年轻代会延长普通GC的周期，增加每次GC的时间；小的年老代会导致更频繁的Full GC</p>
</li>
<li><p>小年轻代大年老代：小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</p>
</li>
</ul>
<h3 id="如何选择年轻代与年老代比例"><a href="#如何选择年轻代与年老代比例" class="headerlink" title="如何选择年轻代与年老代比例"></a>如何选择年轻代与年老代比例</h3><ul>
<li>如果应用存在大量的临时对象，应该选择更大的年轻代；</li>
<li>如果存在相对较多的持久对象，年老代应该适当增大。</li>
<li>Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理</li>
<li>观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE-入门</title>
    <url>/2020/11/12/JavaEE-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>JavaEE-入门</p>
<span id="more"></span>

<h1 id="JavaEE-入门"><a href="#JavaEE-入门" class="headerlink" title="JavaEE-入门"></a>JavaEE-入门</h1><p>介绍：基于JavaSE构建，为企业级应用推出的标准平台，用来开发B/S架构软件。</p>
<p>主要技术：<strong>JDBC</strong>、JNDI、EJB、RMI、<strong>Servlet</strong>、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。</p>
<ul>
<li>JDBC: Java 语言中用来<strong>规范客户端程序如何来访问数据库的应用程序接口</strong>，提供了诸如查询和更新数据库中数据的方法。</li>
<li>Servlet: Java 编写的<strong>服务器端程序</strong>。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。</li>
</ul>
]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2018/04/23/JavaSE-ArrayList/</url>
    <content><![CDATA[<p>List的实现类：ArrayList List的包java.util.List</p>
<span id="more"></span>
<p>= 左边的引用相比于 =右边new的对象 不能处于继承关系的下层，如main函数最后一行会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * &lt;&gt; 泛型    集合的泛型不可以用基本数据类型去定义， 需要放包装类</span><br><span class="line"> * .size()方法  获取长度</span><br><span class="line"> * list集合和数组都拥有下标   默认从0开始</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"> * 方法：</span><br><span class="line"> * 		构造方法：public ArrayList()构造一个初始容量为 10 的空列表。 </span><br><span class="line"> * 			   public ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span><br><span class="line"> * 			   public ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。</span><br><span class="line"> * 		普通方法：</span><br><span class="line"> * 				public void trimToSize()将此 ArrayList 实例的容量调整为列表的当前大小。</span><br><span class="line"> * 				public boolean add(E e)将指定的元素添加到此列表的尾部。</span><br><span class="line"> * 				public void add(int index,E element)将指定的元素插入此列表中的指定位置。</span><br><span class="line"> *  			public boolean addAll(Collection&lt;? extends E&gt; c)按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</span><br><span class="line"> *  			public void clear()移除此列表中的所有元素。</span><br><span class="line"> *  			public boolean contains(Object o)如果此列表中包含指定的元素，则返回 true。</span><br><span class="line"> *  			public E set(int index,E element)用指定的元素替代此列表中指定位置上的元素。 </span><br><span class="line"> *  			public int indexOf(Object o)返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</span><br><span class="line"> *  </span><br><span class="line"> * */		</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayListLearn &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		list.add(2);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(list.size());</span><br><span class="line">		System.out.println(list.get(0));</span><br><span class="line">		//构造</span><br><span class="line">		//public ArrayList(Collection&lt;? extends E&gt; c)</span><br><span class="line">		ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(list);</span><br><span class="line">		list2.add(7);</span><br><span class="line">		list2.add(8);</span><br><span class="line">		System.out.println(list2);</span><br><span class="line">		System.out.println(list2.size());	</span><br><span class="line">		//public ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。</span><br><span class="line">		ArrayList&lt;Integer&gt; list3 = new ArrayList&lt;Integer&gt;(3);</span><br><span class="line">		list3.add(9);</span><br><span class="line">		System.out.println(list3.size());</span><br><span class="line">		</span><br><span class="line">		//普通</span><br><span class="line">		//public boolean add(E e)将指定的元素添加到此列表的尾部。 </span><br><span class="line">		list.add(3);</span><br><span class="line">		System.out.println(list.add(4));</span><br><span class="line">		//public void add(int index,E element)</span><br><span class="line">		list.add(2, 5);</span><br><span class="line">		for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------add(int index,E element结束)&quot;);</span><br><span class="line">		//public boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">		list.addAll(2, list2);</span><br><span class="line">		for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------addALL结束&quot;);</span><br><span class="line">		//public void clear()移除此列表中的所有元素。</span><br><span class="line">		list3.clear();</span><br><span class="line">		System.out.println(list3.size());</span><br><span class="line">		//public boolean contains(Object o)如果此列表中包含指定的元素，则返回 true。</span><br><span class="line">		System.out.println(list.contains(3));</span><br><span class="line">		System.out.println(&quot;-------contains(Object o)结束&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2018/04/23/JavaSE-HashMap/</url>
    <content><![CDATA[<p>map  数据结构  键值对  通过K(key)值获取V(values)值    k  t  v </p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * </span><br><span class="line"> *               </span><br><span class="line"> *      方法：</span><br><span class="line"> *               put(key, value)  //存储数据，修改数据</span><br><span class="line"> *               public V get(Object key)		//得到数据</span><br><span class="line"> *               Object get(Object key)这个方法完成的功能是，通过键对象 key，来找到相应的值对象</span><br><span class="line"> *               put(Object key, Object value)这个方法是把一个键值对放入 Map 中。</span><br><span class="line"> *               remove(Object key)这个方法根据一个键，删除一个键值对。</span><br><span class="line"> *               Set keySet()这个方法返回所有键的集合。</span><br><span class="line"> *               Collection values()values 方法返回类型是一个 Collection，返回的是所有值对象的集合</span><br><span class="line"> *               containsKey / containsValue这两个方法用来判断在 Map 中键是否存在，或者值是否存在</span><br><span class="line"> *               size() 这个方法返回 Map 中键值对的个数</span><br><span class="line"> *               isEmpty()判断 Map 是否为空</span><br><span class="line"> *               clear()清空 Map</span><br><span class="line"> *               entrySet这个方法返回值类型是一个 Set 集合，集合中放的是 Map.Entry 类型。这个方法是用来做键值对遍历的.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HashMapLearn &#123;</span><br><span class="line">	public static void main(String[] args) &#123;		</span><br><span class="line">		//定义map</span><br><span class="line">		//引用类型Map  =   对象类型Map的实现类HashMap的实例化对象</span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		//存储数据put</span><br><span class="line">		map.put(&quot;id&quot;, &quot;04&quot;);</span><br><span class="line">		map.put(&quot;username&quot;, &quot;543&quot;);</span><br><span class="line">		map.put(&quot;password&quot;, &quot;123123&quot;);</span><br><span class="line">		map.put(&quot;name&quot;,&quot;han&quot;);</span><br><span class="line">		//获取数据get  //获得id的映射 并输出</span><br><span class="line">		System.out.println(map.get(&quot;id&quot;));</span><br><span class="line">		//全部输出</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		//修改： 使用put方法 覆盖上次的数据</span><br><span class="line">		map.put(&quot;id&quot;, &quot;05&quot;);</span><br><span class="line">		System.out.println(map.get(&quot;id&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>foreach</title>
    <url>/2018/04/23/JavaSE-foreach/</url>
    <content><![CDATA[<p>为了简化遍历的代码，在 5.0 中引入了 foreach 循环。</p>
<span id="more"></span>

<p>基本语法如下：<br>for(变量 : 集合){<br>循环体;<br>}</p>
<p>foreach 循环遍历和迭代遍历是完全等价的,5.0 的编译器会把 foreach 循环自动的翻译成对应的迭代遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一个 Set 而言，采用迭代遍历的代码如下：</span><br><span class="line">Iterator iter = set.iterator();</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">	Object value = iter.next();</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line">改为foreach遍历</span><br><span class="line">for(Object value : set)&#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>static+this+super</title>
    <url>/2018/04/18/JavaSE-static+this+super/</url>
    <content><![CDATA[<p>面向对象中的关键字:static、this、super</p>
<span id="more"></span>      
<p>#this 指本类中的引用。<br>    可以利用this调取到本类中的属性及方法。<br>    不能在static方法中使用。</p>
<p>#super 指父类中的引用。<br>    可以利用super调取的父类中的属性及方法。<br>    不能在static方法中使用。</p>
<p>#static 静态的。<br>       在类被加载的时候自动加载。<br>       被static修饰的方法 可被类名直接调用， 不需要new对象使用。</p>
<pre><code>   静态方法访问方法外的成员时，此成员只能是静态成员 -全局变量
   静态方法中不可以写this，super关键字
   静态方法中不能直接调用非静态方法（可通过new对象，对象调用）                               
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestObject extends C &#123;</span><br><span class="line">	static int c = 10;</span><br><span class="line">	int d = 15;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TestObject testObject = new TestObject();</span><br><span class="line"></span><br><span class="line">		testObject.staticTest();</span><br><span class="line">		testObject.thisTest();</span><br><span class="line">		testObject.superTest();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void staticTest() &#123;</span><br><span class="line">		int b = c;</span><br><span class="line">		System.out.println(&quot;staticTest结果&quot; + b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 测试this</span><br><span class="line">	public void thisTest() &#123;</span><br><span class="line">		int d = 5;</span><br><span class="line">		int b = this.d;</span><br><span class="line">		System.out.println(&quot;b=this.d的值为&quot; + b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 测试super</span><br><span class="line">	public void superTest() &#123;</span><br><span class="line">		String eString = super.taiyuan;</span><br><span class="line">		System.out.println(&quot;super测试结果：&quot; + eString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C &#123;</span><br><span class="line">	public String taiyuan = &quot;taiyuan&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>双层循环</title>
    <url>/2018/04/17/JavaSE-%E5%8F%8C%E5%B1%82%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>双层循环的逻辑：内循环控制第一个变量，外循环控制第二个变量。</p>
<span id="more"></span>
<p>九九乘法表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1*1=1	</span><br><span class="line">1*2=2	2*2=4	</span><br><span class="line">1*3=3	2*3=6	3*3=9	</span><br><span class="line">1*4=4	2*4=8	3*4=12	4*4=16	</span><br><span class="line">1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	</span><br><span class="line">1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	</span><br><span class="line">1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	</span><br><span class="line">1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	</span><br><span class="line">1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81</span><br></pre></td></tr></table></figure>
<p>内循环的j控制乘数的第一个变量，外循环的i控制乘数的第二个变量。换行条件：第一个变量大于第二个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class For &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">			for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">				System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\t&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>九九乘法表</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类</title>
    <url>/2018/04/19/JavaSE-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>普通类提取出来共性</p>
<span id="more"></span>
<pre><code>抽象类：
    普通类的基础上在类名的返回值类型前加abstract 修饰
    包含抽象方法
    也可能有普通方法
    操作：
        抽象类的实例化对象只能调用抽象类中定义的抽象方法
        抽象类的实例化对象实际执行被子类覆盖的方法。
抽象方法：
    普通方法的基础上在方法的返回值类型前加abstract 修饰
    只能定义在抽象类中
    没有方法体。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Abstract &#123;</span><br><span class="line">	public abstract void show();</span><br><span class="line">	public abstract void eat();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cat extends Abstract&#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;猫吃鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(&quot;我是猫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog extends Abstract&#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;狗吃骨头&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(&quot;我是狗&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AbstractTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Abstract cat = new Cat();</span><br><span class="line">		cat.show();</span><br><span class="line">		cat.eat();</span><br><span class="line">		</span><br><span class="line">		Abstract dog = new Dog();</span><br><span class="line">		dog.show();</span><br><span class="line">		dog.eat();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java方法</title>
    <url>/2018/04/16/JavaSE-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对java中方法（函数）的一些个人总结</p>
<span id="more"></span>
<h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><h2 id="普通方法："><a href="#普通方法：" class="headerlink" title="普通方法："></a>普通方法：</h2><p>修饰符（ <em>public static</em> ） 返回值类型（ <em>int</em> ）方法名（ <em>show</em> ）()（参数）{}（方法体）</p>
<p>修饰符：修饰方法，描述调用方法的权限。<br>返回值类型：返回给调用者数据的类型。<br>方法名：标识此方法，命名规范下随意起名<br>参数：传递数据<br>方法体：放执行语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int show()&#123;</span><br><span class="line">	return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法重载：同名的方法（add相同）不同的参数列表（不同数量的参数或不同类型的参数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public double add(double a, double b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>方法名与类名相同，无参数类型，构造对象时执行。主要用于初始化数据(下例中初始化a的值)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Construction &#123;</span><br><span class="line">	int a;</span><br><span class="line">	public Construction()&#123;</span><br><span class="line">		System.out.println(&quot;无参构造&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public Construction(int a)&#123;</span><br><span class="line">		System.out.println(&quot;有参构造&quot;);</span><br><span class="line">		this.a = a;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-知识点</title>
    <url>/2020/11/12/JavaSE-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>JavaSE-知识点</p>
<span id="more"></span>

<h1 id="JavaSE-知识点"><a href="#JavaSE-知识点" class="headerlink" title="JavaSE-知识点"></a>JavaSE-知识点</h1><p>关键字，操作符，String类，重载与重写。面对对象，异常，集合类，线程，反射</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ol>
<li><p>static </p>
<p>static方法是否可以对非static方法的调用？</p>
<p>不能。当一个static方法被调用时，可能还没有创建任何实例对象。</p>
</li>
<li><p>final 类生成的实例化对象不可改变。</p>
</li>
<li><p>finally： try catch 最终执行的代码放在finally中，比如关闭资源。</p>
</li>
<li><p>finalize: Object的方法，垃圾收集器执行时调用此方法。</p>
</li>
<li><p>Integer与int的区别?</p>
<p>int是java的8大基本类型</p>
<p>Integer是int的包装类。</p>
</li>
</ol>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ol>
<li><p>&amp;和&amp;&amp;的区别</p>
<p>表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运bai算结果才为true，否则，只要有一方为false，则结果为false。</p>
<p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作</p>
</li>
<li><p>用最有效率的方法计算2乘以8</p>
<p> 2 &lt;&lt; 3</p>
</li>
</ol>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ol>
<li><p>String，StringBuffer，StringBuilder</p>
<p>String不可改变。</p>
<p>StringBuffer线程安全。</p>
<p>StringBuilder线程不安全，效率高。</p>
</li>
<li><p>equals</p>
</li>
<li><p>String s = new String(“xyz”);生成了几个对象</p>
<p>1个或两个。</p>
<p>常量池已经有”xyz”时，只生成了new String(“xyz”)一个对象。</p>
<p>String s 中 s是类String的引用。new String(“xyz”)是创建对象。</p>
</li>
<li><p>String s = “Hello”;s = s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</p>
<p>没有改变。final修饰的类，其对象不会被改变。</p>
</li>
<li><p>下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</p>
<p>1个。class文件中自动将其拼接。</p>
</li>
</ol>
<h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重写：重写父类的方法</p>
<p>重载：本类中相同方法名不同形参。</p>
<h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><p>封装，继承，多态。</p>
<p>接口，抽象类</p>
<p>接口多继承，类单继承。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li><p>异常处理机制的简单原理和应用</p>
<p>TODO</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>重载与重写</title>
    <url>/2018/04/19/JavaSE-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<p>重载与重写的不同</p>
<span id="more"></span>
<p>重写:将父类中的某个方法重新定义<br>      前提：继承关系<br>      在子类中定义一个和父类方法名相同的方法。 并在子类同名方法中编写自己的内容。</p>
<pre><code>       重载                          重写
  一个类中的同名方法，           子父类中的同名方法
  控制同名方法的参数类别         控制同名方法的载体
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OverrideTest extends Override&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		OverrideTest overrideTest = new OverrideTest();</span><br><span class="line">		overrideTest.method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method() &#123;</span><br><span class="line">		//super继承父类方法中的内容</span><br><span class="line">		super.method();</span><br><span class="line">		System.out.println(&quot;重写method方法&quot;);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Override &#123;</span><br><span class="line">	public void method() &#123;</span><br><span class="line">		System.out.println(&quot;method方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Jwt了解</title>
    <url>/2020/08/12/Jwt%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>Jwt了解</p>
<span id="more"></span>

<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>官网：<a href="https://jwt.io/introduction/">https://jwt.io/introduction/</a></p>
<p>参考：<a href="https://www.liqingbo.cn/docs/jwt/content/summary.html">https://www.liqingbo.cn/docs/jwt/content/summary.html</a></p>
<p>客户端与服务端之间验证的一种技术，取代了之前使用的Session</p>
<p><strong>Session存在的问题</strong>：</p>
<ul>
<li><p>Session不利于搭建服务器的集群（也就是必须访问原本的那个服务器才能获取对应的SessionId）</p>
</li>
<li><p>CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
</li>
</ul>
<h3 id="鉴权机制"><a href="#鉴权机制" class="headerlink" title="鉴权机制"></a>鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，不需要去考虑用户在哪一台服务器登录</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>用户使用用户名密码来请求服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附送上这个token值</li>
<li>服务端验证token值，并返回数据</li>
</ul>
<p>token必须要在每次请求时传递给服务端，它应该保存在请求头里。</p>
<p>服务端要支持<code>CORS(跨来源资源共享)</code>策略，后端设置<code>Access-Control-Allow-Origin: *</code></p>
<h3 id="JWT-structure（构成）"><a href="#JWT-structure（构成）" class="headerlink" title="JWT structure（构成）"></a>JWT structure（构成）</h3><p>header.payload.signature</p>
<p>xxxxx.yyyyy.zzzzz</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>存储两个变量</p>
<ol>
<li><p>token type，token类型一般是JWT</p>
</li>
<li><p>signing algorithm，签名算法，例如：HMAC SHA256 or RSA</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对其进行Base64Url 编码，生成header.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上例Base64Url编码后的内容</span><br><span class="line">ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9</span><br></pre></td></tr></table></figure>



<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>three parts:<em>registered</em>, <em>public</em>, and <em>private</em> claims.</p>
<ul>
<li>registered claims 标准中注册的声明 (非强制)<ul>
<li>iss:jwt签发者</li>
<li>exp:jwt的过期时间</li>
<li>sub:jwt面向的用户</li>
<li>aud:接收jwt的一方</li>
<li>nbf:该时间之前，jwt不可用</li>
<li>iat:jwt的签发时间</li>
<li>jti:jwt的唯一标识</li>
</ul>
</li>
<li><em>public</em> claims 公共的声明</li>
<li><em>private</em>  claims 私有的声明，除了registered、public</li>
</ul>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,//registered claims </span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其进行Base64Url 编码，生成payload.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上例Base64Url编码后的内容</span><br><span class="line">ewogICJzdWIiOiAiMTIzNDU2Nzg5MCIsLy9yZWdpc3RlcmVkIGNsYWltcyAKICAibmFtZSI6ICJKb2huIERvZSIsCiAgImFkbWluIjogdHJ1ZQp9</span><br></pre></td></tr></table></figure>

<h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>使用 secret 和报头指定的算法对header 和 payload进行签名，生成signature。</p>
<h2 id="为什么使用JWT"><a href="#为什么使用JWT" class="headerlink" title="为什么使用JWT"></a>为什么使用JWT</h2><h3 id="编码后的简洁性"><a href="#编码后的简洁性" class="headerlink" title="编码后的简洁性"></a>编码后的简洁性</h3><p>As JSON is less verbose than XML, when it is encoded its size is also  smaller, making JWT more compact than SAML. This makes JWT a good choice to be passed in HTML and HTTP environments.</p>
<h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h3><p>Security-wise, SWT can only be symmetrically signed by a shared secret  using the HMAC algorithm. However, JWT and SAML tokens can use a  public/private key pair in the form of a X.509 certificate for signing.  Signing XML with XML Digital Signature without introducing obscure  security holes is very difficult when compared to the simplicity of  signing JSON.</p>
<h3 id="解析的方便性"><a href="#解析的方便性" class="headerlink" title="解析的方便性"></a>解析的方便性</h3><p>JSON parsers are common in most programming languages because they map directly to objects. Conversely, XML doesn’t have a natural document-to-object mapping. This makes it easier to work with JWT than SAML assertions.</p>
<h3 id="服务器无关性"><a href="#服务器无关性" class="headerlink" title="服务器无关性"></a>服务器无关性</h3><p>Regarding usage, JWT is used at Internet scale. This highlights the ease of client-side processing of the JSON Web token on multiple platforms, especially mobile.</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>可以使用单个跨站点脚本窃取localStorage中的所有数据，因此建议不要在localStorage中存储敏感信息。</p>
<p>单个跨站点脚本也可用于将恶意数据加载到localStorage中，因此不要认为这些对象是可信的。</p>
<p>localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据。</p>
<p>localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。</p>
<p>localStorage 属性是只读的。</p>
<p>sessionStorage将数据保存在当前会话中</p>
<p>cookie可以使用httpOnly标志来降低这种风险。</p>
]]></content>
      <categories>
        <category>Jwt</category>
      </categories>
      <tags>
        <tag>Jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续正数序列-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>和为s的连续正数序列</p>
<span id="more"></span>

<h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面试题57：和为s的连续正数序列</span><br><span class="line">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FindContinuousSequence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int target = 28;</span><br><span class="line">        for (int[] arrs:findContinuousSequence(target)) &#123;</span><br><span class="line">            for (int arr:arrs) &#123;</span><br><span class="line">                System.out.print(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[][] findContinuousSequence(int target)&#123;</span><br><span class="line">        ArrayList&lt;int[]&gt; list = new ArrayList();</span><br><span class="line">        for (int i = 1; i &lt; target/2+2; i++) &#123;</span><br><span class="line">            int target2 = target;</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            //连续序列的开始为i</span><br><span class="line">            int end = 0;//连续序列的结束</span><br><span class="line">            for (int j = i; j &lt; target/2+2; j++) &#123;</span><br><span class="line">                target2 -= j;</span><br><span class="line">                if (target2 &lt; 0 )&#123;//不是连续序列</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (target2 == 0 )&#123;//是连续序列</span><br><span class="line">                    end = j;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                int[] a = new int[end - i+1];</span><br><span class="line">                int b = 0;</span><br><span class="line">                for (int j = i; j &lt; end+1; j++) &#123;</span><br><span class="line">                    a[b] = b+i;</span><br><span class="line">                    b++;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(a);//不知道二维数组长度，先放在list中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //从list取出数据转移到要求的二维数组中</span><br><span class="line">        int[][] aa = new int[list.size()][];</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            aa[i] = list.get(i);</span><br><span class="line">            //System.out.println(Arrays.toString((int[])list.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test()&#123;</span><br><span class="line">        int target = 15;</span><br><span class="line">        for (int i = 1; i &lt; target/2 + 1; i++) &#123;</span><br><span class="line">            //i为连续序列开头</span><br><span class="line">            int b = 0;//连续序列结尾</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            for (int j = i + 1; j &lt; target/2 + 2; j++) &#123;</span><br><span class="line">                if ((i+j)*(j-i+1)/2 == target)&#123;</span><br><span class="line">                    b = j;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                System.out.println(i+&quot;-&quot;+b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的最大面积-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>岛屿的最大面积</p>
<span id="more"></span>

<h1 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">695岛屿的最大面积:</span><br><span class="line">给定一个包含了一些 0 和 1 的非空二维数组 grid 。</span><br><span class="line">一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</span><br><span class="line">找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> 结果：6</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MaxAreaOfIsland &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] grid =  &#123;&#123;0,0,1,0,0,0,0,1,0,0,0,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,1,1,1,0,0,0&#125;,</span><br><span class="line">                         &#123;0,1,1,0,1,0,0,0,0,0,0,0,0&#125;,</span><br><span class="line">                         &#123;0,1,0,0,1,1,0,0,1,0,1,0,0&#125;,</span><br><span class="line">                         &#123;0,1,0,0,1,1,0,0,1,1,1,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,0,0,0,1,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,1,1,1,0,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,1,1,0,0,0,0&#125;&#125;;</span><br><span class="line">        System.out.println(maxAreaOfIsland(grid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 每次调用的时候假设num为1，进入后判断不是岛屿，则直接返回0，就可以避免错误的情况。</span><br><span class="line">    // 每次找到岛屿，把找到的岛屿改成0，这是传说中的沉岛思想，就是遇到岛屿就把沉默。</span><br><span class="line">    public static int maxAreaOfIsland(int[][] grid)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    res = Math.max(res,dfs(i, j, grid));//math.max选取岛屿中的最大值，不控制时，获得的岛屿值为最后岛屿值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //深度算法，递归实现</span><br><span class="line">    private static int dfs(int i, int j, int[][] grid) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[i].length || grid[i][j] == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = 0;//沉岛思想</span><br><span class="line">        int num = 1;//没进入if判断，则是岛屿</span><br><span class="line">        num += dfs(i + 1, j, grid);</span><br><span class="line">        num += dfs(i, j + 1, grid);</span><br><span class="line">        num += dfs(i - 1, j, grid);</span><br><span class="line">        num += dfs(i, j - 1, grid);</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串压缩-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>字符串压缩</p>
<span id="more"></span>

<h1 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a>字符串压缩</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面试题01.06 字符串压缩：利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</span><br><span class="line">示例1:</span><br><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">输出：&quot;a2b1c5a3&quot;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例2:</span><br><span class="line">输入：&quot;abbccd&quot;</span><br><span class="line">输出：&quot;abbccd&quot;</span><br><span class="line">解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CompressString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aabcccccaaa&quot;;</span><br><span class="line">        System.out.println(compressString(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String compressString(String s) &#123;</span><br><span class="line">        if (s.length() &lt;= 2 || s == null)</span><br><span class="line">            return s;</span><br><span class="line">        char[] ch = s.toCharArray();</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder().append(ch[0]);</span><br><span class="line">        char a = ch[0];//旧字符标记</span><br><span class="line">        int num = 1;//数量标记</span><br><span class="line">        for (int i = 1; i &lt; ch.length; i++) &#123;</span><br><span class="line">            if (a == ch[i]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //1.新串添加数量 2.新串添加新字符</span><br><span class="line">                stringBuilder.append(num).append(ch[i]);</span><br><span class="line">                //3.重置数量标记num</span><br><span class="line">                num = 1;</span><br><span class="line">                //4.重置旧字符标记a</span><br><span class="line">                a = ch[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == ch.length - 1) &#123;</span><br><span class="line">                stringBuilder.append(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.length() &lt;= stringBuilder.length() ? s : stringBuilder.toString();</span><br><span class="line">        //System.out.println(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>拼写单词-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>拼写单词</p>
<span id="more"></span>

<h1 id="拼写单词"><a href="#拼写单词" class="headerlink" title="拼写单词"></a>拼写单词</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1160.拼写单词</span><br><span class="line">给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</span><br><span class="line">假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</span><br><span class="line">注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</span><br><span class="line">返回词汇表 words 中你掌握的所有单词的 长度之和。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br><span class="line"></span><br><span class="line">@see https://leetcode-cn.com/problems</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GetChar2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] words = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;&#125;;</span><br><span class="line">        String chars = &quot;welldonehoneyr&quot;;</span><br><span class="line">        System.out.println(countCharacters(words,chars));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.统计字母表chars中26个字母个数</span><br><span class="line">    //2.统计词汇表中单个词汇words[i]中26个字母个数</span><br><span class="line">    //3.单个词汇中字母个数与字母表中字母个数比较</span><br><span class="line">    public static int countCharacters(String[] words, String chars) &#123;</span><br><span class="line">        //字母表26个字母的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int[] chars1 = new int[26];</span><br><span class="line">        for (char c : chars.toCharArray()) &#123;</span><br><span class="line">            chars1[c - &#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String str : words) &#123;</span><br><span class="line">            int[] chars2 = new int[26];</span><br><span class="line">            //每个单词26个字母的个数</span><br><span class="line">            for (char strch : str.toCharArray()) &#123;</span><br><span class="line">                chars2[strch - &#x27;a&#x27;]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //System.out.println(Arrays.toString(chars2));</span><br><span class="line">            boolean flag = true;</span><br><span class="line">            //比较单词和字母表的26个字母数量的大小</span><br><span class="line">            for (int i = 0; i &lt; chars2.length; i++) &#123;</span><br><span class="line">                if (chars2[i] &gt; chars1[i])&#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                sum += str.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文串-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>最长回文串</p>
<span id="more"></span>

<h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">407.最长回文串:给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class="line">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class="line">注意:</span><br><span class="line">假设字符串的长度不会超过 1010。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @see https://leetcode-cn.com/problems/</span><br><span class="line">public class LongestPalindrome &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abccccdd&quot;;</span><br><span class="line">        System.out.println(longestPalindrome(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int longestPalindrome(String s) &#123;</span><br><span class="line">        int[] count = new int[128];</span><br><span class="line">        //统计每个字符的数量</span><br><span class="line">        for (char c: s.toCharArray())</span><br><span class="line">            count[c]++;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int v: count) &#123;</span><br><span class="line">            ans += v / 2 * 2;// 字符出现次数&gt;1的字符可构成v/2*2</span><br><span class="line">            //当有字符出现奇数次时，可放在回文正中间</span><br><span class="line">            if (v % 2 == 1 &amp;&amp; ans % 2 == 0)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>矩形重叠-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<p>矩形重叠</p>
<span id="more"></span>

<h1 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">836矩形重叠：矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">给出两个矩形，判断它们是否重叠并返回结果。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例 1：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">        输出：true</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例 2：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">        输出：false</span><br><span class="line">&lt;p&gt;</span><br><span class="line">说明：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</span><br><span class="line">        矩形中的所有坐标都处于 -10^9 和 10^9 之间。</span><br><span class="line">&lt;p&gt;</span><br><span class="line"></span><br><span class="line">@see https://leetcode-cn.com/problems/rectangle-overlap</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IsRectangleOverlap &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] rec1 = &#123;0, 0, 2, 2&#125;;</span><br><span class="line">        int[] rec2 = &#123;1, 3, 4, 4&#125;;</span><br><span class="line">        System.out.println(isRectangleOverlap(rec1, rec2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123;</span><br><span class="line">        //不重叠的情况：rec1在rec2左侧，rec1在rec2右侧，rec1在rec2上侧，rec1在rec2下侧</span><br><span class="line">        //左侧：rec1的最右边小于等于rec2的最左边。rec1[2] ≤rec2[0]</span><br><span class="line">        //右侧：rec1的最左边大于等于rec2的最右边。rec1[0] &gt;= rec2[2]</span><br><span class="line">        //上侧：rec1的最下边大于等于rec2的最上边。rec1[1] &gt;= rec2[3])</span><br><span class="line">        //下侧：rec1的最上边小于等于rec2的最下边。rec1[3] &lt;= rec2[1]</span><br><span class="line">        return !(rec1[2] &lt;= rec2[0] ||   // left</span><br><span class="line">                rec1[0] &gt;= rec2[2] ||   // right</span><br><span class="line">                rec1[1] &gt;= rec2[3]||   // top</span><br><span class="line">                rec1[3] &lt;= rec2[1]);  // bottom</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表的中间结点-LeetCode</title>
    <url>/2019/05/19/LeetCode-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>链表的中间结点</p>
<span id="more"></span>

<h1 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">876.链表的中间结点</span><br><span class="line">给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">如果有两个中间结点，则返回第二个中间结点。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例 1：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MiddleNode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListNode head = new ListNode(1);</span><br><span class="line">        head.next = new ListNode(2);</span><br><span class="line">        head.next.next = new ListNode(3);</span><br><span class="line">        head.next.next.next = new ListNode(4);</span><br><span class="line">        System.out.println(middleNode(head).val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ListNode middleNode(ListNode head) &#123;</span><br><span class="line">        //快慢指针</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Definition for singly-linked list.</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-xshell</title>
    <url>/2020/09/05/Linux-xshell/</url>
    <content><![CDATA[<p>Linux-xshell</p>
<span id="more"></span>

<h1 id="Linux-xshell"><a href="#Linux-xshell" class="headerlink" title="Linux-xshell"></a>Linux-xshell</h1><p>参考：<a href="https://www.cnblogs.com/shireenlee4testing/p/9469650.html">https://www.cnblogs.com/shireenlee4testing/p/9469650.html</a></p>
<p>IP地址、子网掩码和网关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim</span><br><span class="line">i</span><br><span class="line">esc</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/DxBGu8U452WTXsS.png" alt="image-20200905172230121"></p>
<p>设置DNS</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/M53vlbCtyou9X8I.png" alt="image-20200905172951580"></p>
<p>设置主机名</p>
<p><code>vim /etc/sysconfig/network</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SVFwH6GXMOlhdo9.png" alt="image-20200905174159032"></p>
<p><code>vim /etc/hostname</code></p>
<p>粘贴shift+insert</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8AoU4bkdBpELsDa.png" alt="image-20200905174437855"></p>
<p>连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh 192.168.3.3</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uDb9IGr5mtcEPi8.png" alt="image-20200905174104282"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-常用命令</title>
    <url>/2020/11/05/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux-常用命令</p>
<span id="more"></span>

<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux-常用命令"></a>Linux-常用命令</h1><p>cat 查看文件</p>
<p>more 查看file的内容</p>
<p>tar 解压</p>
<p>gzip 压缩</p>
<p>rpm 安装</p>
<p>yum 安装</p>
<p>rz 上载到linux</p>
<p>sz 下载到本地</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zumTHUjq8tgN1I5.png" alt="mmexport1560212361684"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j-log4j2报错</title>
    <url>/2020/08/18/Log4j-log4j2%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>Log4j-log4j2报错</p>
<span id="more"></span>

<h1 id="log4j2报错"><a href="#log4j2报错" class="headerlink" title="log4j2报错"></a>log4j2报错</h1><p>报错内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at org.apache.logging.log4j.LogManager.getContext(LogManager.java:194)</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j2 与 spring-boot-starter-logging 模块中的 log4j </span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>排除spring-boot-starter-logging包,可能有多个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;&lt;!-- 去掉默认配置 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;&lt;!-- 去掉默认配置 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NpuHa6jSows3K4y.png" alt="image-20200818191029138"></p>
]]></content>
      <categories>
        <category>Log4j</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis两种开发方式-Mybatis</title>
    <url>/2019/10/22/Mybatis-Mybatis%E4%B8%A4%E7%A7%8D%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Mybatis两种开发方式</p>
<span id="more"></span>

<h1 id="Mybatis两种开发方式"><a href="#Mybatis两种开发方式" class="headerlink" title="Mybatis两种开发方式"></a>Mybatis两种开发方式</h1><h2 id="1-xml开发："><a href="#1-xml开发：" class="headerlink" title="1.xml开发："></a>1.xml开发：</h2><h3 id="1-全局配置文件"><a href="#1-全局配置文件" class="headerlink" title="1.全局配置文件"></a>1.全局配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载属性文件 --&gt;</span><br><span class="line">    &lt;properties resource=&quot;config.properties&quot;&gt;</span><br><span class="line">        &lt;!--properties中还可以配置一些属性名和属性值 --&gt;</span><br><span class="line">        &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 全局配置参数，需要时再设置 --&gt;</span><br><span class="line">    &lt;!-- &lt;settings&gt; &lt;/settings&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;!-- 别名定义 --&gt;</span><br><span class="line">        &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名，类名不能写错</span><br><span class="line">         别名可以随便起，但最好规范--&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;xiaoruiit.mybatis_introduction.pojo.User&quot; alias=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">        &lt;package name=&quot;xiaoruiit.mybatis_introduction.pojo&quot; /&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理，事务控制由mybatis --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池，由mybatis管理 --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载映射文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--通过resource方法一次加载一个映射文件 --&gt;</span><br><span class="line">        &lt;!--注意这里的路径和xml文件 --&gt;</span><br><span class="line">        &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 --&gt;</span><br><span class="line">        &lt;!-- 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 --&gt;</span><br><span class="line">        &lt;!-- 中上边规范的前提是：使用的是mapper代理方法</span><br><span class="line">        &lt;package name=&quot;....&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>​    <code>properties</code>配置数据库属性,可覆盖<code>property</code>,<code>dataSource</code>中的<code>value</code>需要增加jdbc前缀，否则可能读取到windows系统的配置</p>
<p>​    <code>typeAliases</code>配置别名</p>
<p>​    <code>mappers</code>配置mapper.xml所在位置</p>
<h3 id="2-Mapper接口-即dao"><a href="#2-Mapper接口-即dao" class="headerlink" title="2.***Mapper接口,即dao"></a>2.<code>***Mapper</code>接口,即dao</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">	User findUserById(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Mapper-xml"><a href="#3-Mapper-xml" class="headerlink" title="3.***Mapper.xml"></a>3.<code>***Mapper.xml</code></h3><p>​    <code>namespace</code>对应<code>***Mapper</code>接口所在路径</p>
<p>​    id对应Mapper接口方法名</p>
<p>​    <code>parameterType</code>对应Mapper接口的参数类型</p>
<p>​    <code>resultType</code>对应Mapper接口的返回值类型，可以使用全局配置文件的别名<code>typeAliases</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xiaoruiit.mybatis_introduction.dao.UserMapper&quot;&gt;</span><br><span class="line">	&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">		SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>输入映射<code>parameterType</code>：</p>
<ul>
<li><p>简单类型，java</p>
</li>
<li><p>pojo类型、map类型，两种类型一样的处理</p>
</li>
<li><p>List类型，List里边是什么类型就放什么类型</p>
</li>
<li><p>pojo包装pojo类型 </p>
</li>
</ul>
</li>
<li><p>输出映射<code>resultType</code>、<code>resultMap</code></p>
<ul>
<li>``resultType`可映射简单类型、pojo类型、Map类型</li>
<li><code>resultMap</code>可实现，查询列和属性不一致、关联关系，延迟加载</li>
</ul>
</li>
</ol>
<p><code>resultMap</code>：需要单独写resultMap标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义resultMap：将查询的列名和映射的pojo的属性名做一个对应关系 --&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">	 	 type：指定查询结果要映射的pojo的类型</span><br><span class="line">	 	 id：指定resultMap的唯一标示</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;</span><br><span class="line">	 	 &lt;!--</span><br><span class="line">	 	 id标签：映射查询结果的唯一列（主键列）</span><br><span class="line">	 	 	 column：查询sql的列名</span><br><span class="line">	 	 	 property：映射结果的属性名</span><br><span class="line">	 	 --&gt;</span><br><span class="line">	 	 &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">	 	 &lt;!-- result标签：映射查询结果的普通列 --&gt;</span><br><span class="line">	 	 &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;birthday_&quot; property=&quot;birthday&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!-- resultMap入门 --&gt;</span><br><span class="line">&lt;select id=&quot;findUserListResultMap&quot; resultMap=&quot;userListResultMap&quot;&gt;</span><br><span class="line">	 	 SELECT id id_,username username_,birthday birthday_ FROM user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>加载全局配置文件</p>
<p>获取sqlSessionFactory对象，通过sqlSessionFactory的getMapper获取业务对象mapper，</p>
<p>mapper对象执行Mapper接口的实际业务相关的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void init() throws Exception &#123;</span><br><span class="line">    // 加载全局配置文件（同时把映射文件也加载了）</span><br><span class="line">    String resource = &quot;phase02/SqlMapConfig.xml&quot;;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    // sqlsessionFactory需要通过sqlsessionFactoryBuilder读取全局配置文件信息之后</span><br><span class="line">    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testFindUserById() &#123;</span><br><span class="line">    //创建UserMapper对象</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    //调用UserMapper对象的API</span><br><span class="line">    User user = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-注解开发"><a href="#2-注解开发" class="headerlink" title="2.注解开发"></a>2.注解开发</h2><h3 id="1-全局配置文件-1"><a href="#1-全局配置文件-1" class="headerlink" title="1.全局配置文件"></a>1.全局配置文件</h3><p>和XML方式一样,不需要配置mappers属性</p>
<h3 id="2-Mapper接口"><a href="#2-Mapper接口" class="headerlink" title="2.***Mapper接口"></a>2.***Mapper接口</h3><p>接口方法</p>
<p>接口方法上写注解，不需要xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查询</span><br><span class="line">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span><br><span class="line">public User findUserById(int id);</span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><p>和XML方式一样</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-入门</title>
    <url>/2019/10/21/Mybatis-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>使用mybatis从数据库中通过User类的id查询出user</p>
<span id="more"></span>

<p>中文官网：<a href="http://www.mybatis.org/mybatis-3/zh/index.html">www.mybatis.org/mybatis-3/zh/index.html</a></p>
<p><strong>目标：</strong>使用mybatis从数据库中通过User类的id查询出user</p>
<p><strong>介绍：</strong>优秀的持久层框架，支持定制化SQL、存储过程、高级映射。</p>
<p><strong>Implement</strong></p>
<h2 id="1-新建Maven项目"><a href="#1-新建Maven项目" class="headerlink" title="1.新建Maven项目"></a>1.新建Maven项目</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/AoXgIEdWjDHr8h7.png" alt="image-20200523210231180"></p>
<h2 id="2-导入Mybatis的jar包"><a href="#2-导入Mybatis的jar包" class="headerlink" title="2.导入Mybatis的jar包"></a>2.导入Mybatis的jar包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- mybatis核心包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- mysql驱动包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.29&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- junit测试包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 日志文件管理包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-User类"><a href="#3-User类" class="headerlink" title="3.User类"></a>3.User类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname User</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-创建数据库"><a href="#4-创建数据库" class="headerlink" title="4.创建数据库"></a>4.创建数据库</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8WFmVBPRbQq7y5U.png" alt="image-20200523184805091"></p>
<h2 id="5-Mybatis全局配置文件"><a href="#5-Mybatis全局配置文件" class="headerlink" title="5.Mybatis全局配置文件"></a>5.Mybatis全局配置文件</h2><p>resource下新建config.properties和mybatis-config.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver = com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url = jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=UTF-8</span><br><span class="line">jdbc.username = root</span><br><span class="line">jdbc.password = 123456</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载属性文件 --&gt;</span><br><span class="line">    &lt;properties resource=&quot;config.properties&quot;&gt;</span><br><span class="line">        &lt;!--properties中还可以配置一些属性名和属性值 --&gt;</span><br><span class="line">        &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 全局配置参数，需要时再设置 --&gt;</span><br><span class="line">    &lt;!-- &lt;settings&gt; &lt;/settings&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;!-- 别名定义 --&gt;</span><br><span class="line">        &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名，类名不能写错</span><br><span class="line">         别名可以随便起，但最好规范--&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;xiaoruiit.mybatis_introduction.pojo.User&quot; alias=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">        &lt;package name=&quot;xiaoruiit.mybatis_introduction.pojo&quot; /&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理，事务控制由mybatis --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池，由mybatis管理 --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载映射文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--通过resource方法一次加载一个映射文件 --&gt;</span><br><span class="line">        &lt;!--注意这里的路径和xml文件 --&gt;</span><br><span class="line">        &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 --&gt;</span><br><span class="line">        &lt;!-- 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 --&gt;</span><br><span class="line">        &lt;!-- 中上边规范的前提是：使用的是mapper代理方法</span><br><span class="line">        &lt;package name=&quot;....&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Mapper-xml配置文件-sql语句"><a href="#6-Mapper-xml配置文件-sql语句" class="headerlink" title="6.***Mapper.xml配置文件(sql语句)"></a>6.***Mapper.xml配置文件(sql语句)</h2><p>resource下新建UserMapper.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 在映射文件中配置很多sql语句 --&gt;</span><br><span class="line">    &lt;!-- 将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt;</span><br><span class="line">    &lt;!-- parameterType：指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符号 --&gt;</span><br><span class="line">    &lt;!-- #&#123;id&#125;：其中的id表示接收输入的参数，参数名称就是id，如果输入 --&gt;</span><br><span class="line">    &lt;!-- 参数是简单类型，#&#123;&#125;中的参数名可以任意，可以value或其它名称 --&gt;</span><br><span class="line">    &lt;!-- resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。 --&gt;</span><br><span class="line">    &lt;!-- 表名要对，但是不区分大小写，resultType要写类名，同样不区分大小写 user对应mybatis-config里边的typeAliases别名属性--&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot;  resultType=&quot;user&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7-单元测试"><a href="#7-单元测试" class="headerlink" title="7.单元测试"></a>7.单元测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import xiaoruiit.mybatis_introduction.pojo.User;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname UserTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">    public SqlSessionFactory getSqlSessionFactory() throws IOException &#123;</span><br><span class="line">        // mybatis配置文件，这个地方的root地址为：resources，路径要对。</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        // 得到配置文件流</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        // 创建会话工厂，传入mybatis的配置文件信息</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据id查询用户信息，得到一条记录结果</span><br><span class="line">    @Test</span><br><span class="line">    public void findUserByIdTest() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = this.getSqlSessionFactory().openSession();</span><br><span class="line"></span><br><span class="line">        // 通过SqlSession操作数据库</span><br><span class="line">        // 第一个参数：映射文件中statement的id，等于=namespace+&quot;.&quot;+statement的id</span><br><span class="line">        // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数</span><br><span class="line">        // sqlSession.selectOne结果 是与映射文件中所匹配的resultType类型的对象</span><br><span class="line"></span><br><span class="line">        // selectOne查询出一条记录（这种很麻烦的！！！往后看看）</span><br><span class="line">        //这里的参数test.findUserById，test为命名空间，要与user.xml中的对应起来，</span><br><span class="line">        //同理，findUserById也要在user.xml中存在，不然都会报错</span><br><span class="line"></span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);</span><br><span class="line"></span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        // 释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">zs</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>高级特性</title>
    <url>/2019/10/23/Mybatis-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>高级特性，包括关联查询、延迟加载、动态SQL、缓存、逆向工程、PageHelper分页插件</p>
<span id="more"></span>

<h1 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1.关联查询"></a>1.关联查询</h1><h2 id="1-一对一"><a href="#1-一对一" class="headerlink" title="1.一对一"></a>1.一对一</h2><p>例子：一个order订单对应一个user</p>
<p>需要创建专门的结果映射类，OrderExt，里边有User属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OrdersExt extends Orders &#123;</span><br><span class="line"> private User user;// 用户对象</span><br><span class="line">// get/set。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resultMap配置普通的OrderExp的属性+User属性</p>
<ul>
<li><p>​    普通属性直接用result</p>
</li>
<li><p>​    User属性用association内嵌result</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查询订单关联用户信息使用resultmap --&gt;</span><br><span class="line">&lt;resultMap type=&quot;OrdersExt&quot; id=&quot;ordersAndUserRstMap&quot;&gt;</span><br><span class="line">	 	 &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;</span><br><span class="line">	 	 &lt;!-- 一对一关联映射 --&gt;</span><br><span class="line">	 	 &lt;!--</span><br><span class="line">	 	 property:Orders对象的user属性</span><br><span class="line">	 	 javaType：user属性对应 的类型</span><br><span class="line">	 	 --&gt;</span><br><span class="line">	 	 &lt;association property=&quot;user&quot; javaType=&quot;com.kkb.mybatis.po.User&quot;&gt;</span><br><span class="line">	 	 	 &lt;!-- column:user表的主键对应的列 property：user对象中id属性--&gt;</span><br><span class="line">	 	 	 &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;</span><br><span class="line">	 	 &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;findOrdersAndUserRstMap&quot; resultMap=&quot;ordersAndUserRstMap&quot;&gt;</span><br><span class="line">	 	 SELECT</span><br><span class="line">	 	 	 o.id,</span><br><span class="line">	 	 	 o.user_id,</span><br><span class="line">	 	 	 o.number,</span><br><span class="line">	 	 	 o.createtime,</span><br><span class="line">	 	 	 o.note,</span><br><span class="line">	 	 	 u.username,</span><br><span class="line">	 	 	 u.address</span><br><span class="line">	 	 FROM</span><br><span class="line">	 	 	 orders o</span><br><span class="line">	 	 JOIN `user` u ON u.id = o.user_id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2.一对多"></a>2.一对多</h2><p>例子：一个用户有多个订单</p>
<p>User类中有<code>List&lt;Orders&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String  username;</span><br><span class="line">	private String sex;</span><br><span class="line">	private Date birthday;</span><br><span class="line">	private String address;</span><br><span class="line">	private List&lt;Orders&gt; orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resultMap配置User的普通属性+<code>List&lt;Orders&gt;</code>属性</p>
<ul>
<li>普通属性用result</li>
<li><code>List&lt;Orders&gt;</code>用collection,collection的返回类型用ofType配置为List内的泛型orders</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type=&quot;user&quot; id=&quot;userAndOrderRstMap&quot;&gt;</span><br><span class="line">	 	 &lt;!-- 用户信息映射 --&gt;</span><br><span class="line">	 	 &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;</span><br><span class="line">	 	 &lt;!-- 一对多关联映射 --&gt;</span><br><span class="line">	 	 &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;</span><br><span class="line">	 	 	 &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;</span><br><span class="line">	 	 &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;findUserAndOrderRstMap&quot; resultMap=&quot;userAndOrderRstMap&quot;&gt;</span><br><span class="line">	 	 SELECT</span><br><span class="line">	 	 u.*,</span><br><span class="line"> o.id oid,</span><br><span class="line">	 	 o.number,</span><br><span class="line">	 	 o.createtime,</span><br><span class="line">	 	 o.note</span><br><span class="line">	 	 FROM</span><br><span class="line">	 	 `user` u</span><br><span class="line">	 	 LEFT JOIN orders o ON u.id = o.user_id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h1 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2.延迟加载"></a>2.延迟加载</h1><p>延迟加载，也称为懒加载，关联查询时，推迟查询关联对象的查询。</p>
<p>目的：减少数据库的压力。</p>
<p>分类：直接加载、侵入式加载、深度延迟加载</p>
<p>存在的问题：深度加载存在N+1的问题。深度加载的实现是主查询+N次子查询，会发送N次SQL子查询语句。子查询记录比较多时，发送SQL子查询语句很消耗资源。</p>
<p>使用：需要resultMap中的association和collection子标签，主配置文件中settings配置延迟加载<code>lazyLoadingEnabled</code>和<code>aggressiveLazyLoading</code>，resultMap子标签也可开启延迟加载属性<code>fetchType</code>，子标签的<code>fetchType</code>可覆盖全局属性</p>
<p><strong>直接加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;!-- 延迟加载总开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p><strong>侵入式延迟加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;!-- 延迟加载总开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line"> &lt;!-- 侵入式延迟加载开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p><strong>深度延迟加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;!-- 延迟加载总开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line"> &lt;!-- 侵入式延迟加载开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<h1 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3.缓存"></a>3.缓存</h1><h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h2><p>默认开启，作用域：同一个sqlsession中。修改和删除会清除缓存。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOneLevelCache() &#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库</span><br><span class="line">    User user1 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    // 第二次查询ID为1的用户</span><br><span class="line">    User user2 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOneLevelCache() &#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库</span><br><span class="line">    User user1 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setUsername(&quot;隔壁老詹1&quot;);</span><br><span class="line">    user.setAddress(&quot;洛杉矶湖人&quot;);</span><br><span class="line">    //执行增删改操作，清空缓存</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">    // 第二次查询ID为1的用户</span><br><span class="line">    User user2 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2.二级缓存"></a>2.二级缓存</h2><p>默认不开启，作用域：同一个Mapper（namespace）中。不同的sqlsseion可查询到同一个Mapper缓存中的数据。</p>
<p>开启方式：全局配置settings+namespace配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启二级缓存总开关 --&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启本mapper下的namespace的二级缓存，默认使用的是mybatis提供的PerpetualCache --&gt;</span><br><span class="line">&lt;cache&gt;&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p>一般不用，二级缓存控制粒度较粗，同一个namespace中执行任何增删改都会清除缓存。</p>
<p>二级缓存的数据不一定都是存储到内存中  ，比如文件系统 ，二级缓存相关的类和父类需要实现序列化。</p>
<p>一种办法：namespace中只存放查询语句。不清楚其他地方修改了数据库中此namespace中的记录，是否会读到脏数据？</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTwoLevelCache() &#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession3 = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class);</span><br><span class="line">    // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库</span><br><span class="line">    User user1 = mapper1.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    // 关闭SqlSession1</span><br><span class="line">    sqlSession1.close();</span><br><span class="line">    // 第二次查询ID为1的用户</span><br><span class="line">    User user2 = mapper2.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    // 关闭SqlSession2</span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-动态SQL"><a href="#4-动态SQL" class="headerlink" title="4.动态SQL"></a>4.动态SQL</h1><p>解决：字符串的拼接处理、循环判断。  </p>
<h2 id="1-if标签"><a href="#1-if标签" class="headerlink" title="1.if标签"></a>1.if标签</h2><p>queryvo中封装有user对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    SELECT * FROM user where 1=1</span><br><span class="line">    &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">        	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-where标签"><a href="#2-where标签" class="headerlink" title="2.where标签"></a>2.where标签</h2><p>解决 if标签内容开头规定为AND，where 后需要 1 = 1，解决1=1的性能问题 。1=1时不使用索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    &lt;!-- where标签会处理它后面的第一个and --&gt;</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">            &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-SQL片段复用"><a href="#3-SQL片段复用" class="headerlink" title="3.SQL片段复用"></a>3.SQL片段复用</h2><p>include标签，提取可复用代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;query_user_where&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">        	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sq</span><br></pre></td></tr></table></figure>

<p>使用include标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用包装类型查询用户 使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内</span><br><span class="line">容部的属性 --&gt;</span><br><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    &lt;!-- where标签会处理它后面的第一个and --&gt;</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">    	&lt;include refid=&quot;query_user_where&quot;&gt;&lt;/include&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>引用其他Mapper标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;namespace.sql片段”/&gt;  </span><br></pre></td></tr></table></figure>

<h2 id="4-foreach标签"><a href="#4-foreach标签" class="headerlink" title="4.foreach标签"></a>4.foreach标签</h2><p>需求：综合查询时，传入多个id查询用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM USER WHERE username LIKE &#x27;%老郭%&#x27; AND id IN (1,10,16)</span><br></pre></td></tr></table></figure>

<p>pojo中添加<code>List&lt;Interger&gt; ids</code>属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class QueryVo &#123;</span><br><span class="line">	private User user;</span><br><span class="line">	private List&lt;Interger&gt; ids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;query_user_where&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">        	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;!-- collection： 指定输入的集合参数的参数名称 --&gt;</span><br><span class="line">        &lt;!-- item： 声明集合参数中的元素变量名 --&gt;</span><br><span class="line">        &lt;!-- open： 集合遍历时，需要拼接到遍历sql语句的前面 --&gt;</span><br><span class="line">        &lt;!-- close： 集合遍历时，需要拼接到遍历sql语句的后面 --&gt;</span><br><span class="line">        &lt;!-- separator： 集合遍历时，需要拼接到遍历sql语句之间的分隔符号 --&gt;</span><br><span class="line">        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot; AND id IN ( &quot;</span><br><span class="line">            close=&quot; ) &quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<h1 id="5-逆向工程"><a href="#5-逆向工程" class="headerlink" title="5.逆向工程"></a>5.逆向工程</h1><p><strong>功能：</strong>可以依据数据库表生成User实体类、UserExample扩展类、UserMapper接口、UserMapper.xml。UserMapper.xml包括增删改查。不可自动实现部分：一对一、一对多映射。</p>
<p><strong>如何使用：</strong>导入逆向工程项目，配置生成的各个类的路径，执行逆向工程main函数。</p>
<p><strong>配置文件：</strong></p>
<ol>
<li><p>修改要生成的数据库表</p>
</li>
<li><p>pojo文件所在包路径</p>
</li>
<li><p>Mapper所在的包路径  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;commentGenerator&gt;&lt;!-- 是否去除自动生成的注释 true： 是 ： false:否 --&gt;</span><br><span class="line">        	&lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        	connectionURL=&quot;jdbc:mysql://localhost:3306/ssm&quot; userId=&quot;root&quot;</span><br><span class="line">        	password=&quot;root&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;</span><br><span class="line">        	connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;</span><br><span class="line">        	userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt;</span><br><span class="line">        &lt;!-- 默认false， 把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer， 为 true时</span><br><span class="line">        	把JDBC DECIMAL和 NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">        	&lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line">        &lt;!-- targetProject:生成PO类的位置 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.kkb.ms.po&quot; targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.kkb.ms.mapper&quot; targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- targetPackage： mapper接口生成的位置 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.kkb.ms.mapper&quot; targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 指定数据库表 --&gt;</span><br><span class="line">        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table schema=&quot;&quot; tableName=&quot;order&quot;&gt;&lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>

<h1 id="6-分页插件PageHelper"><a href="#6-分页插件PageHelper" class="headerlink" title="6.分页插件PageHelper"></a>6.分页插件PageHelper</h1><p><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/en/HowToUse.md">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/en/HowToUse.md</a></p>
<p>功能：分页</p>
<p>原理：实现Mybatis预留的分页接口。</p>
<p>使用：</p>
<p>​    导入jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置全局配置文件plugins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;</span><br><span class="line">        &lt;!-- config params as the following --&gt;</span><br><span class="line">        &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取第1页， 每页10条内容，默认查询总数count</span><br><span class="line">PageHelper.startPage(1, 10);</span><br><span class="line">//增加上边一行后，此处的返回的list变为PageHelper提供的Page对象。</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectAll();</span><br><span class="line">//用PageInfo对结果进行包装</span><br><span class="line">PageInfo page = new PageInfo(list);</span><br><span class="line">//测试PageInfo全部属性</span><br><span class="line">//PageInfo包含了非常全面的分页属性</span><br><span class="line">assertEquals(1, page.getPageNum());</span><br><span class="line">assertEquals(10, page.getPageSize());</span><br><span class="line">assertEquals(1, page.getStartRow());</span><br><span class="line">assertEquals(10, page.getEndRow());</span><br><span class="line">assertEquals(183, page.getTotal());</span><br><span class="line">assertEquals(19, page.getPages());</span><br><span class="line">assertEquals(1, page.getFirstPage());</span><br><span class="line">assertEquals(8, page.getLastPage());</span><br><span class="line">assertEquals(true, page.isFirstPage());</span><br><span class="line">assertEquals(false, page.isLastPage());</span><br><span class="line">assertEquals(false, page.isHasPreviousPage());</span><br><span class="line">assertEquals(true, page.isHasNextPage());</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​    查询语句是使用resultMap进行的嵌套结果映射，则无法使用PageHelper进行分页  </p>
<p><strong><code>PageHelper</code> 安全调用</strong></p>
<ul>
<li><p>不安全：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(1, 10);</span><br><span class="line">List&lt;User&gt; list;</span><br><span class="line">if(param1 != null)&#123;</span><br><span class="line">    list = userMapper.selectIf(param1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    list = new ArrayList&lt;User&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>安全：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list;</span><br><span class="line">if(param1 != null)&#123;</span><br><span class="line">    PageHelper.startPage(1, 10);</span><br><span class="line">    list = userMapper.selectIf(param1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    list = new ArrayList&lt;User&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>高级特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务</title>
    <url>/2020/07/29/Mysql-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>MySQL中的InnoDB引擎实现了事务。</p>
<span id="more"></span>

<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>原子性：由undo log保证</p>
<p>隔离性：</p>
<p>一致性：由redo log保证</p>
<p>持久性：有redo log保证</p>
<h2 id="InnoDB架构"><a href="#InnoDB架构" class="headerlink" title="InnoDB架构"></a>InnoDB架构</h2><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/aV1sTqgQmh5Eowr.png" alt="image-20200728072518535"></p>
<h4 id="BufferPool-缓冲池"><a href="#BufferPool-缓冲池" class="headerlink" title="BufferPool 缓冲池"></a>BufferPool 缓冲池</h4><p>数据页</p>
<p>脏页</p>
<p>insert buffer 插入缓冲（插入比较复杂）</p>
<p>lock info 锁信息</p>
<p>data dictionary 表定义信息</p>
<p>undo log（数据的历史记录）</p>
<h4 id="Redo-log-Buffer"><a href="#Redo-log-Buffer" class="headerlink" title="Redo log Buffer"></a>Redo log Buffer</h4><h4 id="redo-log-的落盘机制"><a href="#redo-log-的落盘机制" class="headerlink" title="redo log 的落盘机制"></a>redo log 的落盘机制</h4><p>buffer pool</p>
<p>redo log buffer</p>
<p>OS Buffer（文件系统缓存）：存储应用程序命令的缓存，这是属于操作系统的。调用fsync可以将文件系统缓存写入到磁盘。</p>
<p>ib_logfiles（磁盘）：操作系统才能操作磁盘。</p>
<ol>
<li><p>默认落盘机制：</p>
<p>innodb_flflush_log_at_trx_commit =2</p>
<p>commit;// 记录到redo log buffer 并经过OSBuffer调用一次fsync写入到redo log file(磁盘)</p>
</li>
<li><p>innodb_flflush_log_at_trx_commit =0时：</p>
<p>commit;// 记录到 redo log buffer，隔固定时间，刷新到redo log file（磁盘）</p>
</li>
<li><p>innodb_flflush_log_at_trx_commit =1时：</p>
<p>commitj;//记录到 redo log buffer,并写入到 OS Buffer，操作系统隔固定时间刷新到磁盘。</p>
<p>这一级别下，操作系统不崩溃，数据也不会丢失。</p>
</li>
</ol>
<h4 id="buffer-pool-落盘机制"><a href="#buffer-pool-落盘机制" class="headerlink" title="buffer pool 落盘机制"></a>buffer pool 落盘机制</h4><h5 id="Double-write双写"><a href="#Double-write双写" class="headerlink" title="Double write双写"></a>Double write双写</h5><p>带给InnoDB存储引擎的是数据页的可靠性</p>
<p>Double write由两部分组成，一部分是内存中的double write buffer,大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也是2MB。对缓冲池的脏页刷新时，通过memcpy函数将脏页先复制到内存中的double write buffer区域，之后通过double write buffer再分两次，每次1MB写入（系统）共享表空间的物理磁盘上，然后调用fsync函数，同步磁盘。完成double write页的写入后，再将double write buffer中的页写入各个表空间文件中。如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB可以从共享表空间中的double write 中找到该页的副本，将其复制到表空间文件中。</p>
<p>系统表空间和用户表空间各存一份。</p>
<h5 id="CheckPoint检查点"><a href="#CheckPoint检查点" class="headerlink" title="CheckPoint检查点"></a>CheckPoint检查点</h5><p>将脏页写入到磁盘的时机。</p>
<p>目的：</p>
<ul>
<li>缩短数据库的恢复时间</li>
<li>buffer pool 空间不够用时，将脏页刷新到磁盘</li>
<li>redo log不够用时，刷新脏页</li>
</ul>
<p>检查点分类</p>
<ul>
<li><p>sharp checkpoint：完全检查点，数据库正常关闭时，会触发把所有的脏页都写入到磁盘上</p>
</li>
<li><p>fuzzy checkpoint:正常使用时，模糊检查点，部分页写入磁盘。</p>
<ul>
<li><p>maste thread checkpoint</p>
<p>每秒或每10秒的速度从缓冲池的脏页列表中刷新一定比例的页到磁盘，异步。</p>
</li>
<li><p>flush_lru_list checkpoint</p>
<p>读取lru (Least Recently Used) list，找到脏页，写入磁盘。 最近最少使用</p>
</li>
<li><p>async/sync flush checkpoint</p>
<p>redo log fifile快满了，会批量的触发数据页回写，这个事件触发的时候又分为异步和同步，不可被覆盖的redolog占log file的比值：75%—&gt;异步、90%—&gt;同步。</p>
</li>
<li><p>dirty page too mush checkpoint</p>
<p>默认是脏页占比75%的时候，就会触发刷盘，将脏页写入磁盘</p>
</li>
</ul>
</li>
</ul>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><h4 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h4><p>系统表空间（共享表空间）</p>
<ul>
<li>数据字典（data dictionary):记录数据库相关信息</li>
<li>double writer</li>
<li>insert buffer:内存insert buffer 数据，周期写入共享表空间</li>
<li>回滚段（rollback segments)</li>
<li>undo 空间：undo 页</li>
</ul>
<p>用户表空间（独立表空间）</p>
<ul>
<li>每个表的数据和索引都存在自己的表空间中</li>
<li>每个表的结构</li>
<li>undo 空间：undo 页</li>
<li>double write</li>
</ul>
<h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><p>​    两个重做日志文件，大小一致，循环写入。顺序IO循环存储，保证了数据存储的速度和持久性。（每一条SQL致使数据库的改变都真正存储到了磁盘，顺序IO又保证存数据的速度。）</p>
<p>两个redo log file文件。默认10M大小。（不需要很大，只要保证能存储数据库崩溃，buffer pool中没有写入得到磁盘的脏页、undo log写入到磁盘的redo log file即可。）</p>
<p>存储内容：</p>
<ul>
<li>执行SQL后表的记录（脏页的信息）</li>
<li>执行SQL前表的的记录（undo log页的信息)</li>
<li>索引页的信息</li>
</ul>
<h3 id="数据库事务，sql执行经过-undo和redo-的流程"><a href="#数据库事务，sql执行经过-undo和redo-的流程" class="headerlink" title="数据库事务，sql执行经过  undo和redo  的流程"></a>数据库事务，sql执行经过  undo和redo  的流程</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zxQ1Ppv59iWeyRC.png" alt="sql执行经过undo和redo的流程"></p>
<h2 id="事务并发问题："><a href="#事务并发问题：" class="headerlink" title="事务并发问题："></a>事务并发问题：</h2><h3 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h3><p>事务A读取到了事务B为提交的数据，事务B进行了回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">begin;</span><br><span class="line">update user set username = &quot;li&quot; where id =1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">begin;</span><br><span class="line">select * from user where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	li	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">select * from user where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>



<h3 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h3><p>事务A因事务B修改了数据导致事务A两次读取的数据不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">begin;</span><br><span class="line">select * from user where id =1;</span><br><span class="line">#暂停</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">update user set username = &quot;li&quot; where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A：继续</span><br><span class="line">select * from user where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	li	2019-11-28	男	北京</span><br></pre></td></tr></table></figure>

<h3 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h3><p>事务A因事务B插入了新的数据导致事务A两次读取的数据不一致（插入或删除）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">begin;</span><br><span class="line">select * from user;</span><br><span class="line">#暂停</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">insert INTO `user` VALUES(4,&#x27;han&#x27;,2019-11-28,&#x27;nan&#x27;,&#x27;bei&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A：继续</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	li	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<h2 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h2><p>RU读未提交（read-uncommitted）：事务A可读到事务B未提交的数据。</p>
<p>RC读已提交（read-committed）：事务A可读到事务B已提交的数据。</p>
<p>RR可重复读（repeatable-read）:事务B不会对A造成影响。</p>
<p>串行化（serializable）</p>
<h2 id="MySQL事务隔离级别与事务并发问题"><a href="#MySQL事务隔离级别与事务并发问题" class="headerlink" title="MySQL事务隔离级别与事务并发问题"></a>MySQL事务隔离级别与事务并发问题</h2><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>mysql的RR隔离级使用MVCC机制解决了不可重复读，使用间隙锁解决了幻读的发生。</p>
<p>RR不严格，纯select走readview，update不走readview。会引发一些问题。</p>
<h2 id="mysql的MVCC机制"><a href="#mysql的MVCC机制" class="headerlink" title="mysql的MVCC机制"></a>mysql的MVCC机制</h2><p>作用：未加读锁实现了事务并发时可重复读。</p>
<p>MVCC依赖undo log，ReadView和版本号。</p>
<p>每个事务都有自己的事务id，id使用当前的系统版本号，每有新的事务，系统版本号+1</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>聚簇索引记录中有三个隐藏列：row_id、trx_id、roll_pointer</p>
<ul>
<li>trx_id： 存储每次对某条聚簇索引记录进行修改的时候的事务id。</li>
<li>roll_pointer： 每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向undo log的老版本地址。</li>
</ul>
<p>undo log 的删除是由 purge Thead操作的</p>
<h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct read_view_t&#123;</span><br><span class="line">	ulint	type;</span><br><span class="line">	undo_no_t	undo_no;</span><br><span class="line">	trx_id_t	low_limit_no;</span><br><span class="line">	trx_id_t	low_limit_id;	// 高水位，大于此事务id的记录都不可见。</span><br><span class="line">	trx_id_t	up_limit_id;	// 低水位，小于此事务id的记录可见。</span><br><span class="line">	ulint	n_trx_ids;			// 活跃事务数量</span><br><span class="line">	trx_id_t*	trx_ids;		// 以逆序排列的当前获取活跃事务id的数组</span><br><span class="line">	trx_id_t	creator_trx_id;	// 创建当前视图的事务id</span><br><span class="line">	UT_LIST_NODE_T(read_view_t)	view_list;	// 事务系统中的一致性视图链表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>trx_id_t*    trx_ids; </p>
<ul>
<li>记录系统活跃事务的id数组。</li>
<li>除去本身事务的id，除去内存中commit的id</li>
<li>直到事务中的 select 不加锁语句执行时创建。update、delete不会创建。 </li>
</ul>
</li>
<li><p>trx_id_t    low_limit_id;</p>
<ul>
<li>因id倒数排列，代表活跃事务中最高版本的事务id</li>
<li>其他事务找到的行记录的trx_id &gt; low_limit_id时，找到的行记录不可见，去undo log中找老版本。</li>
</ul>
</li>
<li><p>trx_id_t    up_limit_id;</p>
<ul>
<li>因id倒数排列，代表活跃事务中最低版本的事务id</li>
<li>其他事务找到的行记录的trx_id &lt; up_limit_id时，找到的行记录可见，返回此行记录。</li>
</ul>
</li>
</ul>
<h4 id="判断行记录是否可见"><a href="#判断行记录是否可见" class="headerlink" title="判断行记录是否可见"></a>判断行记录是否可见</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*********************************************************************//**</span><br><span class="line">Checks if a read view sees the specified transaction.</span><br><span class="line">@return	true if sees */</span><br><span class="line">UNIV_INLINE</span><br><span class="line">bool</span><br><span class="line">read_view_sees_trx_id(</span><br><span class="line">	const read_view_t*	view,	/*!&lt; in: read view */</span><br><span class="line">	trx_id_t		trx_id)	/*!&lt; in: trx id */</span><br><span class="line">&#123;</span><br><span class="line">	if (trx_id &lt; view-&gt;up_limit_id) &#123;/*行记录的事务trx_id &lt; 活跃事务的*/</span><br><span class="line">		return(true);</span><br><span class="line">	&#125; else if (trx_id &gt;= view-&gt;low_limit_id) &#123;</span><br><span class="line">		return(false);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ulint	lower = 0;</span><br><span class="line">		ulint	upper = view-&gt;n_trx_ids - 1;</span><br><span class="line"></span><br><span class="line">		ut_a(view-&gt;n_trx_ids &gt; 0);</span><br><span class="line"></span><br><span class="line">		do &#123;</span><br><span class="line">			ulint		mid	= (lower + upper) &gt;&gt; 1;</span><br><span class="line">			trx_id_t	mid_id	= view-&gt;trx_ids[mid];</span><br><span class="line"></span><br><span class="line">			if (mid_id == trx_id) &#123;</span><br><span class="line">				return(FALSE);</span><br><span class="line">			&#125; else if (mid_id &lt; trx_id) &#123;</span><br><span class="line">				if (mid &gt; 0) &#123;</span><br><span class="line">					upper = mid - 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				lower = mid + 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (lower &lt;= upper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*行记录的事务trx_id &lt; 活跃事务链表中的最小事务id，此条记录可被当前事务读取。*/</span><br><span class="line">if (trx_id &lt; view-&gt;up_limit_id) &#123;</span><br><span class="line">		return(true);</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*行记录的事务trx_id &gt;= 活跃事务链表中的最大事务id，此条记录不可被当前事务读取。*/</span><br><span class="line">else if (trx_id &gt;= view-&gt;low_limit_id) &#123;</span><br><span class="line">		return(false);</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#空表user,有id、name两列</span><br><span class="line">#例如：事务A，trx_id = 10</span><br><span class="line">begin;</span><br><span class="line">select * from user;//无数据</span><br><span class="line"></span><br><span class="line">#事务B，trx_id = 11</span><br><span class="line">insert into user values(1,1);</span><br><span class="line"></span><br><span class="line">#事务A</span><br><span class="line">select * from user;//无数据</span><br><span class="line"></span><br><span class="line">#解释：</span><br><span class="line">#找到了数据 id = 1,name = 1, trx_id = 11。</span><br><span class="line">#但是事务A (trx_id =10 &lt; trx_id = 11),所以此数据没有返回</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*二分查找算法，如果行记录的事务trx_id == 活跃事务链表的id，此条记录不可被当前事务读取。否则，可被读取。*/</span><br><span class="line">else &#123;</span><br><span class="line">		ulint	lower = 0;</span><br><span class="line">		ulint	upper = view-&gt;n_trx_ids - 1;</span><br><span class="line"></span><br><span class="line">		ut_a(view-&gt;n_trx_ids &gt; 0);</span><br><span class="line"></span><br><span class="line">		do &#123;</span><br><span class="line">			ulint		mid	= (lower + upper) &gt;&gt; 1;</span><br><span class="line">			trx_id_t	mid_id	= view-&gt;trx_ids[mid];</span><br><span class="line"></span><br><span class="line">			if (mid_id == trx_id) &#123;</span><br><span class="line">				return(FALSE);</span><br><span class="line">			&#125; else if (mid_id &lt; trx_id) &#123;</span><br><span class="line">				if (mid &gt; 0) &#123;</span><br><span class="line">					upper = mid - 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				lower = mid + 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (lower &lt;= upper);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<p>原数据</p>
<table>
<thead>
<tr>
<th>trx_id</th>
<th>roll_pointer</th>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>undo中上一个版本的地址 0x001</td>
<td>1</td>
<td>zs</td>
</tr>
<tr>
<td>3</td>
<td>undo中上一个版本的地址 0x002</td>
<td>5</td>
<td>zs</td>
</tr>
<tr>
<td>13</td>
<td>undo中上一个版本的地址 0x003</td>
<td>10</td>
<td>13</td>
</tr>
</tbody></table>
<p>undo log的数据</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>trx_id</th>
<th>roll_pointer</th>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>0x001</td>
<td>2</td>
<td>undo中再上一个版本的地址 0x***</td>
<td>1</td>
<td>zs</td>
</tr>
<tr>
<td>0x002</td>
<td>1</td>
<td>undo中再上一个版本的地址 0x***</td>
<td>5</td>
<td>zs</td>
</tr>
<tr>
<td>0x003</td>
<td>3</td>
<td>undo中再上一个版本的地址 0x***</td>
<td>10</td>
<td>zs</td>
</tr>
</tbody></table>
<p>有trx_id 为6、7、8、9、10、11、12七个事务，7和11在内存中准备提交，当前事务为9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务的trx_id为9 执行</span><br><span class="line">begin;</span><br><span class="line">update role set name = &#x27;www&#x27; where id = 5;// 无关的sql</span><br><span class="line">select * from user; // 普通select执行时创建readview</span><br></pre></td></tr></table></figure>

<p>readview的部分数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trx_ids[12,10,8,6]</span><br><span class="line">low_limit_id = 12</span><br><span class="line">up_limit_id =6</span><br></pre></td></tr></table></figure>

<p>查出来的数据：</p>
<table>
<thead>
<tr>
<th>trx_id</th>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>1</td>
<td>zs</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>zs</td>
</tr>
<tr>
<td>3</td>
<td>10</td>
<td>zs</td>
</tr>
</tbody></table>
<p>第三条数据：因为 行记录(trx_id = 13) &gt; review-&gt;low_limit_id,此条行记录对事务9不可见，去undo log中找到行记录trx_id = 3 的记录返回。</p>
<h3 id="不同隔离级如何创建readview"><a href="#不同隔离级如何创建readview" class="headerlink" title="不同隔离级如何创建readview"></a>不同隔离级如何创建readview</h3><h5 id="RC隔离级"><a href="#RC隔离级" class="headerlink" title="RC隔离级"></a>RC隔离级</h5><p>RC隔离级别下，在每个语句开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(read<br>view)  </p>
<p>每个语句开始，拷贝新的readview，已提交的事务就不在列表中了。</p>
<p><strong>这么一个问题：</strong>RC隔离级下使用了MVCC机制，trx_id=5的事务A不应该读到trx_id=10的事务B提交的数据。因为事务B提交后的行记录(trx_id =10) &gt; view-&gt;low_limit_id(高水位)</p>
<p>解释：每个语句开始的时候拷贝新的readview，readview包括本事务的id，拷贝新的readview就会更新本事务的id，这样本事务的id = 5变为了id = 11，这样就可以看到事务B提交的 id = 10 的记录了。</p>
<h5 id="RR隔离级"><a href="#RR隔离级" class="headerlink" title="RR隔离级"></a>RR隔离级</h5><p>RR隔离级别下，在每个事务开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(readview)  ，直到事务结束，不会更新readview。不会看到readview事务链表中提交的事务数据。</p>
<h5 id="设置隔离级别："><a href="#设置隔离级别：" class="headerlink" title="设置隔离级别："></a>设置隔离级别：</h5><p>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</p>
<p>当前会话隔离级读已提交：</p>
<p>set session transaction isolation level read COMMITTED;  </p>
<h4 id="RR不严格的问题："><a href="#RR不严格的问题：" class="headerlink" title="RR不严格的问题："></a>RR不严格的问题：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session1</span><br><span class="line">begin;</span><br><span class="line">select * from user;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	123	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	hxr234	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session2</span><br><span class="line">insert into user values(5,&#x27;zala&#x27;,0000-00-00,&#x27;nan&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">#session1</span><br><span class="line">update user set username = &#x27;123&#x27; where id &gt; 1;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	123	0000-00-00	nan	bei</span><br><span class="line">4	123	0000-00-00	nan	bei</span><br><span class="line">5	123	0000-00-00	nan	beijing</span><br></pre></td></tr></table></figure>

<p>update 不走readview视图使第二次select查到了别的事务insert的数据。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务复习</title>
    <url>/2020/11/17/Mysql-%E4%BA%8B%E5%8A%A1%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>Mysql-行列转换</p>
<span id="more"></span>

<h1 id="Mysql-事务复习"><a href="#Mysql-事务复习" class="headerlink" title="Mysql-事务复习"></a>Mysql-事务复习</h1><p>四大特性：原子性，一致性，持久性，隔离性。</p>
<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p>单个事务如何保证事务特性？关键点：1.事务回滚，2.事务结束提交。</p>
<ul>
<li><p>事务回滚通过undo log保证，undo log 记录了事务修改前的日志数据。</p>
</li>
<li><p>事务提交通过redo log file保证，事务 commit后，数据会持久化到redo log file（磁盘）中。 redo log file 快满时，持久化undo log中的数据，清空redo log file。</p>
</li>
</ul>
<p>具体的执行情况：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zxQ1Ppv59iWeyRC.png" alt="img"></p>
<p><strong>redo log file：</strong> 是顺序循环存储的日志文件，不像undo log是存储有关联关系的数据。redo log file 达到75%时，异步持久化undo log，redo log file达到90%时，使用同步操作持久化undo log。</p>
<h3 id="单个事务"><a href="#单个事务" class="headerlink" title="单个事务"></a>单个事务</h3><p>mysql中用undo log 和redo log file解决持久性问题。</p>
<p>事务进行一半系统崩溃，重启后如何保证事务的特性？</p>
<h3 id="事务并发"><a href="#事务并发" class="headerlink" title="事务并发"></a>事务并发</h3><p>多个事务之间产生什么样的影响？</p>
<p>不同的隔离级别下影响不同。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）RU</td>
<td>是</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>不可重复读（read-committed）RC</td>
<td>否</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）RR</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h4 id="mysql-mvcc"><a href="#mysql-mvcc" class="headerlink" title="mysql-mvcc"></a>mysql-mvcc</h4><p><strong>解决了什么</strong>：</p>
<p>​    mysql中RR隔离级别实现了，单事务内重复读一条数据，结果不变。</p>
<p>​    mysql中RC隔离级实现了，单事务内不会读取其他事务未提交的数据。</p>
<h4 id="SQL实例"><a href="#SQL实例" class="headerlink" title="SQL实例"></a>SQL实例</h4><p>RR隔离级SQL实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># session1</span><br><span class="line">begin;</span><br><span class="line">select * from tb_user where user_id = 1;</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	nie16226	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br><span class="line"></span><br><span class="line"># session2</span><br><span class="line">begin;</span><br><span class="line">update tb_user set pass_word = 123 where user_id = 1;</span><br><span class="line"></span><br><span class="line"># session1</span><br><span class="line">select * from tb_user where user_id = 1;#单个事务内查询结果不变</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	nie16226	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br><span class="line"></span><br><span class="line"># session2</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># session1</span><br><span class="line">select * from tb_user where user_id = 1;#单个事务内查询结果不变</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	nie16226	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br></pre></td></tr></table></figure>

<p>如何保证可重复读：开始事务时拷贝readview。</p>
<p>RC隔离级SQL实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置当前会话隔离级别为 读已提交</span><br><span class="line">set session transaction isolation level read COMMITTED; </span><br></pre></td></tr></table></figure>

<p>RU 隔离级SQL实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># session1</span><br><span class="line">set session transaction isolation level READ UNCOMMITTED;# 设置当前会话隔离级别为 读未提交</span><br><span class="line">begin;</span><br><span class="line">update tb_user set pass_word = 12345 where user_id = 1;</span><br><span class="line"></span><br><span class="line"># session2</span><br><span class="line">set session transaction isolation level READ UNCOMMITTED;</span><br><span class="line">begin;</span><br><span class="line">select * from tb_user where user_id = 1;#读取到session未提交的数据</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	12345	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br></pre></td></tr></table></figure>

<h4 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h4><p><strong>三个关键点</strong>：undo log，ReadView，版本号。</p>
<p>事务流程（涉及undo log 和版本号）：每个事务以系统版本号为事务id，修改记录行时将事务id记录到隐藏列trx_id.隐藏列roll_pointer指向未修改的记录行。事务开始时copy  read_view。</p>
<p>read_view记录当前进行中的事务id， 事务id大的可以看到事务id小的记录。</p>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>聚簇索引记录中了隐藏列trx_id、roll_pointer</p>
<h5 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h5><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><ul>
<li>结构：</li>
</ul>
<ul>
<li><p>判断可见性</p>
<ul>
<li>行记录事务id &gt; readview 最大事务id     <strong>不可见</strong>，通过回滚指针找上一个记录</li>
<li>行记录事务id &lt; readview 最小事务id     <strong>可见</strong></li>
<li>行记录事务id = readview 事务数组中id <strong>不可见</strong></li>
<li>行记录事务id &gt; readview 最小事务id &lt; readview  最大事务id != 事务数组中的id    <strong>可见</strong></li>
</ul>
</li>
<li><p>readview建立时机：</p>
<ul>
<li>RR 事务开始时建立。第二次执行select不会重新拷贝readview，事务B提交事务后，事务B的事务id仍存在于事务A的readview中。事务A不会读取到事务B提交的数据。</li>
<li>RC在事务中的每一条SQL语句执行时建立。其他事务未提交时，事务id存在于readview的事务数组中，不可见。</li>
</ul>
</li>
</ul>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p><strong>什么是幻读？</strong>因为事务B在事务A多次查询中间插入了数据，事务A读取结果不一致。</p>
<p><strong>RR隔离级是否解决了幻读？</strong> 解决了。</p>
<p><strong>如何解决的？</strong>MVCC+next key</p>
<p><strong>RR下的幻读：</strong></p>
<p>事务A update 全表后，查询到事务B insert的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session1</span><br><span class="line">begin;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	123	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	hxr234	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session2</span><br><span class="line">insert into user values(5,&#x27;zala&#x27;,0000-00-00,&#x27;nan&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">#session1</span><br><span class="line">update user set username = &#x27;123&#x27; where id &gt; 1;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	123	0000-00-00	nan	bei</span><br><span class="line">4	123	0000-00-00	nan	bei</span><br><span class="line">5	123	0000-00-00	nan	beijing</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>RR为什么单事务读取数据一致？事务开始时拷贝readview。不再更新readview。</p>
<p>RC为什么出现重复读一条数据结果不一致？每一条语句执行时，拷贝readview。</p>
<p>RU为什么不会读取其他事务未提交的数据？其他事务id存在于readview中。select语句执行时 拷贝readview看到了其他事务的id。</p>
<p>RC可处理并发量大于RR？RR增加了间隙锁。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-基础+架构</title>
    <url>/2020/07/18/Mysql-%E5%9F%BA%E7%A1%80+%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>mysql介绍；SQL的解析顺序；mysql架构，包括逻辑架构、物理结构</p>
<span id="more"></span>

<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="Mysql语言"><a href="#Mysql语言" class="headerlink" title="Mysql语言"></a>Mysql语言</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>数据库定义语言</p>
<p>creat database;</p>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>数据库操作语言</p>
<p>insert</p>
<p>update</p>
<p>delete</p>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>数据库查询语言</p>
<p>select</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>数据库控制语言</p>
<p>权限控制</p>
<h2 id="MySQL解析顺序"><a href="#MySQL解析顺序" class="headerlink" title="MySQL解析顺序"></a>MySQL解析顺序</h2><h3 id="写的顺序"><a href="#写的顺序" class="headerlink" title="写的顺序"></a>写的顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct</span><br><span class="line">	&lt; select_list&gt;</span><br><span class="line">from</span><br><span class="line">join 	 on</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h3 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a>解析顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 表</span><br><span class="line">from</span><br><span class="line"># 行过滤</span><br><span class="line">on</span><br><span class="line">join</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line"># 列过滤</span><br><span class="line">select</span><br><span class="line">distinct</span><br><span class="line"># 排序</span><br><span class="line">order by</span><br><span class="line"># 标准SQL之外</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><h4 id="逻辑架构图"><a href="#逻辑架构图" class="headerlink" title="逻辑架构图"></a>逻辑架构图</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/z4kJu5tmrUYOqLZ.jpg" alt="jiagou"></p>
<h4 id="简单执行流程"><a href="#简单执行流程" class="headerlink" title="简单执行流程"></a>简单执行流程</h4><p>​        连接器</p>
<p>查询缓存 分析器</p>
<p>​                优化器</p>
<p>​                执行器</p>
<p>​                存储引擎</p>
<h4 id="详细执行流程"><a href="#详细执行流程" class="headerlink" title="详细执行流程"></a>详细执行流程</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OTtLRi4J6ZAmUdf.jpg" alt="img"></p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ul>
<li><p>mysql通过文件系统对数据和索引进行存储。</p>
</li>
<li><p>物理结构上分为日志文件和数据索引文件。</p>
</li>
<li><p>日志文件使用顺序 I/O 存储，数据文件使用随机 I/O 存储。</p>
</li>
</ul>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>错误日志</p>
<p>二进制日志：数据备份、恢复、主从使用，生产中开启</p>
<p>通用查询日志：记录所有东西，影响性能。</p>
<p>慢查询日志：SQL优化时使用，配置检测SQL执行时间，过滤并记录SQL。</p>
<p>重做日志</p>
<p>回滚日志</p>
<p>中继日志：主从使用</p>
<h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><h5 id="InnoDB数据文件"><a href="#InnoDB数据文件" class="headerlink" title="InnoDB数据文件"></a>InnoDB数据文件</h5><p>.frm 与表相关的信息，主要包括表结构定义信息</p>
<p>.ibd  使用独享表空间存储 数据+索引。一张表对应一个ibd文件。</p>
<p>ibdata 使用共享表空间存储 数据+索引。所有表共用一个或多个ibdata文件。</p>
<h5 id="MyISAM数据文件"><a href="#MyISAM数据文件" class="headerlink" title="MyISAM数据文件"></a>MyISAM数据文件</h5><p>.fmi 与表相关的信息，主要包括表结构定义信息</p>
<p>.myd 存储表数据信息</p>
<p>.myi 存储表数据文件的索引</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Mysql</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-性能分析和优化</title>
    <url>/2020/08/09/Mysql-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>mysql优化.包括软件、硬件、SQL语句</p>
<span id="more"></span>

<h1 id="Mysql-性能分析和优化"><a href="#Mysql-性能分析和优化" class="headerlink" title="Mysql-性能分析和优化"></a>Mysql-性能分析和优化</h1><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>分析：</p>
<ol>
<li>通过慢查询日志获取查询时间较长的SQL</li>
<li>查看SQL的执行计划explain</li>
<li>使用show profile[s] 查看SQL的性能使用情况</li>
</ol>
<p>注意：开启慢查询日志影响mysql性能，排查问题时再开启。</p>
<h4 id="开启慢查询日志："><a href="#开启慢查询日志：" class="headerlink" title="开启慢查询日志："></a>开启慢查询日志：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow_query_log=ON </span><br><span class="line">long_query_time=3 </span><br><span class="line">slow_query_log_file=/var/lib/mysql/slow-log.log</span><br></pre></td></tr></table></figure>

<h4 id="慢查询工具"><a href="#慢查询工具" class="headerlink" title="慢查询工具"></a>慢查询工具</h4><h5 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h5><p>mysql自带的慢查询日志工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">到按照时间排序的前10条里面含有左连接的查询语句：</span><br><span class="line">mysqldumpslow -s t -t 10 -g “left join”  /var/log/mysql/slow.log </span><br></pre></td></tr></table></figure>

<h5 id="percona-toolkit"><a href="#percona-toolkit" class="headerlink" title="percona-toolkit"></a>percona-toolkit</h5><p>高级命令行工具的集合，可以查看当前服务的摘要信息，磁盘检测，分析慢查询日志，查找重复索引，实现表同步等等。</p>
<p>linux:</p>
<p><a href="https://www.percona.com/downloads/percona-toolkit/3.0.11/binary/tarball/percona-toolkit-3.0.11_x86_64.tar.gz">https://www.percona.com/downloads/percona-toolkit/3.0.11/binary/tarball/percona-toolkit-3.0.11_x86_64.tar.gz</a></p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>默认128M，修改为系统内存的4/5，尽量从内存中读取。</p>
<p>buffer pool越大和存储引擎I/O次数越少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_buffer_pool_pages_%&#x27;; </span><br><span class="line">| Innodb_buffer_pool_pages_free | 0 | 0 表示已经被用光</span><br></pre></td></tr></table></figure>

<p>修改 my.cnf</p>
<p>innodb_buffffer_pool_size =3000M</p>
<h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><p>默认8M,修改为Buffer的1/4.降低磁盘写入次数。</p>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>普通硬盘更换为SSD，提高磁盘读写，SSD寻道时间很短。</p>
<h3 id="内存预热"><a href="#内存预热" class="headerlink" title="内存预热"></a>内存预热</h3><h3 id="表和字段设计"><a href="#表和字段设计" class="headerlink" title="表和字段设计"></a>表和字段设计</h3><ul>
<li>减少关联查询，创建合理的冗余字段</li>
<li>字段太多的大表，拆表</li>
<li>表中不常用的字段或者存储数据比较多的字段，拆表。（商品表中的商品介绍字段单独拆解到另一个表中，使用ID关联）</li>
<li>每张表都要有主键，主键最好是int类型。</li>
</ul>
<h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>数量不要超过6个。通过索引返回的数据量需要小于1/3才有效。</p>
<ul>
<li><p><strong>建立索引：</strong></p>
<ol>
<li>on两边，where字段</li>
<li>组合索引（最左前缀）</li>
<li>order排序</li>
<li>group by分组统计</li>
</ol>
</li>
<li><p><strong>避免索引失效：</strong></p>
<ol>
<li>or，is null,is not null</li>
<li>between右边</li>
<li> where 子句中的“=”左边进行函数、算术运算或其他表达式运算</li>
<li>不遵循组合索引最左前缀</li>
<li>字符串不加’’(单引号)</li>
<li>like (%abc)，可通过组合索引解决</li>
</ol>
</li>
</ul>
<h4 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h4><p>注意sql执行顺序</p>
<ol>
<li>小表驱动大表</li>
<li>使用条件缩小左表后再连接右表，会有数量级的提升</li>
</ol>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>有截断效果（停止全表扫描），但还是在server层处理数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user limit 10</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一千万条数据</span><br><span class="line"># 速度很慢 10</span><br><span class="line">select * from user limit 9000000 for 10</span><br><span class="line"># 速度很快 0.03</span><br><span class="line">select * from user where id &gt; 9000000 limit 10</span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>count（*）找普通索引，即去最小的索引树遍历，包含null</p>
<p>count（字段） ，走缓存，不包含null</p>
<p>count（1） 包含null</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能分析</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-索引</title>
    <url>/2020/07/24/Mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引原理</p>
<span id="more"></span>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><h2 id="索引优劣势"><a href="#索引优劣势" class="headerlink" title="索引优劣势"></a>索引优劣势</h2><p>优点：提高查询速度，以索引为条件。索引有序，可以用查找算法快速找到。否则只能遍历。</p>
<p>缺点：额外占存储空间，影响更新表效率。增删操作不应更新数据，还会更新索引。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>主键索引：主键自带</p>
<p>单列索引：普通索引，唯一索引，全文索引（鸡肋，对文本的索引。ES的效率更好）</p>
<p>组合索引：组合多个列</p>
<p>空间索引</p>
<p>位图索引：Oracle</p>
<h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>普通索引:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length)) ; </span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column(length)) ;</span><br></pre></td></tr></table></figure>

<p>唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table(column(length)) ; </span><br><span class="line">alter table table_name add unique index index_name(column);</span><br></pre></td></tr></table></figure>

<p>组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10)) ;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>

<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM table_name</span><br></pre></td></tr></table></figure>



<p><strong>例子：</strong></p>
<p>show index from table_name</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place （占用常数内存，不占用额外内存）</p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:Primary</p>
<p>主键索引Primary  索引方式</p>
<table>
<thead>
<tr>
<th></th>
<th>Non_unique</th>
<th>key_name</th>
<th>seq_in_index</th>
<th>coulmn_name</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>0</td>
<td>primary</td>
<td>1</td>
<td>id</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>唯一索引</td>
<td>0</td>
<td>ids_loginname</td>
<td>1</td>
<td>loginname</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>组合索引</td>
<td>1</td>
<td>ids_age_sex_name</td>
<td>1</td>
<td>age</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>组合索引</td>
<td>1</td>
<td>ids_age_sex_name</td>
<td>2</td>
<td>sex</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>组合索引</td>
<td>1</td>
<td>ids_age_sex_name</td>
<td>3</td>
<td>name</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>普通索引</td>
<td>1</td>
<td>ids_dep</td>
<td>1</td>
<td>dep</td>
<td>btree（B+tree）</td>
</tr>
</tbody></table>
<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><h3 id="索引使用的数据结构"><a href="#索引使用的数据结构" class="headerlink" title="索引使用的数据结构"></a>索引使用的数据结构</h3><p> 数据量：三层20G，四层几十T</p>
<p>  树演示网址：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>特点：</p>
<ul>
<li>所有数据存储在叶子节点。</li>
<li>叶子节点排成了一个链表</li>
<li>叶子节点的链表顺序取出可得到有序的数据</li>
</ul>
<h4 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h4><p>特点 ：</p>
<ul>
<li>数据存储在叶子节点和非叶子节点上。</li>
<li>无链表结构</li>
</ul>
<h3 id="索引树："><a href="#索引树：" class="headerlink" title="索引树："></a>索引树：</h3><p>每建立一个索引会建立一颗索引树</p>
<h3 id="非聚集索引-MyISAM"><a href="#非聚集索引-MyISAM" class="headerlink" title="非聚集索引-MyISAM"></a>非聚集索引-MyISAM</h3><p>主键索引：存储主键和指向数据的地址。</p>
<p>辅助索引：存储辅助索引值和指向数据的地址。</p>
<h3 id="聚集索引-InnoDB"><a href="#聚集索引-InnoDB" class="headerlink" title="聚集索引-InnoDB"></a>聚集索引-InnoDB</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>存储主键值和数据</p>
<p>索引是排序后建立的。主键的创建最好用自增整数。不要用大字符串比如 uuid —- 》 雪花算法 snowflflakes</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>存储索引值和主键值</p>
<h5 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h5><p>存储组合索引中的各个值和主键值</p>
<p>组合索引优点：一定程度上避免回表。回表：组合索引树没有要查询的列数据，根据组合索引树的主键回到主键索引树查找数据。</p>
<h2 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h2><p>什么情况建立索引</p>
<ul>
<li>主键自动创建主键索引</li>
<li>表数据量大，100万条。</li>
<li>频繁作为查询字段</li>
<li>多表关联查询，on两端都要建立索引</li>
<li>查询中排序的字段创建B+Tree，B+Tree可直接有序取出</li>
<li>覆盖索引，使用组合索引防止回表</li>
<li>统计或分组字段，应该创建索引</li>
</ul>
<p>什么情况没必要建立索引</p>
<ul>
<li><p>表数据量少</p>
</li>
<li><p>频繁更新，索引需要维护</p>
</li>
<li><p>查询字段使用频率低</p>
</li>
</ul>
<h2 id="索引的执行"><a href="#索引的执行" class="headerlink" title="索引的执行"></a>索引的执行</h2><p>数据量少时，返回的数据量超过一半时，不使用索引。数据量多时，返回的数据量超过1/3不使用索引。</p>
<p>组合索引的创建顺序是使用顺序。</p>
<p>最左前缀原则:</p>
<ol>
<li><p>前缀索引</p>
<p>like 常量% 使用索引</p>
<p>like %常量不使用索引</p>
</li>
<li><p>最左前缀</p>
</li>
</ol>
<p>​    按照索引的建立顺序搜索，范围查询（&gt;&lt;between）后的索引失效。</p>
<p>where id =1 and name =”han” and a &gt; 1 and b =1</p>
<h3 id="查看执行-计划"><a href="#查看执行-计划" class="headerlink" title="查看执行 计划"></a>查看执行 计划</h3><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</span><br></pre></td></tr></table></figure>

<p>id:</p>
<ul>
<li>每个 SELECT语句都会自动分配的一个唯一标识符. </li>
<li>id相同：执行顺序由上到下,id不同：如果是子查询，id号会自增，<strong>id越大，优先级越高</strong>。id相同的不同的同时存在</li>
<li>id列为null的就表示这是一个结果集，不需要使用它来进行查询。</li>
</ul>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type:"></a>select_type:</h5><ul>
<li>主要用于区别普通查询、联合查询(union、union all)、子查询等复杂查询。</li>
<li><strong>simple</strong>:表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</li>
<li><strong>primary</strong>:一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</li>
<li><strong>subquery</strong>:除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</li>
<li><strong>dependent subquery</strong>:与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</li>
<li><strong>union</strong>:union连接的两个select查询，第一个查询是PRIMARY，除了第一个表外，第二个以后的表select_type都是union</li>
<li><strong>union result</strong>:包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</li>
<li><strong>derived</strong>:from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</li>
</ul>
<p>table:</p>
<ul>
<li>显示的查询表名，如果查询使用了别名，那么这里显示的是别名</li>
<li>如果不涉及对数据表的操作，那么这显示为null</li>
</ul>
<h5 id="type"><a href="#type" class="headerlink" title="type:"></a>type:</h5><h6 id="索引的类型（最好→最坏）："><a href="#索引的类型（最好→最坏）：" class="headerlink" title="索引的类型（最好→最坏）："></a>索引的类型（最好→最坏）：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system，const，eq_ref，ref，fulltext,ref_or_null,unique_subquery,index_subquery,range，index_merge，index，ALL </span><br></pre></td></tr></table></figure>

<p><strong>除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</strong></p>
<p>system：空表,数据只有一行。</p>
<p><strong>const（重要）</strong>：使用主键索引或唯一索引,返回1行记录。</p>
<p><strong>eq_ref（重要）</strong>:连接字段是<strong>主键或者唯一性索引</strong>。</p>
<p><strong>ref（重要）</strong>:<strong>针对非唯一性索引</strong>，使用<strong>等值（=）查询</strong>非主键。或者是使用了<strong>最左前缀规则索引的查询</strong>。</p>
<p>index 列过滤，回表。比如组合索引没命中全部字段，回主键索引树查询数据。</p>
<p>fulltext：全文索引检索。全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql优先选择使用全文索引</p>
<p>unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p>
<p>index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p>
<p><strong>range（重要）</strong>：<strong>索引范围扫描</strong>，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p>
<p>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引</p>
<p><strong>index（重要）</strong>：</p>
<ul>
<li><strong>条件出现在索引树中的节点。可能没有完全匹配索引。</strong></li>
<li><strong>索引全表扫描</strong>，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</li>
<li>explain select loginname from tuser; #单索引</li>
<li>explain select age from tuser; #组合索引</li>
</ul>
<p><strong>all（重要）</strong>：是全表扫描数据文件，然后再<strong>在server(layer(解析器、优化器))层进行过滤</strong>返回符合要求的记录。explain select * from tuser; </p>
<p>possible_keys：此次查询中可能选用的索引，一个或多个。</p>
<p>key：查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</p>
<p>key_len：用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，会计算具体使用到了多少个列的索引。</p>
<p>ref：</p>
<ul>
<li>如果是等值查询，这里会显示const</li>
<li>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li>
<li>如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</li>
</ul>
<p>rows：估算的扫描行数，不是精确值（InnoDB不是精确的值，MyISAM是精确的值</p>
<h5 id="extra（重要）："><a href="#extra（重要）：" class="headerlink" title="extra（重要）："></a>extra（重要）：</h5><p>包含不适合在其他列中显示单十分重要的额外的信息，这个列可以显示的信息非常多，有几十</p>
<p>种，常用的有下列几种：</p>
<ul>
<li><strong>using fifilesort（重要）</strong>：    <ul>
<li>排序时无法使用到索引时，就会出现这个。常见于order by和group by语句</li>
<li>MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li>
<li>MySQL中无法利用索引完成的排序操作称为“文件排序“</li>
</ul>
</li>
<li><strong>using index（重要）</strong>：<ul>
<li>查询时<strong>不需要回表查询</strong>，直接通过索引就可以获取查询的数据。</li>
<li>表示相应的SELECT查询中使用到了<strong>覆盖索引</strong></li>
<li>如果同时出现Using Where ，说明索引被用来执行查找索引键值</li>
<li>如果没有同时出现Using Where ，表明索引用来读取数据而非执行查找动作</li>
</ul>
</li>
<li><strong>using where（重要）</strong>：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</li>
<li><strong>using index condition</strong>：5.6.x之后支持<strong>ICP</strong>特性，可以把检查条件（非主键索引）也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。</li>
</ul>
<h2 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h2><p>口诀:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.全值匹配我最爱</span><br><span class="line">2.最佳左前缀法则</span><br><span class="line">3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</span><br><span class="line">4.存储引擎不能使用索引中范围条件右边的列</span><br><span class="line">5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）</span><br><span class="line">6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描(5.6之后主键是特例)</span><br><span class="line">7.is null，is not null 也无法使用索引（有特例）</span><br><span class="line">8.like以通配符开头（%abc..）mysql索引失效会变成全表扫描的操作（有特例）</span><br><span class="line">9.字符串不加单引号索引失效</span><br><span class="line">10.少用or，用它来连接时会索引失效</span><br></pre></td></tr></table></figure>

<p>索引字段上使用 is null 判断时，可使用索引</p>
<p>解决like ‘%字符串%’时，索引失效问题的方法？使用覆盖索引可以解决。 </p>
<p>explain select name , age,sex from tuser where name like ‘%a%’; </p>
<p><strong>2.最佳左前缀法则</strong></p>
<p>组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">带头索引不能死，中间索引不能断</span><br></pre></td></tr></table></figure>

<p>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且不跳过索引中的列。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-行列转换</title>
    <url>/2020/11/17/Mysql-%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>Mysql-行列转换</p>
<span id="more"></span>

<h1 id="Mysql-行列转换"><a href="#Mysql-行列转换" class="headerlink" title="Mysql-行列转换"></a>Mysql-行列转换</h1><h2 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h2><p>9行4列 转 3行5列</p>
<p><strong>原数据：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/t4TOU2ud87EDoaI.png" alt="image-20201117151521097"></p>
<p><strong>转换sql：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用了group by 根据user_id分组，然后用聚合函数行转列</span><br><span class="line">SELECT</span><br><span class="line">	user_id,</span><br><span class="line">	max( CASE course WHEN &#x27;数学&#x27; THEN	fenzhi ELSE	0 END ) &#x27;数学&#x27;,</span><br><span class="line">	max( CASE course WHEN &#x27;语文&#x27; THEN	fenzhi ELSE	0 END ) &#x27;语文&#x27;,</span><br><span class="line">	max( CASE course WHEN &#x27;英语&#x27; THEN	fenzhi ELSE	0 END ) &#x27;英语&#x27;</span><br><span class="line">FROM</span><br><span class="line">	u_score</span><br><span class="line">group BY user_id</span><br></pre></td></tr></table></figure>

<p><strong>转换后：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/GY76UltFiK9kPzA.png" alt="image-20201117152730552"></p>
<h2 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h2><p>列转行 4列3行 转 3列9行</p>
<p> <strong>原数据：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ToIHJPezNWsLl9t.png" alt="image-20201117153039324"></p>
<p><strong>转行SQL：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列转行 4列3行 转 3列9行</span><br><span class="line">SELECT</span><br><span class="line">	id,</span><br><span class="line">	&#x27;数学&#x27; AS course,</span><br><span class="line">	shuxue fenzhi</span><br><span class="line">FROM</span><br><span class="line">	score</span><br><span class="line">UNION ALL</span><br><span class="line">	SELECT</span><br><span class="line">		id,</span><br><span class="line">		&#x27;语文&#x27; AS course,</span><br><span class="line">		yuwen fenzhi</span><br><span class="line">	FROM</span><br><span class="line">		score</span><br><span class="line">	UNION ALL</span><br><span class="line">		SELECT</span><br><span class="line">			id,</span><br><span class="line">			&#x27;英语&#x27; AS course,</span><br><span class="line">			yingyu fenzhi</span><br><span class="line">		FROM</span><br><span class="line">			score;</span><br></pre></td></tr></table></figure>

<p><strong>转换后：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ndya57Fr4iqwZ89.png" alt="image-20201117153159494"></p>
<p><strong>求单人平均成绩大于80：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#单个学生的平均成绩&gt;80</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">		SELECT</span><br><span class="line">			id,</span><br><span class="line">			avg(fenzhi) avg</span><br><span class="line">		FROM</span><br><span class="line">			(</span><br><span class="line">				SELECT</span><br><span class="line">					id,</span><br><span class="line">					&#x27;数学&#x27; AS course,</span><br><span class="line">					shuxue fenzhi</span><br><span class="line">				FROM</span><br><span class="line">					score</span><br><span class="line">				UNION ALL</span><br><span class="line">					SELECT</span><br><span class="line">						id,</span><br><span class="line">						&#x27;语文&#x27; AS course,</span><br><span class="line">						yuwen fenzhi</span><br><span class="line">					FROM</span><br><span class="line">						score</span><br><span class="line">					UNION ALL</span><br><span class="line">						SELECT</span><br><span class="line">							id,</span><br><span class="line">							&#x27;英语&#x27; AS course,</span><br><span class="line">							yingyu fenzhi</span><br><span class="line">						FROM</span><br><span class="line">							score</span><br><span class="line">			) sc</span><br><span class="line">		GROUP BY</span><br><span class="line">			id</span><br><span class="line">	) sc2</span><br><span class="line">WHERE</span><br><span class="line">	sc2.avg &gt; 80</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/UrwRJMESmHZuq8L.png" alt="image-20201117153241128"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-锁</title>
    <url>/2020/07/27/Mysql-%E9%94%81/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>程序实现。使用版本号或者时间戳。</p>
<p>mysql实现效率并不好，redis实现更好。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>MySQLLayer层</p>
<p>MySQL 实现的表级锁定的争用状态变量：</p>
<p>表锁可查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;table%&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variable_name				Value</span><br><span class="line">Table_locks_immediate		76</span><br><span class="line">Table_locks_waited			0</span><br><span class="line">Table_open_cache_hits		0</span><br><span class="line">Table_open_cache_misses		0</span><br><span class="line">Table_open_cache_overflows	0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- table_locks_immediate：产生表级锁定的次数(包括意向锁)； </span><br><span class="line">- table_locks_waited：出现表级锁定争用而发生等待的次数；</span><br></pre></td></tr></table></figure>

<ul>
<li>行锁升级为表锁的原因：update语句的条件没有使用索引。update where name = “han”，name没有使用索引。</li>
</ul>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MySQLLayer层</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>用处：显著提高对整个表修改时的性能</p>
<p>意向锁：</p>
<ul>
<li>InnoDB内部使用。</li>
<li>有两种：共享读锁，排他写锁。</li>
<li>意向锁不是真正的锁，只是一个标记。</li>
<li>获得行锁中的共享读锁之前会先获得意向读锁，获得行锁中的排他写锁之前会先获得意向写锁。</li>
</ul>
<p>原理：做整个表的update操作时，不用一行行看有没有行锁中的排他写锁。只需要看一次有没有意向写锁即可。</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB内部，行锁是通过锁住索引上的索引项来实现的。</p>
<h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>共享读：lock in share mode</p>
<h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>排它写：</p>
<ul>
<li>手动：for update</li>
<li>自动：DML(insert、update、delete语句),select … for update</li>
<li>行锁升级为表锁的原因：update语句的条件没有使用索引。update where name = “han”，name没有使用索引。</li>
</ul>
<p>可能发生锁等待情况：</p>
<ul>
<li>行锁升级为表锁</li>
<li>update 长事务</li>
</ul>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>mysql默认的RR隔离级别+一些条件产生间隙锁，可防止幻读。RC隔离级别不产生。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
<p>id 主键，name 普通索引</p>
<p>在update gap set  name = 2 where name = 5时，间隙锁锁住相邻数据。</p>
<p>相邻数据：where 条件 name = 5 对应的id =5，相邻数据为id=3和id=7的记录。</p>
<p>​    具体锁住的数据：id=任意 &amp;&amp;name = [3,6]和 name = 7 &amp;&amp; id= [3,7]。</p>
<p>​    name = 7,id&lt;3 || id&gt;7,不锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session1:</span><br><span class="line">begin;</span><br><span class="line">update gap g SET g.name = 2 where g.name = 5; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session2:</span><br><span class="line">insert into gap values(8,7);#可执行成功。</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>发生的原因：两个(或以上)的Session【加锁的顺序】不一致。</p>
<p>记录锁产生死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session1: begin;--开启事务未提交 --手动加行写锁 id=1 ，使用索引 update mylock set name=&#x27;m&#x27; where id=1; </span><br><span class="line">session2：begin;--开启事务未提交 --手动加行写锁 id=2 ，使用索引 update mylock set name=&#x27;m&#x27; where id=2; </span><br><span class="line">session1: update mylock set name=&#x27;nn&#x27; where id=2; -- 加写锁被阻塞 </span><br><span class="line">session2：update mylock set name=&#x27;nn&#x27; where id=1; -- 加写锁会死锁，不允许操作 </span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>间隙锁产生死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session1：start transaction ; select * from news where number=6 for update--产生间隙锁 </span><br><span class="line">session2：start transaction ; select * from news where number=7 for update--产生间隙锁 </span><br><span class="line">session1：insert into news values(9,7);--阻塞 </span><br><span class="line">session2：insert into news values(9,7); </span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>查看死锁情况：<code>show engine innodb status</code></p>
<p>如何避免死锁：</p>
<ul>
<li>注意程序的逻辑，不要交叉更新。如trx1:更新表A，更新表B，trx2：更新表B，更新表A。</li>
<li>保持事务轻量，占用少的锁资源。</li>
<li>提供运行速度，尽量避免子查询，尽量使用主键</li>
<li>尽快提交事务。</li>
<li>RR隔离级有Gap锁，RC隔离级无Gap锁，RC隔离级更不容易产生死锁。</li>
</ul>
<h2 id="SQL加锁分析"><a href="#SQL加锁分析" class="headerlink" title="SQL加锁分析"></a>SQL加锁分析</h2><p>加锁的条件：</p>
<p>1.系统的隔离级别？</p>
<p>2.where 条件 中的字段是否有索引？</p>
<h3 id="简单SQL"><a href="#简单SQL" class="headerlink" title="简单SQL"></a>简单SQL</h3><h4 id="RC隔离级"><a href="#RC隔离级" class="headerlink" title="RC隔离级"></a>RC隔离级</h4><ul>
<li><p>字段为主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where id = 1;// id = 1的记录加x锁（记录锁）</span><br></pre></td></tr></table></figure></li>
<li><p>唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where username = &#x27;zs&#x27;; //1.在唯一索引树的username=&#x27;zs&#x27;的记录加记录锁；2.通过唯一索引找到主键id = 1,在主键索引树上id=1的记录加记录锁</span><br></pre></td></tr></table></figure></li>
<li><p>普通索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where name = &#x27;张三&#x27;; //1.在普通索引树的name = &#x27;张三&#x27;的记录加记录锁（可能多条）；2.通过普通索引找到主键id = 10 和id =11,在主键索引树上id=10 和 id =11的记录加记录锁</span><br></pre></td></tr></table></figure></li>
<li><p>无索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where age = 80; //锁表 可查询</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RR隔离级"><a href="#RR隔离级" class="headerlink" title="RR隔离级"></a>RR隔离级</h4><ul>
<li><p>字段为主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where id = 3; // x锁+Gap锁（Next key Lock算法） 间隙锁</span><br></pre></td></tr></table></figure></li>
<li><p>唯一索引 唯一索引树X锁+Gap锁，主键索引树X锁+Gap锁</p>
</li>
<li><p>普通索引 普通索引树匹配的多条记录X锁+Gap锁，主键索引树X锁+Gap锁</p>
</li>
<li><p>无索引 锁表</p>
</li>
</ul>
<h4 id="Serializable-LBCC"><a href="#Serializable-LBCC" class="headerlink" title="Serializable(LBCC)"></a>Serializable(LBCC)</h4><p>每一条SQL都加锁，包括select</p>
<h3 id="复杂SQL"><a href="#复杂SQL" class="headerlink" title="复杂SQL"></a>复杂SQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 准备环境</span><br><span class="line">CREATE TABLE `blog` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `userid` int(11) DEFAULT NULL,</span><br><span class="line">  `blogid` int(11) DEFAULT NULL,</span><br><span class="line">  `pub` int(11) DEFAULT NULL,</span><br><span class="line">  `comment` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_pub_userid` (`pub`,`userid`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mBG6OTNK25ePEsb.png" alt="image-20200809184056603"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from blog where pub &gt; 1 and pub &lt; 15 and userid = 1 and comment is not NULL;</span><br></pre></td></tr></table></figure>

<p>数据库版本：5.6（包括5.6）</p>
<p>首先判断pub&gt;1 and pub &lt;15,将组合索引树的 pub = {3，5，10}加X锁，[1,20)加Gap锁（Mysql5.1，范围索引没有下推，5.6有索引下推，减少使用普通索引的回表次数）<br>然后 userid = 1，对组合索引树的pub = {5,10}加记录锁，通过ICP索引下推，不加Gap锁<br>comment is not null 无索引。将存储引擎的数据取到server层，对取出来的数据加X锁和Gap锁。</p>
<p><strong>Index key</strong>：pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</p>
<p><strong>Index Filter</strong>：userid = ‘hdc’ 。此条件，可以在index_pub_userid索引上进行过滤，但不属于Index Key。 </p>
<p><strong>Table Filter</strong>：comment is not NULL。此条件，在index_pub_userid索引上无法过滤，只能在聚簇索引上过滤。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-集群、主从复制、读写分离</title>
    <url>/2020/08/10/Mysql-%E9%9B%86%E7%BE%A4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>集群、主从复制、读写分离</p>
<span id="more"></span>

<h1 id="Mysql-集群、主从复制、读写分离"><a href="#Mysql-集群、主从复制、读写分离" class="headerlink" title="Mysql-集群、主从复制、读写分离"></a>Mysql-集群、主从复制、读写分离</h1><p>从库备份主库，读写分离后，从库可以读，主库可以写和读。</p>
<p>单击mysql做不到：高可用、高并发、海量数据（5千万）</p>
<p>主从复制，读写分离原理：主库中事务提交后，写入到 bin log 中，从库I/O读取bin log日志到从库日志relay日志，然后从relay日志中将数据放入从库中。</p>
<p>从库备份主库。mysql中做配置，从主库的一定的位置开始复制。</p>
<h2 id="主从复制mysql配置："><a href="#主从复制mysql配置：" class="headerlink" title="主从复制mysql配置："></a>主从复制mysql配置：</h2><h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><p>1.修改my.cnf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启用二进制日志 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">#服务器唯一ID，一般取IP最后一段 </span><br><span class="line">server-id=133 </span><br><span class="line">#指定复制的数据库(可选) </span><br><span class="line">binlog-do-db=test2 </span><br><span class="line">binlog-ignore-db=test </span><br><span class="line">#指定不复制的数据库(可选，mysql5.7) </span><br><span class="line">replicate-ignore-db=test1 </span><br><span class="line">#指定忽略的表（可选，mysql5.7） </span><br><span class="line">replicate-ignore-table = db.table1</span><br></pre></td></tr></table></figure>

<p>2.重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p>3.主机给从机授权备份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>4.刷新权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>5.查询mater的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>

<p>主从备份： mysqldump</p>
<h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><p>1.修改my.cnf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=135</span><br></pre></td></tr></table></figure>



<p>2.重启并登录到mysql配置从服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line">#关闭</span><br><span class="line">stop slave</span><br><span class="line">#同步初始化 master_log_file、master_log_pos 以主机状态为主</span><br><span class="line">show master status</span><br><span class="line"></span><br><span class="line">change master to</span><br><span class="line">master_host= &#x27;192.168.56.101&#x27;,</span><br><span class="line">master_port=3306,</span><br><span class="line">master_user=&#x27;root&#x27;,</span><br><span class="line">master_password=&#x27;***&#x27;,</span><br><span class="line">master_log_file=&#x27;mysql-bin.000059&#x27;,</span><br><span class="line">master_log_pos=394;</span><br></pre></td></tr></table></figure>



<p>3.启动从服务器复制功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>



<p>4.检查从服务器复制功能状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line"># ......(省略)</span><br><span class="line"># Slave_IO_Running: Yes //此状态必须YES</span><br><span class="line"># Slave_SQL_Running: Yes //此状态必须YES</span><br><span class="line"># ......(省略)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>向主机插入数据，看从机是否有数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入失败时解决方案：</span><br><span class="line">set global sql_slave_skip_counter =1; # 忽略一个错误 </span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>



<h3 id="主从延时"><a href="#主从延时" class="headerlink" title="主从延时"></a>主从延时</h3><ol>
<li><p>因为SQLThread和IOThread是默认单线程，当主机的tps(每秒事务处理数)高于从机的Thread所能承受范围，则会出现从机复制延时</p>
<p>解决：将thread改成多线程模式 MySQL5.6改表，MySQL5.7改GTID</p>
</li>
<li><p>网络延时</p>
<p>解决：主和从放在一个网内</p>
</li>
<li><p>IO延时</p>
<p>解决 ：slave server硬件升级</p>
</li>
</ol>
<p>解决方案： 利用分库分表中间件 Mycat、 sharding JDBC强制读取主库</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>一个库对外工作，性能限制在一个库。多个库对外工作，增加数据库负载能力。</p>
<p>主从集群中，让主库负责写和部分读，从库负责读。即读写分离。</p>
<h4 id="Mysql-Proxy"><a href="#Mysql-Proxy" class="headerlink" title="Mysql-Proxy"></a>Mysql-Proxy</h4><p>代理。负责路由SQL到Master或Slave</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https://downloads.mysql.com/archives/get/file/mysql-proxy-0.8.5-linux-el6- x86-64bit.tar.gz</span><br><span class="line"></span><br><span class="line">#解压缩</span><br><span class="line">tar -xf mysql-proxy-0.8.5-linux-el6-x86-64bit.tar.gz -C /plan</span><br></pre></td></tr></table></figure>

<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>创建mysql-proxy.cnf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql-proxy] </span><br><span class="line">user=root </span><br><span class="line">admin-username=root </span><br><span class="line">admin-password=123456 </span><br><span class="line">proxy-address=192.168.10.137:4040 </span><br><span class="line">proxy-backend-addresses=192.168.10.135:3306 </span><br><span class="line">proxy-read-only-backend-addresses=192.168.10.136:3306 </span><br><span class="line">proxy-lua-script=/root/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua </span><br><span class="line">log-file=/root/mysql-proxy/logs/mysql-proxy.log </span><br><span class="line">log-level=debug </span><br><span class="line">keepalive=true </span><br><span class="line">daemon=true</span><br></pre></td></tr></table></figure>

<p>修改mysql-proxy.cnf文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 660 mysql-proxy.cnf #可读写</span><br></pre></td></tr></table></figure>

<p>修改rw-splitting.lua</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40		min_idle_connections = 1,</span><br><span class="line">41		max_idle_connections = 2,</span><br></pre></td></tr></table></figure>

<p>Mysql-Ploxy启动域测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mysql-proxy --defaults-file=mysql-proxy.cnf配置文件的地址</span><br></pre></td></tr></table></figure>



<p>连接Mysql Proxy机器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456 -h192.168.56.102 -P4040; #注： 关闭防火墙</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>集群</tag>
        <tag>主从复制</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>Number1引入Vue</title>
    <url>/2019/10/10/Number1%20%E5%BC%95%E5%85%A5Vue/</url>
    <content><![CDATA[<p>引入Vue</p>
<span id="more"></span>
<ul>
<li>1.直接使用script标签引入Vue.js（简单）</li>
<li>2.使用脚手架（复杂）</li>
</ul>
<h1 id="1-直接使用script标签引入Vue-js（简单）"><a href="#1-直接使用script标签引入Vue-js（简单）" class="headerlink" title="1.直接使用script标签引入Vue.js（简单）"></a>1.直接使用script标签引入Vue.js（简单）</h1><p>   有两种方式</p>
<h2 id="1-1通过网络引入外部的vue-js"><a href="#1-1通过网络引入外部的vue-js" class="headerlink" title="1.1通过网络引入外部的vue.js"></a>1.1通过网络引入外部的vue.js</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;!--引入外部的vue.js--&gt;</span><br><span class="line">		 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123; message &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var app = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="1-2引入本地的vue-js"><a href="#1-2引入本地的vue-js" class="headerlink" title="1.2引入本地的vue.js"></a>1.2引入本地的vue.js</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;!--引入本地的vue.js--&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123; message &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var app = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number2创建Vue实例</title>
    <url>/2019/10/10/Number2%20%E5%88%9B%E5%BB%BAVue%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>引入vue.js的基础上，用vue实例改变html中绑定id的内容</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;!--引入本地的vue.js--&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123; message &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var app = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number3初始Vue的数据和方法</title>
    <url>/2019/10/10/Number3%20%E5%88%9D%E8%AF%86Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>介绍Vue实例的属性，和一个观测属性值变化的方法。</p>
<span id="more"></span>

<!DOCTYPE html>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123;a&#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		  //  定义a,赋值为1.定义data.</span><br><span class="line">			var data =&#123;a:1,b:2&#125;;</span><br><span class="line">			定义vm,创建vue实例。将上边定义的data赋值给vm的属性data</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el:&#x27;#app&#x27;,</span><br><span class="line">				data:data</span><br><span class="line">			&#125;)</span><br><span class="line">			// 三种改值写法</span><br><span class="line">			data.a=&quot;sdafas&quot;;</span><br><span class="line">			vm.a=&quot;333&quot;;</span><br><span class="line">			//观测a的新旧值,函数在新旧值中间</span><br><span class="line">			vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123;</span><br><span class="line">				console.log(newVal,oldVal);</span><br><span class="line">			&#125;)</span><br><span class="line">			vm.$data.a=&quot;222&quot;;</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number4 Vue的生命周期钩子</title>
    <url>/2019/10/10/Number4%20Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<p>vue的生命周期内&amp;改变数据期间可通过钩子函数执行一些操作</p>
<span id="more"></span>

<p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%">官网地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src= &quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123;msg&#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el:&quot;#app&quot;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					msg:&quot;hi lifecycle hooks&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				//在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</span><br><span class="line">				beforeCreate() &#123;</span><br><span class="line">					console.log(&#x27;beforeCreate&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				/* 在实例创建完成后被立即调用。</span><br><span class="line">				在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</span><br><span class="line">				然而，挂载阶段还没开始，$el 属性目前不可见。 */</span><br><span class="line">				created() &#123;</span><br><span class="line">					console.log(&#x27;created&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				//在挂载开始之前被调用：相关的渲染函数首次被调用</span><br><span class="line">				beforeMount() &#123;</span><br><span class="line">					console.log(&#x27;beforeMount&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				// el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span><br><span class="line">				mounted() &#123;</span><br><span class="line">					console.log(&#x27;mounted&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				//数据更新时调用</span><br><span class="line">				beforeUpdate() &#123;</span><br><span class="line">					console.log(&#x27;beforeUpdate&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				//组件 DOM 已经更新, 组件更新完毕</span><br><span class="line">				updated() &#123;</span><br><span class="line">					console.log(&#x27;updated&#x27;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			setTimeout(function()&#123;</span><br><span class="line">				vm.msg =&quot;change&quot;;</span><br><span class="line">				&#125;,3000</span><br><span class="line">			);</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number5Vue的模板语法1</title>
    <url>/2019/10/10/Number5%20Vue%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%951/</url>
    <content><![CDATA[<p>Vue的模板语法1</p>
<span id="more"></span>
<h1 id="1-插值"><a href="#1-插值" class="headerlink" title="1.插值"></a>1.插值</h1><h2 id="1-1-文本"><a href="#1-1-文本" class="headerlink" title="1.1 文本"></a>1.1 文本</h2><pre><code>&#123;&#123;msg&#125;&#125;
一次性插值 v-once
</code></pre>
<h2 id="1-2-原始html-v-html"><a href="#1-2-原始html-v-html" class="headerlink" title="1.2 原始html v-html"></a>1.2 原始html v-html</h2><h2 id="1-3-特性-v-bind"><a href="#1-3-特性-v-bind" class="headerlink" title="1.3 特性 v-bind"></a>1.3 特性 v-bind</h2><h2 id="1-4-javascript表达式"><a href="#1-4-javascript表达式" class="headerlink" title="1.4 javascript表达式"></a>1.4 javascript表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		    &lt;!--1.1 文本 --&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">			&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;!--1.2 原始html --&gt;</span><br><span class="line">			&lt;!-- 改变字符串内容为html标签 --&gt;</span><br><span class="line">			&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">			&lt;!--1.3 特性 --&gt;</span><br><span class="line">			&lt;!-- 声明.css属性class,赋值为变量color --&gt;</span><br><span class="line">			&lt;div v-bind:class=&quot;color&quot;&gt;test...&lt;/div&gt;</span><br><span class="line">			&lt;!--1.4 javascript表达式 --&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123;number+1&#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;!-- 字符串的分割&amp;翻转&amp;拼接 --&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123;message2.split(&#x27;&#x27;).reverse()&#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123;message2.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;,</span><br><span class="line">					msg:&#x27;hi vue&#x27;,</span><br><span class="line">					rawHtml:&#x27;&lt;span style=&quot;color:red&quot;&gt;this is red&lt;/span&gt;&#x27;,</span><br><span class="line">					//yellow 为变量color的值,标识不同class</span><br><span class="line">					color:&#x27;yellow&#x27;,</span><br><span class="line">					number:11,</span><br><span class="line">					message2:&#x27;hello world&#x27;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			vm.msg=&#x27;no change&#x27;;</span><br><span class="line">			</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">		&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			.red&#123;color:red&#125;</span><br><span class="line">			.yellow&#123;color:yellow;font-size: 100px;&#125;;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number6Vue的模板语法2</title>
    <url>/2019/10/10/Number6%20Vue%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%952/</url>
    <content><![CDATA[<p>Vue的模板语法2</p>
<span id="more"></span>
<p>指令<br>    1参数<br>    2修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br><span class="line">			&lt;p v-if=&quot;seen2&quot;&gt;现在你看不到我了&lt;/p&gt;</span><br><span class="line">			&lt;!-- v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 --&gt;</span><br><span class="line">			&lt;a v-bind:href=&quot;url&quot;&gt;baidu&lt;/a&gt;</span><br><span class="line">			&lt;a v-on:click=&quot;doSomething&quot;&gt;点击事件&lt;/a&gt;</span><br><span class="line">			&lt;!-- v-on的缩写@   .stop执行click2后停止，不执行click1--&gt;</span><br><span class="line">			&lt;div @click=&quot;click1&quot;&gt;</span><br><span class="line">				&lt;div @click.stop=&quot;click2&quot;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					seen: true,</span><br><span class="line">					seen2: false,</span><br><span class="line">					url:&#x27;http://baidu.com&#x27;,</span><br><span class="line">				&#125;,</span><br><span class="line">				methods:&#123;</span><br><span class="line">					doSomething:function()&#123;</span><br><span class="line">						console.log(&#x27;点击事件出现&#x27;);</span><br><span class="line">					&#125;,</span><br><span class="line">					click1:function()&#123;</span><br><span class="line">						console.log(&#x27;click1&#x27;);</span><br><span class="line">					&#125;,</span><br><span class="line">					click2:function()&#123;</span><br><span class="line">						console.log(&#x27;click2&#x27;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbit-安装</title>
    <url>/2020/08/24/Rabbit-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Linux环境，xshell</p>
<span id="more"></span>

<h1 id="Rabbit-安装"><a href="#Rabbit-安装" class="headerlink" title="Rabbit-安装"></a>Rabbit-安装</h1><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/sLeKaPM1DNQHgzu.png" alt="image-20200905175636998"></p>
<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><p>上传</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/p9T2YVJsGDCWtUL.png" alt="image-20200905175921141"></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/MZLUJOX21luiYhC.png" alt="image-20200905180030092"></p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">警告：socat-1.7.3.2-1.1.el7.x86_64.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID 87e360b8: NOKEY</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">	tcp_wrappers 被 socat-1.7.3.2-1.1.el7.x86_64 需要</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm --nodeps --force</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wvzOrPg6LQVI2Tq.png" alt="image-20200905180800041"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/kLWq8jAdTK4E9Fs.png" alt="image-20200905180834609"></p>
<h2 id="开启管理界面"><a href="#开启管理界面" class="headerlink" title="开启管理界面"></a>开启管理界面</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启管理界面</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"># 修改默认配置信息</span><br><span class="line">vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app </span><br><span class="line"># 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/KtAXaeiVkYj9oEH.png" alt="image-20200905180938193"></p>
<p>端口号，默认账号</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20200905191508314.png" alt="image-20200905191508314"></p>
<p>最后一个红框的guest不放开会导致登录失败</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zZlH8m5TEfUKc1G.png" alt="image-20200905191659280"></p>
<h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/share/doc/rabbitmq-server-3.6.5/</span><br><span class="line"></span><br><span class="line">cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service rabbitmq-server start # 启动服务</span><br><span class="line">service rabbitmq-server stop # 停止服务</span><br><span class="line">service rabbitmq-server restart # 重启服务</span><br></pre></td></tr></table></figure>

<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>guest guest</p>
<p>添加虚拟机，添加账号</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/C5wtrn3K7Sc6V8o.png" alt="image-20200906093925469"></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>安装</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbit-应用问题解决</title>
    <url>/2020/08/29/Rabbit-%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>消息可靠性解决，幂等性解决。</p>
<span id="more"></span>

<h1 id="Rabbit-应用问题解决方案"><a href="#Rabbit-应用问题解决方案" class="headerlink" title="Rabbit-应用问题解决方案"></a>Rabbit-应用问题解决方案</h1><h2 id="消息可靠性解决"><a href="#消息可靠性解决" class="headerlink" title="消息可靠性解决"></a>消息可靠性解决</h2><p>架构图</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/HiCon2weFsykGX9.png" alt="RabbitMQ消息可靠性保障"></p>
<p>解决思路：</p>
<ol>
<li>回调检查<ol>
<li>producer发送消息，consumer消费消息后，要发送确认消息。</li>
<li>producer发送消息后，等3分钟再发送一条同样的消息</li>
<li>对比延迟3分钟的消息和确认消息，有延迟消息无确认消息时，让producer重新发这一条消息。</li>
</ol>
</li>
<li>定时检查<ol>
<li>检查producer库中的消息和确认消息库是否一致，producer库中有，确认消息库中没有时，让producer重新发消息。</li>
</ol>
</li>
</ol>
<h2 id="幂等性解决"><a href="#幂等性解决" class="headerlink" title="幂等性解决"></a>幂等性解决</h2><p>解决方法：</p>
<ul>
<li>使用全局MessageID    </li>
<li>乐观锁</li>
</ul>
<h3 id="全局MessageID"><a href="#全局MessageID" class="headerlink" title="全局MessageID"></a>全局MessageID</h3><p>发送消息时发送MessageID，消费消息时去redis中判断是否存在MessageID。</p>
<ul>
<li><p>如果存在，则代表消息已经被消费。</p>
</li>
<li><p>如果不存在，则去消费该消息，消费完成后存储到redis中。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-与SpringBoot整合</title>
    <url>/2020/08/27/RabbitMQ-%E4%B8%8ESpringBoot%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>RabbitMQ-与SpringBoot整合</p>
<span id="more"></span>

<h1 id="RabbitMQ-与SpringBoot整合"><a href="#RabbitMQ-与SpringBoot整合" class="headerlink" title="RabbitMQ-与SpringBoot整合"></a>RabbitMQ-与SpringBoot整合</h1><p>spring boot项目中只需要引入对应的amqp启动器依赖即可，可以方便的使用RabbitTemplate发送消息，使用注解接收消息。</p>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><p><strong>生产者工程：</strong></p>
<ol>
<li>导入依赖</li>
<li>application.yml文件配置RabbitMQ相关信息；</li>
<li>在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定</li>
<li>注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机</li>
</ol>
<p><strong>消费者工程：</strong></p>
<ol>
<li>导入依赖</li>
<li>application.yml文件配置RabbitMQ相关信息</li>
<li>创建消息处理类，用于接收队列中的消息并进行处理</li>
</ol>
<h2 id="生产者工程："><a href="#生产者工程：" class="headerlink" title="生产者工程："></a>生产者工程：</h2><ol>
<li><p>创建生产者工程 new module</p>
</li>
<li><p>导入maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!-- 父工程 --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- rabbit --&gt;</span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot-rabbitmq-producer&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 单元测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname ProducerApplication</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ProducerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class);//SpringApplication 不是SpringBootApplication</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置rabbit服务器信息</span><br><span class="line"># 地址、端口号、账号、密码</span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.3.3</span><br><span class="line">    port: 5672</span><br><span class="line">    username: xiaorui</span><br><span class="line">    password: xiaorui</span><br><span class="line">    virtual-host: learn</span><br></pre></td></tr></table></figure></li>
<li><p>编写配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.*;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname RabbitMQConfig</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    //交换机名称</span><br><span class="line">    public static final String ITEM_TOPIC_EXCHANGE = &quot;xiaorui_topic_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String ITEM_QUEUE = &quot;xiaorui_queue&quot;;</span><br><span class="line"></span><br><span class="line">    //声明交换机</span><br><span class="line">    @Bean(&quot;xiaoruiTopicExchange&quot;)</span><br><span class="line">    public Exchange topicExchange()&#123;</span><br><span class="line">        return ExchangeBuilder.topicExchange(ITEM_TOPIC_EXCHANGE).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //声明队列</span><br><span class="line">    @Bean(&quot;xiaoruiQueue&quot;)</span><br><span class="line">    public Queue xiaoruiQueue()&#123;</span><br><span class="line">        return QueueBuilder.durable(ITEM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //绑定队列和交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding xiaoruiQueueExchange(@Qualifier(&quot;xiaoruiQueue&quot;) Queue queue, @Qualifier(&quot;xiaoruiTopicExchange&quot;) Exchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(&quot;xiaorui.#&quot;).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.rabbitmq;</span><br><span class="line"></span><br><span class="line">import com.xiaoruiit.config.RabbitMQConfig;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname ProducerTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, &quot;xiaorui.insert&quot;, &quot;新增，routing key 为xiaorui.insert&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, &quot;xiaorui.update&quot;, &quot;修改，routing key 为xiaorui.update&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, &quot;xiaorui.delete&quot;, &quot;删除，routing key 为xiaorui.delete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/FQAyC9WMfvtZ8xe.png" alt="image-20200906221641322"></p>
</li>
</ol>
<h2 id="消费者工程"><a href="#消费者工程" class="headerlink" title="消费者工程"></a>消费者工程</h2><ol>
<li><p>创建工程</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot-rabbitmq-consumer&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname ConsumerApplication</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.3.3</span><br><span class="line">    port: 5672</span><br><span class="line">    username: xiaorui</span><br><span class="line">    password: xiaorui</span><br><span class="line">    virtual-host: learn</span><br></pre></td></tr></table></figure></li>
<li><p>消费者监听处理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.com.xiaoruiit.rabbitmq.listener;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class ConsumerListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 监听某个队列的消息</span><br><span class="line">     * @param message 接收到的消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = &quot;xiaorui_queue&quot;)</span><br><span class="line">    public void myListener1(String message)&#123;</span><br><span class="line">        System.out.println(&quot;消费者接收到的消息为：&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消费者接收到的消息为：新增，routing key 为xiaorui.insert</span><br><span class="line">消费者接收到的消息为：修改，routing key 为xiaorui.update</span><br><span class="line">消费者接收到的消息为：删除，routing key 为xiaorui.delete</span><br></pre></td></tr></table></figure></li>
<li><p>rabbitmq控制台</p>
</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/9VYKZrNWeSDgc4A.png" alt="image-20200906223020442"></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>整合</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-复习</title>
    <url>/2020/11/18/RabbitMQ-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>RabbitMQ-复习</p>
<span id="more"></span>

<h1 id="RabbitMQ-复习"><a href="#RabbitMQ-复习" class="headerlink" title="RabbitMQ-复习"></a>RabbitMQ-复习</h1><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p><strong>诞生业务背景</strong>:</p>
<ul>
<li>A 系统通过接口调用发送数据到 BCD 三个系统。一天后E 系统也要这个数据，有一天后 C 系统现在不需要了。</li>
<li>A 系统接收一个前端请求，需要在ABCD四个系统写入库，请求总延时是 3 + 300 + 400 + 200 = 903ms，接近 1s。而互联网类的企业，对于用户直接的操作，一般要求每个请求在 200 ms 以内完成。</li>
<li>每天 12:00 ~ 13:00 ，A系统每秒并发请求数量突然会暴增到 5k+ 条。可能会导致数据库崩溃，系统无法访问。其他时间，并发量小于100.</li>
</ul>
<p><strong>解决了什么</strong>：降低A系统其他系统的耦合，提升响应速度，将一个时间段的高并发量平均到其他时间段。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>解耦</li>
<li>提升响应速度</li>
<li>削峰</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>可用性降低，rabbitmq可能宕机。</li>
<li>复杂度提高</li>
<li>需要解决数据一致性<ul>
<li>消息丢失</li>
<li>重复消费</li>
</ul>
</li>
</ul>
<h2 id="不同消息中间件对比"><a href="#不同消息中间件对比" class="headerlink" title="不同消息中间件对比"></a>不同消息中间件对比</h2><p>RabbitMQ 基于erlang并发语言实现，性能好，延时最低。社区活跃</p>
<p>kafaka 大数据方面，日志收集，社区活跃。高可用的实现更好，本身是分布式的。用到了选举算法。</p>
<p>RocketMQ 阿里出品，已捐献给apache,社区不够活跃</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>介绍：基于erlang语言开发，延时低，并发性能高。</p>
<p>架构：</p>
<p>工作模式：7种。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p>一个生产者，一个交换机，多个队列，多个消费者</p>
<p>交换机类型 topic</p>
<p>生产者发送消息指定 路由 key.</p>
<p>队列绑定交换机，指定路由key，路由key 可以是通配符。</p>
<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h5><h5 id="消费者限流（削峰填谷）"><a href="#消费者限流（削峰填谷）" class="headerlink" title="消费者限流（削峰填谷）"></a>消费者限流（削峰填谷）</h5><h5 id="TTL（过期时间）"><a href="#TTL（过期时间）" class="headerlink" title="TTL（过期时间）"></a>TTL（过期时间）</h5><h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><h5 id="消息追踪（rabbitmq-tracing）"><a href="#消息追踪（rabbitmq-tracing）" class="headerlink" title="消息追踪（rabbitmq_tracing）"></a>消息追踪（rabbitmq_tracing）</h5><h5 id="消息一致性解决"><a href="#消息一致性解决" class="headerlink" title="消息一致性解决"></a>消息一致性解决</h5><h5 id="幂等性解决"><a href="#幂等性解决" class="headerlink" title="幂等性解决"></a>幂等性解决</h5><h3 id="RabbitMQ高可用"><a href="#RabbitMQ高可用" class="headerlink" title="RabbitMQ高可用"></a>RabbitMQ高可用</h3><p>为了解决引入RabbitMQ带来的系统可用性降低。</p>
<p>解决方法：镜像集群模式。</p>
<h4 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h4><p><strong>介绍</strong>：将创建的queue的元数据（queue配置信息）和queue里的消息存储到多个实例上。</p>
<p><strong>如何使用镜像集群模式</strong>：</p>
<p>​        在RabbitMQ的管理控制台，就是在后台新增一个<strong>镜像集群模式</strong>策略，指定数据同步的节点。</p>
<p><strong>镜像集群模式缺点</strong>：性能开销大</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RandomAccessFile-分块加载</title>
    <url>/2020/09/10/RandomAccessFile-%E5%88%86%E5%9D%97%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>RandomAccessFile-分块加载</p>
<span id="more"></span>

<h1 id="RandomAccessFile-分块加载"><a href="#RandomAccessFile-分块加载" class="headerlink" title="RandomAccessFile-分块加载"></a>RandomAccessFile-分块加载</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>加载PDF时，按照自己设定的分块的大小，分多次请求。</p>
<p>RandomAccessFile可以从任意位置开始，任意位置结束读取文件内容。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/BbMtWeXIEcTnqy5.png" alt="image-20200910154816957"></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>foxit-web-sdk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdfui.openPDFByHttpRangeRequest(&#123;</span><br><span class="line">	range: &#123;</span><br><span class="line">		//url: &quot;http://127.0.0.1:8849/FoxitPDFSDKforWeb_DemoGuide.pdf&quot;,</span><br><span class="line">		url: &quot;http://127.0.0.1:8849/foxit/&quot;?pdfId=&quot; + pdfId,</span><br><span class="line">		chunkSize: 131072</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求头Request Headers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Range: bytes=0-131071</span><br><span class="line">Referer: http://127.0.0.1:8849/foxit/lib/WebPDFJRWorker.js?h=245349c6d66690b2cd6362d2643584e9</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.100 Safari/537.36</span><br></pre></td></tr></table></figure>



<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/foxit&quot;)</span><br><span class="line">    public void foxit(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        int pdfId = Integer.parseInt(request.getParameter(&quot;pdfId&quot;));</span><br><span class="line"></span><br><span class="line">        //获取文件</span><br><span class="line">        String filePath = foxitService.getPdfurl(pdfId);</span><br><span class="line">        if (filePath == null || &quot;&quot;.equals(filePath)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        /* 不分片</span><br><span class="line">        response.setContentType(&quot;application/pdf&quot;); </span><br><span class="line">        // 读取路径下面的文件</span><br><span class="line">        try &#123;  </span><br><span class="line">            FileCopyUtils.copy(new FileInputStream(filePath),response.getOutputStream());</span><br><span class="line">        &#125; catch (IOException e)&#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125; */</span><br><span class="line">        </span><br><span class="line">        File downloadFile = new File(filePath);</span><br><span class="line">        if (downloadFile == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取分片起始位置并处理</span><br><span class="line">        long downloadSize = downloadFile.length();</span><br><span class="line">        long fromPos = 0,toPos = 0;</span><br><span class="line">        String range = request.getHeader(&quot;Range&quot;);</span><br><span class="line">        String bytes = range.replaceAll(&quot;bytes=&quot;, &quot;&quot;);</span><br><span class="line">        String[] ary = bytes.split(&quot;-&quot;);</span><br><span class="line">        fromPos = Long.parseLong(ary[0]);</span><br><span class="line">        if (ary.length == 2) &#123;</span><br><span class="line">            toPos = Long.parseLong(ary[1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (toPos - fromPos &gt; 131072)</span><br><span class="line">            return;</span><br><span class="line">        int size;</span><br><span class="line">        if (toPos &gt; fromPos) &#123;</span><br><span class="line">            size = (int) (toPos - fromPos + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size = (int) (downloadSize - fromPos + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 响应头 */</span><br><span class="line">        // 返回流信息 开始-结束/流总大小</span><br><span class="line">        response.setHeader(&quot;Content-Range&quot;, &quot;bytes &quot; + fromPos + &quot;-&quot; + toPos + &quot;/&quot; + downloadSize);</span><br><span class="line">        // 返回流大小</span><br><span class="line">        response.setHeader(&quot;Content-Length&quot;, size + &quot;&quot;);</span><br><span class="line">        response.setContentType(&quot;application/pdf&quot;);</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;, String.format(&quot;inline; filename=\&quot;%s\&quot;&quot;, downloadFile.getName()));</span><br><span class="line">        response.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;content-range, content-length, accept-ranges&quot;);// 坑点，前后端分离时必须添加</span><br><span class="line">        // 206</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span><br><span class="line">        response.setHeader(&quot;Connetion&quot;, &quot;keep-alive&quot;);</span><br><span class="line"></span><br><span class="line">        // 返回流内容</span><br><span class="line">        downloadSize = size;</span><br><span class="line">        RandomAccessFile in = null;</span><br><span class="line">        OutputStream out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new RandomAccessFile(downloadFile, &quot;r&quot;);</span><br><span class="line">            // 设置下载起始位置</span><br><span class="line">            if (fromPos &gt; 0) &#123;</span><br><span class="line">                in.seek(fromPos);</span><br><span class="line">            &#125;</span><br><span class="line">            // 缓冲区大小</span><br><span class="line">            int bufLen = (int) (downloadSize &lt; 2048 ? downloadSize : 2048);</span><br><span class="line">            byte[] buffer = new byte[bufLen];</span><br><span class="line">            int num;</span><br><span class="line">            int count = 0; // 当前写到客户端的大小</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            while ((num = in.read(buffer)) != -1) &#123;</span><br><span class="line">                out.write(buffer, 0, num);</span><br><span class="line">                count += num;</span><br><span class="line">                //处理最后一段，计算不满缓冲区的大小</span><br><span class="line">                if (downloadSize - count &lt; bufLen) &#123;</span><br><span class="line">                    bufLen = (int) (downloadSize - count);</span><br><span class="line">                    if (bufLen == 0) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer = new byte[bufLen];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            response.flushBuffer();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (null != out) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (null != in) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>响应头Response Headers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Methods: GET</span><br><span class="line">Access-Control-Allow-Origin: http://127.0.0.1:8849</span><br><span class="line">Access-Control-Expose-Headers: content-range, content-length, accept-ranges</span><br><span class="line">Access-Control-Max-Age: 3600</span><br><span class="line">Connetion: keep-alive</span><br><span class="line">Content-Disposition: inline; filename=&quot;1.pdf&quot;</span><br><span class="line">Content-Length: 131072</span><br><span class="line">Content-Range: bytes 0-131071/526889</span><br><span class="line">Content-Type: application/pdf</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>文件流</category>
      </categories>
      <tags>
        <tag>RandomAccessFile</tag>
        <tag>分块加载</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Java缓存</title>
    <url>/2020/05/22/Redis-Java%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>了解Java中Redis作为缓存如何使用</p>
<span id="more"></span>

<p><strong>目的：</strong>了解Java中Redis作为缓存如何使用<br><strong>参考：</strong><a href="https://www.cnblogs.com/jinbuqi/p/11038731.html">https://www.cnblogs.com/jinbuqi/p/11038731.html</a></p>
<h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><h2 id="1-准备redis环境"><a href="#1-准备redis环境" class="headerlink" title="1.准备redis环境"></a>1.准备redis环境</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p>下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></p>
<p>版本3.0.503.zip</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vdMJrCyOEaZkYF4.png" alt="img"></p>
<h3 id="2-解压到指定位置"><a href="#2-解压到指定位置" class="headerlink" title="2.解压到指定位置"></a>2.解压到指定位置</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mREUpTxhbvJ53fd.png" alt="img"></p>
<h3 id="3-启动redis服务器："><a href="#3-启动redis服务器：" class="headerlink" title="3.启动redis服务器："></a>3.启动redis服务器：</h3><p>解压目录中新建文件<code>startup.cmd</code>，内容为：<code>redis-server redis.windows.conf</code></p>
<p>启动redis服务器：双击<code>startup.cmd</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/pMFru3qJyn7a9mO.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hu6OsdR3BfVUHDm.png" alt="img"></p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>打开同一个文件夹下的 redis-cli.exe<br>输入测试语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br><span class="line"></span><br><span class="line">get key</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“value”</span><br></pre></td></tr></table></figure>

<h2 id="2-java中使用"><a href="#2-java中使用" class="headerlink" title="2.java中使用"></a>2.java中使用</h2><h3 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h3><p>我的环境 idea:<code>2018.3.3</code> jdk:<code>1.8.0_131</code><br>idea新建springboot项目</p>
<p>maven添加jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--注释掉，开启junit--&gt;</span><br><span class="line">    &lt;!--&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">    &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--Web--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--json包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- log --&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h3 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h3><p><code>application.properties</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure>

<p>新建<code>log4j.properties</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=CONSOLE,FILE</span><br><span class="line">log4j.addivity.org.apache=true</span><br><span class="line"></span><br><span class="line"># 应用于控制台</span><br><span class="line">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CONSOLE.Threshold=INFO</span><br><span class="line">log4j.appender.CONSOLE.Target=System.out</span><br><span class="line">log4j.appender.CONSOLE.Encoding=UTF-8</span><br><span class="line">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n</span><br><span class="line"></span><br><span class="line"># 每天新建日志</span><br><span class="line">log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.A1.File=D:/log4j/log</span><br><span class="line">log4j.appender.A1.Encoding=UTF-8</span><br><span class="line">log4j.appender.A1.Threshold=DEBUG</span><br><span class="line">log4j.appender.A1.DatePattern=&#x27;.&#x27;yyyy-MM-dd</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L : %m%n</span><br><span class="line"></span><br><span class="line">#应用于文件</span><br><span class="line">log4j.appender.FILE=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.FILE.File=E:/log4j/file.log</span><br><span class="line">log4j.appender.FILE.Append=false</span><br><span class="line">log4j.appender.FILE.Encoding=UTF-8</span><br><span class="line">log4j.appender.FILE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n</span><br></pre></td></tr></table></figure>

<h3 id="3-包结构"><a href="#3-包结构" class="headerlink" title="3.包结构"></a>3.包结构</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iumg1tOfKz8hwqC.png" alt="image-20200522161701680"></p>
<h3 id="4-配置Redis"><a href="#4-配置Redis" class="headerlink" title="4.配置Redis"></a>4.配置Redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: redis配置  配置序列化方式以及缓存管理器</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">@EnableCaching//开启以注解方式使用缓存。</span><br><span class="line">@Configuration//这是一个配置类</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Description: json序列化</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer() &#123;</span><br><span class="line">        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line">        return serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Description:配置自定义redisTemplate</span><br><span class="line">     *</span><br><span class="line">     * @param connectionFactory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer());</span><br><span class="line">        //使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置缓存管理器</span><br><span class="line">     * @param redisConnectionFactory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        // 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        // 设置缓存的默认过期时间，也是使用Duration设置</span><br><span class="line">        config = config.entryTtl(Duration.ofMinutes(1))</span><br><span class="line">                // 设置 key为string序列化</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))</span><br><span class="line">                // 设置value为json序列化</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer()))</span><br><span class="line">                // 不缓存空值</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        // 设置一个初始化的缓存空间set集合</span><br><span class="line">        Set&lt;String&gt; cacheNames = new HashSet&lt;&gt;();</span><br><span class="line">        cacheNames.add(&quot;timeGroup&quot;);</span><br><span class="line">        cacheNames.add(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">        // 对每个缓存空间应用不同的配置</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; configMap = new HashMap&lt;&gt;();</span><br><span class="line">        configMap.put(&quot;timeGroup&quot;, config);</span><br><span class="line">        configMap.put(&quot;user&quot;, config.entryTtl(Duration.ofSeconds(120)));</span><br><span class="line"></span><br><span class="line">        // 使用自定义的缓存配置初始化一个cacheManager</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">                // 一定要先调用该方法设置初始化的缓存名，再初始化相关的配置</span><br><span class="line">                .initialCacheNames(cacheNames)</span><br><span class="line">                .withInitialCacheConfigurations(configMap)</span><br><span class="line">                .build();</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存的key是 包名+方法名+参数列表</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public KeyGenerator keyGenerator() &#123;</span><br><span class="line">        return (target, method, objects) -&gt; &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            sb.append(target.getClass().getName());</span><br><span class="line">            sb.append(&quot;::&quot; + method.getName() + &quot;:&quot;);</span><br><span class="line">            for (Object obj : objects) &#123;</span><br><span class="line">                sb.append(obj.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-实体类pojo"><a href="#5-实体类pojo" class="headerlink" title="5.实体类pojo"></a>5.实体类pojo</h3><p>使用了lombok</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.redis_cache.pojo;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line">import lombok.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor                 //无参构造</span><br><span class="line">@AllArgsConstructor                //有参构造</span><br><span class="line">public class User &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String  nickname;</span><br><span class="line">    private String mobile;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)//在输出的Json数据中隐藏密码，只能输入不输出</span><br><span class="line">    private String password;</span><br><span class="line">    private String role;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Controller"><a href="#6-Controller" class="headerlink" title="6.Controller"></a>6.Controller</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redis;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&#123;id&#125;&quot;, method = RequestMethod.GET, produces = &quot;application/json&quot;)</span><br><span class="line">    public User getUserById(@PathVariable long id)&#123;</span><br><span class="line">        User user = userService.getUserById(id);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&#123;id&#125;/change-nick&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;)</span><br><span class="line">    public User updateNickname(@PathVariable long id) throws Exception&#123;</span><br><span class="line">        String nickname = &quot;ww-&quot; + Math.random();</span><br><span class="line">        User user = userService.updateUserNickname(id, nickname);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&#123;id&#125;/change-nick&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;)</span><br><span class="line">    public User updateMobile(@PathVariable long id) throws Exception&#123;</span><br><span class="line">        String mobile = &quot;134&quot; + Math.random();</span><br><span class="line">        User user = userService.updateUserNickname(id, mobile);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用RedisTemplate访问redis服务器</span><br><span class="line">    @RequestMapping(value=&quot;/redis&quot;, method=RequestMethod.GET, produces=&quot;application/json&quot;)</span><br><span class="line">    public String redis() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 设置键&quot;key&quot;，值&quot;value&quot;</span><br><span class="line">        redis.opsForValue().set(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">        String value = (String) redis.opsForValue().get(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Service-ServiceImpl"><a href="#7-Service-ServiceImpl" class="headerlink" title="7.Service + ServiceImpl"></a>7.Service + ServiceImpl</h3><ul>
<li><p><code>@Cacheable</code> - 表明对应方法的返回结果可以被缓存，首次调用后，下次就从缓存中读取结果，方法不会再被执行了。</p>
</li>
<li><p><code>@CachePut</code> - 更新缓存，方法每次都会执行</p>
</li>
<li><p><code>@CacheEvict</code> - 清除缓存，方法每次都会执行</p>
<p>Service </p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public User getUserById(long userId);</span><br><span class="line">    public User updateUserNickname(long userId, String nickname);</span><br><span class="line">    public User updateUserMobile(long userId, String mobile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceImpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    private User user = new User(11, &quot;zs&quot;, &quot;13400000000&quot;, &quot;123456&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">    @Cacheable(value = &quot;user&quot;, key = &quot;#userId&quot;) //表明对应方法的返回结果可以被缓存，首次调用后，下次就从缓存中读取结果，可以查到时，方法不会被执行。</span><br><span class="line">    @Override</span><br><span class="line">    public User getUserById(long userId) &#123;</span><br><span class="line">       log.info(&quot;加载user&quot;);</span><br><span class="line">       return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(value = &quot;user&quot;, key= &quot;#userId&quot;) //清除缓存，方法每次都会执行</span><br><span class="line">    @Override</span><br><span class="line">    public User updateUserNickname(long userId, String nickname) &#123;</span><br><span class="line">        log.info(&quot;修改名字，清除缓存&quot;);</span><br><span class="line">        user.setNickname(nickname);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(value = &quot;user&quot;, key= &quot;#userId&quot;) //更新缓存，方法每次都会执行</span><br><span class="line">    @Override</span><br><span class="line">    public User updateUserMobile(long userId, String mobile) &#123;</span><br><span class="line">        log.info(&quot;修改手机，更新缓存&quot;);</span><br><span class="line">        user.setMobile(mobile);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-启动redis监控"><a href="#8-启动redis监控" class="headerlink" title="8.启动redis监控"></a>8.启动redis监控</h3><p>进入redis安装目录，双击<code>redis-cli.exe</code>,输入<code>monitor</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/UEFXkalCY9nH12p.png" alt="image-20200522163608886"></p>
<h3 id="9-APIPost测试q"><a href="#9-APIPost测试q" class="headerlink" title="9.APIPost测试q"></a>9.APIPost测试q</h3><p>启动springboot项目，打开Apipost</p>
<h4 id="1-Cacheable测试"><a href="#1-Cacheable测试" class="headerlink" title="1.@Cacheable测试"></a>1.@Cacheable测试</h4><p>发送请求，查看redis监控器中的变化</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oMpZUuDN7EwtH4c.png" alt="image-20200522164136415"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TR3mnLX7QeYUWCG.png" alt="image-20200522164207296"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/LHbgJUqorjpuRnk.png" alt="image-20200522164320735"></p>
<p>再发送三次</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/yBuAsTJCrc9omQZ.png" alt="image-20200522164431496"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/dmNgeVWGrR8ut7F.png" alt="image-20200522164451522"></p>
<p>加载user只打印了一次，方法内部只执行了一次</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4xQa5b3ToyhFqwf.png" alt="image-20200522164949723"></p>
<h4 id="2-CacheEvict测试"><a href="#2-CacheEvict测试" class="headerlink" title="2.@CacheEvict测试"></a>2.@CacheEvict测试</h4><p>发送两次请求</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/rK1xvcdqCbJX9p3.png" alt="image-20200522164734057"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/biqWDTYPdM7X1gy.png" alt="image-20200522164834405"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XEwOBgGp7UyhFYJ.png" alt="image-20200522164927084"></p>
<h4 id="3-CachePut测试"><a href="#3-CachePut测试" class="headerlink" title="3.CachePut测试"></a>3.CachePut测试</h4><p>发送两次请求</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Tqx7CP3njuph2eA.png" alt="image-20200522165145493"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/9D8xbBXWdh6mZt2.png" alt="image-20200522165212982"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oun1vPAICTfSslx.png" alt="image-20200522165257318"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-入门</title>
    <url>/2020/05/22/Redis-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>了解redis功能和作用，会使用Redis</p>
<span id="more"></span>

<p><strong>目的：</strong>了解redis功能和作用，会使用Redis<br><strong>参考：</strong><a href="https://www.jianshu.com/p/56999f2b8e3b">https://www.jianshu.com/p/56999f2b8e3b</a><br><strong>功能：</strong>redis是内存数据库，可将数据存放在内存中。读写效率是mysql的几个量级。<br><strong>作用：</strong>缓存数据，大大提升访问速度。高速读写，并发<br><strong>场景：</strong>缓存热点数据，高速读写，并发场合。</p>
<h1 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis-入门"></a>Redis-入门</h1><h2 id="1-准备redis环境"><a href="#1-准备redis环境" class="headerlink" title="1.准备redis环境"></a>1.准备redis环境</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p>下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></p>
<p>版本3.0.503.zip</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vdMJrCyOEaZkYF4.png" alt="img"></p>
<h3 id="2-解压到指定位置"><a href="#2-解压到指定位置" class="headerlink" title="2.解压到指定位置"></a>2.解压到指定位置</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mREUpTxhbvJ53fd.png" alt="img"></p>
<h3 id="3-启动redis服务器："><a href="#3-启动redis服务器：" class="headerlink" title="3.启动redis服务器："></a>3.启动redis服务器：</h3><p>解压目录中新建文件<code>startup.cmd</code>，内容为：<code>redis-server redis.windows.conf</code></p>
<p>启动redis服务器：双击<code>startup.cmd</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/pMFru3qJyn7a9mO.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hu6OsdR3BfVUHDm.png" alt="img"></p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>打开同一个文件夹下的 redis-cli.exe<br>输入测试语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br><span class="line"></span><br><span class="line">get key</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“value”</span><br></pre></td></tr></table></figure>

<h2 id="2-java中使用"><a href="#2-java中使用" class="headerlink" title="2.java中使用"></a>2.java中使用</h2><h3 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h3><p>我的环境 idea:<code>2018.3.3</code> jdk:<code>1.8.0_131</code><br>idea新建springboot项目</p>
<p>maven添加jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--先注释掉才能使用Junit--&gt;</span><br><span class="line">    &lt;!--&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h3 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h3><p><code>application.properties</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure>

<h3 id="3-操作Spring"><a href="#3-操作Spring" class="headerlink" title="3.操作Spring"></a>3.操作Spring</h3><p>新建类<code>ConnectRedisTest</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest()</span><br><span class="line">public class ConnectRedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate = new StringRedisTemplate();</span><br><span class="line"></span><br><span class="line">    //存储String</span><br><span class="line">    @Test</span><br><span class="line">    public void string() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">        //</span><br><span class="line">        stringRedisTemplate.opsForValue().set(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(&quot;key2&quot;,&quot;value2&quot;);</span><br><span class="line">        Assert.assertEquals(&quot;value3&quot;,stringRedisTemplate.opsForValue().get(&quot;key&quot;));</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-存储对象"><a href="#4-存储对象" class="headerlink" title="4.存储对象"></a>4.存储对象</h3><p>新建类<code>User</code>,注意需要实现接口<code>Serializable</code>。这里我还是用<code>lombok</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConnectRedisTest</code>中注入<code>RedisTemplate</code>,添加测试方法<code>object</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line"> RedisTemplate redisTemplate = new RedisTemplate();</span><br><span class="line"></span><br><span class="line">//存储对象</span><br><span class="line">@Test</span><br><span class="line">public void object() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;1&quot;);</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setId(&quot;1&quot;);</span><br><span class="line">    user.setName(&quot;zs&quot;);</span><br><span class="line">    //User需实现序列化接口</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;user&quot;,user);</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-操作List"><a href="#5-操作List" class="headerlink" title="5.操作List"></a>5.操作List</h3><p><code>ConnectRedisTest</code>添加测试方法<code>list</code> 和<code>listRemove</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//List</span><br><span class="line">@Test</span><br><span class="line">public void list() throws Exception&#123;</span><br><span class="line">    System.out.println(&quot;1&quot;);</span><br><span class="line">    redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;1&quot;);</span><br><span class="line">    redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;2&quot;);</span><br><span class="line">    redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;0&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = redisTemplate.opsForList().range(&quot;list&quot;, 0, -1);</span><br><span class="line">    System.out.println(list.toString());//[0, 1, 2, A]</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list2 = redisTemplate.opsForList().range(&quot;list&quot;, 0, 3);</span><br><span class="line">    System.out.println(list2.toString());//[0, 1, 2, A]</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = redisTemplate.opsForList().range(&quot;list&quot;, 1, 2);</span><br><span class="line">    System.out.println(list3.toString());//[0, 1, 2, A]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void listRemove()&#123;</span><br><span class="line">    System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1).toString());//[0, 0, 1, 2, 1, 2, 1, 2, A]</span><br><span class="line">    //删除第一个为A的元素</span><br><span class="line">    redisTemplate.opsForList().remove(&quot;list&quot;, 1, &quot;A&quot;);</span><br><span class="line">    System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1));//[0, 0, 1, 2, 1, 2, 1, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //删除所有的value为0的元素</span><br><span class="line">    redisTemplate.opsForList().remove(&quot;list&quot;, 0, &quot;0&quot;);</span><br><span class="line">    System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1));//[1, 2, 1, 2, 1, 2]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-windows下后台启动"><a href="#3-windows下后台启动" class="headerlink" title="3.windows下后台启动"></a>3.windows下后台启动</h2><h3 id="1-安装成windows服务"><a href="#1-安装成windows服务" class="headerlink" title="1.安装成windows服务"></a>1.安装成windows服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --service-install redis.windows.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/PsUG8i6h3NbCDdc.png" alt="image-20201029104307873"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/viEH4hSzsZMPFx5.png" alt="image-20201029104407433"></p>
<h3 id="2-启动Redis"><a href="#2-启动Redis" class="headerlink" title="2.启动Redis"></a>2.启动Redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --service-start</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/kc2D7FMvUCaWKS4.png" alt="image-20201029104515578"></p>
<h3 id="3-停止、卸载"><a href="#3-停止、卸载" class="headerlink" title="3.停止、卸载"></a>3.停止、卸载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --service-stop</span><br><span class="line">redis-server --service-uninstall</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据结构Hash</title>
    <url>/2021/06/10/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Hash/</url>
    <content><![CDATA[<p>Redis的数据结构Hash</p>
<span id="more"></span>

<h1 id="Redis的数据结构Hash"><a href="#Redis的数据结构Hash" class="headerlink" title="Redis的数据结构Hash"></a>Redis的数据结构Hash</h1><p>适合存储对象，比存储在String类型类，占用 更小的内存空间，并方便存取整个对象。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="string结构"><a href="#string结构" class="headerlink" title="string结构"></a>string结构</h3><p>key，value</p>
<h3 id="hash结构"><a href="#hash结构" class="headerlink" title="hash结构"></a>hash结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key,&#123;&#123;field1,value1&#125;,&#123;field2,value2&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hset key field value</span><br><span class="line">hset user name zs</span><br></pre></td></tr></table></figure>

<h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hget user</span><br><span class="line">hget user</span><br></pre></td></tr></table></figure>

<h3 id="删除field"><a href="#删除field" class="headerlink" title="删除field"></a>删除field</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hdel key field [field......]</span><br><span class="line">hdel user name age</span><br></pre></td></tr></table></figure>

<h3 id="获取所有field"><a href="#获取所有field" class="headerlink" title="获取所有field"></a>获取所有field</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hkeys key</span><br></pre></td></tr></table></figure>

<h3 id="获取所有value"><a href="#获取所有value" class="headerlink" title="获取所有value"></a>获取所有value</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hvals key</span><br></pre></td></tr></table></figure>

<h3 id="获取所有field-value"><a href="#获取所有field-value" class="headerlink" title="获取所有field-value"></a>获取所有field-value</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hgetall key</span><br></pre></td></tr></table></figure>



<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p><a href="https://redis.io/commands/scan">参考</a></p>
<p>sscan 查询set结构</p>
<p>hscan 查询hash结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询key = swagger, field 模糊匹配*test* ,row &lt; 100000的所有值</span><br><span class="line">hscan swagger 0 match *test* count 100000</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework体系结构</title>
    <url>/2020/01/27/Spring-Spring%20Framework%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Spring Framework体系结构</p>
<span id="more"></span>

<h1 id="Spring-Framework体系结构"><a href="#Spring-Framework体系结构" class="headerlink" title="Spring Framework体系结构"></a>Spring Framework体系结构</h1><p>Spring组件被分别整合在核心容器（CoreContainer）、AOP（AspectOrientedProgramming）和设备支持（Instrmentation）、数据</p>
<p>访问及集成（DataAccess/Integeration）、Web、报文发送（Messaging）、Test，6个模块集合中。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Ql64MGWBKVjDcSf.png" alt="image-20200606101444656"></p>
<h2 id="1-核心容器"><a href="#1-核心容器" class="headerlink" title="1.核心容器"></a>1.核心容器</h2><p><strong>由spring-beans、spring-core、spring-context和spring-expression（Spring ExpressionLanguage,SpEL）4个模块组成。</strong></p>
<p>spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（InversionofControl,IOC）和依赖注入（DependencyInjection,DI）。BeanFactory接口是Spring框架中的核心接口。</p>
<p>spring-context模块构架于核心模块之上，他扩展了BeanFactory，为她添加了Bean生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext是该模块的核心接口，ApplicationContext容器实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</p>
<p>spring-expression模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。</p>
<h2 id="2-AOP相关"><a href="#2-AOP相关" class="headerlink" title="2.AOP相关"></a>2.AOP相关</h2><p><strong>由spring-aop、spring-aspects和spring-instrument3个模块组成。</strong></p>
<p>spring-aop是Spring的另一个核心模块，是AOP主要的实现模块。</p>
<p>spring-aspects模块集成自AspectJ框架，主要是为SpringAOP提供多种AOP实现方法。</p>
<p>spring-instrument模块是基于JAVASE中的”java.lang.instrument”进行设计的，算是AOP的一个支援模块，主要作用是在JVM启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现AOP的功能。</p>
<h2 id="3-数据处理"><a href="#3-数据处理" class="headerlink" title="3.数据处理"></a>3.数据处理</h2><p><strong>由spring-jdbc、spring-tx、spring-orm、spring-jms和spring-oxm5个模块组成。</strong></p>
<h2 id="4-web"><a href="#4-web" class="headerlink" title="4.web"></a>4.web</h2><p><strong>由spring-web、spring-webmvc、spring-websocket和spring-webflflux4个模块组成。</strong></p>
<h2 id="5-消息支持"><a href="#5-消息支持" class="headerlink" title="5.消息支持"></a>5.消息支持</h2><p><strong>spring-messaging模块</strong>，为Spring框架集成一些基础的报文传送应用</p>
<h2 id="6-Test测试"><a href="#6-Test测试" class="headerlink" title="6.Test测试"></a>6.Test测试</h2><p><strong>即spring-test模块。</strong></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>idea导入spring源码</title>
    <url>/2020/01/30/Spring-idea%E5%AF%BC%E5%85%A5spring%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>idea导入spring源码，导入时出现一些问题的解决</p>
<span id="more"></span>

<h1 id="idea导入spring源码"><a href="#idea导入spring源码" class="headerlink" title="idea导入spring源码"></a>idea导入spring源码</h1><h2 id="此次导入的环境："><a href="#此次导入的环境：" class="headerlink" title="此次导入的环境："></a>此次导入的环境：</h2><p>​    Idea:2018.3.3 </p>
<p>​    jdk:1.8.0_131 </p>
<p>​    gradle:4.6</p>
<p>​    Spring-framework 5.0.7</p>
<h2 id="官方源码导入步骤："><a href="#官方源码导入步骤：" class="headerlink" title="官方源码导入步骤："></a>官方源码导入步骤：</h2><h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><ol>
<li><p>下载源码</p>
<p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
</li>
<li><p>下载gradle</p>
<p><a href="http://downloads.gradle.org/distributions/gradle-4.6-bin.zip">http://downloads.gradle.org/distributions/gradle-4.6-bin.zip</a></p>
<p>最好用4G网下载，稳定，不容易失败</p>
</li>
<li><p>配置gradle环境变量  按照第一篇博客配置gradle环境变量</p>
<ol>
<li><p>配置变量</p>
<p>添加<code>GRADLE_HOME</code>变量:<code>D:\development\gradle-4.6</code></p>
<p><code>GRADLE_HOME</code>到Path变量 : <code>%GRADLE_HOME%\bin</code></p>
<p>配置gradle工厂,添加<code>GRADLE_USER_HOME</code> 变量: <code>%GRADLE_HOME%\.gradle</code></p>
</li>
<li><p>检测</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/e7d1bzoIHjrPc8g.png" alt="image-20200613163121207"></p>
</li>
</ol>
</li>
</ol>
<h3 id="2-下载依赖并预编译一些源码"><a href="#2-下载依赖并预编译一些源码" class="headerlink" title="2.下载依赖并预编译一些源码"></a>2.下载依赖并预编译一些源码</h3><p>进入源码目录：cmd输入<code>.\gradlew :spring-oxm:compileTestJava</code>，中间可能出现连接断开，需要再次输入。等待一会，10分钟左右</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ypkztC5iT4xHOhA.png" alt="image-20200612170443764"></p>
<h3 id="3-open-project"><a href="#3-open-project" class="headerlink" title="3.open project"></a>3.open project</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TF7vb2KY6hMoNnW.png" alt="image-20200612143119648"></p>
<p>选项配置：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6QMOSaveHYg5qUi.png" alt="image-20200612143258195"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/GxtrRlPodqswIin.png" alt="image-20200612143359736"></p>
<p>gradle中过程中报错</p>
<p>1.遇到第一个问题</p>
<h3 id="4-build-project"><a href="#4-build-project" class="headerlink" title="4.build project"></a>4.build project</h3><p>gradle结束后，build项目时报错。</p>
<p>遇到AspectJ的问题，请查看issues</p>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><h3 id="第一个问题："><a href="#第一个问题：" class="headerlink" title="第一个问题："></a>第一个问题：</h3><p><strong>报错：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No such property: values for class: org.gradle.api.internal.tasks.DefaultTas</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>点击<code>open file</code>，注释掉spring-beans.gradle倒数第二行和第三行。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/xjLDk8YH9rB2RPK.png" alt="image-20200613173049016"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ySxiL9zoZcJbmwk.png" alt="image-20200611183343723"></p>
<p><strong>解决后：</strong></p>
<p>开始下载依赖，下载很长时间，4G网半小时左右</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JBIl9iQfe4vudzL.png" alt="image-20200611183803599"></p>
<p>问题：<code>Error:java: Compilation failed: internal java compiler error</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/DibpSRdkXjvF4wP.png" alt="image-20200613184804031"></p>
<h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>缺少两个包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning:Kotlin: Classpath entry points to a non-existent location: D:\han\project\spring-framework-5.0.7.RELEASE\spring-core\build\libs\spring-cglib-repack-3.2.6.jar</span><br><span class="line"></span><br><span class="line">D:\han\project\spring-framework-5.0.7.RELEASE\spring-core\src\main\java\org\springframework\cglib\core\SpringNamingPolicy.java</span><br><span class="line">Error:(30, 41) java: 找不到符号</span><br><span class="line">  符号: 类 DefaultNamingPolicy</span><br><span class="line">Error:(34, 9) java: 方法不会覆盖或实现超类型的方法</span><br></pre></td></tr></table></figure>

<h4 id="第一种解决方法："><a href="#第一种解决方法：" class="headerlink" title="第一种解决方法："></a>第一种解决方法：</h4><p>Add Hooks for Before Gradle Import</p>
<p>官方文档<a href="https://youtrack.jetbrains.com/issue/IDEA-160605">https://youtrack.jetbrains.com/issue/IDEA-160605</a></p>
<h5 id="官方添加的内容："><a href="#官方添加的内容：" class="headerlink" title="官方添加的内容："></a>官方添加的内容：</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/abgtnuoWVcS41vC.png" alt="image-20200612115207945"></p>
<h5 id="我添加的内容："><a href="#我添加的内容：" class="headerlink" title="我添加的内容："></a>我添加的内容：</h5><p>少添加了一个spring下的genXmlbeans,因为找不到</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/EPVMQrZ582pzhaC.png" alt="image-20200612115416599"></p>
<h5 id="添加步骤："><a href="#添加步骤：" class="headerlink" title="添加步骤："></a>添加步骤：</h5><p>1.打开idea的gradle视图</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OExDjXW5H1wLKSd.png" alt="image-20200612115822785"></p>
<p>2.添加hooks</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tHwlyhsfTCKGaOc.png" alt="image-20200612115007891"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/kVcvGPSKOfx3y89.png" alt="image-20200612115048276"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/AhDyZFgVMmn91Rz.png" alt="image-20200612114758749"></p>
<h5 id="刷新gradle"><a href="#刷新gradle" class="headerlink" title="刷新gradle"></a>刷新gradle</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OV7WrqvsAPDgfyI.png" alt="image-20200612133911713"></p>
<h5 id="等待几分钟"><a href="#等待几分钟" class="headerlink" title="等待几分钟"></a>等待几分钟</h5><h3 id="AspectJ的问题"><a href="#AspectJ的问题" class="headerlink" title="AspectJ的问题"></a>AspectJ的问题</h3><ol>
<li><p>移走 unload</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Z3hfXRPDSFmiEU4.png" alt="image-20200612173712719"></p>
</li>
<li><p>重新编译</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XW2z3HwPy1OfFio.png" alt="image-20200612173748663"></p>
</li>
<li><p>编译成功</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RZtmYoqeG9kgcW7.png" alt="image-20200612173622416"></p>
</li>
</ol>
<h2 id="有注释的残缺源码导入"><a href="#有注释的残缺源码导入" class="headerlink" title="有注释的残缺源码导入"></a>有注释的残缺源码导入</h2><h3 id="1-搭建环境-1"><a href="#1-搭建环境-1" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><p>同上</p>
<h3 id="2-预编译源码"><a href="#2-预编译源码" class="headerlink" title="2.预编译源码"></a>2.预编译源码</h3><p>源码目录下，双击gradlew.bat</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6P1MoUvjamXgDxN.png" alt="image-20200612143004534"></p>
<h3 id="3-open-project-1"><a href="#3-open-project-1" class="headerlink" title="3.open project"></a>3.open project</h3><p>同上</p>
<h3 id="4-build-project-1"><a href="#4-build-project-1" class="headerlink" title="4.build project"></a>4.build project</h3><p>2.第二个问题 请查看issues</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/2020/01/26/Spring-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务</p>
<span id="more"></span>

<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h3><p>原子性：不可分割</p>
<p>一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态</p>
<p>隔离性：不被其他事物影响</p>
<p>持久性：对数据库的改变是持久的。</p>
<h3 id="事务并发时会出现的问题"><a href="#事务并发时会出现的问题" class="headerlink" title="事务并发时会出现的问题"></a>事务并发时会出现的问题</h3><p>脏读：一个事务读取到另一个事务未提交的数据。</p>
<p>不可重复读：是指一个事务范围内，多次查询某个数据，却得到不同的结果。第一个事务中的两次读取数据之间，第二个事务对数据进行了修改。</p>
<p>幻读：第一个事务对一个表中全部数据行中的某一项的数据进行了修改。同时，第二个事务向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>Read uncommitted（读未提交）：任何情况都无法保证。</p>
<p>Read committed（读已提交）：可避免脏读。oracle采用。</p>
<p>Repeatable read(可重复读)：可避免脏读、不可重复读。mysql采用</p>
<p>Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>给格数据源提供开启事务、释放资源、回滚数据等接口，各数据源负责具体实现。比如：jdbc，mybatis，hibernate。自己的框架需要自己实现。</p>
<p>底层使用SpringAop，而不是SpringAop+Aspectj</p>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="xml使用"><a href="#xml使用" class="headerlink" title="xml使用"></a>xml使用</h3><p>配置事务+数据源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">&lt;!-- 配置数据源 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">	class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;driverClassName&quot;</span><br><span class="line">		value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///kkb&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;	</span><br><span class="line"></span><br><span class="line">&lt;!-- 扫描AccountDao和AccountService --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kkb.spring.tx&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>


<p>配置通配符方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务通知类（Spring实现的事务增强类） --&gt;</span><br><span class="line">&lt;!--   TransactionInterceptor  --&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;</span><br><span class="line">	transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">	&lt;tx:attributes&gt;</span><br><span class="line">		&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;transfer*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>

<p>配置切面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置aop切面类或者通知器类 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;!-- 这使用的是Spring AOP的实现 --&gt;</span><br><span class="line">	&lt;!-- advice-ref：指定advice增强类 --&gt;</span><br><span class="line">	&lt;aop:advisor advice-ref=&quot;txAdvice&quot;</span><br><span class="line">		pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<h3 id="xml-注解混合使用"><a href="#xml-注解混合使用" class="headerlink" title="xml+注解混合使用"></a>xml+注解混合使用</h3><p>通配符方法+切面改为注解@Transactional</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务注解驱动 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="纯注解使用"><a href="#纯注解使用" class="headerlink" title="纯注解使用"></a>纯注解使用</h3><p>xml配置改为注解@EnableTransactionManagement</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring介绍</title>
    <url>/2020/01/23/Spring-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>IOC、DI、AOP、事务</p>
<span id="more"></span>

<p><strong>目标：</strong>掌握一些概念，包括IoC、DI、AOP、Spring容器</p>
<p>Spring的优点：</p>
<ul>
<li><p>方便解耦</p>
<p>Spring可以管理对象之间的依赖关系 @Autow @Resource 单例模式</p>
</li>
<li><p>AOP编程的支持</p>
<p>面向切面编程，不改变原有类的情况下增强Bean的功能。代理模式，jdk动态道理，Cligb动态代理。</p>
</li>
<li><p>声明式事务支持</p>
</li>
<li><p>方便程序测试</p>
<p>Spring 对Junit支持很好，可以通过注解方便的测试。</p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>Hessian、Quartz</p>
</li>
<li><p>Java源码的经典学习案例</p>
<p>Spring源码是java技术的最佳实践案例，可以学到设计模式的灵活应用，提高代码编写质量。</p>
</li>
</ul>
<p>Spring核心概念：</p>
<ul>
<li><p>IoC：Inverse of Control，控制反转。由Spring框架负责对象的创建，用到了单例模式（也可多例Struts2）。Spring创建对象时，需要将UserService类的依赖对象userDao注入到Bean组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>DI：Dependency Injection，依赖注入。依赖：Bean实例的属性。给依赖对象的属性赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AOP：不修改目标对象代码的情况下，增强IOC容器中Bean的功能。</p>
</li>
<li><p>Spring容器：指的是IoC容器，底层是BeanFactory</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>全家桶介绍</title>
    <url>/2020/01/27/Spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>全家桶介绍</p>
<span id="more"></span>

<p>springframework：spring，aop，mvc，test，jdbc，orm，oxm。message</p>
<p>springdata：spring对数据的支持。springdata，jpa，springRedis，springMongoDB。</p>
<p>springboot：简化配置</p>
<p>springcloud：关于分布式服务</p>
<p>熔断器，服务注册</p>
<p>springconfiguration：配置中心</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-手写框架流程</title>
    <url>/2020/02/05/Spring-%E6%89%8B%E5%86%99%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>手写框架流程,附上了获取bean和创建bean的代码，为附上加载配置文件，生成bean定义的代码</p>
<span id="more"></span>

<h2 id="一-准备环境"><a href="#一-准备环境" class="headerlink" title="一.准备环境"></a>一.准备环境</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><h3 id="2-写xml配置文件"><a href="#2-写xml配置文件" class="headerlink" title="2.写xml配置文件"></a>2.写xml配置文件</h3><h3 id="3-编写测试代码"><a href="#3-编写测试代码" class="headerlink" title="3.编写测试代码"></a>3.编写测试代码</h3><h2 id="二-写框架"><a href="#二-写框架" class="headerlink" title="二.写框架"></a>二.写框架</h2><h3 id="1-加载并解析配置文件"><a href="#1-加载并解析配置文件" class="headerlink" title="1.加载并解析配置文件"></a>1.加载并解析配置文件</h3><p>​    涉及到Bedifinition</p>
<h3 id="2-创建Bean实例"><a href="#2-创建Bean实例" class="headerlink" title="2.创建Bean实例"></a>2.创建Bean实例</h3><ol>
<li><p>判断单例缓存Map中是否存在需要的实例</p>
<ol>
<li><p>存在</p>
<p>返回单例实例</p>
</li>
<li><p>不存在</p>
<p>创建实例</p>
<ol>
<li><p>获取Bedifinition，判断是否为null</p>
<ol>
<li><p>null,return null</p>
</li>
<li><p>判断是单例还是多例</p>
<ol>
<li><p>单例</p>
<ol>
<li><p>创建实例</p>
</li>
<li><p>创建bean的实例</p>
<ol start="2">
<li><p>注入属性</p>
</li>
<li><p>是否有初始化方法</p>
</li>
<li><p>有</p>
<ol>
<li>执行方法 通过反射</li>
</ol>
</li>
<li><p>无</p>
</li>
<li><p>是否有后置处理方法</p>
</li>
<li><p>有</p>
<ol>
<li>通过aop处理</li>
</ol>
</li>
</ol>
</li>
<li><p>加入缓存Map</p>
</li>
<li><p>返回实例对象</p>
</li>
</ol>
</li>
<li><p>多例</p>
<ol>
<li><p>创建实例</p>
</li>
<li><p>返回实例对象</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>创建bean实例简化代码，只实现核心部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Map&lt;String, BeanDefinition&gt; beanDefinitions = new HashMap&lt;&gt;();</span><br><span class="line">// 单例缓存</span><br><span class="line">Map&lt;String, Object&gt; beans = new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition bd) &#123;</span><br><span class="line">	beanDefinitions.put(beanName, bd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public BeanDefinition getBeanDefinition(String beanName) &#123;</span><br><span class="line">	return beanDefinitions.get(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// @Override</span><br><span class="line">public Object getBean2(String name) &#123;</span><br><span class="line">	</span><br><span class="line">	// 从单例缓存获取实例对象</span><br><span class="line">	Object object = beans.get(name);</span><br><span class="line">	// 有实例对象时返回实现对象</span><br><span class="line">	if (object != null) &#123;</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br><span class="line">	// 没有实例对象，创建实例对象</span><br><span class="line">	// 获取Bedifinition,类的定义</span><br><span class="line">	BeanDefinition beanDefinition = getBeanDefinition(name);</span><br><span class="line">	// 没有类的定义时返回实例null</span><br><span class="line">	if (beanDefinition == null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取单例多例属性，判断多例还是单例</span><br><span class="line">	String scope = beanDefinition.getScope();</span><br><span class="line">	if (&quot;singleton&quot;.equals(scope)) &#123;</span><br><span class="line">		// 单例：</span><br><span class="line">		// 一、创建实例</span><br><span class="line">		Object bean = creaBean2(name, beanDefinition);</span><br><span class="line">		// 二、加入单例缓存</span><br><span class="line">		beans.put(name, bean);</span><br><span class="line">		// 三、返回单例实例</span><br><span class="line">		return bean;</span><br><span class="line">	&#125; else if (&quot;prototype&quot;.equals(scope)) &#123;</span><br><span class="line">		// 多例：</span><br><span class="line">		// 一、创建实例</span><br><span class="line">		// 二、返回实例</span><br><span class="line">		 return creaBean2(name, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object creaBean2(String name, BeanDefinition beanDefinition) &#123;</span><br><span class="line">	// 1.创建bean的实例</span><br><span class="line">	// 1.1获取类的类型</span><br><span class="line">	String clazzName = beanDefinition.getClazzName();</span><br><span class="line">	// 1.2创建</span><br><span class="line">	Class&lt;?&gt; type = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		type = Class.forName(clazzName);</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	Object bean = ReflectUtils.createObject(type);</span><br><span class="line">	// 2.注入属性</span><br><span class="line">	List&lt;PropertyValue&gt; propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line">	for (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">		// 类属性名称</span><br><span class="line">		String name2 = propertyValue.getName();</span><br><span class="line">		// 类属性值 分两种，普通类型value和引用类型ref  propertity中的value标签中的内容</span><br><span class="line">		Object value = propertyValue.getValue();</span><br><span class="line">		</span><br><span class="line">		Object valueToUse = null;</span><br><span class="line">		// 判断普通类型or引用类型</span><br><span class="line">		if (value instanceof TypedStringValue) &#123;// 判断是否为普通类型</span><br><span class="line">			TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">			String stringValue = typedStringValue.getValue();</span><br><span class="line">			Class&lt;?&gt; targetType = typedStringValue.getTargetType();</span><br><span class="line">			</span><br><span class="line">			// 只匹配了两种Integer和String</span><br><span class="line">			if (targetType == Integer.class) &#123;</span><br><span class="line">				// 确定了value的类型为Integer，注入属性 name2:属性名称:age;valueToUse:属性值:18</span><br><span class="line">				valueToUse = Integer.parseInt(stringValue);</span><br><span class="line">			&#125; else if (targetType == String.class) &#123;</span><br><span class="line">				valueToUse = stringValue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; else if (value instanceof RuntimeBeanReference) &#123;// 判断是否为引用类型</span><br><span class="line">			RuntimeBeanReference runtimeBeanReference = (RuntimeBeanReference) value;</span><br><span class="line">			String ref = runtimeBeanReference.getRef();</span><br><span class="line">			</span><br><span class="line">			// TODO 容易引起循环依赖问题</span><br><span class="line">			// 获取引用类型的属性，并注入。获取引用类型时，需要把引用类型Course中的属性name和age先注入到Course中</span><br><span class="line">			valueToUse = getBean2(ref);</span><br><span class="line">		&#125;</span><br><span class="line">		// 设置属性</span><br><span class="line">		ReflectUtils.setProperty(bean, name2, valueToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	// 3.处理初始化方法</span><br><span class="line">	String initMethod = beanDefinition.getInitMethod();</span><br><span class="line">	if (&quot;init&quot;.equals(initMethod)) &#123;</span><br><span class="line">		ReflectUtils.invokeMethod(bean, initMethod);</span><br><span class="line">	&#125;</span><br><span class="line">	// 4.处理后置方法 aop</span><br><span class="line">	</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>核心基础</title>
    <url>/2020/01/24/Spring-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>基于XML使用、基于注解+XML混合使用、基于纯注解使用</p>
<span id="more"></span>

<h1 id="1-基于XML使用"><a href="#1-基于XML使用" class="headerlink" title="1.基于XML使用"></a>1.基于XML使用</h1><h2 id="1-IoC配置"><a href="#1-IoC配置" class="headerlink" title="1.IoC配置"></a>1.IoC配置</h2><p>配置被Spring容器管理的bean信息，默认使用无参构造方法。</p>
<p>bean标签实例化三种方式：</p>
<ol>
<li><p>无参构造（常用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id = &quot;userService&quot; class = &quot;com.xiaoruiit.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>静态工厂</p>
</li>
<li><p>实例工厂</p>
</li>
</ol>
<h2 id="2-DI配置"><a href="#2-DI配置" class="headerlink" title="2.DI配置"></a>2.DI配置</h2><p>给bean的属性赋值</p>
<ol>
<li><p>构造函数注入，<code>constructor-arg</code>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.xiaoruiit.service.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>set方法注入,<code>property</code>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 需要配置bean标签的子标签property</span><br><span class="line">- 需要配置的bean中指定setter方法。</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2-基于注解-XML混合使用"><a href="#2-基于注解-XML混合使用" class="headerlink" title="2.基于注解+XML混合使用"></a>2.基于注解+XML混合使用</h1><p>使用xml的地方：1.xml配置文件，内容包括：扫描包，配置数据源；2.加载配置文件。</p>
<p>使用注解的地方：</p>
<h3 id="IoC注解的使用方法"><a href="#IoC注解的使用方法" class="headerlink" title="IoC注解的使用方法"></a>IoC注解的使用方法</h3><ol>
<li><p>xml配置 <code>context:component-scan</code>标签  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.xiaoruiit.service&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>类上添加注解@Component @Controller @Service @Repository</p>
<p>@Component:把类交给Spring容器管理。</p>
<p>@Controller @Service @Repository:@Component的延伸，为了方便标注表现层、业务层、持久层，乱写不影响使用，影响理解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="DI的注解"><a href="#DI的注解" class="headerlink" title="DI的注解"></a>DI的注解</h3><ul>
<li><p>@Autowired  </p>
<ul>
<li>默认按类型装配（byType）  </li>
<li>spring自带的注解  </li>
<li>找不到时会报错，如果需要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)  </li>
<li>如果我们想按名称装配（byName）可以结合 @Qualifier 注解进行使用  </li>
</ul>
</li>
<li><p>@Qualifier </p>
<ul>
<li>在给字段注入时不能独立使用，必须和@Autowire 一起使用；</li>
</ul>
</li>
<li><p>@Resource  </p>
<ul>
<li>默认按名称装配（byName）  </li>
<li>属于J2EE JSR250规范的实现  ，jdk的注解</li>
<li>推荐使用@Resource注解  </li>
</ul>
</li>
<li><p>@Inject  </p>
<ul>
<li>根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；  </li>
<li>是JSR330中的规范，需要导入javax.inject.Inject  </li>
<li>可以作用在变量、setter方法、构造函数上。  </li>
</ul>
</li>
<li><p>@Value</p>
<ul>
<li><p>给基本类型和String类型注入值  </p>
</li>
<li><p>可以使用占位符获取属性文件中的值  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(“$&#123;name&#125;”)//name是properties文件中的key</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@Scope  </p>
<ul>
<li>指定 bean 的作用范围  </li>
<li>属性：  value：指定范围的值。取值：singleton(默认，单例) prototype（原型，多例） request session globalsession  </li>
</ul>
</li>
</ul>
<h1 id="3-基于纯注解使用"><a href="#3-基于纯注解使用" class="headerlink" title="3.基于纯注解使用"></a>3.基于纯注解使用</h1><p>将“基于注解+XML混合使用”中的xml部分使用注解实现。</p>
<h2 id="xml实现的部分"><a href="#xml实现的部分" class="headerlink" title="xml实现的部分"></a>xml实现的部分</h2><p>1.扫描包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启注解并扫描指定包中带有注解的类 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.xiaoruiit.service&quot;/&gt;</span><br><span class="line">&lt;context:property-placeholder src=&quot;&quot;&gt;&lt;/context:property-placeholder&gt;</span><br></pre></td></tr></table></figure>

<p>2.非自定义Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; value=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>3.加载配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(“beans.xml”);</span><br></pre></td></tr></table></figure>

<h2 id="使用注解实现"><a href="#使用注解实现" class="headerlink" title="使用注解实现"></a>使用注解实现</h2><p>1.xml扫描包</p>
<p>@Configuration 相当于xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">    //spring容器初始化时，会调用配置类的无参构造函数</span><br><span class="line">    public SpringConfiguration()&#123;</span><br><span class="line">    	System.out.println(“容器启动初始化。。。”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ComponentScan  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于context:component-scan标签</span><br><span class="line">组件扫描器，扫描@Component、@Controller、@Service、@Repository注解的类。</span><br><span class="line">该注解是编写在类上面的，一般配合@Configuration注解一起使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages=&quot;com.xiaoruiit.service&quot;)</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">    public SpringConfiguration() &#123;</span><br><span class="line">    	System.out.println(&quot;容器初始化...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // @Bean</span><br><span class="line">    // @Scope(&quot;prototype&quot;)</span><br><span class="line">    // public UserService userService() &#123;</span><br><span class="line">    // return new UserServiceImpl(1,&quot;张三&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.非自定义Bean</p>
<p>@Bean （@value）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于&lt;bean&gt;标签</span><br><span class="line">作用为：注册bean对象，主要用来配置非自定义的bean，比如DruidDataSource、SqlSessionFactory</span><br><span class="line">@Bean标注在方法上(返回某个实例的方法)</span><br><span class="line">name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。如果不指定，默认与标注的方法名相</span><br><span class="line">同。</span><br><span class="line">@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">    //spring容器初始化时，会调用配置类的无参构造函数</span><br><span class="line">    public SpringConfiguration()&#123;</span><br><span class="line">    	System.out.println(“容器启动初始化。。。”);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(“prototype”)</span><br><span class="line">    public SqlSessionFactory userService()&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory();</span><br><span class="line">        sqlSessionFactory.setxxx();</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(“prototype”)</span><br><span class="line">    public SqlSessionFactory userService()&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory();</span><br><span class="line">        sqlSessionFactory.setxxx();</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@PropertySource  </p>
<p>解决properties文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:///spring</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    /**</span><br><span class="line">    * 创建一个数据源，并存入 spring 容器中</span><br><span class="line">    * *</span><br><span class="line">    @return</span><br><span class="line">    */</span><br><span class="line">    @Bean(name = &quot;dataSource&quot;)</span><br><span class="line">    public DataSource createDataSource() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ComboPooledDataSource ds = new ComboPooledDataSource();</span><br><span class="line">            ds.setDriverClass(driver);</span><br><span class="line">            ds.setJdbcUrl(url);</span><br><span class="line">            ds.setUser(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            return ds;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.加载配置文件</p>
<p>@Import</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于spring配置文件中的&lt;import&gt;标签</span><br><span class="line">用来组合多个配置类,在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.kkb.spring&quot;)</span><br><span class="line">@Import(&#123; JdbcConfig.class &#125;)</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">	public class JdbcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建纯注解方式上下文容器  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new</span><br><span class="line">	AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br><span class="line">	UserService service = context.getBean(UserService.class);</span><br><span class="line">service.saveUser();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>核心高级</title>
    <url>/2020/01/26/Spring-%E6%A0%B8%E5%BF%83%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>AOP介绍，AOP的一些术语，AspectJ概念，SpringAOP，动态代理</p>
<span id="more"></span>

<h1 id="核心高级"><a href="#核心高级" class="headerlink" title="核心高级"></a>核心高级</h1><h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><ul>
<li>AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构。</li>
<li>AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范</li>
</ul>
<p><strong>作用：</strong>AOP采取横向抽取机制，补充了传统纵向继承体系（OOP）无法解决的重复性代码优化（性能监视、事务管理、安全检查、缓存），将业务逻辑和系统处理的代码（关闭连接、事务管理、操作日志记录）解耦。  </p>
<h3 id="AOP的一些术语"><a href="#AOP的一些术语" class="headerlink" title="AOP的一些术语"></a>AOP的一些术语</h3><ul>
<li>Target 目标对象</li>
</ul>
<ul>
<li> Joinpoint 连接点 目标类的方法</li>
</ul>
<ul>
<li>Pointcut  切入点 具体要增强的Joinpoint 方法</li>
</ul>
<ul>
<li><p>Advice 通知 对应增强的内容类，分为前置通知,后置通知,异常通知,最终通知,环绕<br>通知(切面要完成的功能)  </p>
</li>
<li><p>Aspect  切面 切入点+通知，自己来编写和配置的  </p>
</li>
<li><p>Proxy（代理）  </p>
</li>
<li><p>Weaving(织入)  把增强应用到目标对象来创建新的代理对象的过程  </p>
</li>
</ul>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>AOP的一种早期实现，比较完善，实现的功能多。</p>
<p>有自己的编译器。</p>
<p>与JAVA无缝衔接。</p>
<p>静态织入</p>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p>动态代理实现，使用了JDK动态代理和CGlib动态代理实现</p>
<h4 id="两种动态实现原理"><a href="#两种动态实现原理" class="headerlink" title="两种动态实现原理"></a>两种动态实现原理</h4><p>类加载时动态生成一个类给目标类添加功能。</p>
<h5 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h5><p>目标类必须实现一个接口</p>
<p>通过反射实现</p>
<p>比CGlib用的资源少</p>
<p>Spring先用jdk动态代理，目标类没有实现接口时使用CGlib代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 使用JDK的方式生成代理对象</span><br><span class="line">*/</span><br><span class="line">public class MyProxyUtils &#123;</span><br><span class="line">    public static UserService getProxy(final UserService service) &#123;</span><br><span class="line">        // 使用Proxy类生成代理对象</span><br><span class="line">        UserService proxy = (UserService)Proxy.newProxyInstance(service.getClass().</span><br><span class="line">        	getClassLoader(),service.getClass().getInterfaces(),new InvocationHandler() &#123;</span><br><span class="line">            // 代理对象方法一执行，invoke方法就会执行一次</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) </span><br><span class="line">            	throws Throwable &#123;</span><br><span class="line">                if(&quot;save&quot;.equals(method.getName()))&#123;</span><br><span class="line">                	System.out.println(&quot;记录日志...&quot;);</span><br><span class="line">                &#125;             </span><br><span class="line">                // 让service类的save或者update方法正常的执行下去</span><br><span class="line">                return method.invoke(service, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 返回代理对象</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CGlib动态代理"><a href="#CGlib动态代理" class="headerlink" title="CGlib动态代理"></a>CGlib动态代理</h5><p>通过继承目标类实现</p>
<p>目标类不能被 final 或static 修饰</p>
<p>单例时使用较好，因为创建一次消耗的资源较多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static UserService getProxy()&#123;</span><br><span class="line">    // 创建CGLIB核心的类</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    // 设置父类 目标类</span><br><span class="line">    enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">    // 设置回调函数</span><br><span class="line">    enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object intercept(Object obj, Method method, Object[] args,</span><br><span class="line">        MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">            if(&quot;save&quot;.equals(method.getName()))&#123;</span><br><span class="line">                // 记录日志</span><br><span class="line">                System.out.println(&quot;记录日志了...&quot;);</span><br><span class="line">            &#125; </span><br><span class="line">        	return methodProxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 生成代理对象</span><br><span class="line">    UserService proxy = (UserService) enhancer.create();</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于AspectJ的aop使用"><a href="#基于AspectJ的aop使用" class="headerlink" title="基于AspectJ的aop使用"></a>基于AspectJ的aop使用</h2><p>Spring+AspectJ整合</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 基于AspectJ的aop依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;aopalliance&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="目标类和方法"><a href="#目标类和方法" class="headerlink" title="目标类和方法"></a>目标类和方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UserService接口</span><br><span class="line">UserServiceImpl实现类</span><br></pre></td></tr></table></figure>

<h3 id="xml实现"><a href="#xml实现" class="headerlink" title="xml实现"></a>xml实现</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li><p>编写通知类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyAdvice&#123;</span><br><span class="line">	public void log()&#123;</span><br><span class="line">		System.out.println(&quot;记录日志&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置通知,交给IoC容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name = &quot;myAdvice&quot; class = &quot;com.xiaoruiit.advice.Myadvice&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置切面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;</span><br><span class="line">		&lt;!-- 对哪些切入点进行功能增强由pointcut属性指定 --&gt;</span><br><span class="line">		&lt;!-- 增强哪些功能由method属性指定，它指定的方法是advice类中的方法 --&gt;</span><br><span class="line">		&lt;!-- 什么时候织入？通过aop:before等标签来指定 --&gt;</span><br><span class="line">		&lt;aop:before method=&quot;before&quot;</span><br><span class="line">			pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;</span><br><span class="line">		&lt;aop:after method=&quot;after&quot;</span><br><span class="line">			pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;</span><br><span class="line">	&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure>

<h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><p><strong>通知类型（五种）：</strong>前置通知、后置通知、最终通知、环绕通知、异常抛出通知。  </p>
<h3 id="XML结合注解实现"><a href="#XML结合注解实现" class="headerlink" title="XML结合注解实现"></a>XML结合注解实现</h3><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1.编写切面类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component(&quot;myAspect&quot;)</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">	</span><br><span class="line">	private static final String pcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;;</span><br><span class="line">	</span><br><span class="line">	@Before(value=&quot;MyAspect.fn()&quot;)</span><br><span class="line">	public void before() &#123;</span><br><span class="line">		System.out.println(&quot;这是注解方式的前置通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@AfterReturning(pcut)</span><br><span class="line">	public void after() &#123;</span><br><span class="line">		System.out.println(&quot;这是注解方式的后置通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Pointcut(&quot;execution(* *..*.*ServiceImpl.*(..))&quot;)</span><br><span class="line">	public void fn() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开启AOP自动代理"><a href="#开启AOP自动代理" class="headerlink" title="开启AOP自动代理"></a>开启AOP自动代理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启aspectj的自动代理，用于AOP的注解方式 --&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><p>取代开启Aspect自动代理xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">@ComponentScan(basePackages=&quot;com.xiaoruiit&quot;) </span><br><span class="line">@EnableAspectJAutoProxy </span><br><span class="line">public class SpringConfiguration &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>高级特性</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>spring总结</title>
    <url>/2020/10/25/Spring%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>对spring总结</p>
<span id="more"></span>

<h1 id="spring总结"><a href="#spring总结" class="headerlink" title="spring总结"></a>spring总结</h1><p>不使用spring：编写登录功能。此功能由多个类的对象互相调用实现。一个对象调用另一个对象。Controller调用Service。不使用spring，Controller调用Service，需要先<code>UserService userService = new UserService()</code></p>
<p><strong>解决了什么</strong>：优化了new对象硬编码，类与类之间进行解耦。减小了jvm频繁new对象的开销。</p>
<p><strong>做了什么</strong>：类的实例化对象的管理。</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><p>IoC（Inversion of Control,控制翻转）：生成对象这件事交给spring。</p>
</li>
<li><p>IoC容器：</p>
<ul>
<li>D</li>
<li>存放类的实例化对象</li>
</ul>
</li>
<li><p>DI</p>
</li>
</ul>
<p><strong>如何管理类的实例化对象</strong>：</p>
<ul>
<li>单例对象，系统启动进行初始化时，将对象new出来放在IOC容器中。</li>
</ul>
<p><strong>使用</strong>：</p>
<ul>
<li>xml方式</li>
<li>注解方式<ul>
<li><p>@Autowire</p>
<p>@Resource</p>
</li>
<li><p>@Service</p>
</li>
<li><p>@Controller</p>
</li>
<li><p>@Repository</p>
</li>
<li><p>@Transaction</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码中的设计模式</title>
    <url>/2020/10/25/Spring%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>spring源码中的设计模式</p>
<span id="more"></span>

<h1 id="spring源码中的设计模式"><a href="#spring源码中的设计模式" class="headerlink" title="spring源码中的设计模式"></a>spring源码中的设计模式</h1><p>策略模式，代理模式，单例模式，模板方法模式</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><strong>策略模式</strong>：</p>
<p><strong>Spring源码中如何使用</strong>：</p>
<ul>
<li>加载xml文件。AbstractApplicationContext的refresh方法的第二步。加载xml文件，bean定义读取器BeanDefinitionReader中，资源加载器ResourceLoader、bean名称生成器（BeanNameGenerator）,使用了策略模式。ClassPathXmlApplicationContext、FileSystemXmlApplicationContext（覆盖了方法Resource getResourceByPath(String path)）是DefaultResource的子孙类，表示两种加载xml文件的策略：类路径、系统路径。</li>
<li>AOP代理。代理类AopProxy，有JdkDynamicAopProxy和CglibAopProxy两个实现类。</li>
<li>template的实现。JDBCTemplate，HibernateTemplate。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>代理模式</strong>：AOP用代理模式实现。</p>
<p><strong>目的</strong>：对业务代码做前置处理，增加日志</p>
<p><strong>Spring源码如何使用</strong>：</p>
<ul>
<li>JDK动态代理，需实现接口</li>
<li>CGLib代理，直接给字节码加代码</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式</strong>：类只有单个对象会被创建（实例化），向其他类只提供一种访问方式。可以全局访问.</p>
<p><strong>spring源码如何使用</strong>：</p>
<p>用到了双重校验锁。支持多线程，有lazy loading效果。</p>
<p>第一个<code>if (singletonObject== null)</code>，singletonObject没有被实例化时，对实例化内容加锁。避免非必要加锁。</p>
<p>第二个<code>if (singletonObject== null)</code>，第一次实例化singletonObject时，防止多个线程在synchronized处等待并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">	Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">	if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">			if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">				if (singletonFactory != null) &#123;</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					this.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><strong>模板方法</strong>：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<p><strong>spring源码如何使用</strong>：</p>
<p>AbstractApplicationContext的refresh方法定义了初始化容器的流程。只是写了一个个流程的方法。</p>
<p>1.刷新预处理，重置容器的一些信息</p>
<p>2.创建容器，加载xml信息到BeanDefinition</p>
<p>3.对IOC容器进行预处理</p>
<p>…</p>
<p>11.实例化开发者配置的非抽象非延迟加载的单例Bean。</p>
<p>12.发步相应的事件。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码总结</title>
    <url>/2020/10/25/Spring%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>spring源码总结</p>
<span id="more"></span>

<h1 id="spring源码总结"><a href="#spring源码总结" class="headerlink" title="spring源码总结"></a>spring源码总结</h1><p><strong>spring使用场景</strong>：编写登录功能。此功能由多个类的对象互相调用实现。一个对象调用另一个对象，Controller调用Service。不使用spring，Controller调用Service，调用之前需要<code>UserService userService = new UserService()</code></p>
<p><strong>spring源码做了什么</strong>：管理类的实例化对象</p>
<p><strong>如何做的</strong>：</p>
<ul>
<li><p>对不同对象的处理。</p>
<p>首先初始化的时候，即项目启动，加载所有的xml文件存为Bedifinition对象</p>
<ul>
<li>非延迟加载的单例对象，初始化的时候new出来放在IOC容器中。</li>
<li>延迟加载的单例对象，第一次调用的时候new 出来放在IOC容器中。</li>
<li>多例对象，在使用时根据Bedifinition将对象new出来，返回给调用方。</li>
</ul>
</li>
<li><p>AbstractApplicationContext定义了管理对象的流程。referesh有12个步骤.关键是第2步和第11步。</p>
<ul>
<li>第2步加载xml配置文件为Bedifinition对象<ul>
<li>创建IOC容器<code>DefaultListableBeanFactory</code></li>
<li>加载解析XML文件，存到Document中</li>
<li>读取Document，处理为BeanDefinition</li>
</ul>
</li>
<li>第11步根据Bedifinition中对Bean的定义，将bean new出来放在IOC容器中。<ul>
<li>finishBeanFactoryInitialization()</li>
<li>preInstantiateSingletons(),判断抽象、单例、懒加载，FactoryBean。</li>
<li>getBean()</li>
<li>doGetBean<ul>
<li>creatBean</li>
<li>doCreatBean<ul>
<li>creatBeanInstance()，默认使用无参构造函数生成Bean</li>
<li>放入三级缓存，用于解决循环依赖</li>
<li>populateBean()，依赖注入（DI），填充属性</li>
<li>initislizeBean()，调用初始化方法。（AOP发生在此步骤)</li>
</ul>
</li>
<li>DI</li>
<li>AOP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>spring源码关键点</strong>：</p>
<ul>
<li><p>FactoryBean与BeanFactory</p>
<p>BeanFactory，spring中的顶级接口。FactoryBean是工厂Bean。</p>
</li>
<li><p>三级缓存的理解</p>
<p>三级缓存扩展性更好。二级缓存可以解决循环依赖。但这意味着Bean在实例化之后就要完成AOP代理。而spring设计之初是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器在创建Bean的最后一步完成AOP代理。</p>
<ul>
<li><p>一级缓存 singletonObjects</p>
<p>单例bean完成三部曲之后，会添加到一级缓存中。存储的是所有创建好了的单例Bean</p>
</li>
<li><p>二级缓存 earlySingletonObjects</p>
<p>二级缓存，完成实例化，但是还未进行属性注入及初始化的对象。</p>
</li>
<li><p>三级缓存 singletonFactories</p>
<p>提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象.</p>
</li>
</ul>
</li>
<li><p>循环依赖</p>
<p>如何产生：类A中有一个属性是B，类B中有一个属性是A。初始化A和B的时候，使用构造函数初始化，new A发现需要先new B，new B 发现要先new A。产生循环依赖。构造函数：A(B b){this.b = b}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class  A&#123;</span><br><span class="line">	private B b;</span><br><span class="line">	</span><br><span class="line">	public A(B b)&#123;this.b = b;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">	private A a;</span><br><span class="line">	</span><br><span class="line">	public B(A a)&#123;this.a = a;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如何解决：DI属性注入使用set，而不是构造函数。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class  A&#123;</span><br><span class="line">	private B b;</span><br><span class="line">	</span><br><span class="line">	public A()&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public void setB()&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public B getB()&#123;</span><br><span class="line">		this.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  B&#123;</span><br><span class="line">	private A a;</span><br><span class="line">	</span><br><span class="line">	public B()&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public void setA()&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public A getA()&#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成A和B对象的流程。</p>
<ol>
<li>new A，放入缓存</li>
<li>依赖注入，set B<ol>
<li>new B，放入缓存</li>
<li>依赖注入，setA，从缓存中取出A，完成setA</li>
</ol>
</li>
<li>从缓存拿出B，完成setB</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-入门</title>
    <url>/2020/11/12/TCP-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>TCP-入门</p>
<span id="more"></span>

<h1 id="TCP-入门"><a href="#TCP-入门" class="headerlink" title="TCP-入门"></a>TCP-入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<h2 id="TCP解决了什么"><a href="#TCP解决了什么" class="headerlink" title="TCP解决了什么"></a>TCP解决了什么</h2><p>为连接到<strong>不同但互连</strong>的计算机通信网络的主计算机中的成对<strong>进程</strong>  提供<strong>可靠</strong>的<strong>通信服务</strong>。</p>
<h2 id="TCP如何解决"><a href="#TCP如何解决" class="headerlink" title="TCP如何解决"></a>TCP如何解决</h2><ol>
<li>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流</li>
<li>TCP把数据流分区成适当长度的报文段</li>
<li>TCP把结果包编序号并传给IP层</li>
<li>IP层通过网络将包传送给接收端实体的TCP层。</li>
<li>接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（<a href="https://baike.baidu.com/item/RTT">RTT</a>）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</li>
<li>接收端实体将包按照编号顺序组装起来。</li>
</ol>
<h2 id="TCP结构"><a href="#TCP结构" class="headerlink" title="TCP结构"></a>TCP结构</h2><h2 id="TCP常见知识点"><a href="#TCP常见知识点" class="headerlink" title="TCP常见知识点"></a>TCP常见知识点</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>建立连接的过程：</p>
<ol>
<li>客户端发送SYN报文给服务器端</li>
<li>服务器端接收到SYN，回应一个SYN</li>
<li>客户端接收到服务的SYN，回应一个ACK</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/STC4Lkmyvq9Zj5o.png" alt="image-20201112150119410"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>断开连接的过程：</p>
<ol>
<li>客户端发送FIN</li>
<li>接收端发送ACK</li>
<li>接收端发送FIN</li>
<li>客户端发送ACK</li>
</ol>
<h3 id="与UDP异同"><a href="#与UDP异同" class="headerlink" title="与UDP异同"></a>与UDP异同</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。</p>
<p><strong>优点：</strong>传输过程中延迟小、数据传输效率高。</p>
<p><strong>缺点：</strong>没有可靠性保证、顺序保证和流量控制字段</p>
<h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>强调传输性能而不是传输的完整性。是分发信息的一个理想协议。例如，在屏幕上报告股票市场、显示航空信息等等。如果有一个消息丢失，在几秒之后另一个新的消息就会替换它。</p>
<ol>
<li>音频</li>
<li>多媒体应用</li>
<li>网络视频会议</li>
<li>聊天：QQ</li>
</ol>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue+SpringBoot实战 打通前后端联调</title>
    <url>/2019/12/11/Vue+SpringBoot%E5%AE%9E%E6%88%98%20%E6%89%93%E9%80%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/</url>
    <content><![CDATA[<p>开发工具：HbuilderX+IDEA</p>
<span id="more"></span>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="1-创建vue项目（已安装node-js和vue的脚手架cli）"><a href="#1-创建vue项目（已安装node-js和vue的脚手架cli）" class="headerlink" title="1.创建vue项目（已安装node.js和vue的脚手架cli）"></a>1.创建vue项目（已安装node.js和vue的脚手架cli）</h2><p>在D盘新建文件夹Vue-SpringBoot <img src="https://img-blog.csdnimg.cn/20191211152847386.png" alt="新建文件夹"><br>  在此处进入命令行<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20191211153003220.png">https://img-blog.csdnimg.cn/20191211153003220.png</a><br>  输入命令<code>vue init webpack vue_springboot_demo</code>，<br>  <img src="https://img-blog.csdnimg.cn/20191211153216920.png" alt="在这里插入图片描述"><br>然后一路回车。<br><img src="https://img-blog.csdnimg.cn/20191211153241407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  等待项目构建完毕<br><img src="https://img-blog.csdnimg.cn/20191211153326363.png" alt="在这里插入图片描述">进入项目 <code>cd D:\workspace\vue_springboot_demo</code><br>加载项目所需的依赖包，输入命令<code>npm install</code><br>加载axios,输入<code>npm install --save axios</code><br><img src="https://img-blog.csdnimg.cn/20191211163214487.png" alt="在这里插入图片描述"><br>启动项目：<code>npm run dev</code><br><img src="https://img-blog.csdnimg.cn/20191211155125517.png" alt="在这里插入图片描述"><br>在浏览器输入<code>localhost:8080</code> 效果如下：<br><img src="https://img-blog.csdnimg.cn/20191211155155726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">将vue_springboot_demo拖到hbuilderX中</p>
<h2 id="2-访问后端"><a href="#2-访问后端" class="headerlink" title="2.访问后端"></a>2.访问后端</h2><p>在HelloWord.vue增加访问后端内容<br><img src="https://img-blog.csdnimg.cn/20191211170121634.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191211170242396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;p&gt;springbootdata:&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;getdata()&quot;&gt;获取数据&lt;/button&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Essential Links&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://vuejs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Core Docs</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://forum.vuejs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Forum</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://chat.vuejs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Community Chat</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://twitter.com/vuejs&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Twitter</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://vuejs-templates.github.io/webpack/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Docs for This Template</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;Ecosystem&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://router.vuejs.org/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vue-router</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://vuex.vuejs.org/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vuex</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://vue-loader.vuejs.org/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vue-loader</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://github.com/vuejs/awesome-vue&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          awesome-vue</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Welcome to Your Vue.js App&#x27;,</span><br><span class="line">      message: &#x27;1&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getdata () &#123;</span><br><span class="line">        this.$axios</span><br><span class="line">          .post(&#x27;/getdata&#x27;).then(successResponse =&gt;  &#123;</span><br><span class="line">            console.log(successResponse.data);</span><br><span class="line">					&#125;)</span><br><span class="line">          .catch(failResponse =&gt; &#123;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1, h2 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;</span><br><span class="line">  color: #42b983;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-前端相关配置"><a href="#3-前端相关配置" class="headerlink" title="3.前端相关配置"></a>3.前端相关配置</h2><h3 id="1-设置反向代理"><a href="#1-设置反向代理" class="headerlink" title="(1)设置反向代理"></a>(1)设置反向代理</h3><p>修改 <code>src\main.js</code> 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">// 设置反向代理，前端请求默认发送到 http://localhost:8443/api</span><br><span class="line">var axios = require(&#x27;axios&#x27;)</span><br><span class="line">axios.defaults.baseURL = &#x27;http://localhost:8443/api&#x27;</span><br><span class="line">// 注册axios</span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2-跨域支持"><a href="#2-跨域支持" class="headerlink" title="(2)跨域支持"></a>(2)跨域支持</h3><p>在 <code>config\index.js</code> 中，找到 proxyTable 位置，<br><img src="https://img-blog.csdnimg.cn/20191211163750706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://localhost:8443&#x27;,</span><br><span class="line">        changeOrigin: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191211164012872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">断开服务器Ctrl + C 然后Enter<br>运行服务器 npm run dev</p>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="4-创建SpringBoot项目"><a href="#4-创建SpringBoot项目" class="headerlink" title="4.创建SpringBoot项目"></a>4.创建SpringBoot项目</h2><p>创建一个springboot项目并运行起来<br><img src="https://img-blog.csdnimg.cn/20191211173248555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">第一次创建需要等待下载jar依赖<br>在<code>application.properties</code>文件中添加 <code>server.port=8443</code><br>运行项目：<br><img src="https://img-blog.csdnimg.cn/20191211175108417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">浏览器输入：<code>localhost:8443</code>,成功页面如下：<br><img src="https://img-blog.csdnimg.cn/20191211175159181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-开发后端"><a href="#5-开发后端" class="headerlink" title="5.开发后端"></a>5.开发后端</h2><p>在<code>com.xiaoruiit.springbootdemo</code>下新建包package <code>controller</code>,在包下新建类<code>TestConnectController</code>。内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class TestConnectController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;api/test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;hxr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//@CrossOrigin 后端开启跨域访问</span><br><span class="line">    @CrossOrigin</span><br><span class="line">    @PostMapping(value = &quot;/api/getdata&quot;)</span><br><span class="line">    public String getdata()&#123;</span><br><span class="line">        return &quot;hxr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器输入<code>localhost:8443/api/test</code>，可获取hxr。<br><img src="https://img-blog.csdnimg.cn/20191211182926381.png" alt="在这里插入图片描述"></p>
<h2 id="6-前后端联动效果"><a href="#6-前后端联动效果" class="headerlink" title="6.前后端联动效果"></a>6.前后端联动效果</h2><p>浏览器输入<code>localhost:8080</code>，点击<code>获取数据</code>，浏览器控制台打印出<code>hxr</code></p>
<p><img src="https://img-blog.csdnimg.cn/2019121118284076.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>前后端</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper-安装</title>
    <url>/2020/08/25/Zookeeper-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Zookeeper的安装</p>
<span id="more"></span>

<h1 id="ZooKeeper-安装"><a href="#ZooKeeper-安装" class="headerlink" title="ZooKeeper-安装"></a>ZooKeeper-安装</h1><p>官网：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p>
<p>版本：ZooKeeper3.5.6</p>
<p>支持JDK8、11、12</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RBHqshvYfZPKdwb.png" alt="image-20200825064140355"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装jdk,我已安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看JDK安装路径</span><br><span class="line">[root@localhost ~]# whereis java</span><br><span class="line">java: /usr/local/jdk1.8.0_151/bin/java</span><br></pre></td></tr></table></figure>

<p>上传解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#上传 apache-zookeeper-3.5.6-bin.tar.gz</span><br><span class="line">#打开 opt目录</span><br><span class="line">cd /opt</span><br><span class="line">#创建zooKeeper目录</span><br><span class="line">mkdir  zooKeeper</span><br><span class="line">#将zookeeper安装包移动到 /opt/zooKeeper</span><br><span class="line">mv /root/apache-zookeeper-3.5.6-bin.tar.gz /opt/zookeeper/</span><br><span class="line">#解压</span><br><span class="line">cd /opt/zookeeper/</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p>修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入到conf目录</span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line">#拷贝</span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br><span class="line">#修改zoo.cfg</span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br><span class="line">#修改存储目录：dataDir=/opt/zookeeper/zkdata</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8V5Cwm4ujRfD7Wn.png" alt="image-20200913001445650"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/FeCjhZySlDXv3Oa.png" alt="image-20200913001619835"></p>
<p>创建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开目录</span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line">#创建zooKeeper存储目录</span><br><span class="line">mkdir zkdata</span><br></pre></td></tr></table></figure>

<p>启动zookeeper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/</span><br><span class="line">#启动</span><br><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure>

<p>退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>bootshiro-学习</title>
    <url>/2020/09/27/bootshiro-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>学习搭建后端脚手架。</p>
<span id="more"></span>

<h1 id="bootshiro-学习"><a href="#bootshiro-学习" class="headerlink" title="bootshiro-学习"></a>bootshiro-学习</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>此脚手架的功能：前后端分离，后端接口开发。</p>
<ul>
<li>支持RESTful风格。</li>
<li>用户-角色-接口功能。</li>
<li>用户登录日志、操作日志</li>
<li>封装后端返回结果，code,msg+data</li>
</ul>
<p>使用的技术：</p>
<ul>
<li>springboot</li>
<li>mybatis</li>
<li>shiro 权限管理，用户-角色-接口</li>
<li>jwt token，每次访问后端使用jwt做验证</li>
<li>redis 存jwt</li>
<li>jasypt 数据库密码密文配置在yum中</li>
</ul>
<h2 id="学习流程："><a href="#学习流程：" class="headerlink" title="学习流程："></a>学习流程：</h2><ol>
<li>down</li>
<li>等待下载jar包</li>
<li>启动</li>
<li>postman测试</li>
<li>本地mysql导入usthe.sql</li>
<li>修改yum中的SQL配置和jasypt配置</li>
<li>启动</li>
<li>postman测试，导入测试数据postman_test_example.json<ol>
<li><p>注册</p>
<p>问题：bootshiro-register-no-encrpty <a href="http://localhost:8080/account/register">http://localhost:8080/account/register</a> 注册时ase秘钥为空</p>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootshiro:</span><br><span class="line">  enableEncryptPassword: false</span><br></pre></td></tr></table></figure>

<p>注册为访客角色，在数据库改为了role_admin</p>
</li>
<li><p>登录</p>
<p>bootshiro-login <a href="http://localhost:8080/account/login">http://localhost:8080/account/login</a></p>
<p>修改body中的”appId”: “tom33”,”password”: “1234”,</p>
<p>拿到jwt：eyJhbGciOiJIUzUx…</p>
</li>
<li><p>获取角色</p>
<p>bootshiro-jwt <a href="http://localhost:8080/user/role/tom33">http://localhost:8080/user/role/tom33</a></p>
<p>修改jwt，修改restful风格tom33</p>
<p>结果：拿到角色role_admin</p>
</li>
</ol>
</li>
</ol>
<p>具体内容：</p>
<ul>
<li><p>yum文件设置了开发、测试、生产三种环境</p>
</li>
<li><p>jasypt</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端脚手架</category>
      </categories>
  </entry>
  <entry>
    <title>ecxel导出</title>
    <url>/2020/03/23/ecxel%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>ecxel导出</p>
<span id="more"></span>

<h1 id="ecxel导出"><a href="#ecxel导出" class="headerlink" title="ecxel导出"></a>ecxel导出</h1><ul>
<li><p>maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.5.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>后端</p>
<ul>
<li><p>controller接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value = &quot;数据导出--待完成&quot;, notes = &quot;数据导出&quot;, httpMethod = &quot;POST&quot;)</span><br><span class="line">    @PostMapping(value = &quot;/excel/export&quot;, headers = &quot;Accept=application/octet-stream&quot;)</span><br><span class="line">    public void export(@ApiParam HttpServletResponse response,@RequestBody String matrixId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(matrixId);</span><br><span class="line">            bodyService.excelExport(response);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;批量导出失败！&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>serviceImpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 矩阵管理-数据导出</span><br><span class="line">     *</span><br><span class="line">     * @param response</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void excelExport(HttpServletResponse response) &#123;</span><br><span class="line">        // 创建excel表格数据</span><br><span class="line">        ArrayList&lt;Map&lt;String, Object&gt;&gt; rows = createExcelData();</span><br><span class="line"></span><br><span class="line">        ExcelWriter writer = ExcelUtil.getWriter(false);</span><br><span class="line">        OutputStream out = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 一次性写出内容，强制输出标题</span><br><span class="line">            writer.write(rows, true);</span><br><span class="line">            // 矩阵名称 TODO</span><br><span class="line">            String fileName = URLEncoder.encode(&quot;数据导出&quot;, &quot;UTF-8&quot;);</span><br><span class="line">            response.setContentType(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8&quot;);</span><br><span class="line">            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xls&quot;);</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            writer.flush(out, true);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">            IoUtil.close(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 创建excel表格数据 TODO 1.添加隐藏列，校验动态列 2.下拉框</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private ArrayList&lt;Map&lt;String, Object&gt;&gt; createExcelData() &#123;</span><br><span class="line"></span><br><span class="line">        // 创建excel表格数据</span><br><span class="line">        Map&lt;String, Object&gt; row = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        row.put(&quot;序号&quot;, &quot;1&quot;);</span><br><span class="line">        row.put(&quot;组织单元编码&quot;, &quot;A020&quot;);</span><br><span class="line">        row.put(&quot;组织单元&quot;, &quot;集团总部 / 人力资源部&quot;);</span><br><span class="line">        row.put(&quot;岗位编码&quot;, &quot;P001&quot;);</span><br><span class="line">        row.put(&quot;岗位名称&quot;, &quot;COE&quot;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Map&lt;String, Object&gt;&gt; rows = CollUtil.newArrayList();</span><br><span class="line">        rows.add(row);</span><br><span class="line">        return rows;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>postMan测试</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Owcn83oxq94r7YQ.png" alt="img"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>ecxel操作</category>
      </categories>
      <tags>
        <tag>ecxel操作</tag>
      </tags>
  </entry>
  <entry>
    <title>git-常见错误</title>
    <url>/2020/08/20/git-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>git-常见错误，没有使用分支的情况</p>
<span id="more"></span>

<h1 id="git-常见错误"><a href="#git-常见错误" class="headerlink" title="git-常见错误"></a>git-常见错误</h1><h2 id="git流程："><a href="#git流程：" class="headerlink" title="git流程："></a>git流程：</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IPzvlRdumkUwn23.png" alt="image-20200819205443771"></p>
<p>图片来源于网络</p>
<h2 id="正确操作："><a href="#正确操作：" class="headerlink" title="正确操作："></a>正确操作：</h2><p>​    无冲突：</p>
<p>​        pull,commit,push</p>
<p>​    有冲突：</p>
<p>​        pull失败，stash,pull,unstash,解决冲突代码,commit,push</p>
<h2 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h2><p>B提交的更改没有了，远程服务器的版本回退到了没有更改的时候。</p>
<h3 id="错误操作："><a href="#错误操作：" class="headerlink" title="错误操作："></a>错误操作：</h3><p>git仓库有a.html，b.html</p>
<p>A </p>
<p>​    12:00 commit</p>
<p>​    18:00 commit push </p>
<p>B </p>
<p>​    修改b.html</p>
<p>​    14:00 commit b.html  push</p>
<p>A 在18:00的push操作会将12：00commit的b.html提交到远程仓库，从而覆盖B在14:01push的b.html.</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>1.commit后需要push</p>
<p>2.commit后未push，第二次commit之后的push要把B的新的b.html推送到远程仓库。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>正常使用也会发生：B提交的更改没有了，远程服务器的版本回退到了没有更改的时候。</p>
<p>例如：A pull和push中间的时间，B 做了push操作。团队开发发生这种时间差push的情况很少。</p>
<h2 id="pull报443"><a href="#pull报443" class="headerlink" title="pull报443"></a>pull报443</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># git中执行下行代码，取消代理</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客百度收录</title>
    <url>/2018/04/16/hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<p>注意：提交博客域名到百度，等待的时间比较长。错误{“error”:401,”message”:”site error”}解决方法。</p>
<span id="more"></span>
<h1 id="向百度提交信息"><a href="#向百度提交信息" class="headerlink" title="向百度提交信息"></a>向百度提交信息</h1><p>1登录<a href="https://ziyuan.baidu.com/linksubmit">百度站长管理</a>，移动鼠标到网站支持，点击下边的链接提交。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1-1.png"><br>2按步骤提交网址<br>3验证。三种验证方式CNAME验证最简单。去域名管理处在网址解析添加一条记录。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1-2.png"><br>3拿到token。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1-3.png"><br>4进入根目录的配置文件，新增以下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 ## 提交最新的一个链接</span><br><span class="line">  host: www.blog.xiaoruiit.com ## 在百度站长平台中注册的域名</span><br><span class="line">  token: H4KSennR803cks3C ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>
<p>记得查看URL,如果是<a href="http://yoursite.com/child%EF%BC%8C%E4%BF%AE%E6%94%B9%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E5%9D%80%E3%80%82">http://yoursite.com/child，修改为自己的网址。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://www.blog.xiaoruiit.com</span><br></pre></td></tr></table></figure>

<p>新加deploy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  #type: git 之前的</span><br><span class="line">  bucket: blog.xiaoruiit.com</span><br><span class="line">  type: baidu_url_submitter 现在的</span><br></pre></td></tr></table></figure>
<p>需要等待很长时间，可能十几天。</p>
<p>输入命令<code>hexo g,hexo d</code>成功提示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;remain&quot;:4999993,&quot;success&quot;:1,&quot;not_same_site&quot;:[&quot;http://www.blog.xiaoruiit.com/hexo博客百度收录.html/&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>remain:剩余可提交链接数量。success：成功提交链接数量</p>
<h1 id="出现错误-“error”-401-”message”-”site-error”-："><a href="#出现错误-“error”-401-”message”-”site-error”-：" class="headerlink" title="出现错误{“error”:401,”message”:”site error”}："></a>出现错误{“error”:401,”message”:”site error”}：</h1><p>输入命令<code>hexo d</code>出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;error&quot;:401,&quot;message&quot;:&quot;site error&quot;&#125;</span><br><span class="line">INFO  Deploy done: baidu_url_submitter</span><br></pre></td></tr></table></figure>
<p>请检查配置中的域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 </span><br><span class="line">  host: blog.xiaoruiit.com #没有www的域名请不要添加www</span><br><span class="line">  token: H4KSen*****cks3C </span><br><span class="line">  path: baidu_urls.txt</span><br></pre></td></tr></table></figure>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #提交给GitHub</span><br><span class="line">  bucket: blog.xiaoruiit.com</span><br><span class="line">  #type: baidu_url_submitter #提交给baidu</span><br></pre></td></tr></table></figure>
<p> 提交到GitHub和baidu需要来回切换</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>百度收录</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo来必力评论+learncloud统计访客</title>
    <url>/2018/04/15/hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/</url>
    <content><![CDATA[<p>韩国来必力评论+learncloud统计阅读次数</p>
<span id="more"></span>
<h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><h2 id="1注册来必力"><a href="#1注册来必力" class="headerlink" title="1注册来必力"></a>1注册来必力</h2><p><a href="https://livere.com/">来必力官网</a></p>
<h2 id="2去管理页面"><a href="#2去管理页面" class="headerlink" title="2去管理页面"></a>2去管理页面</h2><p>点击右上边的小头像，点击管理页面</p>
<h2 id="3安装免费版"><a href="#3安装免费版" class="headerlink" title="3安装免费版"></a>3安装免费版</h2><p>很快，只需要点免费即可，并不会在电脑上安装东西。</p>
<h2 id="4设置网页链接"><a href="#4设置网页链接" class="headerlink" title="4设置网页链接"></a>4设置网页链接</h2><p>url:为自己的域名。名称不重要。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-1.png"></p>
<h2 id="5获取id"><a href="#5获取id" class="headerlink" title="5获取id"></a>5获取id</h2><p>一般网站中在代码中找data-uid后””中的内容<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-2.png"></p>
<h2 id="6修改主题配置文件"><a href="#6修改主题配置文件" class="headerlink" title="6修改主题配置文件"></a>6修改主题配置文件</h2><p>找到livere_uid:(可能被注释，去掉前边的#)将获取到的id粘贴到这。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-3.png"><br>成功效果图：<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-4.png"></p>
<h1 id="统计文章阅读次数"><a href="#统计文章阅读次数" class="headerlink" title="统计文章阅读次数"></a>统计文章阅读次数</h1><h2 id="1注册leancloud"><a href="#1注册leancloud" class="headerlink" title="1注册leancloud"></a>1注册leancloud</h2><p>点击<a href="https://leancloud.cn/">leancloud</a>。注册好账号。</p>
<h2 id="2创建应用"><a href="#2创建应用" class="headerlink" title="2创建应用"></a>2创建应用</h2><p><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/2-1.png"></p>
<h2 id="3创建class"><a href="#3创建class" class="headerlink" title="3创建class"></a>3创建class</h2><p>class名称为Counter，选择限制写入，点击创建。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/2-2.png"></p>
<h2 id="4获取key"><a href="#4获取key" class="headerlink" title="4获取key"></a>4获取key</h2><p>依次点击设置→应用key。找到App ID和App Key。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/2-3.png"></p>
<h2 id="5修改next主题设置"><a href="#5修改next主题设置" class="headerlink" title="5修改next主题设置"></a>5修改next主题设置</h2><p>找到next目录下的_config文件，修改enable，将刚才获取的app_id和app_key粘贴到此处对应位置。注意留下空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: S5VAuYJ1Iw******k8a4FHBc-gzGzoHsz</span><br><span class="line">  app_key: 4uuoVMQeq******7xwgWjGat</span><br></pre></td></tr></table></figure>
<p>可以了。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>评论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>jar包冲突</title>
    <url>/2020/05/18/jar%E5%8C%85%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>jar包冲突</p>
<span id="more"></span>

<h1 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>启动报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/jsontype/PolymorphicTypeValidator</span><br></pre></td></tr></table></figure>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>jar包冲突，jackjson2.9.8中没有类<code>PolymorphicTypeValidator</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TmWJLBy4GpOszFb.png" alt="image-20210518094949654"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="如何定位冲突jar与xml"><a href="#如何定位冲突jar与xml" class="headerlink" title="如何定位冲突jar与xml"></a>如何定位冲突jar与xml</h4><h5 id="定位jar"><a href="#定位jar" class="headerlink" title="定位jar"></a>定位jar</h5><ol>
<li><p>根据报错Caused by去依赖中找<code>com/fasterxml/jackson/databind/jsontype/PolymorphicTypeValidator</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/jsontype/PolymorphicTypeValidator</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ILaSpzh1YV6PtMX.png" alt="image-20210518095608269"></p>
</li>
<li><p>根据报错类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Failed to introspect Class [com.youlu.common.config.RedisConfig] from ClassLoader [sun.misc.Launcher$AppClassLoader@18b4aac2]</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Mwy1P6uj3HKrVLe.png" alt="image-20210518095808710"></p>
</li>
</ol>
<h4 id="jar定位xml"><a href="#jar定位xml" class="headerlink" title="jar定位xml"></a>jar定位xml</h4><p>命令行输入mvn命令<code>mvn dependency:tree</code>,会展示maven依赖拓扑关系，然后Ctrl+F搜索</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/cZIVQjf9UTHeA5O.png" alt="image-20210518102441361"></p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>一般保留高版本jar；也可能保留低版本jar，重新实现使用高版本的地方。</p>
<p>pom.xml去除jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;seata.vsersion&#125;&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>jar</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>jeecg按钮权限</title>
    <url>/2019/06/20/jeecg%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>jeecg按钮权限</p>
<span id="more"></span>
<h1 id="jeecg按钮权限"><a href="#jeecg按钮权限" class="headerlink" title="jeecg按钮权限"></a>jeecg按钮权限</h1><p>参考官方文档 <a href="http://idoc.jeecg.com/1275970">http://idoc.jeecg.com/1275970</a></p>
<h2 id="1-在要控制的页面按钮添加属性"><a href="#1-在要控制的页面按钮添加属性" class="headerlink" title="1.在要控制的页面按钮添加属性"></a>1.在要控制的页面按钮添加属性</h2><p><code>operationCode=&quot;test_delete&quot;</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vmZLRBwyzOji3KI.png" alt="image-20200414132620754"></p>
<h2 id="2-在菜单管理的对应页面设置页面控件权限"><a href="#2-在菜单管理的对应页面设置页面控件权限" class="headerlink" title="2.在菜单管理的对应页面设置页面控件权限"></a>2.在菜单管理的对应页面设置页面控件权限</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/CPmEGlcqKDoRUWg.png" alt="image-20200414133436351"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JpZofajOYvMuz5Q.png" alt="image-20200414133727176"></p>
<h2 id="3-确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限"><a href="#3-确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限" class="headerlink" title="3.确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限"></a>3.确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iMevSwTIn9HsQlL.png" alt="image-20200414134012108"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/lC5HgiqmozGVBkP.png" alt="image-20200414134326453"></p>
]]></content>
      <categories>
        <category>jeecg</category>
      </categories>
  </entry>
  <entry>
    <title>jeecg用代码生成器添加一个功能</title>
    <url>/2019/06/18/jeecg%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>jeecg用代码生成器添加一个功能</p>
<span id="more"></span>
<h1 id="jeecg用代码生成器添加一个功能"><a href="#jeecg用代码生成器添加一个功能" class="headerlink" title="jeecg用代码生成器添加一个功能"></a>jeecg用代码生成器添加一个功能</h1><h2 id="1-创建表单"><a href="#1-创建表单" class="headerlink" title="1.创建表单"></a>1.创建表单</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/1wBSdpvFsI82mf6.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/74zetYh3S8OEFUn.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/QdavBg2GThiuVAy.png" alt="img"></p>
<h2 id="2-同步表单信息到数据库"><a href="#2-同步表单信息到数据库" class="headerlink" title="2.同步表单信息到数据库"></a>2.同步表单信息到数据库</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/bSvdYFm2kyDciQq.png" alt="img"></p>
<p><strong>同步效果：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/u93mNwTWA6SYbnc.png" alt="img"></p>
<h2 id="3-测试功能"><a href="#3-测试功能" class="headerlink" title="3.测试功能"></a>3.测试功能</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hyaH7ueB5NzToCq.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WLjZw2g1HFeiGOm.png" alt="image-20200413180405257"></p>
<h2 id="4-生成后台功能代码"><a href="#4-生成后台功能代码" class="headerlink" title="4.生成后台功能代码"></a>4.生成后台功能代码</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ozw1d9yJCkDpLxG.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ehqwInbLcOlRDxS.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NfhaIeHlA84oREG.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Mk9BVGpmzaSsbKf.png" alt="img"></p>
<h2 id="5-刷新项目，并重启启动"><a href="#5-刷新项目，并重启启动" class="headerlink" title="5.刷新项目，并重启启动"></a>5.刷新项目，并重启启动</h2>]]></content>
      <categories>
        <category>jeecg</category>
      </categories>
  </entry>
  <entry>
    <title>jspxcms添加一个功能</title>
    <url>/2019/08/06/jspxcms%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p> jspxcms二次开发配置文件的介绍</p>
<span id="more"></span>
<h1 id="jspxcms添加一个功能"><a href="#jspxcms添加一个功能" class="headerlink" title="jspxcms添加一个功能"></a>jspxcms添加一个功能</h1><p>向菜单后台管理-功能插件下，添加“领导管理”（不修改配置文件，使用默认前台模板添加功能）</p>
<h2 id="（1）添加菜单"><a href="#（1）添加菜单" class="headerlink" title="（1）添加菜单"></a>（1）添加菜单</h2><p><code>\src\main\resources\conf\plugin\plug</code>下的<code>backend.xml</code>,<code>conf.properties</code>,<code>context.xml</code>不动，<code>menu.yml</code>下添加要增加的菜单名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">600-1001:</span><br><span class="line">  name: lead.management</span><br><span class="line">  url: plug/lead/list.do</span><br><span class="line">  perms: plug:lead:list</span><br><span class="line">  ops:</span><br><span class="line">    - create@plug:lead:create</span><br><span class="line">    - copy@plug:lead:copy</span><br><span class="line">    - edit@plug:lead:edit</span><br><span class="line">    - save@plug:lead:save</span><br><span class="line">    - update@plug:lead:update</span><br><span class="line">    - delete@plug:lead:delete</span><br></pre></td></tr></table></figure>



<h2 id="（2）添加国际化代码"><a href="#（2）添加国际化代码" class="headerlink" title="（2）添加国际化代码"></a>（2）添加国际化代码</h2><p><code>src\main\resources\messages\plugin\plug\</code>plug.properties中仿照原例子添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lead.management=领导管理</span><br><span class="line">opr.lead.add=领导新增</span><br><span class="line">opr.lead.edit=领导修改</span><br><span class="line">opr.lead.delete=领导删除</span><br><span class="line">lead.name=姓名</span><br><span class="line">lead.partyPosts=党内职务</span><br><span class="line">lead.administrativePost=行政职务</span><br></pre></td></tr></table></figure>



<h2 id="（3）添加功能代码"><a href="#（3）添加功能代码" class="headerlink" title="（3）添加功能代码"></a>（3）添加功能代码</h2><p><code>仿照\src\main\java\com\jspxcms\plug</code>下内容并添加新的domain、repository、service、web（主要是将resume修改为lead）</p>
<h2 id="4-创建数据库"><a href="#4-创建数据库" class="headerlink" title="(4)创建数据库"></a>(4)创建数据库</h2><p>在数据库中执行下列语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table introduction_lead</span><br><span class="line">(</span><br><span class="line">   j_lead_id          		int not null,</span><br><span class="line">   f_site_id            	int not null,</span><br><span class="line">   j_name               	varchar(100) not null comment &#x27;领导姓名&#x27;,</span><br><span class="line">   j_party_posts            varchar(100)  comment &#x27;党内职务&#x27;,</span><br><span class="line">   j_administrative_post    varchar(100)  comment &#x27;行政职务&#x27;,</span><br><span class="line">   primary key (j_lead_id)</span><br><span class="line">)</span><br><span class="line">engine = innodb;</span><br><span class="line">alter table introduction_lead comment &#x27;领导信息表&#x27;;</span><br><span class="line">alter table introduction_lead add constraint `fk_introduction_lead_site` foreign key (`f_site_id`)</span><br><span class="line">      references cms_site(`f_site_id`) on delete restrict on update restrict;</span><br></pre></td></tr></table></figure>

<h2 id="（5）添加页面"><a href="#（5）添加页面" class="headerlink" title="（5）添加页面"></a>（5）添加页面</h2><p>在\src\main\webapp\WEB-INF\views\plug下新建文件夹lead，复制resume的文件到lead中，修改文件（主要是将resume修改为lead，还需要根据实体类lead字段不同修改）</p>
<h2 id="（6）效果"><a href="#（6）效果" class="headerlink" title="（6）效果"></a>（6）效果</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OgXeI8TxZMfSsWd.png" alt="image-20200428151003349"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XpYvcAoUy9Qbl3i.png" alt="image-20200428151037539"></p>
]]></content>
      <categories>
        <category>jspxcms</category>
      </categories>
  </entry>
  <entry>
    <title>jspxcms二次开发配置文件</title>
    <url>/2019/08/05/jspxcms%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%9C%89%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p> jspxcms二次开发配置文件的介绍</p>
<span id="more"></span>
<h1 id="jspxcms添加功能有关配置文件介绍"><a href="#jspxcms添加功能有关配置文件介绍" class="headerlink" title="jspxcms添加功能有关配置文件介绍"></a>jspxcms添加功能有关配置文件介绍</h1><p>配置文件位置：src\main\resources\conf\plugin\plug\</p>
<h2 id="1-context-xml"><a href="#1-context-xml" class="headerlink" title="1.context.xml"></a>1.context.xml</h2><p>配置实体Entity、数据库操作类Dao、service、前台controller的路径</p>
<p><code>&lt;bean class=&quot;com.jspxcms.plug.ContextConfig&quot; /&gt;</code></p>
<p>配置模板类<!--FreeMarker标签类--></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;IntroductionLeadList&quot; class=&quot;com.jspxcms.plug.web.directive.LeadListDirective&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>​    向\src\main\java\com\jspxcms\plug下添加功能的代码</p>
<h2 id="2-backend-xml"><a href="#2-backend-xml" class="headerlink" title="2.backend.xml"></a>2.backend.xml</h2><p>配置后台controller路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.jspxcms.plug.web.back&quot; use-default-filters=&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-conf-properties"><a href="#3-conf-properties" class="headerlink" title="3.conf.properties"></a>3.conf.properties</h2><p>前台模板Freemarker标签、国际化文件目录？？</p>
<p>前端页面标签英文对应中文，包括菜单、类的属性、增删改，几乎页面的所有中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">messageSource.basenames.plug=classpath:messages/plugin/plug/plug</span><br></pre></td></tr></table></figure>

<p>？？？路径文件内容为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">messageSource.basenames.plugfore=classpath:messages/plugin/plugfore/plugfore</span><br></pre></td></tr></table></figure>

<p>和模板Freemarker有关，具体？？？</p>
<p>ResumeList 在模板中调用标签的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freemarkerVariables.ResumeList=PlugLeadList</span><br></pre></td></tr></table></figure>

<p>模板中的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@ResumeList; result]</span><br><span class="line">[#list result as bean]</span><br><span class="line">    $&#123;bean.name&#125;, $&#123;bean.mobile&#125;</span><br><span class="line">[/#list]</span><br><span class="line">[/@ResumeList]</span><br></pre></td></tr></table></figure>

<h2 id="4-menu-yml"><a href="#4-menu-yml" class="headerlink" title="4.menu.yml"></a>4.menu.yml</h2><p><a href="http://www.jspxcms.com/documentation/366.html">http://www.jspxcms.com/documentation/366.html</a></p>
<p>配置后台的左侧菜单，使其显示</p>
<p>600：一级菜单 1000：二级菜单代表的数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">600-1000:</span><br></pre></td></tr></table></figure>

<p><code>perms: plug:resume:list</code> 菜单权限值。这个权限值必须要对应url的Controller方法的<code>@RequiresPermissions(&quot;plug:resume:list&quot;)</code>一致。</p>
]]></content>
      <categories>
        <category>jspxcms</category>
      </categories>
  </entry>
  <entry>
    <title>kettle-入门</title>
    <url>/2021/06/10/kettle-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>kettle-入门</p>
<span id="more"></span>

<h2 id="kettle-入门"><a href="#kettle-入门" class="headerlink" title="kettle-入门"></a>kettle-入门</h2><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>抽取、转换、装载。将一种数据格式转换为另一种数据格式。例如：旧系统导出的.json人员数据通过转换导入到新系统数据库中。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>spoon图形化工具：写出抽取、转换、装载的文件。</p>
<p>KettleOnline在线调度系统（java项目）：定时执行文件。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>视频：<a href="https://www.bilibili.com/video/BV1jE411B7J8?from=search&amp;seid=8259670291223952308">https://www.bilibili.com/video/BV1jE411B7J8?from=search&amp;seid=8259670291223952308</a></p>
<p>官网：<a href="https://www.kettle.net.cn/2401.html">https://www.kettle.net.cn/2401.html</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>版本：8.2</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要安装1.8jdk环境。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>双击spoon.bat</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>json → mysql数据库</p>
<ol>
<li><p>新建转换</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/E2S3dFlGDOB6mrh.png" alt="image-20210221160938883"></p>
</li>
<li><p>提取json数据</p>
<ol>
<li><p>新建输入组件 json</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/u1xZPOS9fTvnlMF.png" alt="image-20210221161047332"></p>
</li>
<li><p>选择文件</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/PxNCAbX4RkKqyD7.png" alt="image-20210221161240144"></p>
</li>
<li><p>提取字段</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Vnxykg5BXmZFMCT.png" alt="image-20210221161448619"></p>
</li>
<li><p>预览</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NLoUtzjWu5eglmc.png" alt="image-20210221161627613"></p>
</li>
</ol>
</li>
<li><p>将json数据插入mysql数据库</p>
<ol>
<li><p>mysql中新建表</p>
</li>
<li><p>新建表输出组件</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/nb2cYsrRD8LpxQW.png" alt="image-20210221161939392"></p>
</li>
<li><p>连线</p>
<p>点击+shift→shift+移动鼠标到另一个组件。选择主输出步骤</p>
</li>
<li><p>新建mysql连接</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/CcWYLox28zhVjPi.png" alt="image-20210221162245428"></p>
</li>
<li><p>选择连接和表</p>
<p>双击组件。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/w1GENrO4Udnfb57.png" alt="image-20210221162333583"></p>
</li>
<li><p>将json的字段与表中字段对应起来</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Rz2ICxavVdqL6jS.png" alt="image-20210221162425679"></p>
</li>
<li><p>启动</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Yyd4S1FNa5Aifj7.png" alt="image-20210221162511493"></p>
</li>
</ol>
</li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="转换文件中不要有中文"><a href="#转换文件中不要有中文" class="headerlink" title="转换文件中不要有中文"></a>转换文件中不要有中文</h3><p>步骤命名</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mhMzZa7LK58Yb3A.png" alt="image-20210220115924186"></p>
<p>文件的路径</p>
<p>（D:\Users\Administrator\Desktop\测试\4.json）</p>
<p>数据库连接命名</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hnC83HB2SlOQbm9.png" alt="image-20210220120012726"></p>
<h3 id="jsonpath读取json数据"><a href="#jsonpath读取json数据" class="headerlink" title="jsonpath读取json数据"></a>jsonpath读取json数据</h3><p>json中的key中含有jsonpath语法<code>.</code>时读取该key的方法。key:<code>parent_id.department_code</code></p>
<p>数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;data&quot;: &#123;</span><br><span class="line">            &quot;query_data&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;start_date&quot;: &quot;2000-01-01&quot;,</span><br><span class="line">                    &quot;parent_id.department_code&quot;: &quot;D0115&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;start_date&quot;: &quot;2000-01-01&quot;,</span><br><span class="line">                    &quot;parent_id.department_code&quot;: &quot;D0136&quot;</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure>

<p>读取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.data.query_data..[&#x27;parent_id.department_code&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="数据库连接问题"><a href="#数据库连接问题" class="headerlink" title="数据库连接问题"></a>数据库连接问题</h3><h4 id="添加对应数据库的jar包"><a href="#添加对应数据库的jar包" class="headerlink" title="添加对应数据库的jar包"></a>添加对应数据库的jar包</h4><p>根据mysql数据库版本8.0.18，去mysql官网下载 <code>mysql-connector-java-8.0.18.zip</code> ，将其中的<code>mysql-connector-java-8.0.18.jar</code>添加jar包到lib目录下.</p>
<p>将mysql.jar放入到lib下。</p>
<h4 id="mysql数据库时区"><a href="#mysql数据库时区" class="headerlink" title="mysql数据库时区"></a>mysql数据库时区</h4><ul>
<li><p>报错</p>
<p>The server time zone value ‘�й���׼ʱ��’ is unrecognized</p>
</li>
<li><p>解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%time_zone%&#x27;;</span><br><span class="line">set global time_zone=&#x27;+8:00&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>kettle</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>kettle</tag>
      </tags>
  </entry>
  <entry>
    <title>localStorage-内容消失</title>
    <url>/2020/08/07/localStorage-%E5%86%85%E5%AE%B9%E6%B6%88%E5%A4%B1/</url>
    <content><![CDATA[<p>localStorage-内容消失</p>
<span id="more"></span>

<h1 id="localStorage-内容消失"><a href="#localStorage-内容消失" class="headerlink" title="localStorage-内容消失"></a>localStorage-内容消失</h1><p>使用HbuilderX开发前端项目</p>
<p>​    前端项目跳转路径写为<code>localhost</code>，存储localStorage后，下一个页面取不到localStorage.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var baseurl = &quot;http://localhost:8849/&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//login.js中</span><br><span class="line">localStorage.setItem(key, value);</span><br><span class="line"></span><br><span class="line">// user.js中</span><br><span class="line">localStorage.getItem(key);// 取不到</span><br></pre></td></tr></table></figure>





<p>​    前端项目跳转路径写为127.0.0.1,存储localStorage后，项目运行正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var baseurl = &quot;http://127.0.0.1:8849/&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//login.js中</span><br><span class="line">localStorage.setItem(key, value);</span><br><span class="line"></span><br><span class="line">// user.js中</span><br><span class="line">localStorage.getItem(key);// 可以取到</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>localStorage</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-入门实践</title>
    <url>/2020/08/20/nginx-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>入门实践</p>
<span id="more"></span>

<p>window环境nginx部署项目。</p>
<h1 id="nginx-入门实践"><a href="#nginx-入门实践" class="headerlink" title="nginx-入门实践"></a>nginx-入门实践</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oMKEpsxDd8q4zg7.png" alt="image-20200823214440256"></p>
<h2 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h2><p>一般80端口被占用，我改为了8082端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8082;# 80 改为了 8082</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">		# 省略...</span><br></pre></td></tr></table></figure>



<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>管理员身份运行<code>nginx.exe</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器输入<code>localhost:8082</code></p>
<h2 id="停止nginx"><a href="#停止nginx" class="headerlink" title="停止nginx"></a>停止nginx</h2><p>通过端口号查找进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\nginx-1.10.3&gt;netstat -aon|findstr &quot;8080&quot;</span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       24968</span><br></pre></td></tr></table></figure>

<p>杀进程失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\nginx-1.10.3&gt;taskkill -f -pid 24968</span><br><span class="line">错误: 无法终止 PID 为 24968 的进程。</span><br><span class="line">原因: 拒绝访问。</span><br></pre></td></tr></table></figure>

<p>解决：任务管理器手动结束进程</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4LfiVa8pSGuZjA7.png" alt="image-20200823213505090"></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>将静态目录放到<code>nginx/html</code>下，不包含项目目录时，访问时没有项目目录。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/d4SIRY9X86gAPrN.png" alt="image-20200823214145458"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ImWHST3pk1gfr8u.png" alt="image-20200823214213072"></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-问题</title>
    <url>/2020/10/19/nginx-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>nginx-问题</p>
<span id="more"></span>

<h1 id="nginx-问题"><a href="#nginx-问题" class="headerlink" title="nginx-问题"></a>nginx-问题</h1><p><strong>访问报错：</strong></p>
<p>404 Not Found</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vfmhaGjUpRSbWEu.png" alt="image-20201019142343627"></p>
<p>日志文件nginx.1.10.3/logs/error.log信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020/10/19 14:05:51 [crit] 21512#26196: *3 CreateFile() &quot;D:	estweb/index.html&quot; failed (123: The filename, directory name, or volume label syntax is incorrect), client: 127.0.0.1, server: 127.0.0.1, request: &quot;GET /index.html HTTP/1.1&quot;, host: &quot;127.0.0.1:8850&quot;</span><br></pre></td></tr></table></figure>

<p><strong>原因:</strong></p>
<p>配置文件<code>nginx.conf</code>属性<code>location</code>中D:\test_web 路径含有\t，被解析为<code>D:    estweb/index.html</code></p>
<p>原配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            root   D:\test_web;</span><br><span class="line">            index  index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决：</strong></p>
<p>​    修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            root   D:/test_web;</span><br><span class="line">            index  index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/PCcrRSkYNgaXl4I.png" alt="image-20201019141335011"></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-jwt</title>
    <url>/2020/09/18/shiro-jwt/</url>
    <content><![CDATA[<p>学习官网10分钟教程</p>
<span id="more"></span>

<h1 id="shiro-jwt"><a href="#shiro-jwt" class="headerlink" title="shiro-jwt"></a>shiro-jwt</h1><p>shiro：Java安全框架,执行身份验证、授权、密码和会话管理。</p>
<p>jwt：客户端与服务端之间验证的一种技术，具体说就是服务器端对每次请求的来源认证。</p>
<h2 id="shiro的三个核心组件"><a href="#shiro的三个核心组件" class="headerlink" title="shiro的三个核心组件"></a>shiro的三个核心组件</h2><p>subject：当前操作用户，也可以是第三方进程、后台帐户。</p>
<p>securityManager：</p>
<p>Realm:提供用户及其权限信息</p>
<h2 id="jwt构成"><a href="#jwt构成" class="headerlink" title="jwt构成"></a>jwt构成</h2><p>header：签名类型和签名算法</p>
<p>payload：存储数据</p>
<p>signature：使用秘钥和算法对header和payload签名。</p>
<h2 id="shiro与jwt整合"><a href="#shiro与jwt整合" class="headerlink" title="shiro与jwt整合"></a>shiro与jwt整合</h2><ol>
<li>编写jwtRealm</li>
<li>将jwtRealm配置到securiManager中</li>
<li>shiro的过滤器处判断  登录请求or jwt请求。</li>
<li>subject.login验证失败后，jwt过期处理。</li>
</ol>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-web</title>
    <url>/2020/09/26/shiro-web/</url>
    <content><![CDATA[<p>servlet+jsp+shiro</p>
<span id="more"></span>

<h1 id="shiro-web"><a href="#shiro-web" class="headerlink" title="shiro-web"></a>shiro-web</h1><ol>
<li><p>新建模块</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/reVCtPg3pqIbXBQ.png" alt="image-20200926131453085"></p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-learn&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;chapter4-web&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.23&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;chapter4-web&lt;/finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;8.1.8.v20121106&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;webAppConfig&gt;</span><br><span class="line">                        &lt;contextPath&gt;/$&#123;project.build.finalName&#125;&lt;/contextPath&gt;</span><br><span class="line">                    &lt;/webAppConfig&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;path&gt;/$&#123;project.build.finalName&#125;&lt;/path&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app</span><br><span class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">        version=&quot;3.0&quot;</span><br><span class="line">        metadata-complete=&quot;false&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--- shiro 1.2 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt;&lt;!-- 默认先从/WEB-INF/shiro.ini，如果没有找classpath:shiro.ini --&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:shiro-web.ini&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--&lt;error-page&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;error-code&gt;401&lt;/error-code&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;location&gt;/WEB-INF/jsp/unauthorized.jsp&lt;/location&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/error-page&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置web环境</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Jqu1VckA3a9NGdI.png" alt="image-20200926193310648"></p>
</li>
<li><p>配置shiro-web.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">#默认是/login.jsp，配置访问servleturl</span><br><span class="line">authc.loginUrl=/login</span><br><span class="line">roles.unauthorizedUrl=/unauthorized</span><br><span class="line">perms.unauthorizedUrl=/unauthorized</span><br><span class="line"></span><br><span class="line">logout.redirectUrl=/login</span><br><span class="line"></span><br><span class="line">[users]</span><br><span class="line">zhang=123,admin</span><br><span class="line">wang=123</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line">admin=user:*,menu:*</span><br><span class="line"></span><br><span class="line">[urls]</span><br><span class="line">/logout2=logout</span><br><span class="line">/login=anon</span><br><span class="line">/logout=anon</span><br><span class="line">/unauthorized=anon</span><br><span class="line">/static/**=anon</span><br><span class="line"># 需要认证通过</span><br><span class="line">/authenticated=authc</span><br><span class="line"># 需要认证通过，并拥有admin角色</span><br><span class="line">/role=authc,roles[admin]</span><br><span class="line"># 需要认证通过，并拥有user下的create权限</span><br><span class="line">/permission=authc,perms[&quot;user:create&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编写Servlet</p>
<p>LoginServlet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.userServlet;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationException;</span><br><span class="line">import org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line">import org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname LoginServlet</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@WebServlet(name = &quot;loginServelt&quot;, urlPatterns = &quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        String error = null;</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">        try &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; catch (UnknownAccountException e) &#123;</span><br><span class="line">            error = &quot;用户名/密码错误&quot;;</span><br><span class="line">        &#125; catch (IncorrectCredentialsException e) &#123;</span><br><span class="line">            error = &quot;用户名/密码错误&quot;;</span><br><span class="line">        &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">            //其他错误，比如锁定，如果想单独处理请单独catch处理</span><br><span class="line">            error = &quot;其他错误：&quot; + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        if (error != null) &#123;//出错了，返回登录页面</span><br><span class="line">            req.setAttribute(&quot;error&quot;, error);</span><br><span class="line">            req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(req, resp);</span><br><span class="line">        &#125; else &#123;//登录成功</span><br><span class="line">            req.getRequestDispatcher(&quot;/WEB-INF/jsp/loginSuccess.jsp&quot;).forward(req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogoutServlet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.userServlet;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname LogoutServlet</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@WebServlet(name = &quot;logoutServlet&quot;, urlPatterns = &quot;/logout&quot;)</span><br><span class="line">public class LogoutServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        SecurityUtils.getSubject().logout();</span><br><span class="line">        req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写jsp</p>
<p>login.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;.error&#123;color:red;&#125;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;error&quot;&gt;$&#123;error&#125;&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>loginSuccess.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">欢迎$&#123;subject.principal&#125;登录成功！&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;&gt;退出&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>index.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;&gt;登录&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/authenticated&quot;&gt;已身份认证&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/role&quot;&gt;角色授权&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/permission&quot;&gt;权限授权&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<p>先配置maven环境</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wBZO9epVWkToRul.png" alt="image-20200926131907024"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/coKNq8WB1MXtJF3.png" alt="image-20200926131944076"></p>
</li>
<li><p>测试</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/C8m7XBGzJc1s2HK.png" alt="image-20200926131739585"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RfMCa16ySGKTrzI.png" alt="image-20200926131755401"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-入门</title>
    <url>/2020/09/18/shiro-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>学习官网10分钟教程</p>
<span id="more"></span>

<h1 id="shiro-入门"><a href="#shiro-入门" class="headerlink" title="shiro-入门"></a>shiro-入门</h1><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p><a href="http://shiro.apache.org/10-minute-tutorial.html">官网地址</a></p>
<p>用途：solution to authentication, authorization, cryptography, and session management.<a href="http://shiro.apache.org/features.html">更详细</a></p>
<p>此教程：了解shiro的API</p>
<h2 id="practice"><a href="#practice" class="headerlink" title="practice:"></a>practice:</h2><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><ol>
<li><p>require: JDK 1.8+ and Maven 3.0.3+</p>
</li>
<li><p><a href="http://shiro.apache.org/download.html">download</a></p>
<p>版本1.6.0</p>
</li>
<li><p>unzip 解压</p>
</li>
<li><p>cmd下进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">cd shiro-learn\shiro-root-1.6.0\samples\quickstart</span><br></pre></td></tr></table></figure></li>
<li><p>maven编译并启动Quickstart.java 需等待下载jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile exec:java</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/EfF3iMILywYzqko.png" alt="image-20200918184659372"></p>
</li>
</ol>
<h3 id="learn-Quickstart-java"><a href="#learn-Quickstart-java" class="headerlink" title="learn Quickstart.java"></a>learn Quickstart.java</h3><p>获取当前用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">log.info(&quot;currentUser: &quot; + currentUser);</span><br></pre></td></tr></table></figure>



<p>设置当前用户的session</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Session session = currentUser.getSession();</span><br><span class="line">session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; );</span><br></pre></td></tr></table></figure>

<p>认证用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果没被认证过。（可能认证过并且记录以后不需要认证。）</span><br><span class="line">if ( !currentUser.isAuthenticated() ) &#123;</span><br><span class="line">    //collect user principals and credentials in a gui specific manner</span><br><span class="line">    //such as username/password html form, X509 certificate, OpenID, etc.</span><br><span class="line">    //We&#x27;ll use the username/password example here since it is the most common.</span><br><span class="line">    //(do you know what movie this is from? ;)</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">    //this is all you have to do to support &#x27;remember me&#x27; (no config - built in!):</span><br><span class="line">    token.setRememberMe(true);</span><br><span class="line">    // 认证从登录框输入的token用户是否存在于currentUser中。</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获不同的异常，对应认证不通过的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    currentUser.login( token );</span><br><span class="line">    //if no exception, that&#x27;s it, we&#x27;re done!</span><br><span class="line">&#125; catch ( UnknownAccountException uae ) &#123;</span><br><span class="line">	// 无此账号</span><br><span class="line">    //username wasn&#x27;t in the system, show them an error message?</span><br><span class="line">&#125; catch ( IncorrectCredentialsException ice ) &#123;</span><br><span class="line">	// 密码错误</span><br><span class="line">    //password didn&#x27;t match, try again?</span><br><span class="line">&#125; catch ( LockedAccountException lae ) &#123;</span><br><span class="line">	//账号被锁定。</span><br><span class="line">    //account for that username is locked - can&#x27;t login.  Show them a message?</span><br><span class="line">&#125;</span><br><span class="line">    ... more types exceptions to check if you want ...</span><br><span class="line">&#125; catch ( AuthenticationException ae ) &#123;</span><br><span class="line">    //unexpected condition - error?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录成功，打印用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info( &quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot; );</span><br></pre></td></tr></table></figure>

<p>判断用户是否拥有某个角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( currentUser.hasRole( &quot;schwartz&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;May the Schwartz be with you!&quot; );</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info( &quot;Hello, mere mortal.&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断用户是否拥有某个权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( currentUser.isPermitted( &quot;lightsaber:weild&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ( currentUser.isPermitted( &quot;winnebago:drive:eagle5&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;You are permitted to &#x27;drive&#x27; the &#x27;winnebago&#x27; with license plate (id) &#x27;eagle5&#x27;.  &quot; +</span><br><span class="line">                &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登出，清理session</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentUser.logout(); </span><br></pre></td></tr></table></figure>



<h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing,</span><br><span class="line"> * software distributed under the License is distributed on an</span><br><span class="line"> * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="line"> * KIND, either express or implied.  See the License for the</span><br><span class="line"> * specific language governing permissions and limitations</span><br><span class="line"> * under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Simple Quickstart application showing how to use Shiro&#x27;s API.</span><br><span class="line"> *</span><br><span class="line"> * @since 0.9 RC2</span><br><span class="line"> */</span><br><span class="line">public class Quickstart &#123;</span><br><span class="line"></span><br><span class="line">    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // The easiest way to create a Shiro SecurityManager with configured</span><br><span class="line">        // realms, users, roles and permissions is to use the simple INI config.</span><br><span class="line">        // We&#x27;ll do that by using a factory that can ingest a .ini file and</span><br><span class="line">        // return a SecurityManager instance:</span><br><span class="line"></span><br><span class="line">        // Use the shiro.ini file at the root of the classpath</span><br><span class="line">        // (file: and url: prefixes load from files and urls respectively):</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">        // for this simple example quickstart, make the SecurityManager</span><br><span class="line">        // accessible as a JVM singleton.  Most applications wouldn&#x27;t do this</span><br><span class="line">        // and instead rely on their container configuration or web.xml for</span><br><span class="line">        // webapps.  That is outside the scope of this simple quickstart, so</span><br><span class="line">        // we&#x27;ll just do the bare minimum so you can continue to get a feel</span><br><span class="line">        // for things.</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        // Now that a simple Shiro environment is set up, let&#x27;s see what you can do:</span><br><span class="line"></span><br><span class="line">        // get the currently executing user:</span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        // Do some stuff with a Session (no need for a web or EJB container!!!)</span><br><span class="line">        Session session = currentUser.getSession();</span><br><span class="line">        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);</span><br><span class="line">        String value = (String) session.getAttribute(&quot;someKey&quot;);</span><br><span class="line">        if (value.equals(&quot;aValue&quot;)) &#123;</span><br><span class="line">            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // let&#x27;s login the current user so we can check against roles and permissions:</span><br><span class="line">        if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">            token.setRememberMe(true);</span><br><span class="line">            try &#123;</span><br><span class="line">                currentUser.login(token);</span><br><span class="line">            &#125; catch (UnknownAccountException uae) &#123;</span><br><span class="line">                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());</span><br><span class="line">            &#125; catch (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);</span><br><span class="line">            &#125; catch (LockedAccountException lae) &#123;</span><br><span class="line">                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +</span><br><span class="line">                        &quot;Please contact your administrator to unlock it.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // ... catch more exceptions here (maybe custom ones specific to your application?</span><br><span class="line">            catch (AuthenticationException ae) &#123;</span><br><span class="line">                //unexpected condition?  error?</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //say who they are:</span><br><span class="line">        //print their identifying principal (in this case, a username):</span><br><span class="line">        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        //test a role:</span><br><span class="line">        if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;</span><br><span class="line">            log.info(&quot;May the Schwartz be with you!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Hello, mere mortal.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //test a typed permission (not instance-level)</span><br><span class="line">        if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;</span><br><span class="line">            log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //a (very powerful) Instance Level permission:</span><br><span class="line">        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;</span><br><span class="line">            log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot; +</span><br><span class="line">                    &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //all done - log out!</span><br><span class="line">        currentUser.logout();</span><br><span class="line"></span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>classparh:shiro.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"># or more contributor license agreements.  See the NOTICE file</span><br><span class="line"># distributed with this work for additional information</span><br><span class="line"># regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"># to you under the Apache License, Version 2.0 (the</span><br><span class="line"># &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"># with the License.  You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing,</span><br><span class="line"># software distributed under the License is distributed on an</span><br><span class="line"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="line"># KIND, either express or implied.  See the License for the</span><br><span class="line"># specific language governing permissions and limitations</span><br><span class="line"># under the License.</span><br><span class="line">#</span><br><span class="line"># =============================================================================</span><br><span class="line"># Quickstart INI Realm configuration</span><br><span class="line">#</span><br><span class="line"># For those that might not understand the references in this file, the</span><br><span class="line"># definitions are all based on the classic Mel Brooks&#x27; film &quot;Spaceballs&quot;. ;)</span><br><span class="line"># =============================================================================</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Users and their assigned roles</span><br><span class="line">#</span><br><span class="line"># Each line conforms to the format defined in the</span><br><span class="line"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[users]</span><br><span class="line"># user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; role</span><br><span class="line">root = secret, admin</span><br><span class="line"># user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; role</span><br><span class="line">guest = guest, guest</span><br><span class="line"># user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on</span><br><span class="line"># my luggage!!!&quot; ;)), and role &#x27;president&#x27;</span><br><span class="line">presidentskroob = 12345, president</span><br><span class="line"># user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;</span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line"># user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;</span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Roles with assigned permissions</span><br><span class="line"># </span><br><span class="line"># Each line conforms to the format defined in the</span><br><span class="line"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[roles]</span><br><span class="line"># &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;</span><br><span class="line">admin = *</span><br><span class="line"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line"># The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with</span><br><span class="line"># license plate &#x27;eagle5&#x27; (instance specific id)</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-权限</title>
    <url>/2020/09/18/shiro-%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>权限管理</p>
<span id="more"></span>

<h1 id="shiro-权限"><a href="#shiro-权限" class="headerlink" title="shiro-权限"></a>shiro-权限</h1><p>控制谁能访问哪些资源。</p>
<p>谁：主体（Subject）、角色（Role）</p>
<p>哪些资源：资源（Resource）、权限（Permission） </p>
<h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><ol>
<li><p>编程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">if(subject.hasRole(“admin”)) &#123;</span><br><span class="line">    //有权限</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //无权限</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiresRoles(&quot;admin&quot;)</span><br><span class="line">public void hello() &#123;</span><br><span class="line">    //有权限</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>标签</p>
<p>JSP/GSP 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">&lt;!— 有权限 —&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h2><ol>
<li><p>配置shiro-role.ini</p>
<p>resource下新建shiro-role.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhang=123,role1,role2</span><br><span class="line">wang=123,role1</span><br></pre></td></tr></table></figure></li>
<li><p>Base</p>
<p>封装了开头和结尾的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.apache.shiro.util.ThreadContext;</span><br><span class="line">import org.junit.After;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname BaseAuthorizationTest</span><br><span class="line"> * @Description Authorization base</span><br><span class="line"> */</span><br><span class="line">public class BaseAuthorizationTest &#123;</span><br><span class="line"></span><br><span class="line">    protected void login(String configFile, String username, String password) &#123;</span><br><span class="line">        //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory =</span><br><span class="line">                new IniSecurityManagerFactory(configFile);</span><br><span class="line"></span><br><span class="line">        //2、得到SecurityManager实例 并绑定给SecurityUtils</span><br><span class="line">        org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line"></span><br><span class="line">        subject.login(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public void tearDown() throws Exception &#123;</span><br><span class="line">        ThreadContext.unbindSubject();//退出时请解除绑定Subject到线程 否则对下次测试造成影响</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname AuthorizationTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class AuthorizationTest extends  BaseAuthorizationTest&#123;</span><br><span class="line"></span><br><span class="line">    // 基于角色的访问控制（隐式）</span><br><span class="line">    // 1.基于角色的访问控制（隐式）</span><br><span class="line">    @Test</span><br><span class="line">    public void testHasRole()&#123;</span><br><span class="line">        login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //判断拥有角色：role1</span><br><span class="line">        ;</span><br><span class="line">        Assert.assertTrue(SecurityUtils.getSubject().hasRole(&quot;role1&quot;));</span><br><span class="line">        //判断拥有角色：role1 and role2</span><br><span class="line">        Assert.assertTrue(SecurityUtils.getSubject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));</span><br><span class="line">        //判断拥有角色：role1 and role2 and !role3</span><br><span class="line">        boolean[] result = SecurityUtils.getSubject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));</span><br><span class="line">        Assert.assertEquals(true, result[0]);</span><br><span class="line">        Assert.assertEquals(true, result[1]);</span><br><span class="line">        Assert.assertEquals(false, result[2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.基于角色的访问控制（隐式）</span><br><span class="line">    // checkRole/checkRoles 和 hasRole/hasAllRoles 不同的地方是它在判断为假的情况下会抛出 UnauthorizedException 异常。</span><br><span class="line">    @Test(expected = UnauthorizedException.class)</span><br><span class="line">    public void testCheckRole() &#123;</span><br><span class="line">        login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //断言拥有角色：role1</span><br><span class="line">        SecurityUtils.getSubject().checkRole(&quot;role1&quot;);</span><br><span class="line">        //断言拥有角色：role1 and role3 失败抛出异常</span><br><span class="line">        SecurityUtils.getSubject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基于资源的访问控制（显示角色）"><a href="#基于资源的访问控制（显示角色）" class="headerlink" title="基于资源的访问控制（显示角色）"></a>基于资源的访问控制（显示角色）</h2><ol>
<li><p>配置shrio-permission.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhang=123,role1,role2</span><br><span class="line">wang=123,role1</span><br><span class="line">[roles]</span><br><span class="line">role1=user:create,user:update</span><br><span class="line">role2=user:create,user:delete</span><br></pre></td></tr></table></figure></li>
<li><p>BaseAuthorizationTest</p>
<p>同上的BaseAuthorizationTest</p>
</li>
<li><p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname AuthorizationPermittedTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class AuthorizationPermittedTest extends BaseAuthorizationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testIsPermitted() &#123;</span><br><span class="line">        login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //判断拥有权限：user:create</span><br><span class="line">        boolean permitted = SecurityUtils.getSubject().isPermitted(&quot;user:create&quot;);</span><br><span class="line">        //判断拥有权限：user:update and user:delete</span><br><span class="line">        boolean permittedAll = SecurityUtils.getSubject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;);</span><br><span class="line">        //判断没有权限：user:view</span><br><span class="line">        boolean permitted1 = SecurityUtils.getSubject().isPermitted(&quot;user:view&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(permitted + &quot; &quot; + permittedAll + &quot; &quot; + permitted1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test(expected = UnauthorizedException.class)</span><br><span class="line">    public void testCheckPermission () &#123;</span><br><span class="line">        login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //断言拥有权限：user:create</span><br><span class="line">        SecurityUtils.getSubject().checkPermission(&quot;user:create&quot;);</span><br><span class="line">        //断言拥有权限：user:delete and user:update</span><br><span class="line">        SecurityUtils.getSubject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);</span><br><span class="line">        //断言拥有权限：user:view 失败抛出异常</span><br><span class="line">        SecurityUtils.getSubject().checkPermissions(&quot;user:view&quot;);</span><br><span class="line">        // 阻塞了后续代码，即使@Test(expected = UnauthorizedException.class)</span><br><span class="line">        System.out.println(1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-身份认证</title>
    <url>/2020/09/20/shiro-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>junit学习并总结shiro的身份认证</p>
<span id="more"></span>

<h1 id="shiro-身份认证"><a href="#shiro-身份认证" class="headerlink" title="shiro-身份认证"></a>shiro-身份认证</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p><a href="http://shiro.apache.org/10-minute-tutorial.html">官网地址</a></p>
<p>验证主体Subject（会存入前端的账号/密码）是否存在于realm（后端数据源）中</p>
<h2 id="code-Implementation"><a href="#code-Implementation" class="headerlink" title="code Implementation"></a>code Implementation</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>使用junit的shiro入门demo</p>
<ol>
<li><p>新建项目</p>
</li>
<li><p>导入maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-learn&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置后端数据源</p>
<p>resources下新建shiro.ini文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">   zhang=123</span><br><span class="line">   wang=123</span><br></pre></td></tr></table></figure>

<p>notice:idea需要ini4idea插件，并配置。<a href="https://blog.csdn.net/lintianlin/article/details/80050309">参考</a></p>
</li>
<li><p>junit测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationException;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.apache.shiro.util.ThreadContext;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">public class LoginLogout &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHelloword ()&#123;</span><br><span class="line">        //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">        //2、得到SecurityManager实例 并绑定给SecurityUtils</span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        // 4.从前端传来的账号/密码</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 身份验证</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; catch (AuthenticationException e)&#123;</span><br><span class="line">            // 认证失败</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;登录失败&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(true, subject.isAuthenticated());// 断言用户已经登录</span><br><span class="line">        // 退出，会清理session</span><br><span class="line">        subject.logout();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @After</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        // 不执行可能影响第二次运行Test</span><br><span class="line">        ThreadContext.unbindSubject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Singlon-Realm"><a href="#Singlon-Realm" class="headerlink" title="Singlon-Realm"></a>Singlon-Realm</h3><ol>
<li><p>从demo的3开始</p>
<p>新建MyRealm类实现Realm接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.realm.Realm;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname MyRealm</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class MyRealm implements Realm &#123;</span><br><span class="line">    // 返回一个唯一的Realm名字</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;myRealm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断此Realm是否支持此Token</span><br><span class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</span><br><span class="line">        // 仅支持UsernamePasswordToken类型的Token</span><br><span class="line">        return authenticationToken instanceof UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据Token获取认证信息</span><br><span class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">        // 获取用户名</span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        // 获取密码</span><br><span class="line">        String password = new String((char[])authenticationToken.getCredentials());</span><br><span class="line"></span><br><span class="line">        if (!&quot;zhang&quot;.equals(username))&#123;</span><br><span class="line">            throw new UnknownAccountException();// 用户名不存在</span><br><span class="line">        &#125;</span><br><span class="line">        if (!&quot;123&quot;.equals(password))&#123;</span><br><span class="line">            throw new IncorrectCredentialsException();// 密码错误</span><br><span class="line">        &#125;</span><br><span class="line">        // 认证成功，返回AutnenticationInfo信息</span><br><span class="line">        return new SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置MyRealm</p>
<p>resource下新建shiro-realm文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">#声明一个realm</span><br><span class="line">myRealm = com.xiaoruiit.shiro.config.MyRealm</span><br><span class="line">#指定securityManager的realms实现</span><br><span class="line">securityManager.realms=$myRealm</span><br></pre></td></tr></table></figure></li>
<li><p>junit测试</p>
<p>增加一个测试方法，修改shrio-reaml.ini即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testSingleRealm()&#123;</span><br><span class="line">       Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;);</span><br><span class="line">       SecurityManager securityManager = factory.getInstance();</span><br><span class="line">       SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);</span><br><span class="line">       try &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125; catch (AuthenticationException e)&#123;</span><br><span class="line">           // 认证失败</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(&quot;登录失败&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Assert.assertEquals(true, subject.isAuthenticated());// 断言用户已经登录</span><br><span class="line">       subject.logout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JDBC-Realm"><a href="#JDBC-Realm" class="headerlink" title="JDBC-Realm"></a>JDBC-Realm</h3><p>建立在在demo的基础上</p>
<ol>
<li><p>导入数据库依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.1.25&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;0.2.23&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在mysql中新建库shiro</p>
</li>
<li><p>新建三个表+1条user信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database if exists shiro;</span><br><span class="line">create database shiro;</span><br><span class="line">use shiro;</span><br><span class="line"></span><br><span class="line">create table users (</span><br><span class="line">  id bigint auto_increment,</span><br><span class="line">  username varchar(100),</span><br><span class="line">  password varchar(100),</span><br><span class="line">  password_salt varchar(100),</span><br><span class="line">  constraint pk_users primary key(id)</span><br><span class="line">) charset=utf8 ENGINE=InnoDB;</span><br><span class="line">create unique index idx_users_username on users(username);</span><br><span class="line"></span><br><span class="line">create table user_roles(</span><br><span class="line">  id bigint auto_increment,</span><br><span class="line">  username varchar(100),</span><br><span class="line">  role_name varchar(100),</span><br><span class="line">  constraint pk_user_roles primary key(id)</span><br><span class="line">) charset=utf8 ENGINE=InnoDB;</span><br><span class="line">create unique index idx_user_roles on user_roles(username, role_name);</span><br><span class="line"></span><br><span class="line">create table roles_permissions(</span><br><span class="line">  id bigint auto_increment,</span><br><span class="line">  role_name varchar(100),</span><br><span class="line">  permission varchar(100),</span><br><span class="line">  constraint pk_roles_permissions primary key(id)</span><br><span class="line">) charset=utf8 ENGINE=InnoDB;</span><br><span class="line">create unique index idx_roles_permissions on roles_permissions(role_name, permission);</span><br><span class="line"></span><br><span class="line">insert into users(username,password)values(&#x27;zhang&#x27;,&#x27;123&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>配置shiro-jdbc-realm</p>
<p>resource下新建shiro-jdbc-realm.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123456</span><br><span class="line"></span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure>

<p>JdbcRealm是shrio提供的。可继承并重写方法来改写sql</p>
</li>
<li><p>junit测试</p>
<p>修改shiro-jdbc-realm.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testJdbcRealm()&#123;</span><br><span class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-jdbc-realm.ini&quot;);</span><br><span class="line">       SecurityManager securityManager = factory.getInstance();</span><br><span class="line">       SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);</span><br><span class="line">       try &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125; catch (AuthenticationException e)&#123;</span><br><span class="line">           // 认证失败</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(&quot;登录失败&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Assert.assertEquals(true, subject.isAuthenticated());// 断言用户已经登录</span><br><span class="line">       subject.logout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger2入门</title>
    <url>/2019/09/08/swagger2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>swagger2入门</p>
<span id="more"></span>

<h1 id="swagger2入门"><a href="#swagger2入门" class="headerlink" title="swagger2入门"></a>swagger2入门</h1><h2 id="1-idea新建springboot项目"><a href="#1-idea新建springboot项目" class="headerlink" title="1.idea新建springboot项目"></a>1.idea新建springboot项目</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/eafTzln1IDhOxN6.png" alt="image-20200414100202180"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/o94bDNLFvhtYnai.png" alt="image-20200414100238353"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/1pHj5zauQsvdk4o.png" alt="image-20200414100328628"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jw9Zg62UsN5xfBW.png" alt="image-20200414100523771"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tSwMurdNIxvWon9.png" alt="image-20200414100727061"></p>
<h2 id="2-引入swagger2的jar包"><a href="#2-引入swagger2的jar包" class="headerlink" title="2.引入swagger2的jar包"></a>2.引入swagger2的jar包</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OLMjzFGW8E2cfoV.png" alt="image-20200414101046464"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;       </span><br></pre></td></tr></table></figure>

<h2 id="3-写swagger2的配置类"><a href="#3-写swagger2的配置类" class="headerlink" title="3.写swagger2的配置类"></a>3.写swagger2的配置类</h2><p>新建包configuration，包下新建类Swagger2Config</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/YQ7pZ83hsGxPcvk.png" alt="image-20200414101825597"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zBYWSb8q1J7DgR4.png" alt="image-20200414101737209"></p>
<p>Swagger2Config的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.demo.configuration;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line">import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line">import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration //表示这是一个配置类</span><br><span class="line">@EnableSwagger2 //启用Swagger2相关功能</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo&quot;))//基础路径</span><br><span class="line">                .paths(PathSelectors.regex(&quot;/*&quot;))//匹配开启接口文档的路径</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;学习swaggerRestful API&quot;)</span><br><span class="line">                .description(&quot;学习swaggerRestful API&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http://127.0.0.1:8080/&quot;)</span><br><span class="line">                .contact(&quot;demo&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-写一个测试类"><a href="#4-写一个测试类" class="headerlink" title="4.写一个测试类"></a>4.写一个测试类</h2><p>新建包controller，包下新建类TestSwagger2</p>
<p>类的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class TestSwagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;swagger2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-启动项目，访问-http-localhost-8080-swagger-ui-html"><a href="#5-启动项目，访问-http-localhost-8080-swagger-ui-html" class="headerlink" title="5.启动项目，访问 http://localhost:8080/swagger-ui.html"></a>5.启动项目，访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/143ONtwmK2QsMBu.png" alt="image-20200414103730999"></p>
]]></content>
      <categories>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>《渴望生活》读后感</title>
    <url>/2018/05/05/%E3%80%8A%E6%B8%B4%E6%9C%9B%E7%94%9F%E6%B4%BB%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>《渴望生活》即梵高传，描写了温森特·梵高青年到37岁时的生活。</p>
<span id="more"></span>
<p>他人生的每个转折点对我触动都很大。</p>
<p>为讲真话辞职古比尔公司，为了当牧师而努力考大学，努力到每天学18-20个小时。</p>
<p>努力学一年后因觉得上大学后的牧师并不是真的解决需要的人的穷苦人民的疾苦而放弃。然后去学做一名福音传教士。他学习时，不做表面的演讲，努力深入讲解，却因自己学这种太慢而被孤立、欺负。(梵高得这种做法是否就不应该？)</p>
<p>决定去做福音传教士时与老师的对话，老师在人生路对梵高的指点。</p>
<p>被好心的皮特森牧师派到博里纳日煤矿。在煤矿先布道演讲，效果不错。跟着下了一次煤矿后，发现自己太虚伪了，也发现演讲并不实际。(当时的煤矿太苦了，小孩8岁开始下井，20就会的肺病，最多不超过40岁。一直生活在死亡的威胁下。井下很热，不通风，也没法通风，通风意味着不能工作，不工作就没钱，一样会饿死。凌晨3点开始，13个小时的高强度体力活，只就着空气中的煤吃一点面包，奶酪，咖啡。稍上层的煤矿只能弯腰干活，底层只能趴着向前凿。)一次煤矿的塌方，60人的死亡，与煤矿经理的交流，让他彻底失去了上帝。(经理也想提高工资，但做不到，这个矿是最贫的一个矿，提高工资或缩短工作时间，或买安全设备，煤价就会低于市场价，矿主就会撤资，煤矿就会倒闭。最终工人会没有活干，没有钱。)</p>
<p>生病一段时间（大概一个月）后开始素描。</p>
<p>他每次有了自己想做的事后都很疯狂，每天只睡很短的时间，其余时间就是工作。</p>
<p>在家乡画画被村民称作二流子，说他该干正经事了。村民异样的眼光，精神的压力。(疑惑:自己的生活别人无法理解，并实施干扰时，怎么办？梵高当时想逃离，但在家乡的工作还没完成。)</p>
<p>想拜毛威表哥为师时毛威表哥的推辞，毛威表哥的严肃。毛威的独白：艺术家都是自私的，尤其保护自己工作的时间，除非能互相帮忙，不然不会要一个累赘。我并不经常有那种想要谈论自己创作的欲望。</p>
<p>在阿尔这个地方，他因为长期不带帽子暴露在强烈的阳光下作画，得了三个月一犯的精神病。（这的阳光特别毒）</p>
<p>最后，从阿尔的疗养院回巴黎后，在伽塞大夫那画了一些画后，梵高什么也不想画了，他已把自己要表现的都表现了。到了一个星期两幅油画，还不是完全想画。(之前都是一天至少一幅。)自己想做的事做完了，也就枯竭了。</p>
<p>如果自己能懂一些画画、油画、欧洲文化，就能更读懂书中艺术家作画，争论画，争论自己画画的理论的心情。</p>
<p>其实看这本书前面触动大，后边少，后边就是一直在描述主角不被人理解自己的画。但好像只是接触到这么一种没见过的情景的触动，对我自己并没有什么影响。（尤其与人类简史、未来简史、孤独的行路人相比较，这几本书都改变了我很多的思想。）不过这本书更完整，鲜活。</p>
]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>读后感</tag>
        <tag>传记</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离-重定向url携带数据</title>
    <url>/2020/08/18/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E9%87%8D%E5%AE%9A%E5%90%91url%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>前后端分离-重定向url携带数据</p>
<span id="more"></span>

<h1 id="前后端分离-重定向url携带中文数据"><a href="#前后端分离-重定向url携带中文数据" class="headerlink" title="前后端分离-重定向url携带中文数据"></a>前后端分离-重定向url携带中文数据</h1><p>后端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String redirectUrl = &quot;http://127.0.0.1/test.html&quot; </span><br><span class="line">try &#123;</span><br><span class="line">	String msg = &quot;登录失败&quot;;</span><br><span class="line">	msg = java.net.URLEncoder.encode(msg, &quot;UTF-8&quot;);// 编码</span><br><span class="line">	response.sendRedirect(redirectUrl+&quot;?msg=&quot;+msg);</span><br><span class="line">&#125; catch (IOException e2) &#123;</span><br><span class="line">	e2.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var request = new Object();</span><br><span class="line">request = GetRequest();</span><br><span class="line">var msg = request[&#x27;msg&#x27;];</span><br><span class="line">console.log(msg);</span><br><span class="line"></span><br><span class="line">function GetRequest() &#123;</span><br><span class="line">	debugger;</span><br><span class="line">	var url = location.search; //获取url中&quot;?&quot;符后的字串</span><br><span class="line">	console.log(url);</span><br><span class="line">	var theRequest = new Object();</span><br><span class="line">	if (url.indexOf(&quot;?&quot;) != -1) &#123;</span><br><span class="line">		var str = url.substr(1);</span><br><span class="line">		strs = str.split(&quot;&amp;&quot;);</span><br><span class="line">		for (var i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">			theRequest[strs[i].split(&quot;=&quot;)[0]] = decodeURI(strs[i].split(&quot;=&quot;)[1]);// 解码</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return theRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前后端分离</category>
      </categories>
      <tags>
        <tag>前后端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端-弹出框底层不可选</title>
    <url>/2020/08/07/%E5%89%8D%E7%AB%AF-%E5%BC%B9%E5%87%BA%E6%A1%86%E5%BA%95%E5%B1%82%E4%B8%8D%E5%8F%AF%E9%80%89/</url>
    <content><![CDATA[<p>前端-弹出框底层不可选</p>
<span id="more"></span>

<h1 id="前端-弹出框底层不可选"><a href="#前端-弹出框底层不可选" class="headerlink" title="前端-弹出框底层不可选"></a>前端-弹出框底层不可选</h1><p>转载：<a href="https://blog.csdn.net/llllvvv/article/details/79926656?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-79926656.nonecase">https://blog.csdn.net/llllvvv/article/details/79926656?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-79926656.nonecase</a></p>
<p>修改了一点</p>
<p>效果：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/foxnmYKIAycqOt8.png" alt="image-20200807175921117"></p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;弹出窗口后，后面的层不可操作&lt;/title&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">	function show()  //显示隐藏层和弹出层 </span><br><span class="line">	&#123; </span><br><span class="line">	   var hideobj=document.getElementById(&quot;hidebg&quot;); </span><br><span class="line">	   hidebg.style.display=&quot;block&quot;;  //显示隐藏层 </span><br><span class="line">	   //hidebg.style.height=document.body.clientHeight+&quot;px&quot;;  //设置隐藏层的高度为当前页面高度 </span><br><span class="line">	   document.getElementById(&quot;hidebox&quot;).style.display=&quot;block&quot;;  //显示弹出层 </span><br><span class="line">	&#125; </span><br><span class="line">	function hide()  //去除隐藏层和弹出层 </span><br><span class="line">	&#123; </span><br><span class="line">	   document.getElementById(&quot;hidebg&quot;).style.display=&quot;none&quot;; </span><br><span class="line">	   document.getElementById(&quot;hidebox&quot;).style.display=&quot;none&quot;; </span><br><span class="line">	&#125; </span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">   #hidebg &#123; position:absolute;left:0px;top:0px; </span><br><span class="line">      background-color:#000; </span><br><span class="line">      width:100%;  /*宽度设置为100%，这样才能使隐藏背景层覆盖原页面*/    </span><br><span class="line">      height: 100%;</span><br><span class="line">      filter:alpha(opacity=60);  /*设置透明度为60%*/ </span><br><span class="line">      opacity:0.6;  /*非IE浏览器下设置透明度为60%*/ </span><br><span class="line">      display:none;</span><br><span class="line">      z-Index:2;&#125; </span><br><span class="line">   #hidebox &#123; text-align: right;position:absolute;width:400px;height:300px;top:200px;left:30%;border-radius: 5px;background-color:#fff;display:none;z-Index:3;padding: 10px;&#125; </span><br><span class="line">   #content &#123; text-align: center;cursor:pointer;z-Index:1;&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=&quot;hidebg&quot;&gt;&lt;/div&gt;&lt;!--隐藏层--&gt;</span><br><span class="line">	&lt;div id=&quot;hidebox&quot;&gt;&lt;span onClick=&quot;hide();&quot; style=&quot;cursor:pointer;&quot;&gt;关闭&lt;/span&gt;&lt;/div&gt;&lt;!--弹出层--&gt;</span><br><span class="line">	&lt;div id=&quot;content&quot; onClick=&quot;show();&quot;&gt;点击打开&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>弹出框</tag>
      </tags>
  </entry>
  <entry>
    <title>参数校验</title>
    <url>/2021/06/10/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>参数校验</p>
<span id="more"></span>

<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><p>客户端校验和服务端校验</p>
<h2 id="客户端校验"><a href="#客户端校验" class="headerlink" title="客户端校验"></a>客户端校验</h2><p>客户端校验：提示用户正确输入，密码的输入等准确性来加强用户体验。</p>
<h2 id="服务端校验"><a href="#服务端校验" class="headerlink" title="服务端校验"></a>服务端校验</h2><p>服务端校验即接口校验：更多的是为了接口安全，数据库安全，防止非法用户。</p>
<p>java规范:JSR-303</p>
<h3 id="为什么对接口参数校验"><a href="#为什么对接口参数校验" class="headerlink" title="为什么对接口参数校验"></a>为什么对接口参数校验</h3><ul>
<li><p>数据库汇中字段对应的数据，应该遵循业务要求和数据库设计</p>
</li>
<li><p>防止（减小）范围外的输入的数据入库后影响业务正常运行的风险</p>
</li>
<li><p>数据来源是接口，从入口处（接口）进行校验。</p>
</li>
</ul>
<h3 id="如何进行接口参数校验实现"><a href="#如何进行接口参数校验实现" class="headerlink" title="如何进行接口参数校验实现"></a>如何进行接口参数校验实现</h3><h4 id="使用-Valid"><a href="#使用-Valid" class="headerlink" title="使用@Valid"></a>使用@Valid</h4><p>spring基于规范的实现：@Valid，对@Valid的扩展：@Validated</p>
<p>注解 springboot中@Validated @Valid，通过注解的方法，在实体上加注解。</p>
<ol>
<li><p>非实体校验</p>
<p>   形参校验注解（@NotBlank、@NotNull等）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result delete(@RequestParam @NotBlank(message = &quot;主键不能为空&quot;) String id)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实体校验</p>
<p>   @Validated + 属性校验注解（@NotBlank、@NotNull等）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result update(@RequestBody @Validated UserUpdateVO data) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class UserUpdateVO &#123;</span><br><span class="line">   </span><br><span class="line">    @NotBlank(message = &quot;id不能为空&quot;)</span><br><span class="line">    private String id;</span><br><span class="line">   </span><br><span class="line">    @NotNull(message = &quot;小数位数不能为空&quot;)</span><br><span class="line"> @Max(value = 2,message = &quot;小数位数格式错误&quot;)</span><br><span class="line">    @Min(value = 0, message = &quot;小数位数格式错误&quot;)</span><br><span class="line">    private Integer decimalDigits;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>List<Bean>校验</p>
<p>@Valid + ValidList</p>
<p>@Valid 起嵌套校验的作用</p>
<p>原Controller方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result add(@RequestBody List&lt;实体&gt; data) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>List是jdk的接口。@Valid，@Validated 无法校验非实体Bean.</p>
<p>校验List&lt;实体&gt;的方法。 定义ValidList 实现List接口。List&lt;实体&gt; → ValidList&lt;实体&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result add( @RequestBody @Valid ValidList&lt;实体&gt; data) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ValidList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Valid</span><br><span class="line">    private List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    public ValidList() &#123;</span><br><span class="line">        this.list = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ValidList(List&lt;E&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;E&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;E&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return list.contains(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return list.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        return list.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return list.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return list.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return list.addAll(index, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return list.removeAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return list.retainAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        return list.set(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        return list.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        return list.indexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">        return list.lastIndexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">        return list.listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        return list.listIterator(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        return list.subList(fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实体内List校验</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result update(@RequestBody @Validated UserUpdateVO data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class UserUpdateVO &#123;</span><br><span class="line"></span><br><span class="line">	@NotBlank(message = &quot;id不能为空&quot;)</span><br><span class="line">	private String id;</span><br><span class="line"></span><br><span class="line">	@NotNull(message = &quot;小数位数不能为空&quot;)</span><br><span class="line">	@Max(value = 2,message = &quot;小数位数格式错误&quot;)</span><br><span class="line">	@Min(value = 0, message = &quot;小数位数格式错误&quot;)</span><br><span class="line">	private Integer decimalDigits;</span><br><span class="line">	</span><br><span class="line">	@Size(min = 1,message = &quot;角色不能为空&quot;)</span><br><span class="line">    @Valid</span><br><span class="line">    // @Valid 开启递归校验Role</span><br><span class="line">	private List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Role&#123;</span><br><span class="line">	</span><br><span class="line">	@NotBlank(message = &quot;角色不能为空&quot;)</span><br><span class="line">	private String roleId;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="通过工具类"><a href="#通过工具类" class="headerlink" title="通过工具类"></a>通过工具类</h4><p>RegexUtils.java</p>
<p>将常用的校验方法放在一个类中，然后哪个参数需要校验，就调用工具类中的方法。</p>
<h3 id="校验失败处理"><a href="#校验失败处理" class="headerlink" title="校验失败处理"></a>校验失败处理</h3><p>使用全局异常捕获。 使用 @ControllerAdvice 分别定义方法，捕获并处理MethodArgumentNotValidException、BindException、ConstraintViolationException</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.hibernate.validator.internal.engine.path.PathImpl;</span><br><span class="line">import org.springframework.validation.BindException;</span><br><span class="line">import org.springframework.validation.BindingResult;</span><br><span class="line">import org.springframework.validation.FieldError;</span><br><span class="line">import org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">import javax.validation.ConstraintViolation;</span><br><span class="line">import javax.validation.ConstraintViolationException;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 参数异常处理</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = MethodArgumentNotValidException.class)</span><br><span class="line">    public Result handleValidException(MethodArgumentNotValidException e) &#123;</span><br><span class="line">        BindingResult bindingResult = e.getBindingResult();</span><br><span class="line">        String message = null;</span><br><span class="line">        if (bindingResult.hasErrors()) &#123;</span><br><span class="line">            FieldError fieldError = bindingResult.getFieldError();</span><br><span class="line">            if (fieldError != null) &#123;</span><br><span class="line">                message = fieldError.getField() + fieldError.getDefaultMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.validateFailed(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = BindException.class)</span><br><span class="line">    public Result handleValidException(BindException e) &#123;</span><br><span class="line">        BindingResult bindingResult = e.getBindingResult();</span><br><span class="line">        String message = null;</span><br><span class="line">        if (bindingResult.hasErrors()) &#123;</span><br><span class="line">            FieldError fieldError = bindingResult.getFieldError();</span><br><span class="line">            if (fieldError != null) &#123;</span><br><span class="line">                message = fieldError.getField() + fieldError.getDefaultMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.validateFailed(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = ConstraintViolationException.class)</span><br><span class="line">    public Result handleValidException(ConstraintViolationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.info(&quot;全局异常捕获：&#123;&#125;&quot;, e.getStackTrace());</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = e.getConstraintViolations();</span><br><span class="line">        for (ConstraintViolation&lt;?&gt; constraintViolation : constraintViolations) &#123;</span><br><span class="line">            PathImpl pathImpl = (PathImpl) constraintViolation.getPropertyPath();</span><br><span class="line">            // 读取参数字段，constraintViolation.getMessage() 读取验证注解中的message值</span><br><span class="line">            String paramName = pathImpl.getLeafNode().getName();</span><br><span class="line">            String message = constraintViolation.getMessage();</span><br><span class="line">            return Result.validateFailed(message);</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.validateFailed(e.getMessage());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用校验注解"><a href="#常用校验注解" class="headerlink" title="常用校验注解"></a>常用校验注解</h3><table>
<thead>
<tr>
<th>空校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Null</td>
<td>任何类型</td>
<td>校验对象必须为空</td>
</tr>
<tr>
<td>@NotNull</td>
<td>任何类型</td>
<td>校验对象不为空，不能校验字符串长度为0的对象</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>字符串</td>
<td>只对字符串有效，校验字符串去掉前后空格后长度不为0</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>字符串、集合、数组</td>
<td>校验对象不能为空 (字符串长度不为0、集合大小不为0)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>boolean校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@AssertTrue</td>
<td>布尔</td>
<td>校验boolean类型必须为true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>布尔</td>
<td>校验boolean类型必须为false</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>日期校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Past</td>
<td>日期类型</td>
<td>校验必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>日期类型</td>
<td>校验必须是一个将来的日期</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>数值校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Min</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须大于或等于指定的最小值</td>
</tr>
<tr>
<td>@Max</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须小于或等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须大于或等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须小于或等于指定的最大值</td>
</tr>
<tr>
<td>@Digits(integer=,fraction=)</td>
<td>数字类型</td>
<td>校验必须是一个数字，interger指定整数精度，fraction指定小数精度</td>
</tr>
<tr>
<td>@Range(min =,max = )</td>
<td>数字类型、字符串</td>
<td>校验对象的值在min和max区间内</td>
</tr>
<tr>
<td>@Length(min =,max = )</td>
<td>字符串</td>
<td>校验对象的值的长度在min和max区间内</td>
</tr>
<tr>
<td>@Size(min =,max = )</td>
<td>字符串、集合、数组</td>
<td>校验对象的值在min和max区间内，如字符长度、集合大小</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Email</td>
<td>字符串</td>
<td>校验对象的值必须是Email类型，也可以通过regexp和flag指定自定义的email格式</td>
</tr>
<tr>
<td>@Pattern</td>
<td>字符串</td>
<td>校验对象的值必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@CreditCardNumber</td>
<td>数字类型、字符串</td>
<td>校验对象的值必须是信用卡类型</td>
</tr>
<tr>
<td>@URL</td>
<td>字符串</td>
<td>校验对象的值必须是URL地址</td>
</tr>
</tbody></table>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><ol>
<li>自己写注解类。</li>
<li>约束规则“分组”（group）</li>
<li>校验方法的返回值</li>
<li>约束规则支持正则表达式</li>
<li>支持跨参数校验 ？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sj13074480550/article/details/103399503">https://blog.csdn.net/sj13074480550/article/details/103399503</a></p>
]]></content>
      <categories>
        <category>校验</category>
      </categories>
      <tags>
        <tag>参数校验</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-入门</title>
    <url>/2020/09/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Multithreading-入门</p>
<span id="more"></span>

<h1 id="多线程-入门"><a href="#多线程-入门" class="headerlink" title="多线程-入门"></a>多线程-入门</h1><ul>
<li>1.线程的生命周期</li>
</ul>
<ul>
<li>2.创建线程</li>
<li>3.多线程编程的主要概念</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Multithreading &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);</span><br><span class="line">        R1.start();</span><br><span class="line"></span><br><span class="line">        RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);</span><br><span class="line">        R2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  1.线程的生命周期：新建、就绪、阻塞、运行、死亡</span><br><span class="line"> *  新建：new</span><br><span class="line"> *  就绪：新建状态调用start()方法，手动调用。</span><br><span class="line"> *  运行：就绪状态调用run()方法，自动调用。就绪状态的线程获取到满足运行的 CPU 资源，就执行 run()，</span><br><span class="line"> *  阻塞：线程执行sleep(睡眠)、suspend(挂起).</span><br><span class="line"> *       等待阻塞：运行状态执行wait()</span><br><span class="line"> *       同步阻塞：线程获取synchronized同步锁失败。</span><br><span class="line"> *       其他阻塞：调用线程的sleep()或join()发出来I/O请求。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</span><br><span class="line"> *  死亡：线程执行完或有终止条件</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 2.创建线程</span><br><span class="line"> *     1.实现Runnable接口</span><br><span class="line"> *     2.继承Thread类</span><br><span class="line"> *     3.通过 Callable 和 Future 创建线程</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//2.1.实现Runnable接口</span><br><span class="line">class RunnableDemo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private Thread t;</span><br><span class="line">    private String threadName;</span><br><span class="line"></span><br><span class="line">    RunnableDemo (String name)&#123;</span><br><span class="line">        this.threadName = name;</span><br><span class="line">        System.out.println(&quot;Thread &quot; +  threadName  + &quot;新建 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重写run方法</span><br><span class="line">    // 运行</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Thread &quot; +  threadName + &quot;运行&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;次执行Thread: &quot; + threadName);</span><br><span class="line">                // 阻塞</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Thread &quot; +  threadName + &quot;死亡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start()&#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            // 新建</span><br><span class="line">            t = new Thread (this, threadName);</span><br><span class="line">            // 就绪</span><br><span class="line">            t.start();</span><br><span class="line">            System.out.println(&quot;Thread &quot; +  threadName + &quot; 就绪&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.多线程编程的主要概念：</p>
<ul>
<li><pre><code>线程同步
</code></pre>
</li>
<li><pre><code>线程间通信
</code></pre>
</li>
<li><pre><code>线程死锁
</code></pre>
</li>
<li><pre><code>线程控制：挂起、停止和恢复
</code></pre>
</li>
<li>线程池</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化</title>
    <url>/2020/05/18/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>序列化</p>
<p><escape><span id="more"></span></escape></p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul>
<li><p><strong>定义：</strong>将对象根据一定的格式转换为字节数组。</p>
</li>
<li><p><strong>需要序列化的原因：</strong>存储和网络传输都需要经过把一个对象状态保存成一种跨平台识别的字节格式，IO支持的数据格式是字节数组。</p>
</li>
<li><p><strong>用途：</strong>IO传输对象时，即跨平台存储，网络传输。</p>
</li>
<li><p><strong>实际场景：</strong>存到redis，微服务之间调用传输对象。</p>
</li>
<li><p><strong>做了什么：</strong>将要保存的数据，转换成字节码的形式，反序列化就是把字节码变成数据。</p>
</li>
</ul>
<h2 id="redis序列化"><a href="#redis序列化" class="headerlink" title="redis序列化"></a>redis序列化</h2><p>默认的<code>JdkSerializationRedisSerializer</code>存储时是二进制，redis中查看是乱码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Redis序列化配置</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());// key一般不是对象，String实现性能高</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());// value可能是对象，采用spring提供的Jackson序列化</span><br><span class="line">        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化"></a>java序列化</h2><ul>
<li><p><strong>实现原理</strong></p>
<p>通过<code>serialVersionUID</code>实现，JVM会在运行时判断类的<code>serialVersionUID</code>属性来验证版本一致性，如果传来的字节流中的serialVersionUID与本地相应类的serialVersionUID相同则认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<p>类实现了<code>Serializable </code>接口，JVM会根据类的整体信息生成<code>serialVersionUID</code>，类修改时，JVM会重新生成<code>serialVersionUID</code>。一般实践中会显示的定义类的<code>serialVersionUID</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>序列化</category>
      </categories>
      <tags>
        <tag>序列化</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-冒泡排序</title>
    <url>/2018/04/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序 如：从大到小排序，每次内循环将大数交换到前边，如同大数向上浮，故称为冒泡排序。</p>
<span id="more"></span>
<p>例如：从大到小排序：<br>从前向后判断相邻两个数的大小，*(a[j] &lt; a[j+1])*将小的换到后边，每次内循环完毕会将一个最小的数换到最下方。<br>每次内循环可排好一个数，每次内循环次数递减1 <em>j=a.length-i-1</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MaopaoRang &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a [] = &#123;3,16,18,5,35,6,18,2,15&#125;;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; a.length-i-1; j++) &#123;</span><br><span class="line">				//比较相邻两个数的大小，不符合要求，则交换。</span><br><span class="line">				if(a[j] &lt; a[j+1] )&#123;</span><br><span class="line">					int t = a[j];</span><br><span class="line">					a[j] = a[j+1];</span><br><span class="line">					a[j+1] = t;</span><br><span class="line">					</span><br><span class="line">					//打印每次交换后的数组</span><br><span class="line">					for (int k = 0; k &lt; a.length; k++) &#123;</span><br><span class="line">						System.out.print(a[k]+&quot; &quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.print(&quot;*&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		//打印排序结果</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次交换后的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16 3 18 5 35 6 18 2 15 *16 18 3 5 35 6 18 2 15 *16 18 5 3 35 6 18 2 15 *16 18 5 35 3 6 18 2 15 *16 18 5 35 6 3 18 2 15 *16 18 5 35 6 18 3 2 15 *16 18 5 35 6 18 3 15 2 *</span><br><span class="line">18 16 5 35 6 18 3 15 2 *18 16 35 5 6 18 3 15 2 *18 16 35 6 5 18 3 15 2 *18 16 35 6 18 5 3 15 2 *18 16 35 6 18 5 15 3 2 *</span><br><span class="line">18 35 16 6 18 5 15 3 2 *18 35 16 18 6 5 15 3 2 *18 35 16 18 6 15 5 3 2 *</span><br><span class="line">35 18 16 18 6 15 5 3 2 *35 18 18 16 6 15 5 3 2 *35 18 18 16 15 6 5 3 2 *</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序2-排序算法</title>
    <url>/2019/10/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<p>遍历数组的同时，使本次相邻的俩个数是左小右大（左大右小）；</p>
<span id="more"></span>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>平均时间复杂度：O(n²)；最好情况：O(n)；最坏情况：O(n²)；</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place （占用常数内存，不占用额外内存）</p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡算法</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：遍历数组的同时，使本次相邻的俩个数是左小右大（左大右小）；每次循环少遍历一个数；定义一个标记，当某次没有交换时，数组已经有序。</span><br><span class="line"> */</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		int[] sourceArray = &#123;8,3,2,4,5&#125;;</span><br><span class="line">		</span><br><span class="line">		int[] arr = sort(sourceArray);</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;排序后：&quot;);</span><br><span class="line">		System.out.println(Arrays.toString(sourceArray));</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;排序前：&quot;);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public static int[] sort(int[] sourceArray) throws Exception&#123;</span><br><span class="line">		// 复制数组内容，int[] arr = sourceArray 排序后会改变原数组内容</span><br><span class="line">		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">		</span><br><span class="line">		for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">			// 若循环没有做交换，则数组有序。设定一个标记，若为true，排序已经完成。例如：数组为8,5,4,3,2，第一次循环数组没有做交换，则数组有序，直接返回。</span><br><span class="line">			boolean flag = true;</span><br><span class="line">			</span><br><span class="line">			for (int j = 0; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">				if (arr[j] &lt; arr[j+1]) &#123;</span><br><span class="line">					int temp = arr[j+1];</span><br><span class="line">					arr[j+1] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">					</span><br><span class="line">					flag = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if (flag) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-快速排序</title>
    <url>/2020/10/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序算法-快速排序</p>
<span id="more"></span>

<h1 id="排序算法-快速排序"><a href="#排序算法-快速排序" class="headerlink" title="排序算法-快速排序"></a>排序算法-快速排序</h1><p>平均时间复杂度：O(n log n)；最好情况：O(n²)；最坏情况：O(log n)；</p>
<p>空间复杂度：O(log n)</p>
<p>排序方式：In-place </p>
<p>稳定性：不稳定</p>
<p><strong>Implementation</strong>:</p>
<p>如何调整：quickSort1。循环一次数组，调整一次基准数：quickSort2。通过递归调整n此基准数，排序完成：quickSork3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ClassName: QuickSort &lt;br/&gt;</span><br><span class="line"> * Description: 快速排序&lt;br/&gt;</span><br><span class="line"> * date: 2020-09-29 21:33&lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author hxr&lt;br /&gt;</span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] old = &#123;7, 4, 1, 8, 5, 9, 7, 6&#125;;</span><br><span class="line">        int[] ints = quickSort3(old);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7,4,1,8,5,9,7,6</span><br><span class="line">    // 一：一趟遍历数组排序</span><br><span class="line">    //    1.找一个基准数，把他拿出来standrad=old[0], old[0]是坑位。</span><br><span class="line">    //    2.从右向左找到比基准数小的放在坑位，坑位变成了右边比基准数大的位置</span><br><span class="line">    //    3.从左向右找到比基准数大的放在坑位。坑位变成了左边比基准数小的位置</span><br><span class="line">    //    4.重复2,3.</span><br><span class="line">    //    5.排序成功时i==j退出遍历</span><br><span class="line">    // 二：递归分治，</span><br><span class="line"></span><br><span class="line">    //0,1,2,3,4,5,6,7 数组下标</span><br><span class="line">    //sep1</span><br><span class="line">    //7,4,1,8,5,9,7,6 //坑位为old[0]</span><br><span class="line">    //sep2</span><br><span class="line">    //6,4,1,8,5,9,7,6 //sep2,坑位为old[7]</span><br><span class="line">    //sep3</span><br><span class="line">    //6,4,1,8,5,9,7,8 //sep3,坑位为old[3]</span><br><span class="line"></span><br><span class="line">    // sep4:</span><br><span class="line">    //6,4,1,5,5,9,7,8 //sep2,坑位为old[4]</span><br><span class="line"></span><br><span class="line">    // sep5: i==j</span><br><span class="line">    //6,4,1,5,7,9,7,8 //old[4] = standrad;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 一：一趟遍历数组排序</span><br><span class="line">    //    1.找一个基准数，把他拿出来standrad=old[0], old[0]是坑位。</span><br><span class="line">    //    2.从右向左找到比基准数小的放在坑位，坑位变成了右边比基准数大的位置</span><br><span class="line">    //    3.从左向右找到比基准数大的放在坑位。坑位变成了左边比基准数小的位置</span><br><span class="line">    public static int[] quickSort1(int[] old) &#123;</span><br><span class="line"></span><br><span class="line">        if (null == old || old.length == 0)</span><br><span class="line">            return null;</span><br><span class="line">        //sep1</span><br><span class="line">        int standrad = old[0];</span><br><span class="line">        //sep2</span><br><span class="line">        int j = old.length - 1;</span><br><span class="line">        for (; j &gt; 0; j--) &#123;</span><br><span class="line">            if (old[j] &lt; standrad) &#123;</span><br><span class="line">                old[0] = old[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sep3</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; i &lt; old.length - 1; i++) &#123;</span><br><span class="line">            if (old[i] &gt; standrad) &#123;</span><br><span class="line">                old[j] = old[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 一：1.找一个基准数，把他拿出来standrad=old[0], old[0]是坑位。</span><br><span class="line">    //    2.从右向左找到比基准数小的放在坑位，坑位变成了右边比基准数大的位置</span><br><span class="line">    //    3.从左向右找到比基准数大的放在坑位。坑位变成了左边比基准数小的位置</span><br><span class="line">    //    4.重复2,3.</span><br><span class="line">    //    5.排序成功时i==j退出遍历</span><br><span class="line">    public static int[] quickSort2(int[] old) &#123;</span><br><span class="line">        int i = 0, j = old.length - 1;</span><br><span class="line">        quick(old, i, j);</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Integer quick(int[] old, int i, int j) &#123;</span><br><span class="line">        if (null == old || old.length == 0)</span><br><span class="line">            return null;</span><br><span class="line">        //sep1 选取基准数old[i],坑位下标为i</span><br><span class="line">        int standard = old[i];</span><br><span class="line"></span><br><span class="line">        //sep4 循环sep2和sep3，直到基准值调整完毕</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            //sep2 从右向左找到比基准值小的下标j，将下标的值old[j]放入旧坑位，下标j变为新坑位。</span><br><span class="line">            while (j &gt; i) &#123;</span><br><span class="line">                if (old[j] &lt; standard) &#123;</span><br><span class="line">                    old[i] = old[j];</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(&quot;旧坑的位置：&quot; + i + &quot;,新坑的位置：&quot; + j);</span><br><span class="line">                    System.out.println(Arrays.toString(old));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            //sep3 从左向右找到比基准值大的下标i，将下标的值old[i]放入旧坑位，下标i变为新坑位。</span><br><span class="line">            while (i &lt; j) &#123;</span><br><span class="line">                if (old[i] &gt; standard) &#123;</span><br><span class="line">                    old[j] = old[i];</span><br><span class="line">                    j--;</span><br><span class="line">                    System.out.println(&quot;旧坑的位置：&quot; + j + &quot;,新坑的位置：&quot; + i);</span><br><span class="line">                    System.out.println(Arrays.toString(old));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sep5 退出时i==j，将基准值放入最后的坑位</span><br><span class="line">        old[i] = standard;</span><br><span class="line">        System.out.print(&quot;一趟遍历后的排序结果：&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(old));</span><br><span class="line"></span><br><span class="line">        // 返回基准位置的下标</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 一：一趟遍历数组排序</span><br><span class="line">    // 二：递归分治</span><br><span class="line">    public static int[] quickSort3(int[] old) &#123;</span><br><span class="line">        if (null == old || old.length == 0)</span><br><span class="line">            return null;</span><br><span class="line">        int start = 0, end = old.length - 1;</span><br><span class="line">        quick3(old, start, end);</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void quick3(int[] old, int start, int end) &#123;</span><br><span class="line">        // 二、递归分治 退出条件</span><br><span class="line">        if (start &lt; end) &#123;</span><br><span class="line">            int i = start, j = end;</span><br><span class="line">            int standard = old[i];</span><br><span class="line">            while (i &lt; j) &#123;</span><br><span class="line">                while (j &gt; i) &#123;</span><br><span class="line">                    if (old[j] &lt; standard) &#123;</span><br><span class="line">                        old[i] = old[j];</span><br><span class="line">                        i++;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; j) &#123;</span><br><span class="line">                    if (old[i] &gt; standard) &#123;</span><br><span class="line">                        old[j] = old[i];</span><br><span class="line">                        j--;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            old[i] = standard;</span><br><span class="line">            System.out.print(&quot;一趟遍历后的排序结果：&quot;);</span><br><span class="line">            System.out.println(Arrays.toString(old));</span><br><span class="line"></span><br><span class="line">            // 二、递归分治</span><br><span class="line">            quick3(old, start, i - 1);</span><br><span class="line">            quick3(old, i + 1, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序-排序算法</title>
    <url>/2019/10/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>将第一个数当做有序序列（从小到大排列），将之后的数挨个插入到此有序序列里边。</p>
<span id="more"></span>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>平均时间复杂度：O(n²)；最好情况：O(n)；最坏情况：O(n²)；</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place </p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序 从小到大</span><br><span class="line"> * </span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：将第一个数当做有序序列（从小到大排列），将之后的数挨个插入到此有序序列里边。</span><br><span class="line"> * 每次取有序序列右边的第一个数（记为操作数）插入到有序序列，插入时，从右往左遍历有序序列，并判断操作数与遍历数的大小(1.操作数大，有序序列+操作数依然有序，不再遍历。2.操作数小，遍历数右移，接着遍历)。遍历完成后，将操作数插入到有序序列的准确位置。</span><br><span class="line"> * 优点：减少了交换次数</span><br><span class="line"> */</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = &#123; 8, 5, 3, 9, 1, 2, 4 &#125;;</span><br><span class="line">		for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">			// 记录有序序列右边的第一个数的数值，此后每趟排序右移一位。</span><br><span class="line">			int temp = arr[i];</span><br><span class="line"></span><br><span class="line">			int j = i;</span><br><span class="line">			while(j &gt; 0)&#123;</span><br><span class="line">				if (temp &lt; arr[j - 1]) &#123;</span><br><span class="line">					arr[j] = arr[j - 1];</span><br><span class="line">				&#125; else &#123;//比有序序列右边的数大，即比整个有序序列大。不需要再比较。</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 下标j以后的数比temp更大,插入到j位置</span><br><span class="line">			if (j != i) &#123;</span><br><span class="line">				arr[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 打印</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序-排序算法</title>
    <url>/2019/10/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。</p>
<span id="more"></span>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>平均时间复杂度：O(n+k)；最好情况：O(n+k)；最坏情况：O(n+k)；</p>
<p>空间复杂度：O(k)</p>
<p>排序方式：Out-place （占用常数内存，不占用额外内存）</p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 计数排序</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：申请数组中(max-min)大小的数组，统计数组中各元素的个数，并按元素与min的关系放入申请的数组中，即可输出有序数组。</span><br><span class="line"> */</span><br><span class="line">public class CountingSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] sourceArray = &#123; 8, 5, 6, 9, 5, 5, 5, 4 &#125;;</span><br><span class="line">		</span><br><span class="line">		// 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">		sort(arr);</span><br><span class="line">		System.out.println(&quot;排序前：&quot;+Arrays.toString(sourceArray));</span><br><span class="line">		System.out.println(&quot;排序后：&quot;+Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int[] sort(int[] arr) &#123;</span><br><span class="line">		if (arr.length &gt; 1) &#123;</span><br><span class="line">			//假设下标为0的值最小，下标为1的值最大。</span><br><span class="line">			int min = 0;</span><br><span class="line">			int max = 1;</span><br><span class="line">			if (arr[0] &gt; arr[1] ) &#123;</span><br><span class="line">				min = 1;</span><br><span class="line">				max = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			//同时找出数组中的最大最小值</span><br><span class="line">			for (int i = 2; i &lt; arr.length; i++) &#123;</span><br><span class="line">				if (arr[i] &lt; arr[min]) &#123;</span><br><span class="line">					min = i;</span><br><span class="line">				&#125;</span><br><span class="line">				if (arr[i] &gt; arr[max]) &#123;</span><br><span class="line">					max = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//对统计数组每个数计数</span><br><span class="line">			int[] sort = counting(arr,arr[max],arr[min]);</span><br><span class="line">			System.out.println(&quot;数组中的数计数：&quot;+Arrays.toString(sort));</span><br><span class="line">			//重新排列arr,使有序</span><br><span class="line">			int minarr = arr[min];</span><br><span class="line">			for (int i = 0,j = 0; i &lt; sort.length;) &#123;</span><br><span class="line">				if (sort[i] &gt; 0) &#123;</span><br><span class="line">					arr[j] = minarr+i;</span><br><span class="line">					j++;</span><br><span class="line">					sort[i]--;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//对统计数组每个数计数</span><br><span class="line">	private static int[] counting(int[] arr, int max, int min) &#123;</span><br><span class="line">		int[] count = new int[max-min+1];</span><br><span class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			count[arr[i] - min] ++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序-排序算法</title>
    <url>/2019/10/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>依次在数组中从小到大找数，在数组的头从前往后放。</p>
<span id="more"></span>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>平均时间复杂度：O(n²)；最好情况：O(n²)；最坏情况：O(n²)；</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place </p>
<p>稳定性：不稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：依次在数组中从小到大找数，在数组的头从前往后放。数组从前向后遍历，数据从前往后放if (min!=i)，遍历数组前边每次前进一下（i++）。</span><br><span class="line"> */</span><br><span class="line">public class ChoiceSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = &#123;8,5,3,2,4&#125;;</span><br><span class="line">		for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">			//假定 i最小,利用下标。只是找到最小，具体的数值在遍历完数组才用，利用下标即可。</span><br><span class="line">			int min = i;</span><br><span class="line">			//通过遍历数组寻找真的最小。</span><br><span class="line">			for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">				if (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//将最小与未有序数据放到未有序的头</span><br><span class="line">			if (min!=i) &#123;</span><br><span class="line">				int temp2 = arr[min];</span><br><span class="line">				arr[min] = arr[i];</span><br><span class="line">				arr[i] = temp2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作日志</title>
    <url>/2021/05/15/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>记录操作日志</p>
<span id="more"></span>

<h1 id="记录操作日志"><a href="#记录操作日志" class="headerlink" title="记录操作日志"></a>记录操作日志</h1><h2 id="1-反射获取swagger日志，并插入到redis"><a href="#1-反射获取swagger日志，并插入到redis" class="headerlink" title="1.反射获取swagger日志，并插入到redis"></a>1.反射获取swagger日志，并插入到redis</h2><h2 id="2-Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ"><a href="#2-Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ" class="headerlink" title="2.Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ"></a>2.Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ</h2><h2 id="3-获取RabbitMQ数据，并插入到mysql"><a href="#3-获取RabbitMQ数据，并插入到mysql" class="headerlink" title="3.获取RabbitMQ数据，并插入到mysql"></a>3.获取RabbitMQ数据，并插入到mysql</h2><h2 id="4-从库中查询日志到页面"><a href="#4-从库中查询日志到页面" class="headerlink" title="4.从库中查询日志到页面"></a>4.从库中查询日志到页面</h2>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>操作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>反射获取swagger描述，并插入到redis</title>
    <url>/2021/05/15/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97_1.%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96swagger%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%B9%B6%E6%8F%92%E5%85%A5%E5%88%B0redis/</url>
    <content><![CDATA[<p>反射获取swagger描述，并插入到redis</p>
<span id="more"></span>

<h1 id="反射获取swagger描述，并插入到redis"><a href="#反射获取swagger描述，并插入到redis" class="headerlink" title="反射获取swagger描述，并插入到redis"></a>反射获取swagger描述，并插入到redis</h1><ol>
<li>redis序列化配置</li>
<li>实现SpringBoot的CommandLineRunner接口，作用：项目启动时执行run方法</li>
<li>反射获取所有的Controller类</li>
<li>获取Controller类上的swagger注解，取需要的值</li>
<li>遍历所有的Controller类，获取每个类的所有方法</li>
<li>获取每个方法上的swagger注解，取需要的值</li>
<li>插入到redis中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.*;</span><br><span class="line">import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Redis序列化配置</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.config;</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import com.hanxxiaorui.common.constant.SwaggerConstant;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.CommandLineRunner;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.util.ClassUtils;</span><br><span class="line">import org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class BaseSwaggerCache implements CommandLineRunner &#123;// 实现SpringBoot的CommandLineRunner接口，项目启动时执行run方法</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">    private String appName;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    WebApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getAllUrlAndSetRedisForLogManger();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取swagger注解并放入redis</span><br><span class="line">     */</span><br><span class="line">    public void getAllUrlAndSetRedisForLogManger() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        // 获取带有Controller注解的类</span><br><span class="line">        Map&lt;String, Object&gt; beansMap = applicationContext.getBeansWithAnnotation(Controller.class);</span><br><span class="line">        for (String key : beansMap.keySet()) &#123;</span><br><span class="line">            // 反射获取每个controller类</span><br><span class="line">            Class&lt;?&gt; clazz = beansMap.get(key).getClass();</span><br><span class="line">            // 获取因@Validated注解，导致Cglib代理过的父类。 @Validated会在原类上生成子类，子类不继承父类注解。</span><br><span class="line">            Class&lt;?&gt; userClass = ClassUtils.getUserClass(clazz);</span><br><span class="line"></span><br><span class="line">            String classPath = this.getRequestMappingPath(userClass);</span><br><span class="line">            String apiValue = this.getApiValue(userClass);</span><br><span class="line">            // 获取类的所有方法</span><br><span class="line">            Method[] methods = userClass.getMethods();</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                String methodPath = this.getMethodRequestMappingPath(method);</span><br><span class="line">                String apiOperationPath = this.getApiOperationValue(method);</span><br><span class="line"></span><br><span class="line">                if (StrUtil.isNotEmpty(methodPath)</span><br><span class="line">                        &amp;&amp; StrUtil.isNotEmpty(apiValue)</span><br><span class="line">                        &amp;&amp; StrUtil.isNotEmpty(apiOperationPath)) &#123;</span><br><span class="line">                    apiValue = apiValue.replace(&quot;接口&quot;, &quot;&quot;);</span><br><span class="line">                    result.put(this.deleteBrackets(appName + &quot;/&quot; + classPath + methodPath), apiValue + &quot;|&quot; + apiOperationPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入到redis中</span><br><span class="line">        redisTemplate.opsForHash().putAll(SwaggerConstant.SWAGGER_HASH_KEY, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取类上注解@RequestMapping中的value的值  如：&quot;/back/management&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getRequestMappingPath(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        RequestMapping annotation = clazz.getAnnotation(RequestMapping.class);</span><br><span class="line">        if (annotation == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] values = annotation.value();</span><br><span class="line">        String path = &quot;&quot;;</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            if (StrUtil.isNotEmpty(value)) &#123;</span><br><span class="line">                path = value;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取类上注解@Api中tags的值 如：&quot;后台管理&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getApiValue(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        Api api = clazz.getAnnotation(Api.class);</span><br><span class="line">        if (api == null) &#123;</span><br><span class="line">            String clazzSimpleName = clazz.getSimpleName();</span><br><span class="line">            return clazzSimpleName;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] tags = api.tags();</span><br><span class="line">        String apiValue = &quot;&quot;;</span><br><span class="line">        for (String tag : tags) &#123;</span><br><span class="line">            if (StrUtil.isNotEmpty(tag)) &#123;</span><br><span class="line">                apiValue = tag;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StrUtil.isEmpty(apiValue)) &#123;</span><br><span class="line">            String value = api.value();</span><br><span class="line">            if (StrUtil.isNotEmpty(value)) &#123;</span><br><span class="line">                apiValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return apiValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取方法上注解@RequestMapping、@GetMapping等里边value的值 如：&quot;/add&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getMethodRequestMappingPath(Method method) &#123;</span><br><span class="line">        GetMapping getMapping = method.getAnnotation(GetMapping.class);</span><br><span class="line">        PostMapping postMapping = method.getAnnotation(PostMapping.class);</span><br><span class="line">        DeleteMapping deleteMapping = method.getAnnotation(DeleteMapping.class);</span><br><span class="line">        RequestMapping requestMapping = method.getAnnotation(RequestMapping.class);</span><br><span class="line"></span><br><span class="line">        String[] values = getMapping != null ? getMapping.value()</span><br><span class="line">                : postMapping != null ? postMapping.value()</span><br><span class="line">                : requestMapping != null ? requestMapping.value() : deleteMapping != null ? deleteMapping.value()</span><br><span class="line">                : new String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        String path = &quot;&quot;;</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            if (StrUtil.isNotEmpty(value)) &#123;</span><br><span class="line">                path = value;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取方法上注解@ApiOperation里边value的值 如：&quot;新增&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getApiOperationValue(Method method) &#123;</span><br><span class="line">        ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);</span><br><span class="line">        if (apiOperation == null) &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            return methodName;</span><br><span class="line">        &#125;</span><br><span class="line">        String value = apiOperation.value();</span><br><span class="line">        if (StrUtil.isEmpty(value)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将RESTful风格/&#123;id&#125;，记录为/*</span><br><span class="line">     */</span><br><span class="line">    private String deleteBrackets(String src) &#123;</span><br><span class="line">        if (StrUtil.isEmpty(src)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        src = src.replace(&quot;//&quot;, &quot;/&quot;);</span><br><span class="line">        int i = src.indexOf(&quot;/&#123;&quot;);</span><br><span class="line">        if (i != -1) &#123;</span><br><span class="line">            return src.substring(0, i) + &quot;/*&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作日志</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>swagger</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Gatway过滤器收集接口访问记录，插入到RabbitMQ</title>
    <url>/2021/05/19/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97_2.Gatway%E8%BF%87%E6%BB%A4%E5%99%A8%E6%94%B6%E9%9B%86%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%8F%92%E5%85%A5%E5%88%B0RabbitMQ/</url>
    <content><![CDATA[<p>Gatway过滤器收集接口访问记录，插入到RabbitMQ</p>
<span id="more"></span>

<h1 id="2-Gatway过滤器收集接口访问记录，插入到RabbitMQ"><a href="#2-Gatway过滤器收集接口访问记录，插入到RabbitMQ" class="headerlink" title="2.Gatway过滤器收集接口访问记录，插入到RabbitMQ"></a>2.Gatway过滤器收集接口访问记录，插入到RabbitMQ</h1><ol>
<li>RabbitMQ交换机和队列项目启动时初始化配置</li>
<li>Gatway过滤器拦截所有请求，对表单请求和非表单请求分别处理，获取url和body参数。</li>
<li>将参数组装起来，发送到RabbitMQ。（过滤不记录日志的请求）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.amqp.core.TopicExchange;</span><br><span class="line">import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: hxr</span><br><span class="line"> * @Description: 操作日志交换机和队列初始化</span><br><span class="line"> * @date: 2021/05/19</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    public final static String EXCH_LOG = &quot;exch_log&quot;;</span><br><span class="line"></span><br><span class="line">    public final static String QUEUE_LOG = &quot;queue_log&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TopicExchange exchLog() &#123;</span><br><span class="line">        return new TopicExchange(this.EXCH_LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueLog() &#123;</span><br><span class="line">        return new Queue(this.QUEUE_LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeOrderDicQueue() &#123;</span><br><span class="line">        return BindingBuilder.bind(queueLog()).to(exchLog()).with(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建初始化RabbitAdmin对象</span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);</span><br><span class="line">        // 只有设置为 true，spring 才会加载 RabbitAdmin 这个类</span><br><span class="line">        rabbitAdmin.setAutoStartup(true);</span><br><span class="line">        return rabbitAdmin;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建交换机和对列</span><br><span class="line">    @Bean</span><br><span class="line">    public void createExchangeQueue ()&#123;</span><br><span class="line">        rabbitAdmin.declareExchange(exchLog());</span><br><span class="line">        rabbitAdmin.declareQueue(queueLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.filter;</span><br><span class="line"></span><br><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import com.xiaoruiit.common.constant.AuthConstant;</span><br><span class="line">import com.xiaoruiit.common.domain.UserSignDTO;</span><br><span class="line">import com.xiaoruiit.common.utils.IPUtils;</span><br><span class="line">import com.xiaoruiit.queue.LogHistory;</span><br><span class="line">import com.xiaoruiit.queue.MessageService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line">import org.springframework.cloud.gateway.filter.factory.rewrite.CachedBodyOutputMessage;</span><br><span class="line">import org.springframework.cloud.gateway.route.Route;</span><br><span class="line">import org.springframework.cloud.gateway.support.BodyInserterContext;</span><br><span class="line">import org.springframework.cloud.gateway.support.DefaultServerRequest;</span><br><span class="line">import org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.http.HttpMethod;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line">import org.springframework.http.server.reactive.ServerHttpRequestDecorator;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.util.MultiValueMap;</span><br><span class="line">import org.springframework.web.reactive.function.BodyInserter;</span><br><span class="line">import org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line">import org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">import static org.springframework.cloud.gateway.support.ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @date 2020/05/11</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class GatewayLoggingFilter implements GlobalFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line"></span><br><span class="line">        // 获取用户传来的数据类型</span><br><span class="line">        MediaType mediaType = exchange.getRequest().getHeaders().getContentType();</span><br><span class="line">        ServerRequest serverRequest = new DefaultServerRequest(exchange);</span><br><span class="line">        HttpMethod method = exchange.getRequest().getMethod();</span><br><span class="line">        // 如果是表单请求</span><br><span class="line">        if (method == HttpMethod.POST &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) &#123;</span><br><span class="line">            Mono&lt;String&gt; modifiedBody = serverRequest.bodyToMono(String.class)</span><br><span class="line">                    // .log(&quot;modify_request_mono&quot;, Level.INFO)</span><br><span class="line">                    .flatMap(body -&gt; &#123;</span><br><span class="line">                        assert route != null;</span><br><span class="line">                        recordLog(exchange.getRequest(), body, route);</span><br><span class="line"></span><br><span class="line">                        return Mono.just(body);</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            return getVoidMono(exchange, chain, String.class, modifiedBody);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert route != null;</span><br><span class="line">        recordLog(exchange.getRequest(), &quot;&quot;, route);</span><br><span class="line">        return chain.filter(exchange.mutate().request(exchange.getRequest()).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参照 ModifyRequestBodyGatewayFilterFactory.java 截取的方法</span><br><span class="line">     */</span><br><span class="line">    private Mono&lt;Void&gt; getVoidMono(ServerWebExchange exchange, GatewayFilterChain chain, Class outClass, Mono&lt;?&gt; modifiedBody) &#123;</span><br><span class="line">        BodyInserter bodyInserter = BodyInserters.fromPublisher(modifiedBody, outClass);</span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        headers.putAll(exchange.getRequest().getHeaders());</span><br><span class="line"></span><br><span class="line">        // the new content type will be computed by bodyInserter</span><br><span class="line">        // and then set in the request decorator</span><br><span class="line">        headers.remove(HttpHeaders.CONTENT_LENGTH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CachedBodyOutputMessage outputMessage = new CachedBodyOutputMessage(exchange, headers);</span><br><span class="line">        return bodyInserter.insert(outputMessage, new BodyInserterContext()).then(Mono.defer(() -&gt; &#123;</span><br><span class="line">            ServerHttpRequestDecorator decorator = new ServerHttpRequestDecorator(</span><br><span class="line">                    exchange.getRequest()) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public HttpHeaders getHeaders() &#123;</span><br><span class="line">                    long contentLength = headers.getContentLength();</span><br><span class="line">                    HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">                    httpHeaders.putAll(super.getHeaders());</span><br><span class="line">                    if (contentLength &gt; 0) &#123;</span><br><span class="line">                        httpHeaders.setContentLength(contentLength);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // TODO: this causes a &#x27;HTTP/1.1 411 Length Required&#x27; on httpbin.org</span><br><span class="line">                        httpHeaders.set(HttpHeaders.TRANSFER_ENCODING, &quot;chunked&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return httpHeaders;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public Flux&lt;DataBuffer&gt; getBody() &#123;</span><br><span class="line">                    return outputMessage.getBody();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            return chain.filter(exchange.mutate().request(decorator).build());</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 组装日志需要的字段信息，并发送到RabbitMQ</span><br><span class="line">     *</span><br><span class="line">     * @param request request</span><br><span class="line">     * @param body    请求的body内容</span><br><span class="line">     */</span><br><span class="line">    private void recordLog(ServerHttpRequest request, Object body, Route route) &#123;</span><br><span class="line">        InetSocketAddress address = request.getRemoteAddress();</span><br><span class="line"></span><br><span class="line">        String ip = IPUtils.getIpAddrForGateWay(request);</span><br><span class="line"></span><br><span class="line">        assert address != null;</span><br><span class="line">        // 心跳不记录操作日志 TODO 实现可配置不记录日志</span><br><span class="line">        if (&quot;/message/heartbeats&quot;.equals(request.getURI().getRawPath()))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HttpMethod method = request.getMethod();</span><br><span class="line">        HttpHeaders headers = request.getHeaders();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        URI uri = request.getURI();</span><br><span class="line"></span><br><span class="line">        LogHistory history = new LogHistory();</span><br><span class="line">        history.setIp(ip);</span><br><span class="line">        history.setUrl(uri.toString());</span><br><span class="line">        history.setFunc(request.getURI().getRawPath());</span><br><span class="line">        history.setModel(route.getUri().getHost());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            history.setParams(queryParams.toString().length() &gt; 900 ? &quot;&quot; : queryParams.toString());</span><br><span class="line">            if (method == HttpMethod.POST) &#123;</span><br><span class="line">                history.setBody(body.toString().length() &gt; 900 ? &quot;&quot; : body.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String userStr = headers.getFirst(AuthConstant.USER_TOKEN_HEADER);</span><br><span class="line">            UserSignDTO userSignDto = JSONUtil.toBean(userStr, UserSignDTO.class);</span><br><span class="line">            if (userSignDto != null) &#123;</span><br><span class="line">                history.setUserId(userSignDto.getUserId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        history.setOptTime(LocalDateTime.now());</span><br><span class="line">        try &#123;</span><br><span class="line">        	// 发送到RabbitMQ</span><br><span class="line">            messageService.sendTestMessage(history);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送到RabbitMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.xiaoruiit.common.constant.RabbitQueueConstant;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author xhr</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MessageService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法被controller调用是多线程执行。</span><br><span class="line">     * rabbitTemplate 执行时间是一个递增的过程</span><br><span class="line">     */</span><br><span class="line">    public void sendTestMessage(LogHistory history) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitQueueConstant.EXCH_LOG, &quot;&quot;, JSON.toJSONString(history));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作日志</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Gatway</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>获取RabbitMQ数据，并插入到mysql</title>
    <url>/2021/05/22/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97_3.%E8%8E%B7%E5%8F%96RabbitMQ%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E6%8F%92%E5%85%A5%E5%88%B0mysql/</url>
    <content><![CDATA[<p>获取RabbitMQ数据，并插入到mysql</p>
<span id="more"></span>

<h1 id="获取RabbitMQ数据，并插入到mysql"><a href="#获取RabbitMQ数据，并插入到mysql" class="headerlink" title="获取RabbitMQ数据，并插入到mysql"></a>获取RabbitMQ数据，并插入到mysql</h1><ol>
<li>从RabbitMQ中取数据</li>
<li>获取用户信息，分为登录接口与非登录接口<ol>
<li>登录接口<ol>
<li>对账号解密，通过远程接口查出userId、userCode、userName。</li>
</ol>
</li>
<li>非登录接口<ol>
<li>通过userId去Redis中查询userCode和userName</li>
<li>redis中没有，调用远程接口查询并将结果插入到redis</li>
</ol>
</li>
</ol>
</li>
<li>将 模块+接口 作为key获取redis中key对应的swagger注释</li>
<li>获取其他参数，设置主键值。</li>
<li>每10个插入到mysql库中。（缓解插入压力）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.logmanager.queue;</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.xiaoruiit.common.constant.RabbitQueueConstant;</span><br><span class="line">import com.xiaoruiit.common.service.RedisService;</span><br><span class="line">import com.xiaoruiit.common.utils.*;</span><br><span class="line">import com.xiaoruiit.logmanager.constant.LogMgrIdConstants;</span><br><span class="line">import com.xiaoruiit.logmanager.dao.MyLogHistoryMapper;</span><br><span class="line">import com.xiaoruiit.logmanager.entity.auto.LogmgrLogHistory;</span><br><span class="line">import com.xiaoruiit.logmanager.entity.vo.UserVO;</span><br><span class="line">import com.xiaoruiit.logmanager.service.MdmService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.bouncycastle.crypto.InvalidCipherTextException;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class QueueMessageListener &#123;</span><br><span class="line">    private static final String LOG_USER_INFO_HASH_KEY = &quot;logmgr:user_info&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 合并插入值</span><br><span class="line">     */</span><br><span class="line">    private final static int INSERT_CNT = 10;</span><br><span class="line">    /**</span><br><span class="line">     * 合并插入超时</span><br><span class="line">     */</span><br><span class="line">    private final static int INSERT_TIME_OUT = 5000;</span><br><span class="line">    /**</span><br><span class="line">     * 合并插入集合</span><br><span class="line">     */</span><br><span class="line">    private static final List&lt;LogmgrLogHistory&gt; LIST = new ArrayList&lt;&gt;();</span><br><span class="line">    private long lastInsert;</span><br><span class="line">    private final Lock lock = new ReentrantLock(); //可重入的互斥锁</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogHistoryMapper myHistoryMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MdmService userService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监听器单线程执行</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = RabbitQueueConstant.QUEUE_LOG)</span><br><span class="line">    public void logListener(String msg) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 优化点：批量插入</span><br><span class="line">            LogmgrLogHistory history = JSON.parseObject(msg, LogmgrLogHistory.class);</span><br><span class="line">            if (StrUtil.isEmpty(history.getModel()) || history.getUserId() == null || StrUtil.isEmpty(history.getUserId() + &quot;&quot;)) &#123;</span><br><span class="line">                if (!(&quot;/oauth/token&quot;.equals(history.getFunc())))&#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // TODO 登录日志入库 登录时获取不到userId单独处理</span><br><span class="line">                String url = history.getUrl();</span><br><span class="line">                Map&lt;String, String&gt; params = URLUtils.getParamsByUrl(url);</span><br><span class="line">                signInParameterHandle(params);</span><br><span class="line">                String userPhone = params.get(&quot;username&quot;);</span><br><span class="line">                // 通过手机号获取用户信息  用户id，code，名称</span><br><span class="line">                Result&lt;UserVO&gt; userByMobile = userService.getUserByMobile(userPhone);</span><br><span class="line">                if (userByMobile.getData()!= null)&#123;</span><br><span class="line">                    history.setUserId(userByMobile.getData().getUserId());</span><br><span class="line">                    history.setUserCode(userByMobile.getData().getUserCode());</span><br><span class="line">                    history.setUserName(userByMobile.getData().getUserName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                setUserInfo(history);</span><br><span class="line">            &#125;</span><br><span class="line">            if (StrUtil.isNotEmpty(history.getModel()) &amp;&amp; StrUtil.isNotEmpty(history.getFunc())) &#123;</span><br><span class="line">                Object o = redisService.hGet(Constant.SWAGGER_HASH_KEY, history.getModel() + history.getFunc());</span><br><span class="line">                if (o == null) &#123;</span><br><span class="line">                    o = redisService.hGet(Constant.SWAGGER_HASH_KEY, history.getModel() + deleteLastSlash(history.getFunc()));</span><br><span class="line">                &#125;</span><br><span class="line">                history.setDescription(o == null ? &quot;&quot; : o.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            if (history.getUrl() != null &amp;&amp; history.getUrl().length() &gt; 800) &#123;</span><br><span class="line">                history.setUrl(history.getUrl().substring(0, 790));</span><br><span class="line">            &#125;</span><br><span class="line">            if (history.getFunc() != null &amp;&amp; history.getFunc().length() &gt; 250) &#123;</span><br><span class="line">                history.setFunc(history.getFunc().substring(0, 250));</span><br><span class="line">            &#125;</span><br><span class="line">            if (StrUtil.isNotEmpty(history.getBody()) &amp;&amp; history.getBody().length() &gt;= 4000) &#123;</span><br><span class="line">                history.setBody(history.getBody().substring(0, 4000));</span><br><span class="line">            &#125;</span><br><span class="line">            history.setLogHisId(IdWorker.nextId(LogMgrIdConstants.LOG_HIS_ID_PREFIX));</span><br><span class="line">            LIST.add(history);</span><br><span class="line">            if (LIST.size() &gt;= INSERT_CNT) &#123;</span><br><span class="line">                insertAndReset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setUserInfo(LogmgrLogHistory history) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object o = redisService.hGet(LOG_USER_INFO_HASH_KEY, history.getUserId() + &quot;&quot;);</span><br><span class="line">            if (o != null) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;</span><br><span class="line">                history.setUserName(map.get(&quot;userName&quot;) + &quot;&quot;);</span><br><span class="line">                history.setUserCode(map.get(&quot;userCode&quot;) + &quot;&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Result result = userService.getUserInfoById(history.getUserId());</span><br><span class="line">            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) result.getData();</span><br><span class="line">            if (map != null) &#123;</span><br><span class="line">                history.setUserName(map.get(&quot;userName&quot;) + &quot;&quot;);</span><br><span class="line">                history.setUserCode(map.get(&quot;userCode&quot;) + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            redisService.hSet(LOG_USER_INFO_HASH_KEY, history.getUserId() + &quot;&quot;, map);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String deleteLastSlash(String src) &#123;</span><br><span class="line">        int i = src.lastIndexOf(&quot;/&quot;);</span><br><span class="line">        if (i != -1) &#123;</span><br><span class="line">            return src.substring(0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监听不满足合并要求的数据</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(fixedDelay = 10000)</span><br><span class="line">    public void listListener() &#123;</span><br><span class="line">        if (lock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!LIST.isEmpty() &amp;&amp; System.currentTimeMillis() - lastInsert &gt; INSERT_TIME_OUT) &#123;</span><br><span class="line">                    insertAndReset();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void insertAndReset() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;myHistoryMapper.insertList(LIST) size = &#123;&#125;&quot;, LIST.size());</span><br><span class="line">            myHistoryMapper.insertList(LIST);</span><br><span class="line">            LIST.clear();</span><br><span class="line">            lastInsert = System.currentTimeMillis();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LIST.forEach(lh -&gt; lh.setLogHisId(IdWorker.nextId(LogMgrIdConstants.LOG_HIS_ID_PREFIX)));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 解密</span><br><span class="line">    public void signInParameterHandle(Map&lt;String, String&gt; parameters) throws InvalidCipherTextException &#123;</span><br><span class="line">        String usernamePlaintext;</span><br><span class="line"></span><br><span class="line">        String username = parameters.get(&quot;username&quot;);</span><br><span class="line">        String signInType = parameters.get(&quot;signInType&quot;);</span><br><span class="line">        if (&quot;1&quot;.equals(signInType)) &#123;</span><br><span class="line">            String sm2PublicKeyHex = parameters.get(&quot;公钥字符串&quot;);</span><br><span class="line"></span><br><span class="line">            String sm2PrivateKeyHex = (String) redisService.get(&quot;私钥redis中key&quot; + sm2PublicKeyHex);</span><br><span class="line">            // 还原私钥 私钥16进制格式</span><br><span class="line">            BigInteger privateKeyD = new BigInteger(sm2PrivateKeyHex, 16);</span><br><span class="line"></span><br><span class="line">            usernamePlaintext = Sm2Utils.sm2PrivateKeyDecrypt(privateKeyD, username);</span><br><span class="line">            parameters.put(&quot;username&quot;, usernamePlaintext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>操作日志</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    <content><![CDATA[<p>数据结构和算法</p>
<span id="more"></span>

<h1 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构-树"></a>数据结构-树</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>结点和边组成的，不存在环的一种数据结构。</p>
<p>树满足递归定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根结点后，得到的若干个子结构也是树，通常称作子树。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zOi1UHoS8WhXdEa.png" alt="image-20210829212230523"></p>
<p>分支和层次关系</p>
<p>根节点</p>
<p>父节点</p>
<p>子节点</p>
<p>叶子节点：没有子节点</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>存储结构</p>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>时间复杂度：O(n)</p>
<ul>
<li><p>前(先)序遍历，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void preOrderTraverse(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    System.out.print(node.data + &quot; &quot;);</span><br><span class="line">    preOrderTraverse(node.left);</span><br><span class="line">    preOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 中序遍历</span><br><span class="line">public static void inOrderTraverse(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    inOrderTraverse(node.left);</span><br><span class="line">    System.out.print(node.data + &quot; &quot;);</span><br><span class="line">    inOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 后序遍历</span><br><span class="line">public static void postOrderTraverse(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    postOrderTraverse(node.left);</span><br><span class="line">    postOrderTraverse(node.right);</span><br><span class="line">    System.out.print(node.data + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2.二叉搜索树"></a>2.二叉搜索树</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>特性：</p>
<ul>
<li>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于本结点的值。</li>
<li>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</li>
<li>在二叉查找树中，会尽可能规避两个结点数值相等的情况。（《数据结构》严蔚敏-数值不能相同）</li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。</li>
</ul>
<h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>时间复杂度：O(logn)。</p>
<p>如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>时间复杂度为 O(logn)。</p>
<p>删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。分为下面三种情况。</p>
<ul>
<li>要删除的结点是某个叶子结点，则直接删除。将其父结点指针指向 null 即可。</li>
<li>如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>如果要删除的结点有两个子结点，则有两种可行的操作方式。<ul>
<li>第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。</li>
<li>第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。</li>
</ul>
</li>
</ul>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>时间复杂度为 O(logn)。</p>
<p>查询步骤：</p>
<ul>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序存储</li>
<li>遍历逻辑复杂一些</li>
<li>根据数值查询时间复杂度O(logn)</li>
<li>新增时间复杂度O(logn)</li>
<li>删除时间复杂度O(logn)</li>
</ul>
<h4 id="二叉搜索树算法题"><a href="#二叉搜索树算法题" class="headerlink" title="二叉搜索树算法题"></a>二叉搜索树算法题</h4><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h3 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="3.满二叉树"></a>3.满二叉树</h3><p>满二叉树，定义为只有最后一层无任何子结点，其他所有层上的所有结点都有两个子结点的二叉树。</p>
<h3 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="4.完全二叉树"></a>4.完全二叉树</h3><p>完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。</p>
<p>之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</p>
<h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><ul>
<li><p>链式存储法</p>
<p>也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针</p>
</li>
<li><p>顺序存储法-数组</p>
<p>按照规律把结点存放在数组里，如下图所示，为了方便计算，我们会约定把根结点放在下标为 1 的位置。随后，B 结点存放在下标为 2 的位置，C 结点存放在下标为 3 的位置，依次类推。</p>
<p>结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 * i 的位置，X 的右子结点总是存放在 2 * i + 1 的位置。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/qbQ3WFhRVlGHLM1.png" alt="image-20210829212930204"></p>
</li>
</ul>
<h3 id="5-二叉堆"><a href="#5-二叉堆" class="headerlink" title="5.二叉堆"></a>5.二叉堆</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>特点：</p>
<ul>
<li><p>二叉堆是一棵<strong>完全二叉树</strong></p>
</li>
<li><p>堆中某个节点的值总是不大于其父节点的值（所以也叫做<strong>大根堆</strong>），或者堆中某个节点的值总是不小于其父节点的值（所以也叫做<strong>小根堆</strong>）</p>
</li>
<li><p>注意：层次大的元素值不一定小于层次小的元素</p>
</li>
</ul>
<h4 id="数据操作-2"><a href="#数据操作-2" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h5><p>从倒数第一个非叶子节点（22）开始shift-Down，直到所有非叶子节点。</p>
<p>时间复杂度：O(n)</p>
<h5 id="新增-1"><a href="#新增-1" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>添加元素，依据完全二叉树，添加在最后</p>
</li>
<li><p>递归Shift Up，递归地和父节点比较，交换</p>
</li>
</ul>
<p>时间复杂度：O(logn)</p>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><ul>
<li>取出最大元素</li>
<li>完全二叉树最后的值放到堆顶</li>
<li>递归Shift down，堆顶递归的与孩子节点比较并交换</li>
</ul>
<p>时间复杂度：O(logn)</p>
<h3 id="6-红黑树-TODO"><a href="#6-红黑树-TODO" class="headerlink" title="6.红黑树 TODO"></a>6.红黑树 TODO</h3><h3 id="7-前缀（字典）树-Trie"><a href="#7-前缀（字典）树-Trie" class="headerlink" title="7.前缀（字典）树 Trie"></a>7.前缀（字典）树 Trie</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>字符串集合的前缀进行合并，每个根结点到叶子结点的链条就是一个字符串。</p>
<p>特点：</p>
<p>第一，根结点不包含字符；</p>
<p>第二，除根结点外每一个结点都只包含一个字符；</p>
<p>第三，从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XHE3T5UnkSswlrR.png" alt="image-20210829213733300"></p>
<h4 id="字典树算法题"><a href="#字典树算法题" class="headerlink" title="字典树算法题"></a>字典树算法题</h4><p>输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）</p>
<h3 id="8-线段树"><a href="#8-线段树" class="headerlink" title="8.线段树"></a>8.线段树</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>一种按照二叉树的形式存储数据的结构，每个节点保存的都是数组里某一段的总和。</p>
<p>适用于数据很多，而且需要频繁更新并求和的操作。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TNVpEio75FntMsK.png" alt="image-20210829214048328"></p>
<p>更新数组里某个元素的数值，时间复杂度 O(logn)。</p>
<p>对数组某个区间段里的元素进行求和，时间复杂度O(logn)</p>
<p>LeetCode 315. TODO</p>
<h3 id="9-树状数组"><a href="#9-树状数组" class="headerlink" title="9.树状数组"></a>9.树状数组</h3>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法-二分查找</title>
    <url>/2020/07/29/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><em>二分查找</em>也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素有序排列。</p>
<span id="more"></span>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int binaySearch(int[] data, int des)&#123;</span><br><span class="line">       int start = 0;</span><br><span class="line">       int end = data.length-1;</span><br><span class="line">       while(start &lt;= end)&#123;// end = -1时打破循环</span><br><span class="line">           int middle = (end +start) &gt;&gt;&gt; 1;// 右移一位，相当于/2</span><br><span class="line">           if (des == data[middle])&#123;</span><br><span class="line">               return middle;</span><br><span class="line"></span><br><span class="line">           &#125; else if (des &lt; data[middle])&#123;</span><br><span class="line">               end = middle - 1;</span><br><span class="line"></span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               start = middle+1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>查找算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客！</title>
    <url>/2018/04/11/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<pre><code>欢迎来到我的博客！
    一直想要开通一个属于自己的博客，以前只是模糊的觉得这个东西好，并且在建立的过程遇到些困难就放弃了。
现在我想要用它整理分享自己学到的东西，表达生活中的所想所悟。随后会发自己建立博客的过程。欢迎大家常来交
流评论。
</code></pre>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>测试环境-问题</title>
    <url>/2020/10/17/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>测试环境-问题</p>
<span id="more"></span>

<h1 id="测试环境-问题"><a href="#测试环境-问题" class="headerlink" title="测试环境-问题"></a>测试环境-问题</h1><p>jwt</p>
<p>​    问题：操作时未到jwt过期时间，系统跳到登录页面。</p>
<p>​        测试环境操作同一账户，同一IP地址（127.0.0.1）,A的操作jwt续期生成新jwt返回给A，B使用旧jwt访问时，后端比对错误，返回给前端错误码，前端控制浏览器跳转到登录。</p>
<p>mysql</p>
<p>​    问题1：线上库无法连接</p>
<p>​        可能修改了账号权限</p>
<p>​    问题2：测试库无法修改字段，报错<code>no space left on device</code>。</p>
<p>​        磁盘空间满了，可以删除备份文件、日志文件</p>
<p>solor</p>
<p>​    问题：后端程序断点执行完毕，但方法无返回值。前端页面一直等待后端返回。</p>
<p>​        solor服务器挂掉。</p>
<p>redis</p>
<p>​    问题1：线上正常，本地环境无法连接线上redis。</p>
<p>​    问题2：redis经常宕机。</p>
<p>​        官方提供的redis是Linux环境。windows环境是第三方改的，redis不稳定，windows本身是多线程的也不稳定，都会造成redis宕机。迁移到linux环境。</p>
]]></content>
      <categories>
        <category>测试环境</category>
      </categories>
      <tags>
        <tag>测试环境</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器-非信任证书</title>
    <url>/2020/10/29/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%9D%9E%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>浏览器-谷歌</p>
<span id="more"></span>

<h1 id="浏览器-非信任证书"><a href="#浏览器-非信任证书" class="headerlink" title="浏览器-非信任证书"></a>浏览器-非信任证书</h1><p>问题：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ivPNLqhudzxmeSX.png" alt="image-20201029134637643"></p>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--test-type --ignore-certificate-errors --disable-web-security --user-data-dir</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4nJjHwCIdvr8i6G.png" alt="image-20201029135339320"></p>
<p>解决提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--test-type</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/YOB4VAQlimWJUth.png" alt="image-20201029134849030"></p>
<p>解决证书错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--ignore-certificate-errors</span><br></pre></td></tr></table></figure>

<p>解决跨域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--test-type --ignore-certificate-errors </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>两大数的积</title>
    <url>/2020/05/13/%E7%BC%96%E7%A8%8B%E9%A2%98-%E4%B8%A4%E5%A4%A7%E6%95%B0%E7%9A%84%E7%A7%AF/</url>
    <content><![CDATA[<p>随机给定两个超大整数，实现计算两数之乘积。</p>
<span id="more"></span>

<h1 id="两大数的积"><a href="#两大数的积" class="headerlink" title="两大数的积"></a>两大数的积</h1><p>​        随机给定两个超大整数，实现计算两数之乘积。如“111111111111111”和“222222222222222”，输出乘积“24691358024691308641975308642”</p>
<p>思路：</p>
<pre><code>1.将两个数存到两个整数数组中
2.new 结果数据，长度为两个整数数组之和
3.两个数组逐位相乘后保存在结果数组中
4.处理进位，将数组中超过10的数据对10取余，数组前一位为/10
5.遍历结果数组。结果数组最前边为0时，处理掉。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class NumberTwoProduct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;22&quot;;</span><br><span class="line">        String str2 = &quot;22&quot;;</span><br><span class="line"></span><br><span class="line">        //1.将两个数存到两个整数数组中</span><br><span class="line">        char[] num1 = str1.toCharArray();</span><br><span class="line">        char[] num2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        //2.new 结果数据，长度为两个整数数组之和</span><br><span class="line">        int[] result = new int[num1.length + num2.length];</span><br><span class="line"></span><br><span class="line">        //3.两个数组逐位相乘后保存在结果数组中</span><br><span class="line">        for (int i = 0; i &lt; num1.length; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt; num2.length; j++)&#123;</span><br><span class="line">                result[i + j + 1] += (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.处理进位，数组前一位为前一位+本位/10，数组本位为本位%10</span><br><span class="line">        for (int i = result.length -1 ; i &gt; 0; i--)&#123;</span><br><span class="line">            if (result[i] &gt;= 10)&#123;</span><br><span class="line">                result[i - 1] += result[i] / 10;</span><br><span class="line">                result[i] %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.从后往前遍历结果数组,去除最前边的0</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; result.length; i++)&#123;</span><br><span class="line">            if (i == 0 &amp;&amp; result[i] == 0 )</span><br><span class="line">                continue;</span><br><span class="line">            stringBuilder.append(result[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进制转换</title>
    <url>/2020/05/13/%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>实现将10进制数字字符串转换为16进制数字字符串。</p>
<span id="more"></span>

<h1 id="Java进制转换"><a href="#Java进制转换" class="headerlink" title="Java进制转换"></a>Java进制转换</h1><p>实现将10进制数字字符串转换为16进制数字字符串。如“155”，输出“0x9B”。</p>
<p>数学上如何进行进制转换：155%16为进制的最后一位，155/16%16为进制的倒数第二位，依次类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @see java.lang.Integer#toString(int i, int radix)</span><br><span class="line"> /</span><br><span class="line">public class ExchangeSystem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 155;</span><br><span class="line">        //代表进制的数组</span><br><span class="line">        char[] arr = new char[]&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;</span><br><span class="line">        StringBuilder result = new StringBuilder(&quot;0x&quot;);</span><br><span class="line">        while(a&gt;0)&#123;</span><br><span class="line">            //a%16为进制的最后一位，a/16%16为进制的倒数第二位</span><br><span class="line">            result.insert(2,arr[a%16]);</span><br><span class="line">            a /= 16;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以查看jdk进制转化的源码。java.lang.Integer的toString(int i, int radix)方法</p>
]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2020/01/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>为某个类提供代理，以控制对这个类的访问</p>
<span id="more"></span>

<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>问题：</strong>有时直接访问对象时带来一些问题，比如对象创建开销很大，或者某些主业务前后需要别的逻辑。</p>
<p><strong>解决方案：</strong>图片的加载很慢，可以默认图片先代替。主业务需要有事务控制、权限判断、日志记录。</p>
<p><strong>优点：</strong></p>
<p>​        1.职责清晰,程序员在业务类中只有增删改的具体实现，事务、权限、日志通过代理（AOP）织入业务类，事务、权限、日志的具体实现放在事务、权限、日志各自的类中。</p>
<p>​        2.增加了扩展性，事务、权限、日志可作为框架引入，并且引入的框架可自由组合。</p>
<h2 id="1-静态代理："><a href="#1-静态代理：" class="headerlink" title="1.静态代理："></a>1.静态代理：</h2><p>静态代理在使用时,需要定义接口,被代理对象与代理对象一起实现相同的接口。</p>
<p><strong>局限性：</strong></p>
<p>​    如果同时代理多个类，依然会导致类无限扩展</p>
<p>​    如果类中有多个方法，同样的逻辑需要反复实现</p>
<p><strong>例子：</strong>追求者找两个同学送礼物给女神，两个同学顺序可变</p>
<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//女神</span><br><span class="line">public class Girl &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Girl(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//送礼物 被代理对象的接口</span><br><span class="line">public interface SendGift &#123;</span><br><span class="line">    void sendHower();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//追求者</span><br><span class="line">public class Persuit implements SendGift&#123;</span><br><span class="line">    private Girl girl;</span><br><span class="line"></span><br><span class="line">    public Persuit(Girl girl)&#123;</span><br><span class="line">        this.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendHower() &#123;</span><br><span class="line">        System.out.println(girl.getName() + &quot;给你花&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//学生1</span><br><span class="line">public class Student1 implements SendGift&#123;</span><br><span class="line"></span><br><span class="line">    private SendGift sendGift;</span><br><span class="line"></span><br><span class="line">    public Student1(SendGift sendGift)&#123;</span><br><span class="line">        this.sendGift = sendGift;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendHower() &#123;</span><br><span class="line">        System.out.println(&quot;我是同学1，我是帮忙的&quot;);</span><br><span class="line"></span><br><span class="line">        sendGift.sendHower();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我是同学1，我帮忙结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student2 implements SendGift &#123;</span><br><span class="line">    private SendGift sendGift;</span><br><span class="line"></span><br><span class="line">    public Student2(SendGift sendGift)&#123;</span><br><span class="line">        this.sendGift = sendGift;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendHower() &#123;</span><br><span class="line">        System.out.println(&quot;我是同学2,我是帮忙的&quot;);</span><br><span class="line"></span><br><span class="line">        sendGift.sendHower();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我是同学2,我帮忙结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Girl girl = new Girl(&quot;zs&quot;);</span><br><span class="line">        Persuit persuit = new Persuit(girl);</span><br><span class="line">        </span><br><span class="line">        //先学生1，后学生2</span><br><span class="line">        Student2 student2 = new Student2(persuit);</span><br><span class="line">        Student1 student1 = new Student1(student2);</span><br><span class="line">        student1.sendHower();</span><br><span class="line"></span><br><span class="line">		//先学生2，后学生1</span><br><span class="line">		Student1 student1 = new Student1(persuit);</span><br><span class="line">        Student2 student2 = new Student2(student1);</span><br><span class="line">        student2.sendHower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<pre><code>//先学生1，后学生2
我是同学1，我是帮忙的
我是同学2,我是帮忙的
zs给你花
我是同学2,我帮忙结束
我是同学1，我帮忙结束

//先学生2，后学生1
我是同学2,我是帮忙的
我是同学1，我是帮忙的
zs给你花
我是同学1，我帮忙结束
我是同学2,我帮忙结束
</code></pre>
<p>测试类执行结果1的部分解释：</p>
<p>​    student1.sendHower();  </p>
<p>​    System.out.println(“我是同学1，我是帮忙的”);</p>
<p>​    sendGift.sendHower();</p>
<pre><code>/*
sendGift → student2
student2传入Student1的构造方法  public Student1(SendGift sendGift)&#123;
    this.sendGift = sendGift;
&#125;)
上边的sendGift.sendHower();即student2.sendHower();
*/
</code></pre>
<p>System.out.println(“我是同学2，我是帮忙的”);</p>
<p>再往下一样</p>
<h2 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h2><p><strong>首要条件：</strong>被代理类必须实现一个接口。</p>
<p><strong>应用场景：</strong>日志系统、事务提交或回退、拦截器、权限控制等。面对切面编程AOP的核心就是动态代理机制。</p>
<p>静态代理中每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类。所以我们想<strong>通过一个代理类完成全部的代理功能，那么我们就需要用动态代理</strong>.</p>
<p><strong>动态代理</strong>是在运行时，<strong>通过反射机制实现动态代理，能够代理各种类型的对象</strong>。</p>
<p>在Java中实现动态代理机制，需要<code>java.lang.reflect.InvocationHandler</code>接口和 <code>java.lang.reflect.Proxy</code>类的支持。</p>
<p>java.lang.reflect.InvocationHandler接口的方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args)</span><br><span class="line">        throws Throwable;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Object proxy<br> 被代理对象</p>
</li>
<li><p>Method method<br> 要调用的方法</p>
</li>
<li><p>Object[] args<br> 方法调用时所需要的参数</p>
<p>@return 被代理接口的实现类</p>
</li>
</ul>
<p><code>java.lang.reflect.Proxy</code>类中重要的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">  InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClassLoader loader<br> 类加载器</li>
<li>Class&lt;?&gt;[] interfaces<br> 得到被代理类全部的接口</li>
<li>InvocationHandler h<br> 得到InvocationHandler接口的子类的实例</li>
</ul>
<p><strong>Implementation</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Subject</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行request方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//无接口的鱼类</span><br><span class="line">public class Fish &#123;</span><br><span class="line">    public void getWater()&#123;</span><br><span class="line">        System.out.println(&quot;给我水&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动态代理类  实现动态代理的工具类</span><br><span class="line">public class ProxyHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    //用来代表被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @parm target 被动态代理类的实例</span><br><span class="line">     * @return 动态代理类的实例</span><br><span class="line">     */</span><br><span class="line">    public Object newProxyInstance(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line"></span><br><span class="line">        return  Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写InvocationHandler类的invoke方法，在被代理对象的方法中嵌入代码</span><br><span class="line">     *</span><br><span class="line">     * @param proxy 被代理对象</span><br><span class="line">     * @param method 要控制的被代理对象的方法</span><br><span class="line">     * @param args 被代理对象方法需要的参数</span><br><span class="line">     * @return Object 被代理接口的实现类。</span><br><span class="line">     *</span><br><span class="line">     * @see InvocationHandler#invoke(Object, Method, Object[])</span><br><span class="line">     * @see java.lang.reflect.Proxy</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;被代理对象方法执行前&quot;);</span><br><span class="line"></span><br><span class="line">        Object ret = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //调用目标方法</span><br><span class="line">            ret = method.invoke(target, args);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;调用发生异常&quot;);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;被代理对象方法执行后&quot;);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//客户端测试类</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProxyHandler handler = new ProxyHandler();</span><br><span class="line">        Subject subject = (Subject) handler.newProxyInstance(new ConcreteSubject());</span><br><span class="line">        subject.request();</span><br><span class="line"></span><br><span class="line">        ProxyHandler handler2 = new ProxyHandler();</span><br><span class="line">        //不能代理无接口的类Fish，Proxy中target.getClass().getInterfaces()报错</span><br><span class="line">        Fish fish = (Fish) handler.newProxyInstance(new ConcreteSubject());</span><br><span class="line">        fish.getWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试的控制台显示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">被代理对象方法执行前</span><br><span class="line">执行request方法</span><br><span class="line">被代理对象方法执行后</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to proxy.Fish</span><br><span class="line">	at proxy.Client.main(Client.java:10)</span><br></pre></td></tr></table></figure>

<h2 id="3-cglib代理"><a href="#3-cglib代理" class="headerlink" title="3.cglib代理"></a>3.cglib代理</h2><p>这里用的是spring的cglib代理，用到了spring-core.3.2.5.jar</p>
<p><strong>应用场景：</strong>Spring的AOP中，如果加入容器的目标对象有实现接口,用JDK代理.如果目标对象没有实现接口,用Cglib代理.</p>
<p><strong>原理：</strong>动态生成代理类继承被代理类，执行代理类的方法时拦截，在拦截方法中写调用目标的逻辑代码。</p>
<p><strong>结合实例的详细流程：</strong>动态生成代理类Proxy继承被代理类UserDao，执行代理类Proxy的重写父类Proxy的方法save()时，intercept方法拦截，在intercept方法中执行UserDao的save方法，可在save方法前后添加事务等其他业务代码。</p>
<p><strong>优点：</strong>被代理类不需要实现接口。</p>
<p><strong>注意：</strong>cglib代理是动态生成代理类去继承被代理类，final修饰的类无法被继承，方法被final修饰，无法重写。被static修饰，重写无效。 cglib生成对象比JDK动态代理开销更大。</p>
<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//被代理类 未实现接口</span><br><span class="line">public class UserDao &#123;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        System.out.println(&quot;保存数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.cglib.proxy.Enhancer;</span><br><span class="line">import org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line">import org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Cglib子类代理工厂</span><br><span class="line"> * 需要spring-core的jar包</span><br><span class="line"> *</span><br><span class="line"> * @see MethodInterceptor</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ProxyFactory implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    //被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public  ProxyFactory(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @return 控制被代理对象的实例</span><br><span class="line">     */</span><br><span class="line">    public  Object getProxyInstance()&#123;</span><br><span class="line">        //cglib中的工具类</span><br><span class="line">        Enhancer en = new Enhancer();</span><br><span class="line">        //设置父类</span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line"></span><br><span class="line">        en.setCallback(this);</span><br><span class="line">        //创建实例</span><br><span class="line">        return en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * MethodInterceptor 的方法</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;开始事务&quot;);</span><br><span class="line"></span><br><span class="line">        //执行目标对象的方法</span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;开始事务&quot;);</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserDao target = new UserDao();</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始事务</span><br><span class="line">保存数据</span><br><span class="line">开始事务</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的介绍、原理、常用的实现方式。</p>
<span id="more"></span>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p> <strong>介绍</strong>：单例模式的类只有单个对象会被创建（实例化），向其他类只提供一种访问方式。可以全局访问.</p>
<p><strong>解决了什么</strong>：只能有一个实例操作资源。多个打印任务，正在打印的实例只存在一个。</p>
<p><strong>优点</strong>：减小了频繁创建和销毁类（GC）的系统开销。多线安全的单例模式解决了多线程问题。</p>
<p><strong>哪里用到了</strong>：要求只有一个对象的场景.Controller类中的Service类可用单例模式创建对象。Spring用单例模式管理注入容器的类。</p>
<p><strong>如何实现：</strong>使用一个私有静态变量、一个私有构造函数、以及一个公有静态函数来实现。</p>
<h2 id="Implementation（具体实现）："><a href="#Implementation（具体实现）：" class="headerlink" title="Implementation（具体实现）："></a>Implementation（具体实现）：</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iJUyFpWdfhulX9S.gif" alt="Singleton Implementation - UML Class Diagram"></p>
<h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><p><strong>优点：</strong>支持lazy loading 。私有静态变量 instance被延迟实例化，节约资源。</p>
<p><strong>缺点：</strong>不支持多线程。多线程环境下是不安全的，如果多个线程同时进入 <code>if (instance == null)</code> ，并且此时instance 为 null，会实例化多次instance。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    //私有化构造函数</span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  	//对外提供唯一访问方法</span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">    	return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-饿汉式："><a href="#2-饿汉式：" class="headerlink" title="2.饿汉式："></a>2.饿汉式：</h3><p>类加载（classloader）就实例化 instance，避免了多线程问题，无lazy loading 的效果。<br><strong>优点：</strong>支持多线程。</p>
<p><strong>缺点：</strong>类加载时就实例化 instance，而不是使用时实例化instance，浪费内存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123; </span><br><span class="line">    private static Singleton instance = new Singleton(); </span><br><span class="line">    private Singleton ()&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123; </span><br><span class="line">        return instance; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-双重校验锁"><a href="#3-双重校验锁" class="headerlink" title="3.双重校验锁"></a>3.双重校验锁</h3><p><strong>优点：</strong>支持多线程，有lazy loading效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	//volatile防止JVM编译器指令重排</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getinstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">        	//对实例化的代码加锁</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个<code>if (instance == null)</code>，instance没有被实例化时，对实例化内容加锁。避免非必要加锁。</p>
<p>第二个<code>if (instance == null)</code>，第一次实例化instance时，防止多个线程在synchronized处等待并执行<code>instance = new Singleton()</code>；</p>
<p><strong>volatile 修饰instance的原因：</strong> JVM 具有指令重排的特性，多线程环境下会导致一个线程获得还没有初始化的实例。volatile可禁止JVM指令重排。</p>
<p><strong>具体描述：</strong></p>
<p>​    <code>instance = new Singleton();</code> </p>
<p>实例化对象的代码分为三个指令执行：</p>
<ol>
<li><p>为 instance 分配内存空间</p>
</li>
<li><p>初始化 instance </p>
</li>
<li><p>将 instance 指向分配的内存地址</p>
<p>线程 T1 执行了 1 和 3时，线程T2获取instance，T2会获得一个不该为null的instance。</p>
<p>volatile广泛存在于java并发系列中。</p>
</li>
</ol>
<h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><p><strong>优点：</strong> 支持lazy loading，多线程安全。实现简单。</p>
<p><strong>缺点：</strong> 只适用于静态域的情况。（菜鸟教程提到）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    	private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    	return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private static class SingletonHolder静态内部类不会初始化对象，多次调用getInstance()得到的是同一个对象INSTANCE。</p>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举:"></a>5.枚举:</h3><p><strong>缺点：</strong> 无lazy loading。<br><strong>优点：</strong> 自动支持序列化机制，可防止反射，能避免多线程同步问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    //私有化构造函数</span><br><span class="line">    private User()&#123; &#125;</span><br><span class="line"> </span><br><span class="line">    //定义一个静态枚举类</span><br><span class="line">    static enum SingletonEnum&#123;</span><br><span class="line">        //创建一个枚举对象，该对象天生为单例</span><br><span class="line">        INSTANCE;</span><br><span class="line">        private User user;</span><br><span class="line">        //私有化枚举的构造函数</span><br><span class="line">        private SingletonEnum()&#123;</span><br><span class="line">            user=new User();</span><br><span class="line">        &#125;</span><br><span class="line">        public User getInstnce()&#123;</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //对外暴露一个获取User对象的静态方法</span><br><span class="line">    public static User getInstance()&#123;</span><br><span class="line">        return SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance()==User.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为true</span><br></pre></td></tr></table></figure>

<p><strong>未完成：</strong> 静态内部类只适用于静态域，枚举如何避免多线程和反序列化，未防止反射破解单例。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2020/01/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>主要功能：把对象的实例化部分抽取了出来，降低了系统中代码耦合度，增强了系统的扩展性。</p>
<span id="more"></span>

<p>工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式。</p>
<h1 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单工厂：简单工厂把对象的实例化单独放到一个类中去维护。</span><br><span class="line"> * 工厂角色：</span><br><span class="line"> *  用户类：不同用户需要不同的产品</span><br><span class="line"> *  产品类：不同的产品类对应不同的产品</span><br><span class="line"> *  工厂类：根据用户不同的需求产生不同的产品实例化对象</span><br><span class="line"> * 例子：</span><br><span class="line"> *  用户需要各种不同的产品，不同的客户类中创建了不同的产品类，产品类发生改变时，每个用户类内部需要改变。</span><br><span class="line"> *  简单工厂对客户类和产品类之间解耦。工厂类去对各个产品类实例化。每个客户类不去new产品类，而是通过访问Factory获得需要的产品类对象。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产品</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber3 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂</span><br><span class="line">public class Factory &#123;</span><br><span class="line">    public Product createProduct(int type) &#123;</span><br><span class="line">        if (type == 1) &#123;</span><br><span class="line">            return new ProductNumber1();</span><br><span class="line">        &#125; else if (type == 2) &#123;</span><br><span class="line">            return new ProductNumber2();</span><br><span class="line">        &#125;</span><br><span class="line">        return new ProductNumber3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h1><p>把对象实例化的管理放到一个核心工厂类和n个工厂子类中去维护。</p>
<p>核心工厂：接口，定义创建产品对象的接口方法。</p>
<p>工厂子类：实例化产品类。</p>
<p>新增产品时，只需新增产品子类和工厂子类，不需要改变原有工厂类代码。扩展性更好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产品 无改变</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂方法</span><br><span class="line">//核心工厂</span><br><span class="line">interface FactoryMethod &#123;</span><br><span class="line">    Product getProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂子类</span><br><span class="line">public class Factroy1 implements FactoryMethod &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct()&#123;</span><br><span class="line">        return new ProductNumber1() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂子类</span><br><span class="line">public class Factroy2 implements FactoryMethod &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct()&#123;</span><br><span class="line">        return new ProductNumber2() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h1><p>把对象实例化的管理放到一个核心工厂类的方法和n个工厂子类的方法中去维护。</p>
<p>新增新产品时，添加产品类，核心工厂和工厂子类添加对应的实现方法。</p>
<p>抽象工厂的优势：可新增同类型的工厂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产品 无改变</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//核心工厂</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract Product  getProduct1();</span><br><span class="line">    public abstract Product  getProduct2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品实现</span><br><span class="line">public class ProductFactory extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct1() &#123;</span><br><span class="line">        return new ProductNumber1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct2() &#123;</span><br><span class="line">        return new ProductNumber2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//新增单一产品</span><br><span class="line">//产品 新增一个产品类</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber3 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//核心工厂 新增获取产品的抽象方法</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract Product  getProduct1();</span><br><span class="line">    public abstract Product  getProduct2();</span><br><span class="line">    public abstract Product  getProduct3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品实现 新增产品的实现方法</span><br><span class="line">public class ProductFactory extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct1() &#123;</span><br><span class="line">        return new ProductNumber1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct2() &#123;</span><br><span class="line">        return new ProductNumber2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct3() &#123;</span><br><span class="line">        return new ProductNumber3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板模式</title>
    <url>/2020/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>将各个子类中的共有的实现方法放在父类实现。</p>
<span id="more"></span>

<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>解决了什么：代码复用。</p>
<p>解决方法： 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：养动物，养乌龟和养鱼都需要水，但喂的食物不同</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class RaiseAnimal &#123;</span><br><span class="line">    void water()&#123;</span><br><span class="line">        System.out.println(&quot;水&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    abstract void food();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RaiseTortoise extends  RaiseAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void food()&#123;</span><br><span class="line">        System.out.println(&quot;龟粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RaiseFish extends  RaiseAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void food()&#123;</span><br><span class="line">        System.out.println(&quot;鱼粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Template &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RaiseAnimal raiseAnimal1 = new RaiseTortoise();</span><br><span class="line">        raiseAnimal1.water();</span><br><span class="line">        raiseAnimal1.food();</span><br><span class="line"></span><br><span class="line">        RaiseAnimal raiseAnimal2 = new RaiseFish();</span><br><span class="line">        raiseAnimal2.water();</span><br><span class="line">        raiseAnimal2.food();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<pre><code>水
龟粮
水
鱼粮
</code></pre>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2020/02/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<span id="more"></span>

<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><strong>解决的问题：</strong>有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，使用反射+map替换。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p>if-else解决多个算法相似的代码逻辑时，为什么带来了复杂性？</p>
<p>if-else在逻辑上是有顺序的，而多个算法相似的代码逻辑上是平行的。平行的代码逻辑使用if-else结构是复杂化了的，阅读上不好理解，扩展性差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：spring源码中为实例bean注入属性值时需要判断属性值的类型，下边实例是对判断过程的优化</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong></p>
<p>对targetType进行if-else判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//准备环境</span><br><span class="line">TypedStringValue typedStringValue = new TypedStringValue(&quot;18&quot;);</span><br><span class="line">typedStringValue.setTargetType(Integer.class);</span><br><span class="line"></span><br><span class="line">//获取bean的属性值stringValue和属性值类型targetType</span><br><span class="line">String stringValue = typedStringValue.getValue();</span><br><span class="line">Class&lt;?&gt; targetType = typedStringValue.getTargetType();</span><br><span class="line"></span><br><span class="line">//根据targetType要转换的value</span><br><span class="line">Object valueToUse = null;</span><br><span class="line"></span><br><span class="line">if (targetType == Integer.class) &#123;</span><br><span class="line">	//进行转换</span><br><span class="line">	valueToUse = Integer.parseInt(stringValue);</span><br><span class="line">&#125; else if (targetType == String.class) &#123;</span><br><span class="line">	//进行转换</span><br><span class="line">	valueToUse = stringValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:bean的属性值和属性值类型</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class TypedStringValue &#123;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    private Class&lt;?&gt; targetType;</span><br><span class="line"></span><br><span class="line">    public TypedStringValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getTargetType() &#123;</span><br><span class="line">        return targetType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTargetType(Class&lt;?&gt; targetType) &#123;</span><br><span class="line">        this.targetType = targetType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>**
 * Description:策略的接口类
 *
 * @author hxr
 * @version 1.0
 */
public interface Strategy &#123;

    /**
     * Description: 判断propertype标签中的value标签的Class类型，转换value的值为Class类型
     * @author: hxr
     * @param:
     * @return:
     */
    Object exchageType(String stringValue);
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:整型类型策略类</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class IntegerTypeStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object exchageType(String stringValue) &#123;</span><br><span class="line">        return Integer.parseInt(stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:浮点类型策略类</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class FloatTypeStrategy implements Strategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object exchageType(String stringValue) &#123;</span><br><span class="line">        return Float.parseFloat(stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:向实例注入属性值，需要考虑属性值的类型</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class AbstractAutowiredCapableBeanFactory &#123;</span><br><span class="line">    // 策略类集合</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    public void initMap()&#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">        // 将策略类放入集合map中</span><br><span class="line">        map.put(Integer.class, IntegerTypeStrategy.class);</span><br><span class="line">        map.put(Float.class, FloatTypeStrategy.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取要使用的策略类</span><br><span class="line">    public Class&lt;?&gt; getbean(Class&lt;?&gt; targetType) &#123;</span><br><span class="line">        return map.get(targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成实例工具类</span><br><span class="line">    public Object creatObject(Class&lt;?&gt; object) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = object.getConstructor();</span><br><span class="line">            return constructor.newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 策略模式+反射+map策略类集合优化if-else判断</span><br><span class="line"> *                  将stringValue转化为TypedStringValue.targetType的类型</span><br><span class="line"> *                  优化if-else判断targetType</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 准备环境</span><br><span class="line">        TypedStringValue typedStringValue = new TypedStringValue(&quot;18&quot;);</span><br><span class="line">        typedStringValue.setTargetType(Integer.class);</span><br><span class="line"></span><br><span class="line">        // 获取类型</span><br><span class="line">        Class&lt;?&gt; targetType = typedStringValue.getTargetType();</span><br><span class="line">        String stringValue = typedStringValue.getValue();</span><br><span class="line"></span><br><span class="line">        // 创建beanFactory</span><br><span class="line">        AbstractAutowiredCapableBeanFactory beanFactory = new AbstractAutowiredCapableBeanFactory();</span><br><span class="line">        // 初始化策略类</span><br><span class="line">        beanFactory.initMap();</span><br><span class="line">        // 通过targetTypemap 从策略类集合map获取需要执行的策略类。</span><br><span class="line">        Class&lt;?&gt; Object = beanFactory.getbean(targetType);</span><br><span class="line">        // 获取策略类实例</span><br><span class="line">        Strategy strategy = (Strategy)beanFactory.creatObject(Object);</span><br><span class="line"></span><br><span class="line">        // 执行策略类转换方法 将stringValue转化为Integer、Float、Double等类型</span><br><span class="line">        Object o1 = strategy.exchageType(stringValue);</span><br><span class="line">        System.out.println(o1.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>重新搭建博客</title>
    <url>/2020/06/12/%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>重新搭建博客，hexo版本太低无法使用。升级过程中重新搭建。</p>
<span id="more"></span>

<h1 id="重新搭建博客"><a href="#重新搭建博客" class="headerlink" title="重新搭建博客"></a>重新搭建博客</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>hexo: 5.4.0</p>
<p>node: 12.22.1</p>
<p>npm: 7.16.0</p>
<h2 id="重搭步骤"><a href="#重搭步骤" class="headerlink" title="重搭步骤"></a>重搭步骤</h2><p>备份simpleai.github.io文件夹</p>
<p>删除simpleai.github.io文件夹内的文件</p>
<p>卸载node.js</p>
<p>安装12.22.1node.js</p>
<p>simpleai.github.io文件夹进入git的bash命令</p>
<p>安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>测试博客效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>下载next主题，解压到themes文件夹中，重命名为next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># next换了地址</span><br><span class="line">https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>

<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo 的 _config.yml</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># next 的_config.yml</span><br><span class="line"># scheme: Muse</span><br><span class="line">scheme: Gemini # 修改主题样式</span><br></pre></td></tr></table></figure>

<h3 id="修改hexo首页信息"><a href="#修改hexo首页信息" class="headerlink" title="修改hexo首页信息"></a>修改hexo首页信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Go after </span><br><span class="line">subtitle: </span><br><span class="line">description: 技术融于生活</span><br><span class="line">keywords:</span><br><span class="line">author: 追逐</span><br><span class="line">language: zh-CN # 解决菜单栏乱码 next的_config.yml配置tags后</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: http://blog.xiaoruiit.com</span><br><span class="line"></span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 5 # 每一页显示几条</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure>

<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>分类、标签、关于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page about</span><br><span class="line"># 修改 source下的各个文件下的index.md文件内容</span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2021-06-11 06:53:07</span><br><span class="line">type: &quot;categories&quot; categories文件夹添加本行。其他两个类似</span><br><span class="line">---</span><br><span class="line"># 修改next 下_config.yml</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>hexo配置文件<code>&lt;blog_root&gt;/_config.yml</code>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Configration for Theme-Next</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure>

<p>修改hexo-next配置文件 <code>&lt;next_root&gt;/_config.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h3 id="底部协议，评论，文字统计和阅读时长-阅读次数统计"><a href="#底部协议，评论，文字统计和阅读时长-阅读次数统计" class="headerlink" title="底部协议，评论，文字统计和阅读时长,阅读次数统计"></a>底部协议，评论，文字统计和阅读时长,阅读次数统计</h3><p>协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># next config.yml</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa 4.0</span><br><span class="line">  sidebar: true # 开启</span><br><span class="line">  post: true # 开启</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<p>来必力评论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># next的config.yml</span><br><span class="line">livere_uid: MTAyMC8******8xMjI0MA==</span><br></pre></td></tr></table></figure>

<p>文字统计和阅读时长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>阅读次数统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># leancloud</span><br><span class="line"># leancloud原应用停用，实名认证+手机号验证+发帖请求解封1天后可用</span><br><span class="line"># next的 config.yml</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: S5VAuYJ1Iwl*************-gzGzoHsz</span><br><span class="line">  app_key: 4uuo************gWjGat</span><br></pre></td></tr></table></figure>

<p>去除站点统计次数、时间</p>
<p>\themes\next\layout_partials\footer.swig</p>
<p>删除错误统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if config.symbols_count_time.total_symbols %&#125;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-chart-area&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title=&quot;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsCountTotal(site) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if config.symbols_count_time.total_time %&#125;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-coffee&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125; &amp;asymp;&lt;/span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title=&quot;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsTimeTotal(site, config.symbols_count_time.awl, config.symbols_count_time.wpm, __(&#x27;symbols_count_time.time_minutes&#x27;)) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p>文章访问次数统计leancloud</p>
<ol>
<li><p>申请账号</p>
</li>
<li><p>创建应用</p>
</li>
<li><p>域名绑定（2021.10.1之后不绑定可能不再提供服务）</p>
<ol>
<li><p>leancloud配置，配置域名后会检查备案信息，需等待</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IGLCnxia2Z68fyT.png" alt="image-20210829181327021"></p>
</li>
<li><p>域名解析</p>
<p>阿里云：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SR4WrZ1UBpdslAa.png" alt="image-20210829183606728"></p>
<p>leancloud显示</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ox9Ewr8uSaPObZW.png" alt="image-20210829183709552"></p>
</li>
</ol>
</li>
<li><p>next的_config.yml 设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: S5VA*****************zGzoHsz</span><br><span class="line">  app_key: 4u*********************WjGat</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>next _config.yml 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  #comment: Donate comment here.</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png</span><br><span class="line">  alipay: /images/alipay.png</span><br></pre></td></tr></table></figure>

<p>图片放到 /themes/next/source/images 下</p>
<h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><p>建立ssh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;simpleintelligence@qq.com&quot; #生成key</span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">ssh-add ~/.ssh/id_rsa # 将key放到本地电脑</span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub # 复制ssh key </span><br><span class="line"></span><br><span class="line"># 登录 Github 帐号，依次点击自己的头像，Settings，SSH and GPG keys，New SSH key 或者 Add SSH key， 在 Title 这里输入 Key 的label，比如 your_name - PC，然后在 Key 里面把 SSH Key 粘贴进去，点击 Add SSH key 大功告成。</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">ssh -T git@github.com # 输入enter+yes，看到 Hi simpleai! You&#x27;ve successfully authenticated...</span><br></pre></td></tr></table></figure>



<p>source文件夹下添加一个文件<code>CNAME</code></p>
<p>内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog.xiaoruiit.com</span><br></pre></td></tr></table></figure>

<p>安装hexo-deployer-git插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/simpleai/simpleai.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>部署报错<code>spawn failed</code></p>
<p>解决1：刪除博客文件夹下的.deploy_git，重启电脑。重新执行<code>hexo d</code>。</p>
<p>解決2：可能是分支代码冲突，参考：<a href="https://www.jianshu.com/p/504fdfb31081%EF%BC%8C%E6%9C%AA%E6%B5%8B%E8%AF%95%E3%80%82">https://www.jianshu.com/p/504fdfb31081，未测试。</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），站点的更改无论如何也不生效</span><br><span class="line">$ hexo generate # 生成静态文件，该命令可以简写为 $ hexo g</span><br><span class="line">$ hexo server # 启动服务器，http://localhost:4000/</span><br><span class="line">$ hexo deploy # 部署网站，推送到github。该命令可以简写为 $ hexo d您可能需要运行该命令</span><br><span class="line"></span><br><span class="line">$ hexo init [folder] # 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站</span><br><span class="line">$ hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout ，默认使用 _config.yml 中的 default_layout 参数代替</span><br><span class="line">$ hexo render &lt;file1&gt; [file2] ... # 渲染文件</span><br><span class="line">$ hexo list &lt;type&gt; # 列出网站资料</span><br><span class="line">$ hexo publish [layout] # &lt;filename&gt; 发表草稿</span><br><span class="line">$ hexo version # 显示 Hexo 版本</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>防止重复提交</title>
    <url>/2020/03/10/%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>防止重复提交</p>
<span id="more"></span>

<h1 id="防止重复提交"><a href="#防止重复提交" class="headerlink" title="防止重复提交"></a>防止重复提交</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul>
<li><p>解释：持续触发高频事件，函数每n秒执行一次。</p>
</li>
<li><p>业务场景</p>
<p>输入框的模糊查询</p>
</li>
<li><p>目的</p>
<p>节约流量、内存的损耗，旨在提升性能，在高频率频发的事件中才会用到。</p>
</li>
</ul>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>持续触发高频事件，函数只会执行一次。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul>
<li><p>目的：防止绕过前端校验持续访问接口。</p>
</li>
<li><p>实现</p>
<ol>
<li><p>切面类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.aop;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.util.StringUtils;</span><br><span class="line">import com.xiaoruiit.common.utils.IPUtil;</span><br><span class="line">import com.xiaoruiit.common.utils.IdWorker;</span><br><span class="line">import com.xiaoruiit.common.utils.Result;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Aspect // 定义切面类</span><br><span class="line">public class AvoidDuplicateSubmitAspect &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;@annotation(com.xiaoruiit.common.aop.AvoidDuplicateSubmit)&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 获取request对象</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();</span><br><span class="line">        String ip = IPUtil.getIP(request);</span><br><span class="line">        // 获取方法签名</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        String ipKey = String.format(&quot;%s#%s&quot;, className, methodName);</span><br><span class="line">        int hashCode = Math.abs(ipKey.hashCode());</span><br><span class="line">        // 拼接redisKey,如：127.0.0.1_1234984393</span><br><span class="line">        String redisKey = String.format(&quot;%s_%d&quot;, ip, hashCode);</span><br><span class="line"></span><br><span class="line">        String value = (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">        if (!StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return Result.validateFailed(&quot;请勿重复提交&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取注解</span><br><span class="line">        AvoidDuplicateSubmit avoidDuplicateSubmit = method.getAnnotation(AvoidDuplicateSubmit.class);</span><br><span class="line">        long timeout = avoidDuplicateSubmit.timeout();</span><br><span class="line">        if (timeout &lt; 0) &#123;</span><br><span class="line">            timeout = 5000;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第一次提交，插入redis</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, IdWorker.nextId(), timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        // 继续执行方法</span><br><span class="line">        return joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.aop;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface AvoidDuplicateSubmit &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 指定时间内不可重复提交，单位毫秒</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    long timeout() default 5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法上加注解 @AvoidDuplicateSubmit</span><br><span class="line">@AvoidDuplicateSubmit  默认时间5000毫秒</span><br><span class="line">@AvoidDuplicateSubmit(timeout = 100000) 单位毫秒自己设置控制时间</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取IP真实地址</p>
<p>代理服务器结合java代码</p>
<ul>
<li><p>1.nginx配置</p>
<p>参考：<a href="https://segmentfault.com/a/1190000019197577">https://segmentfault.com/a/1190000019197577</a></p>
</li>
<li><p>java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String[] HEADERS_TO_TRY = &#123;</span><br><span class="line">            &quot;X-Forwarded-For&quot;,</span><br><span class="line">            &quot;Proxy-Client-IP&quot;,</span><br><span class="line">            &quot;WL-Proxy-Client-IP&quot;,</span><br><span class="line">            &quot;HTTP_X_FORWARDED_FOR&quot;,</span><br><span class="line">            &quot;HTTP_X_FORWARDED&quot;,</span><br><span class="line">            &quot;HTTP_X_CLUSTER_CLIENT_IP&quot;,</span><br><span class="line">            &quot;HTTP_CLIENT_IP&quot;,</span><br><span class="line">            &quot;HTTP_FORWARDED_FOR&quot;,</span><br><span class="line">            &quot;HTTP_FORWARDED&quot;,</span><br><span class="line">            &quot;HTTP_VIA&quot;,</span><br><span class="line">            &quot;REMOTE_ADDR&quot; &#125;;</span><br><span class="line"></span><br><span class="line">private String getClientIpAddress(HttpServletRequest request) &#123;</span><br><span class="line">    for (String header : HEADERS_TO_TRY) &#123;</span><br><span class="line">        String ip = request.getHeader(header);</span><br><span class="line">        if (ip != null &amp;&amp; ip.length() != 0 &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            return ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return request.getRemoteAddr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>常见</category>
      </categories>
      <tags>
        <tag>常见</tag>
      </tags>
  </entry>
  <entry>
    <title>项目-产品化</title>
    <url>/2020/10/08/%E9%A1%B9%E7%9B%AE-%E4%BA%A7%E5%93%81%E5%8C%96/</url>
    <content><![CDATA[<p>项目-产品化</p>
<span id="more"></span>

<h1 id="项目-产品化"><a href="#项目-产品化" class="headerlink" title="项目-产品化"></a>项目-产品化</h1><h2 id="什么是产品化"><a href="#什么是产品化" class="headerlink" title="什么是产品化"></a>什么是产品化</h2><p>对同一类型的项目经过多次迭代之后，项目开发变得稳定。这时，可将项目改造成为一个产品。</p>
<p>复用文档、架构、需求解析WBS。</p>
<p><strong>产品化的三个标准：</strong>时间标准，价格标准，开发标准。</p>
<p>架构师关注的开发标准：包括文档标准，迭代标准，交付标准，变更委员会标准，WBS标准（需求分解），技术标准（框架、数据库），代码规范和注释。</p>
<h3 id="软件公司经营模式"><a href="#软件公司经营模式" class="headerlink" title="软件公司经营模式"></a>软件公司经营模式</h3><ol>
<li>公司获得了足够融资，初创开始做的就是产品。如共享单车。</li>
<li>没有获得融资，或资金不足，，接项目进行公司的初步发展。或碍于销售渠道，必须前期开发项目。例如：税务行业、医疗行业的项目。</li>
</ol>
<h3 id="软件公司盈利模式"><a href="#软件公司盈利模式" class="headerlink" title="软件公司盈利模式"></a>软件公司盈利模式</h3><ol>
<li><p>单纯做项目。不断的接项目，卖项目。</p>
<p>如果和一些大客户有长期的合作关系，则公司的模式相对稳定，人员不会太多，盈利也不会太多。当没项目可做时，就需要解散项目组。</p>
</li>
<li><p>前期开发过不少项目，做了足够的积累，项目已经产品化了。这类公司会招聘一些销售人员推广自己的产品。</p>
</li>
<li><p>既卖产品又卖项目。</p>
</li>
<li><p>出售服务。</p>
<p>一般指运维。</p>
<p>另一种是SaaS模式（Software as a Service),意思是软件即服务。先投入大量资金做出来产品，发布到互联网，用户试用满意后购买这种产品（服务）。</p>
</li>
</ol>
<h2 id="软件产品化"><a href="#软件产品化" class="headerlink" title="软件产品化"></a>软件产品化</h2><ol>
<li><p>开发文档</p>
<p>需求说明书，概要设计，详细设计，干系人登记册，项目管理计划。可以根据积累整理一套模板。</p>
</li>
<li><p>产品风格</p>
<p>由美工和UI设计人员来设计界面。比如做灰色、蓝色、黑色三种界面风格的css样式。</p>
</li>
<li><p>前端框架</p>
</li>
<li><p>后端框架</p>
<p>涉及到架构复用，某个技术有漏洞时，要做到一整套框架中单个技术的可插拔。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>项目-完整流程</title>
    <url>/2020/10/08/%E9%A1%B9%E7%9B%AE-%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>项目-完整流程</p>
<span id="more"></span>

<h1 id="项目-完整流程"><a href="#项目-完整流程" class="headerlink" title="项目-完整流程"></a>项目-完整流程</h1><ol>
<li>售前工程师与客户建立关系</li>
<li>正式立项</li>
<li>需求调研</li>
<li>输出调研文档</li>
<li>开发技术选型</li>
<li>项目开工会</li>
<li>项目开发</li>
</ol>
<h2 id="售前工程师与客户建立关系"><a href="#售前工程师与客户建立关系" class="headerlink" title="售前工程师与客户建立关系"></a>售前工程师与客户建立关系</h2><p>与客户交流，包揽下客户的需求，我们可以做。</p>
<p>向客户提供资料，包括已经做成产品的东西，做项目的周期。</p>
<p>客户招投标或直接采购 。</p>
<h2 id="正式立项"><a href="#正式立项" class="headerlink" title="正式立项"></a>正式立项</h2><p>客户方立项</p>
<p>本公司立项</p>
<h2 id="需求调研"><a href="#需求调研" class="headerlink" title="需求调研"></a>需求调研</h2><p>项目经理+架构师+高级开发人员到客户公司调研。</p>
<p>客户开调研会，让客户方参加调研的人员配合乙方项目经理。</p>
<p>架构师回答技术问题。</p>
<p>项目经理确定调研内容、调研对象的主次。</p>
<p>写出需求文档让客户签字，可避免变更需求时没有参考的东西。</p>
<h2 id="输出调研文档"><a href="#输出调研文档" class="headerlink" title="输出调研文档"></a>输出调研文档</h2><h2 id="开发技术选型"><a href="#开发技术选型" class="headerlink" title="开发技术选型"></a>开发技术选型</h2><h2 id="项目开工会"><a href="#项目开工会" class="headerlink" title="项目开工会"></a>项目开工会</h2><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>项目执行阶段，代码开发</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>项目-开发模式</title>
    <url>/2020/10/08/%E9%A1%B9%E7%9B%AE-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>项目-开发模式</p>
<span id="more"></span>

<h1 id="项目-开发模式"><a href="#项目-开发模式" class="headerlink" title="项目-开发模式"></a>项目-开发模式</h1><p>项目开发模式分文瀑布式开发和敏捷开发。</p>
<p><strong>瀑布式开发：</strong>一步一步执行调研、开发、交互，对中间的成果不交付给客户。</p>
<p><strong>敏捷开发：</strong>12个月的开发期，分为12个交付版本，每个月部署一个版本给用户看。频繁与用户确认需求，频繁变更需求。</p>
<p>瀑布式开发适合已经非常成熟的产品，了解自己的产品，也了解用户需要什么样的东西，已经积累了完善的文档。包括需求设计、概要设计、详细设计。</p>
<p>敏捷开发适合频繁变更需求的项目。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-高级特性</title>
    <url>/2020/08/27/RabbitMQ-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>消息可靠投递，Consumer ACK，消费者限流（削峰填谷)，TTL，DLX死信队列，延迟队列，消息追踪</p>
<span id="more"></span>

<h1 id="RabbitMQ-高级特性"><a href="#RabbitMQ-高级特性" class="headerlink" title="RabbitMQ-高级特性"></a>RabbitMQ-高级特性</h1><h2 id="消息可靠投递"><a href="#消息可靠投递" class="headerlink" title="消息可靠投递"></a>消息可靠投递</h2><p>producer到RabbitMQ</p>
<ul>
<li><p>producer→exchange</p>
<p>通过confirmCallback回调函数确认消息的投递</p>
<p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq.host=192.168.3.3</span><br><span class="line">rabbitmq.port=5672</span><br><span class="line">rabbitmq.username=guest</span><br><span class="line">rabbitmq.password=guest</span><br><span class="line">rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure>

<p>xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                 http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                 http://www.springframework.org/schema/context</span><br><span class="line">                 https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">                 http://www.springframework.org/schema/rabbit</span><br><span class="line">                 http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;&gt;</span><br><span class="line">    &lt;!--加载配置文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:rabbitmq.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义rabbitmq connectionFactory  1. 设置  publisher-confirms=&quot;true&quot; --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;$&#123;rabbitmq.host&#125;&quot;</span><br><span class="line">                               port=&quot;$&#123;rabbitmq.port&#125;&quot;</span><br><span class="line">                               username=&quot;$&#123;rabbitmq.username&#125;&quot;</span><br><span class="line">                               password=&quot;$&#123;rabbitmq.password&#125;&quot;</span><br><span class="line">                               virtual-host=&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span><br><span class="line">                               </span><br><span class="line">                               publisher-confirms=&quot;true&quot;</span><br><span class="line">                               /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span><br><span class="line">    &lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--2. 消息可靠性投递（生产端）--&gt;</span><br><span class="line">    &lt;!--队列--&gt;</span><br><span class="line">   &lt;rabbit:queue id=&quot;test_queue_confirm&quot; name=&quot;test_queue_confirm&quot;&gt;&lt;/rabbit:queue&gt;</span><br><span class="line">   &lt;!--交换机--&gt;</span><br><span class="line">    &lt;rabbit:direct-exchange name=&quot;test_exchange_confirm&quot;&gt;</span><br><span class="line">    	&lt;!--交换机绑定队列--&gt;</span><br><span class="line">        &lt;rabbit:bindings&gt;</span><br><span class="line">            &lt;rabbit:binding queue=&quot;test_queue_confirm&quot; key=&quot;confirm&quot;&gt;			               &lt;/rabbit:binding&gt;</span><br><span class="line">        &lt;/rabbit:bindings&gt;</span><br><span class="line">    &lt;/rabbit:direct-exchange&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span><br><span class="line">public class ProducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 确认模式：</span><br><span class="line">     * 步骤：</span><br><span class="line">     * 1. 确认模式开启：ConnectionFactory中开启publisher-confirms=&quot;true&quot;</span><br><span class="line">     * 2. 在rabbitTemplate定义ConfirmCallBack回调函数</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testConfirm() &#123;</span><br><span class="line"></span><br><span class="line">        //2. 定义回调 **</span><br><span class="line">        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">            /**</span><br><span class="line">             *</span><br><span class="line">             * @param correlationData 相关配置信息</span><br><span class="line">             * @param ack   exchange交换机 是否成功收到了消息。true 成功，false代表失败</span><br><span class="line">             * @param cause 失败原因</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</span><br><span class="line">                System.out.println(&quot;confirm方法被执行了....&quot;);</span><br><span class="line"></span><br><span class="line">                if (ack) &#123;</span><br><span class="line">                    //接收成功</span><br><span class="line">                    System.out.println(&quot;接收成功消息&quot; + cause);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //接收失败</span><br><span class="line">                    System.out.println(&quot;接收失败消息&quot; + cause);</span><br><span class="line">                    //做处理，如让消息再次发送。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //3. 发送消息</span><br><span class="line">        //rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;test_exchange_confirm1&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>exchange→queue</p>
<p>returnCallback</p>
<ol>
<li><p>xml开启配置return-true。增加publisher-returns=”true”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义rabbitmq connectionFactory  1. 设置  publisher-confirms=&quot;true&quot; --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;$&#123;rabbitmq.host&#125;&quot;</span><br><span class="line">                             port=&quot;$&#123;rabbitmq.port&#125;&quot;</span><br><span class="line">                               username=&quot;$&#123;rabbitmq.username&#125;&quot;</span><br><span class="line">                             password=&quot;$&#123;rabbitmq.password&#125;&quot;</span><br><span class="line">                               virtual-host=&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span><br><span class="line">                               </span><br><span class="line">                               publisher-confirms=&quot;true&quot;</span><br><span class="line">                             &lt;!-- 开启配置return-true --&gt;</span><br><span class="line">                               publisher-returns=&quot;true&quot;</span><br><span class="line">                             /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>producer中编写测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 步骤：</span><br><span class="line">   * 1. 开启回退模式:publisher-returns=&quot;true&quot;</span><br><span class="line">   * 2. 设置ReturnCallBack</span><br><span class="line">   * 3. 设置Exchange处理消息的模式：</span><br><span class="line">   *  1. 如果消息没有路由到Queue，则丢弃消息（默认）</span><br><span class="line">   *  2. 如果消息没有路由到Queue，返回给消息发送方ReturnCallBack</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">  @Test</span><br><span class="line">  public void testReturn() &#123;</span><br><span class="line">  </span><br><span class="line">      //设置交换机处理失败消息的模式</span><br><span class="line">      rabbitTemplate.setMandatory(true);</span><br><span class="line">  </span><br><span class="line">      //2.设置ReturnCallBack</span><br><span class="line">      rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">          /**</span><br><span class="line">           *</span><br><span class="line">           * @param message   消息对象</span><br><span class="line">           * @param replyCode 错误码</span><br><span class="line">           * @param replyText 错误信息</span><br><span class="line">           * @param exchange  交换机</span><br><span class="line">           * @param routingKey 路由键</span><br><span class="line">           */</span><br><span class="line">          @Override</span><br><span class="line">          public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123;</span><br><span class="line">              System.out.println(&quot;return 执行了....&quot;);</span><br><span class="line">  </span><br><span class="line">              System.out.println(message);</span><br><span class="line">              System.out.println(replyCode);</span><br><span class="line">              System.out.println(replyText);</span><br><span class="line">              System.out.println(exchange);</span><br><span class="line">              System.out.println(routingKey);</span><br><span class="line">  </span><br><span class="line">              //处理</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      //3. 发送消息   </span><br><span class="line">      rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Consumer-ACK"><a href="#Consumer-ACK" class="headerlink" title="Consumer ACK"></a>Consumer ACK</h2><p>RabbitMQ到consumer</p>
<p>消费端收到消息后的确认方式有三种。</p>
<ul>
<li>自动确认：acknowledge=”<strong>none</strong>“，当消息被Consumer接收到，则自动确认收到，并将message 从 RabbitMQ 的消息缓存中移除。</li>
</ul>
<ul>
<li>手动确认：acknowledge=”<strong>manual</strong>“，在业务处理完成后，调用channel.basicAck()，手动签收；如果出现异常，则调用channel.basicNack()方法，让其重新发送消息。</li>
</ul>
<ul>
<li>根据异常情况确认：acknowledge=”<strong>auto</strong>“</li>
</ul>
<ol>
<li><p>xml中配置手动接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">             http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">             http://www.springframework.org/schema/context</span><br><span class="line">             https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">             http://www.springframework.org/schema/rabbit</span><br><span class="line">             http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;&gt;</span><br><span class="line">    &lt;!--加载配置文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:rabbitmq.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义rabbitmq connectionFactory --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;$&#123;rabbitmq.host&#125;&quot;</span><br><span class="line">                               port=&quot;$&#123;rabbitmq.port&#125;&quot;</span><br><span class="line">                               username=&quot;$&#123;rabbitmq.username&#125;&quot;</span><br><span class="line">                               password=&quot;$&#123;rabbitmq.password&#125;&quot;</span><br><span class="line">                               virtual-host=&quot;$&#123;rabbitmq.virtual-host&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.xiaoruiit.listener&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义监听器容器  添加  acknowledge=&quot;manual&quot; 手动--&gt;</span><br><span class="line">    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;manual&quot; &gt;</span><br><span class="line">        &lt;rabbit:listener ref=&quot;ackListener&quot; queue-names=&quot;test_queue_confirm&quot;&gt;	</span><br><span class="line">        &lt;/rabbit:listener&gt;</span><br><span class="line">    &lt;/rabbit:listener-container&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>监听类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.listener;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import org.springframework.amqp.core.Message;</span><br><span class="line">import org.springframework.amqp.core.MessageListener;</span><br><span class="line">import org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Consumer ACK机制：</span><br><span class="line"> *  1. 设置手动签收。acknowledge=&quot;manual&quot;</span><br><span class="line"> *  2. 让监听器类实现ChannelAwareMessageListener接口</span><br><span class="line"> *  3. 如果消息成功处理，则调用channel的 basicAck()签收</span><br><span class="line"> *  4. 如果消息处理失败，则调用channel的basicNack()拒绝签收，broker重新发送给consumer</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class AckListener implements ChannelAwareMessageListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">        long deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1.接收转换消息</span><br><span class="line">            System.out.println(new String(message.getBody()));</span><br><span class="line"></span><br><span class="line">            //2. 处理业务逻辑</span><br><span class="line">            System.out.println(&quot;处理业务逻辑...&quot;);</span><br><span class="line">            int i = 3/0;//出现错误</span><br><span class="line">            //3. 手动签收</span><br><span class="line">            channel.basicAck(deliveryTag,true);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            //4.拒绝签收</span><br><span class="line">            /*</span><br><span class="line">            第三个参数：requeue：重回队列。如果设置为true，则消息重新回到queue，broker会重新发送该消息给消费端</span><br><span class="line">             */</span><br><span class="line">            channel.basicNack(deliveryTag,true,true);</span><br><span class="line">            // 了解</span><br><span class="line">            //channel.basicReject(deliveryTag,true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-consumer.xml&quot;)</span><br><span class="line">public class ConsumerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="消费者限流"><a href="#消费者限流" class="headerlink" title="消费者限流"></a>消费者限流</h2><p>削（xue)峰填谷,RabbitMQ将瞬时的高并发消息慢慢分发给对消息后续处理的系统。</p>
<p>作用：</p>
<ul>
<li><p>缓解瞬时压力。</p>
</li>
<li><p>保护处理RabbitMQ消息的系统，防止系统崩溃。高可用</p>
</li>
</ul>
<p>implementation：</p>
<ul>
<li><p>Consumer需要设置为手动签收</p>
<p>监听类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QosListener implements ChannelAwareMessageListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        //1.获取消息</span><br><span class="line">        System.out.println(new String(message.getBody()));</span><br><span class="line">        //2. 处理业务逻辑</span><br><span class="line">        //3. 签收</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置手动签收 acknowledge=”manual”</p>
</li>
<li><p>设置每次处理多少条消息后再次获取消息。perfetch = 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;manual&quot; prefetch=&quot;1&quot; &gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p><strong>解释：</strong>当消息到达存活时间后，还没有被消费，会被自动清除。</p>
<p>可设置消息或队列的过期时间。</p>
<ul>
<li><p>队列的过期可在<code>xml</code>的<code>queue</code>标签配置,</p>
</li>
<li><p>消息过期在发送消息时增加过期时间的参数即可。</p>
</li>
</ul>
<p><strong>注意：</strong>单条消息和队列都设置了过期时间时，以短的为准。</p>
<p><strong>示例：</strong>订单系统发送到RabbitMQ的消息设置为30分钟过期。交易系统30分钟不取走订单消息，则订单关闭。</p>
<p><strong>implementation：</strong></p>
<ul>
<li><p>设置队列过期时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--ttl--&gt;</span><br><span class="line">&lt;rabbit:queue name=&quot;test_queue_ttl&quot; id=&quot;test_queue_ttl&quot;&gt;</span><br><span class="line">    &lt;!--设置queue的参数--&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;!--x-message-ttl指队列的过期时间,注意Integer类型--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;100000&quot; value-type=&quot;java.lang.Integer&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;test_exchange_ttl&quot; &gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;ttl.#&quot; queue=&quot;test_queue_ttl&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTtl() &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,</span><br><span class="line">                                      &quot;ttl.hehe&quot;, &quot;message ttl....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置单个消息的过期时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTtl() &#123;</span><br><span class="line">  // 消息后处理对象，设置一些消息的参数信息</span><br><span class="line">    MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">            //1.设置message的信息</span><br><span class="line">            message.getMessageProperties().setExpiration(&quot;5000&quot;);//消息的过期时间</span><br><span class="line">            //2.返回该消息</span><br><span class="line">            return message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //消息单独过期</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.hehe&quot;, &quot;message ttl....&quot;,messagePostProcessor);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        if(i == 5)&#123;</span><br><span class="line">            //消息过期</span><br><span class="line">            rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.hehe&quot;, &quot;message ttl....&quot;,messagePostProcessor);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //不过期的消息</span><br><span class="line">            rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.hehe&quot;, &quot;message ttl....&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DLX-死信队列"><a href="#DLX-死信队列" class="headerlink" title="DLX 死信队列"></a>DLX 死信队列</h2><p>死信：</p>
<ul>
<li>TTL过期的消息</li>
<li>未签收的消息,并且没把消息重新放入原队列，requeue=false</li>
<li>超过队列的长度</li>
</ul>
<p><strong>implementation</strong></p>
<ol>
<li><p>设置正常队列，正常交换机，正常交换机绑定正常队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;test_queue_dlx&quot; id=&quot;test_queue_dlx&quot;&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;test_exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;test.dlx.#&quot; queue=&quot;test_queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置死信队列，死信交换机，死信交换机绑定死信队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;queue_dlx&quot; id=&quot;queue_dlx&quot;&gt;&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;dlx.#&quot; queue=&quot;queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置正常队列的死信绑定死信交换机，设置正常队列到死信交换机的路由key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;test_queue_dlx&quot; id=&quot;test_queue_dlx&quot;&gt;</span><br><span class="line">    &lt;!--3. 正常队列绑定死信交换机--&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;!--3.1 x-dead-letter-exchange：死信交换机名称--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;exchange_dlx&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--3.2 x-dead-letter-routing-key：发送给死信交换机的routingkey--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-routing-key&quot; value=&quot;dlx.hehe&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--4.1 设置队列的过期时间 ttl--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Integer&quot; /&gt;</span><br><span class="line">        &lt;!--4.2 设置队列的长度限制 max-length --&gt;</span><br><span class="line">        &lt;entry key=&quot;x-max-length&quot; value=&quot;10&quot; value-type=&quot;java.lang.Integer&quot; /&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;test_exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;test.dlx.#&quot; queue=&quot;test_queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>producer 测试方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 发送测试死信消息：</span><br><span class="line"> *  1. 时间过期</span><br><span class="line"> *  2. 超过长度</span><br><span class="line"> *  3. 消息拒收</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testDlx()&#123;</span><br><span class="line">    //1. 测试时间过期，死信消息</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,</span><br><span class="line">                                  &quot;test.dlx.haha&quot;,&quot;我是一条时间过期的消息&quot;);</span><br><span class="line">   </span><br><span class="line">    //2. 测试超过长度后，消息死信</span><br><span class="line">   for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,</span><br><span class="line">                                      &quot;test.dlx.haha&quot;,&quot;我是一条超过长度的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //3. 测试消息拒收</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,</span><br><span class="line">                                  &quot;test.dlx.haha&quot;,&quot;我是一条消息拒收&quot;);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>TTL+死信队列</p>
<p>架构图：</p>
<p>需求：订单30分钟未支付，取消订单，并回滚库存。</p>
<p>实现思路：正常队列设置30分钟有效期，30分钟内不做处理。30分钟后转入另一个队列判断订单状态，并处理</p>
<p>implementation</p>
<p>xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 定义正常交换机（order_exchange）和队列(order_queue)--&gt;</span><br><span class="line">&lt;rabbit:queue id=&quot;order_queue&quot; name=&quot;order_queue&quot;&gt;</span><br><span class="line">    &lt;!-- 3. 绑定，设置正常队列过期时间30分钟--&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;order_exchange_dlx&quot; /&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-routing-key&quot; value=&quot;dlx.order.cancel&quot; /&gt;</span><br><span class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Integer&quot; /&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;order_exchange&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;order.#&quot; queue=&quot;order_queue&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  2. 定义死信交换机（order_exchange_dlx）和队列(order_queue_dlx)--&gt;</span><br><span class="line">&lt;rabbit:queue id=&quot;order_queue_dlx&quot; name=&quot;order_queue_dlx&quot;&gt;&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;order_exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;dlx.order.#&quot; queue=&quot;order_queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public  void testDelay() throws InterruptedException &#123;</span><br><span class="line">    //1.发送订单消息。 订单系统中，下单成功后，发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;order_exchange&quot;,&quot;order.msg&quot;,&quot;订单信息：id=1,time=2020&quot;);</span><br><span class="line"></span><br><span class="line">    //2.打印倒计时10秒</span><br><span class="line">    for (int i = 10; i &gt; 0 ; i--) &#123;</span><br><span class="line">        System.out.println(i+&quot;...&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><p><strong>问题：</strong>配置写错，producer宕机、consumer宕机，服务器宕机、连接断开可能导致消息不能成功发送。</p>
<p><strong>解决：</strong>通过追踪消息可以排查这些问题。</p>
<p>Firehose、rabbitmq_tracing插件都可以实现消息追踪。</p>
<p>Firehose是额外发送一条消息到系统内部的一个交换机（amq.rabbitmq.trace）。</p>
<p>rabbitmq_tracing是额外发送一条消息（更详细）到内部交换机，并将消息记录到mytrace.log文件中。系统内部发送的消息不容易失败。</p>
<p>开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_tracing</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台发送一条消息</span><br></pre></td></tr></table></figure>

<p>log会显示详细信息</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>高级特性</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>源码加载并解析xml文件</title>
    <url>/2020/02/03/Spring-%E6%BA%90%E7%A0%81%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>模板</p>
<span id="more"></span>

<h1 id="加载并解析xml文件"><a href="#加载并解析xml文件" class="headerlink" title="加载并解析xml文件"></a>加载并解析xml文件</h1><p>相关的类和方法。</p>
<h2 id="使用spring"><a href="#使用spring" class="headerlink" title="使用spring"></a>使用spring</h2><p>1.新建spring项目</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vzHpQKhXfEJ8eYy.png" alt="image-20200707152842482"></p>
<p>2.编写book类和配置文件</p>
<p>Book类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line"></span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public String getBookName() &#123;</span><br><span class="line">        return bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookName(String bookName) &#123;</span><br><span class="line">        this.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printBookInfo() &#123;</span><br><span class="line">        System.out.println(&quot;Book Name：&quot; + this.bookName + &quot;,Author：&quot; + this.author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;book&quot; class=&quot;Book&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookName&quot; value=&quot;平凡的世界&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;author&quot; value=&quot;路遥&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>3.Test方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext  applicationContext = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);</span><br><span class="line">Book book = applicationContext.getBean(&quot;book&quot;,Book.class);</span><br><span class="line">book.printBookInfo();</span><br></pre></td></tr></table></figure>

<h2 id="spring加载并解析xml文件的过程"><a href="#spring加载并解析xml文件的过程" class="headerlink" title="spring加载并解析xml文件的过程"></a>spring加载并解析xml文件的过程</h2><p>1-5准备工作</p>
<p>6-9要获取xml资源时的处理，资源定位，多配置循环处理，资源编码处理</p>
<p>10-11获取资源流，使用工具初步解析</p>
<p>12定义注册流程统计BeanDefinition数量</p>
<p>13获取初步解析的资源，跳转</p>
<p>14-20实际解析</p>
<ul>
<li>14处理命名空间</li>
<li>15默认标签，自定义标签分别处理</li>
<li>16默认标签中的不同标签处理，bean、import、alias、beans</li>
<li>17解析bean标签和注册BeanDefinition的流程</li>
<li>18跳转</li>
<li>19-20解析bean标签</li>
</ul>
<p>​    </p>
<ol>
<li><p>ClassPathXmlApplicationContext类的构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String configLocation) throws BeansException &#123;</span><br><span class="line">    this(new String[]&#123;configLocation&#125;, true, (ApplicationContext)null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造方法内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    this.setConfigLocations(configLocations);</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">    	//刷新，即执行spring流程</span><br><span class="line">        this.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractApplicationContext类规定了refresh()的流程内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		// Prepare this context for refreshing.</span><br><span class="line">		// STEP 1： 刷新预处理</span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">		// STEP 2：</span><br><span class="line">		// 		a） 创建IoC容器（DefaultListableBeanFactory）</span><br><span class="line">		//		b） 加载解析XML文件（最终存储到Document对象中）</span><br><span class="line">		//		c） 读取Document对象，并完成BeanDefinition的加载和注册工作</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		// Prepare the bean factory for use in this context.</span><br><span class="line">		// STEP 3： 对IoC容器进行一些预处理（设置一些公共属性）</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">			// STEP 4： </span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Invoke factory processors registered as beans in the context.</span><br><span class="line">			// STEP 5： 调用BeanFactoryPostProcessor后置处理器对BeanDefinition处理</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Register bean processors that intercept bean creation.</span><br><span class="line">			// STEP 6： 注册BeanPostProcessor后置处理器</span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Initialize message source for this context.</span><br><span class="line">			// STEP 7： 初始化一些消息源（比如处理国际化的i18n等消息源）</span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			// Initialize event multicaster for this context.</span><br><span class="line">			// STEP 8： 初始化应用事件广播器</span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			// Initialize other special beans in specific context subclasses.</span><br><span class="line">			// STEP 9： 初始化一些特殊的bean</span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			// Check for listener beans and register them.</span><br><span class="line">			// STEP 10： 注册一些监听器</span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			// STEP 11： 实例化剩余的单例bean（非懒加载方式）</span><br><span class="line">			// 注意事项：Bean的IoC、DI和AOP都是发生在此步骤</span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Last step: publish corresponding event.</span><br><span class="line">			// STEP 12： 完成刷新时，需要发布对应的事件</span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			// Reset &#x27;active&#x27; flag.</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			// Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		finally &#123;</span><br><span class="line">			// Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">			// might not ever need metadata for singleton beans anymore...</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>obtainFreshBeanFactory()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	// 主要是通过该方法完成IoC容器的刷新</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractRefreshableApplicationContext类refreshBeanFactory()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	// 如果之前有IoC容器，则销毁</span><br><span class="line">   	if (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">      		// 创建IoC容器，也就是DefaultListableBeanFactory</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		// 设置工厂的属性：是否允许BeanDefinition覆盖和是否允许循环依赖</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">           // 调用载入BeanDefinition的方法，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span><br><span class="line">		loadBeanDefinitions(beanFactory);//钩子方法</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractXmlApplicationContext类的loadBeanDefinitions()的方法</p>
<p>准备工作完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">	// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">	// 创建一个BeanDefinition阅读器，通过阅读XML文件，真正完成BeanDefinition的加载和注册</span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">   </span><br><span class="line">	// Configure the bean definition reader with this context&#x27;s</span><br><span class="line">	// resource loading environment.</span><br><span class="line">	beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">   </span><br><span class="line">	// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">	// then proceed with actually loading the bean definitions.</span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"></span><br><span class="line">	// 委托给BeanDefinition阅读器去加载BeanDefinition</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>loadBeanDefinitions(XmlBeanDefinitionReader reader)方法</p>
<p>对资源的其他处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">	// 获取资源的定位</span><br><span class="line">	// 这里getConfigResources是一个空实现，真正实现是调用子类的获取资源定位的方法</span><br><span class="line">	// 比如：ClassPathXmlApplicationContext中进行了实现</span><br><span class="line">	// 		而FileSystemXmlApplicationContext没有使用该方法</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	if (configResources != null) &#123;</span><br><span class="line">		// XML Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的资源</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果子类中获取的资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	if (configLocations != null) &#123;</span><br><span class="line">		// XML Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的资源</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractBeanDefinitionReader的loadBeanDefinitions(configResources)方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">	int counter = 0;</span><br><span class="line">	for (Resource resource : resources) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XmlBeanDefinitionReader的loadBeanDefinitions(resource);</p>
<p>资源编码处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException 	  &#123;</span><br><span class="line">	// 将读入的XML资源进行特殊编码处理</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>loadBeanDefinitions的具体实现</p>
<p>获取xml资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">	if (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	if (currentResources == null) &#123;</span><br><span class="line">		currentResources = new HashSet&lt;&gt;(4);</span><br><span class="line">		this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		// 将资源文件转为InputStream的IO流</span><br><span class="line">		InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">		try &#123;</span><br><span class="line">			// 从InputStream中得到XML的解析源</span><br><span class="line">			InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">			if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			// 这里是具体的读取过程</span><br><span class="line">			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		if (currentResources.isEmpty()) &#123;</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>具体的读取xml过程 doLoadBeanDefinitions(inputSource, encodedResource.getResource());</p>
<p>用工具初步解析获取的xml资源流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// 通过DOM4J加载解析XML文件，最终形成Document对象</span><br><span class="line">		Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">		// 通过对Document对象的操作，完成BeanDefinition的加载和注册工作</span><br><span class="line">           return registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXParseException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ParserConfigurationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Parser configuration exception parsing XML from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Unexpected exception parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>registerBeanDefinitions(doc, resource);</p>
<p>注册bean流程，统计BeanDefinition数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	// 创建BeanDefinitionDocumentReader来解析Document对象，完成BeanDefinition解析</span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	// 获得容器中已经注册的BeanDefinition数量</span><br><span class="line">	int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	//解析过程入口，BeanDefinitionDocumentReader只是个接口，具体的实现过程在DefaultBeanDefinitionDocumentReader完成</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	// 统计新的的BeanDefinition数量</span><br><span class="line">	return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>DefaultBeanDefinitionDocumentReader类registerBeanDefinitions(doc, createReaderContext(resource));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)    &#123;</span><br><span class="line">	this.readerContext = readerContext;</span><br><span class="line">	logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">	// 获得Document的根元素&lt;beans&gt;标签</span><br><span class="line">	Element root = doc.getDocumentElement();</span><br><span class="line">	// 真正实现BeanDefinition解析和注册工作</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>doRegisterBeanDefinitions(root);</p>
<p>处理命名空间，并将解析工作委托给了其他类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">	// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span><br><span class="line">	// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span><br><span class="line">	// keep track of the current (parent) delegate, which may be null. Create</span><br><span class="line">	// the new (child) delegate with a reference to the parent for fallback purposes,</span><br><span class="line">	// then ultimately reset this.delegate back to its original (parent) reference.</span><br><span class="line">	// this behavior emulates a stack of delegates without actually necessitating one.</span><br><span class="line">	</span><br><span class="line">	// 这里使用了委托模式，将具体的BeanDefinition解析工作交给了BeanDefinitionParserDelegate去完成</span><br><span class="line">	BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class="line">	this.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    </span><br><span class="line">	// 判断该根标签是否包含http://www.springframework.org/schema/beans默认命名空间</span><br><span class="line">	if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">							&quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	// 委托给BeanDefinitionParserDelegate,从Document的根元素开始进行BeanDefinition的解析</span><br><span class="line">	parseBeanDefinitions(root, this.delegate);</span><br><span class="line">	// 在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span><br><span class="line">	postProcessXml(root);</span><br><span class="line">    </span><br><span class="line">	this.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>parseBeanDefinitions(root, this.delegate);</p>
<p>默认标签和自定义标签有不同的流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 加载的Document对象是否使用了Spring默认的XML命名空间（beans命名空间）</span><br><span class="line">	if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		// 获取Document对象根元素的所有子节点（bean标签、import标签、alias标签和其他自定义标签context、aop等）</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			if (node instanceof Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				// bean标签、import标签、alias标签，则使用默认解析规则</span><br><span class="line">				if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;//像context标签、aop标签、tx标签，则使用用户自定义的解析规则解析元素节点</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 如果不是默认的命名空间，则使用用户自定义的解析规则解析元素节点</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>parseDefaultElement(ele, delegate);</p>
<p>默认的标签中各个不同的标签解析不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 解析&lt;import&gt;标签</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析&lt;alias&gt;标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析&lt;bean&gt;标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析内置&lt;beans&gt;标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		// recurse</span><br><span class="line">		// 递归调用</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DefaultListableBeanFactory。processBeanDefinition(ele, delegate);</p>
<p>解析bean标签，注册BeanDefinition到IoC容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 解析&lt;bean&gt;标签，获取BeanDefinition</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder != null) &#123;</span><br><span class="line">		// 如果需要，则装饰BeanDefinition对象</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			// Register the final decorated instance.</span><br><span class="line">			// 注册最终的BeanDefinition到BeanDefinitionRegistry（DefaultListableBeanFactory）</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#x27;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#x27;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		// Send registration event.</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BeanDefinitionParserDelegate的parseBeanDefinitionElement(ele);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">	// 解析&lt;bean&gt;标签，获取BeanDefinition对象</span><br><span class="line">	return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>parseBeanDefinitionElement(ele, null);</p>
<p>做bean标签的解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">	// 获取bean的id</span><br><span class="line">	String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">	// 获取bean的name</span><br><span class="line">	String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    </span><br><span class="line">	List&lt;String&gt; aliases = new ArrayList&lt;&gt;();</span><br><span class="line">	if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	String beanName = id;</span><br><span class="line">	if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		beanName = aliases.remove(0);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot; + beanName +</span><br><span class="line">					&quot;&#x27; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	if (containingBean == null) &#123;</span><br><span class="line">		// 检查bean的id或者name是否唯一</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析&lt;bean&gt;标签，获取BeanDefinition对象</span><br><span class="line">	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	if (beanDefinition != null) &#123;</span><br><span class="line">		if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (containingBean != null) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					// Register an alias for the plain bean class name, if still possible,</span><br><span class="line">					// if the generator returned the class name plus a suffix.</span><br><span class="line">					// This is expected for Spring 1.2/2.0 backwards compatibility.</span><br><span class="line">					String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">					if (beanClassName != null &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot; +</span><br><span class="line">							&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		// 将BeanDefinition对象和BeanName封装到BeanDefinitionHolder对象中</span><br><span class="line">		return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>parseBeanDefinitionElement(ele, beanName, containingBean);</p>
<p>解析获取到的资源中的其他属性和bean的子标签，id,name已解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">		Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">    </span><br><span class="line">	this.parseState.push(new BeanEntry(beanName));</span><br><span class="line">    </span><br><span class="line">	String className = null;</span><br><span class="line">	// 获取bean标签的class属性</span><br><span class="line">	if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">	&#125;</span><br><span class="line">	String parent = null;</span><br><span class="line">	// 获取bean标签的parent属性</span><br><span class="line">	if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	try &#123;</span><br><span class="line">		// 创建BeanDefinition对象GenericBeanDefinition</span><br><span class="line">		AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">		</span><br><span class="line">		// 解析&lt;bean&gt;标签的属性</span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		/** 解析&lt;bean&gt;标签的子标签  --- begin**/</span><br><span class="line">		// 解析&lt;description&gt;标签</span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">		// 解析&lt;meta&gt;标签</span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		// 解析&lt;lookup-method&gt;标签</span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		// 解析&lt;replaced-method&gt;标签</span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		</span><br><span class="line">		// 解析&lt;constructor-arg&gt;标签</span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		// 解析&lt;property&gt;标签</span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		// 解析&lt;qualifier&gt;标签</span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line">		/** 解析&lt;bean&gt;标签的子标签  --- end**/</span><br><span class="line">    </span><br><span class="line">		bd.setResource(this.readerContext.getResource());</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line">    </span><br><span class="line">		return bd;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>源码实例化单例bean</title>
    <url>/2020/02/04/Spring-%E6%BA%90%E7%A0%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8D%95%E4%BE%8Bbean/</url>
    <content><![CDATA[<p>记录源码一步步实例化单例bean的过程</p>
<span id="more"></span>

<p>版本5.0.7</p>
<ol>
<li><p>AbstractApplicationContext的refresh()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		// Prepare this context for refreshing.</span><br><span class="line">           // STEP 1： 刷新预处理</span><br><span class="line">		prepareRefresh();</span><br><span class="line">   </span><br><span class="line">		// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">           // STEP 2：</span><br><span class="line">           // 		a） 创建IoC容器（DefaultListableBeanFactory）</span><br><span class="line">           //		b） 加载解析XML文件（最终存储到Document对象中）</span><br><span class="line">           //		c） 读取Document对象，并完成BeanDefinition的加载和注册工作</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">   </span><br><span class="line">		// Prepare the bean factory for use in this context.</span><br><span class="line">           // STEP 3： 对IoC容器进行一些预处理（设置一些公共属性）</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">		try &#123;</span><br><span class="line">			// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">               // STEP 4： </span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Invoke factory processors registered as beans in the context.</span><br><span class="line">			// STEP 5： 调用BeanFactoryPostProcessor后置处理器对BeanDefinition处理</span><br><span class="line">               invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Register bean processors that intercept bean creation.</span><br><span class="line">			// STEP 6： 注册BeanPostProcessor后置处理器</span><br><span class="line">               registerBeanPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Initialize message source for this context.</span><br><span class="line">			// STEP 7： 初始化一些消息源（比如处理国际化的i18n等消息源）</span><br><span class="line">               initMessageSource();</span><br><span class="line">   </span><br><span class="line">			// Initialize event multicaster for this context.</span><br><span class="line">			// STEP 8： 初始化应用事件广播器</span><br><span class="line">               initApplicationEventMulticaster();</span><br><span class="line">   </span><br><span class="line">			// Initialize other special beans in specific context subclasses.</span><br><span class="line">			// STEP 9： 初始化一些特殊的bean</span><br><span class="line">               onRefresh();</span><br><span class="line">   </span><br><span class="line">			// Check for listener beans and register them.</span><br><span class="line">			// STEP 10： 注册一些监听器</span><br><span class="line">               registerListeners();</span><br><span class="line">   </span><br><span class="line">			// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			// STEP 11： 实例化剩余的单例bean（非懒加载方式）</span><br><span class="line">               // 注意事项：Bean的IoC、DI和AOP都是发生在此步骤</span><br><span class="line">               finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Last step: publish corresponding event.</span><br><span class="line">			// STEP 12： 完成刷新时，需要发布对应的事件</span><br><span class="line">               finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			destroyBeans();</span><br><span class="line">   </span><br><span class="line">			// Reset &#x27;active&#x27; flag.</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">   </span><br><span class="line">			// Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		finally &#123;</span><br><span class="line">			// Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">			// might not ever need met		adata for singleton beans anymore...</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>finishBeanFactoryInitialization(beanFactory);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	// Initialize conversion service for this context.</span><br><span class="line">	if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Register a default embedded value resolver if no bean post-processor</span><br><span class="line">	// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">	// at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">	if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">	for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Stop using the temporary ClassLoader for type matching.</span><br><span class="line">	beanFactory.setTempClassLoader(null);</span><br><span class="line">   </span><br><span class="line">	// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line">   </span><br><span class="line">	// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">	// 实例化单例Bean之前</span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DefaultListableBeanFactory的preInstantiateSingletons()方法</p>
<p>FactoryBean的处理</p>
<p>BeanFactory内包括FactoryBean.BeanFactory实例化Bean，FactoryBean用来实例化Bean代理对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">	if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">		this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">	// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">	List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line">   </span><br><span class="line">	// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">	// 触发所有非懒加载方式的单例bean的创建</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		// 如果bean不是抽象的，而且是单例的，同时还不是懒加载的，则进行下面的操作</span><br><span class="line">		if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			// 如果bean是一个FactoryBean，则走下面的方法</span><br><span class="line">			if (isFactoryBean(beanName)) &#123;</span><br><span class="line">				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				if (bean instanceof FactoryBean) &#123;</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123; // 普通bean走下面的方法</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">			final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					return null;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractBeanFactory的getBean(beanName);</p>
<p>跳转，多个getBean重载方法跳转到同一个doGetBean方法    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">	// 获取Bean的实例</span><br><span class="line">	return doGetBean(name, null, null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>doGetBean(name, null, null, false);</p>
<p>获取bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">		@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">   </span><br><span class="line">	// 获取bean名称</span><br><span class="line">	final String beanName = transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line">   </span><br><span class="line">	// Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">	// 从缓存中获取单例bean</span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	if (sharedInstance != null &amp;&amp; args == null) &#123; //如果获取到单例bean，则走下面代码</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.debug(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				logger.debug(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果取出来的Bean实例是FactoryBean的Bean实例，则需要从FactoryBean实例中产生一个对象实例。</span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	else &#123;//如果没有获取到单例bean，则走下面代码</span><br><span class="line">		// Fail if we&#x27;re already creating this bean instance:</span><br><span class="line">		// We&#x27;re assumably within a circular reference.</span><br><span class="line">		</span><br><span class="line">		// 如果原型模式的Bean发生循环引用，则直接不处理，抛出异常</span><br><span class="line">		if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		// Check if bean definition exists in this factory.</span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			// Not found -&gt; check parent.</span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			if (parentBeanFactory instanceof AbstractBeanFactory) &#123;</span><br><span class="line">				return ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (args != null) &#123;</span><br><span class="line">				// Delegation to parent with explicit args.</span><br><span class="line">				return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// No args -&gt; delegate to standard getBean method.</span><br><span class="line">				return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		if (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		try &#123;</span><br><span class="line">			// 获取要实例化的bean的BeanDefinition对象</span><br><span class="line">			final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			// 检查该BeanDefinition对象对应的Bean是否是抽象的</span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">   </span><br><span class="line">			// Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			if (dependsOn != null) &#123;</span><br><span class="line">				for (String dep : dependsOn) &#123;</span><br><span class="line">					if (isDependent(beanName, dep)) &#123;</span><br><span class="line">						throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								&quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					try &#123;</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								&quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			// Create bean instance.</span><br><span class="line">			// 如果是单例的Bean，请下面的代码</span><br><span class="line">			if (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						// 创建单例Bean的主要方法</span><br><span class="line">						return createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (BeansException ex) &#123;</span><br><span class="line">						// Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">						// eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">						// Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						throw ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			else if (mbd.isPrototype()) &#123;</span><br><span class="line">				// It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">				Object prototypeInstance = null;</span><br><span class="line">				try &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				finally &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			else &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">				if (scope == null) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						try &#123;</span><br><span class="line">							return createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						finally &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (IllegalStateException ex) &#123;</span><br><span class="line">					throw new BeanCreationException(beanName,</span><br><span class="line">							&quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; +</span><br><span class="line">							&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Check if required type matches the type of the actual bean instance.</span><br><span class="line">	if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			if (convertedBean == null) &#123;</span><br><span class="line">				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			return convertedBean;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (TypeMismatchException ex) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type &#x27;&quot; +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + &quot;&#x27;&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return (T) bean;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>AbstractAutowireCapableBeanFactory的createBean(beanName, mbd, args);</p>
<p>创建bean的准备工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">		throws BeanCreationException &#123;</span><br><span class="line">   </span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">   </span><br><span class="line">	// Make sure bean class is actually resolved at this point, and</span><br><span class="line">	// clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">	// which cannot be stored in the shared merged bean definition.</span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">		mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">		mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Prepare method overrides.</span><br><span class="line">	// 处理方法覆盖</span><br><span class="line">	try &#123;</span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">				beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	try &#123;</span><br><span class="line">		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">		// 获取BeanPostProcessor代理对象</span><br><span class="line">		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		if (bean != null) &#123;</span><br><span class="line">			return bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">				&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	try &#123;</span><br><span class="line">		// 完成Bean实例的创建（实例化、填充属性、初始化）</span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">		// A previously detected exception with proper bean creation context already,</span><br><span class="line">		// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanCreationException(</span><br><span class="line">				mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>doCreateBean(beanName, mbdToUse, args);</p>
<p>创建bean</p>
<p>通过三级缓存解决set循环依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span><br><span class="line">		throws BeanCreationException &#123;</span><br><span class="line">   </span><br><span class="line">	// Instantiate the bean.</span><br><span class="line">	BeanWrapper instanceWrapper = null;</span><br><span class="line">	if (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	// bean初始化第一步：默认调用无参构造实例化Bean</span><br><span class="line">	// 构造参数依赖注入，就是发生在这一步</span><br><span class="line">	if (instanceWrapper == null) &#123;</span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	// 实例化后的Bean对象</span><br><span class="line">	final Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	if (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Allow post-processors to modify the merged bean definition.</span><br><span class="line">	synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">		if (!mbd.postProcessed) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;</span><br><span class="line">				throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">	// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">	// 解决循环依赖的关键步骤</span><br><span class="line">	boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	// 如果需要提前暴露单例Bean，则将该Bean放入三级缓存中</span><br><span class="line">	if (earlySingletonExposure) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">					&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// 将刚创建的bean放入三级缓存中singleFactories(key是beanName，value是FactoryBean)</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Initialize the bean instance.</span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	try &#123;</span><br><span class="line">		// bean初始化第二步：填充属性（DI依赖注入发生在此步骤）</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		// bean初始化第三步：调用初始化方法，完成bean的初始化操作（AOP发生在此步骤）</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			throw (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	if (earlySingletonExposure) &#123;</span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">		if (earlySingletonReference != null) &#123;</span><br><span class="line">			if (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							&quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">							&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">							&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">							&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Register bean as disposable.</span><br><span class="line">	try &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		throw new BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	return exposedObject;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>三步曲</p>
<p>bean初始化第一步：默认调用无参构造实例化Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 构造参数依赖注入，就是发生在这一步</span><br><span class="line">if (instanceWrapper == null) &#123;</span><br><span class="line">   instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean初始化第二步：填充属性（DI依赖注入发生在此步骤）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure>

<p>bean初始化第三步：调用初始化方法，完成bean的初始化操作（AOP发生在此步骤）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    </p>
<p><strong>先BeanPostProcessor，后放入三级缓存。</strong></p>
<p>AbstractAutowireCapableBeanFactory.java doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Allow post-processors to modify the merged bean definition.</span><br><span class="line">// 执行BeanPostProcessor</span><br><span class="line">synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">	if (!mbd.postProcessed) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		mbd.postProcessed = true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">// 解决循环依赖的关键步骤</span><br><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">		isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">// 如果需要提前暴露单例Bean，则将该Bean放入三级缓存中</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">				&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// 将刚创建的bean放入三级缓存中singleFactories(key是beanName，value是FactoryBean)</span><br><span class="line">	addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-全面了解</title>
    <url>/2020/08/23/SpringMVC-%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>参数绑定，RequestMapping、返回值处理、拦截器、RESTful支持、跨域</p>
<span id="more"></span>

<h1 id="SpringMVC-全面了解"><a href="#SpringMVC-全面了解" class="headerlink" title="SpringMVC-全面了解"></a>SpringMVC-全面了解</h1><p>处理请求映射，视图解析。对servlet做了封装。</p>
<p>执行流程：</p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView。</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View.</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SpringMVC是spring-web模块的一部分。</p>
<p>六大组件</p>
<p>对外的三大组件</p>
<p>​    前端控制器、处理器、视图</p>
<p>内部三大组件</p>
<p> 处理器映射器、处理器适配器、视图解析器</p>
<p>前后端分离只需要开发处理器。</p>
<h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>接收前端传递的参数后，SpringMVC依据绑定规则转换参数后，传递给Controller的形参。</p>
<p>SpringMVC底层采用24种绑定解析器（ArgumentResolver）处理</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>请求参数格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key/value</span><br></pre></td></tr></table></figure>

<p>请求参数数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String</span><br></pre></td></tr></table></figure>

<p>请求参数要绑定的目标类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Controller类中的方法参数，比如简单类型、POJO类型、集合类型等。</span><br></pre></td></tr></table></figure>

<p>RequestParam注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value:参数名字，即入参的请求参数名字</span><br><span class="line">required:默认是true，表示请求中一定要有相应的参数</span><br><span class="line">defaultValue：请求中没有同名参数时的默认值,使用时，required失效</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ModelAndView test(@RequestParam(value=&quot;name&quot;,required=false)String name)&#123;</span><br></pre></td></tr></table></figure>

<h3 id="绑定类型"><a href="#绑定类型" class="headerlink" title="绑定类型"></a>绑定类型</h3><p>简单类型数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过HTTP请求批量传递简单类型数组，Controller方法中可以用String[]或者pojo的String[]属性接收 （两种方式任选其一），但是不能使用List集合接收。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&amp;id=2&amp;id=3</span><br></pre></td></tr></table></figure>

<p>POJO类型集合或数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">批量传递的请求参数，最终要使用List&lt;POJO&gt;来接收，List&lt;POJO&gt;必须放在另一个POJO类中</span><br></pre></td></tr></table></figure>

<p>自定义日期 参数绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于springmvc无法解析的参数绑定类型,需要自定义 [参数转换器]进行参数绑定。</span><br></pre></td></tr></table></figure>

<p>Converter代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DateConverter implements Converter&lt;String, Date&gt; &#123; </span><br><span class="line">	@Override </span><br><span class="line">	public Date convert(String source) &#123; </span><br><span class="line">		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); </span><br><span class="line">		try &#123;</span><br><span class="line">			return simpleDateFormat.parse(source); </span><br><span class="line">		&#125; catch (ParseException e) &#123; </span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125;</span><br><span class="line">		return null; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Converter配置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 转换器配置 --&gt; </span><br><span class="line">&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; 		&lt;property name=&quot;converters&quot;&gt; </span><br><span class="line">		&lt;set&gt;&lt;</span><br><span class="line">			bean class=&quot;com.kkb.ssm.controller.converter.DateConverter&quot;/&gt; </span><br><span class="line">		&lt;/set&gt; </span><br><span class="line">	&lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>文件类型绑定</p>
<p>1.加入依赖<code> commons-fileupload</code></p>
<p>2.前端配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSP中的form表单需要指定enctype=”multipart/form-data”</span><br></pre></td></tr></table></figure>

<p>3.配置Multipart解析器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- multipart类型解析器，文件上传 --&gt; </span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; </span><br><span class="line">	&lt;!-- 上传文件的最大尺寸 5M--&gt; </span><br><span class="line">	&lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;/&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>4.Cotroller类代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;fileupload&quot;) </span><br><span class="line">public String findUserById(MultipartFile uploadFile) throws Exception &#123;</span><br><span class="line">    if (uploadFile != null) &#123;</span><br><span class="line">        System.out.println(uploadFile.getOriginalFilename());</span><br><span class="line">        // 原始图片名称 </span><br><span class="line">        String originalFilename = uploadFile.getOriginalFilename();</span><br><span class="line">        // 如果没有图片名称，则上传不成功 </span><br><span class="line">        if (originalFilename != null &amp;&amp; originalFilename.length() &gt; 0) &#123;</span><br><span class="line">            // 存放图片的物理路径 </span><br><span class="line">            String picPath = &quot;E:\\&quot;;</span><br><span class="line">            // 获取上传文件的扩展名 </span><br><span class="line">            String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">            // 新文件的名称 </span><br><span class="line">            String newFileName = UUID.randomUUID() + extName;</span><br><span class="line">            // 新的文件 </span><br><span class="line">            File newFile = new File(picPath + newFileName);</span><br><span class="line">            // 把上传的文件保存成一个新的文件 </span><br><span class="line">            uploadFile.transferTo(newFile);</span><br><span class="line">            // 同时需要把新的文件名更新到数据库中 </span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;文件上传成功&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h2><p>value属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用于映射URL和HandlerMethod方法</span><br><span class="line">@RequestMapping(value=&quot;test&quot;)</span><br></pre></td></tr></table></figure>

<p>method属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 限定请求URL使用指定的method请求方式</span><br><span class="line">@RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET)</span><br><span class="line">@RequestMapping(value=&quot;/test&quot;,method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure>

<p>params属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 访问HandlerMethod 的限制</span><br><span class="line">@RequestMapping(value=&quot;test&quot;,params= &#123;&quot;name&quot;,&quot;price&gt;5000&quot;&#125;) </span><br><span class="line">public String test(Model model) &#123; </span><br><span class="line">	model.addAttribute(&quot;msg&quot;, &quot;test方法执行了&quot;); </span><br><span class="line">	return &quot;success&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@ResponseBody</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对Controller返回值类型，使用内置的9种HttpMessageConverter进行匹配，找 到合适HttpMessageConverter进行处理。</span><br></pre></td></tr></table></figure>

<p>@RequestBody 处理请求参数的http消息转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping()</span><br><span class="line">public Message test(@RequestBody json)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非注解"><a href="#非注解" class="headerlink" title="非注解"></a>非注解</h3><p>1.ModelAndView </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ModelAndView test()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>ModelAndView 可添加model数据、指定view。</p>
<p>2.void</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test(HttpServletRequest request, HttpServletResponse response)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>request转发向页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</span><br></pre></td></tr></table></figure>

<p>过response页面重定向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(&quot;url&quot;)</span><br></pre></td></tr></table></figure>

<p>response指定响应结果，例如响应json数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;json串&quot;);</span><br></pre></td></tr></table></figure>

<p>3.String</p>
<p>forward转发 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return “forward:testForward&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于“ request.getRequestDispatcher().forward(request,response) ”</span><br><span class="line"></span><br><span class="line">浏览器URL不发送改变</span><br><span class="line"></span><br><span class="line">Request 域可以共享</span><br></pre></td></tr></table></figure>



<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>Spring MVC 的拦截器做了三次拦截。请求拦截一次，返回拦截两次。</p>
<p>请求拦截可做登录认证。</p>
<p>返回拦截中视图处理，前后端分离后不需要了</p>
<p>返回拦截中**，可用统一日志、统一异常处理。</p>
<h3 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h3><p>实现SpringMVC的HandlerIntercepter 接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyHandlerIntercepter implements HandlerInterceptor&#123;</span><br><span class="line"></span><br><span class="line">	//Handler执行前调用 </span><br><span class="line">	//应用场景：登录认证、身份授权 </span><br><span class="line">	//返回值为true则是放行，为false是不放行 </span><br><span class="line">	@Override </span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; </span><br><span class="line">		return false; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//进入Handler开始执行，并且在返回ModelAndView之前调用 </span><br><span class="line">	//应用场景：对ModelAndView对象操作，可以把公共模型数据传到前台，可以统一指定视图 </span><br><span class="line">	@Override </span><br><span class="line">	public void postHandle(HttpServletRequest request,HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; </span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//执行完Handler之后调用 </span><br><span class="line">	//应用场景：统一异常处理、统一日志处理 </span><br><span class="line">	@Override </span><br><span class="line">	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; </span><br><span class="line">	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p>SpringMVC 拦截器是绑定在 HandlerMapping 中的，即：如果某个 HandlerMapping 中配置拦截，则该HandlerMapping 映射成功的 Handler 会使用该拦截器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置全局mapping的拦截器 --&gt; </span><br><span class="line">&lt;mvc:interceptors&gt; </span><br><span class="line">	&lt;!-- 公共拦截器可以拦截所有请求，而且可以有多个 --&gt; </span><br><span class="line">	&lt;bean class=&quot;com.ssm.interceptor.MyHandlerInterceptor&quot; /&gt; </span><br><span class="line">	&lt;bean class=&quot;com.ssm.interceptor.MyHandlerInterceptor2&quot; /&gt; </span><br><span class="line">	&lt;!-- 如果有针对特定URL的拦截器，则进行以下配置 --&gt; </span><br><span class="line">	&lt;mvc:interceptor&gt; </span><br><span class="line">		&lt;!-- /**表示所有URL和子URL路径 --&gt; </span><br><span class="line">		&lt;mvc:mapping path=&quot;/orders/**&quot; /&gt; </span><br><span class="line">		&lt;!-- 特定请求的拦截器只能有一个 --&gt; </span><br><span class="line">		&lt;bean class=&quot;com.ssm.interceptor.MyHandlerInterceptor3&quot; /&gt; </span><br><span class="line">	&lt;/mvc:interceptor&gt; </span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果有多个拦截器，那么配置到`springmvc.xml`中最上面的拦截器，拦截优先级最高。 --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Restful支持"><a href="#Restful支持" class="headerlink" title="Restful支持"></a>Restful支持</h2><h3 id="rest介绍"><a href="#rest介绍" class="headerlink" title="rest介绍"></a>rest介绍</h3><p>REST（英文：Representational State Transfer，意思是：（资源）表述性状态转化)</p>
<p>rest是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。</p>
<p>基于rest风格设计的软件更简洁，有层次，更易于实现缓存等机制。</p>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络上的一个实体，例如：一段文本、一张图片、一首歌曲、一种服务。</span><br><span class="line">可以用URI（统一资源定位符）指向它，每种资源对应一个特定的URI。</span><br></pre></td></tr></table></figure>

<h4 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把资源呈现出来的形式，叫做表现层。</span><br><span class="line">格式：html、xml、json，二级制。</span><br></pre></td></tr></table></figure>

<h4 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每发出一个HTTP请求，就代表了客户端和服务器的一次交互过程。</span><br><span class="line">HTTP协议，是一个无状态协议，即所有的【状态】 都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。</span><br><span class="line"></span><br><span class="line">HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT 、DELETE 。它们分别对应四种 基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</span><br></pre></td></tr></table></figure>

<h3 id="如何设计RESTful应用程序的API"><a href="#如何设计RESTful应用程序的API" class="headerlink" title="如何设计RESTful应用程序的API"></a>如何设计RESTful应用程序的API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径设计：数据库设计完毕之后，基本上就可以确定有哪些资源要进行操作，相对于资源的路径也可以设计出来 </span><br><span class="line">动词设计：也就是针对资源的具体操作类型，由HTTP动词表示，常用的HTTP动词如下：POST、DELETE、PUT、GET</span><br></pre></td></tr></table></figure>

<p>RESTful的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/account/1 HTTP GET ： 得到 id = 1 的 account </span><br><span class="line">/account/1 HTTP DELETE： 删除 id = 1 的 account </span><br><span class="line">/account/1 HTTP PUT： 更新 id = 1 的 account</span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC如何支持Restful"><a href="#SpringMVC如何支持Restful" class="headerlink" title="SpringMVC如何支持Restful"></a>SpringMVC如何支持Restful</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 拦截RESTful请求</span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">	&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; </span><br><span class="line">	&lt;url-pattern&gt;/&lt;/url-pattern&gt; </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">// 设置为/ ,前后端不分离时，需要处理静态资源路径。</span><br></pre></td></tr></table></figure>



<h4 id="url与参数绑定"><a href="#url与参数绑定" class="headerlink" title="url与参数绑定"></a>url与参数绑定</h4><p>@PathVariable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求URL http://localhost:8080/ssm/item/1/lisi</span><br><span class="line"></span><br><span class="line">// Controller</span><br><span class="line">@RequestMapping(“&#123;id&#125;/&#123;name&#125;”) </span><br><span class="line">@ResponseBody </span><br><span class="line">public Item queryItemById(@PathVariable Integer id, @PathVariable String name)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源的表现形式"><a href="#资源的表现形式" class="headerlink" title="资源的表现形式"></a>资源的表现形式</h4><p>SpringMVC中可以使用 ContentNegotiatingManager这个内容协商管理器来控制表现形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展名：比如.json表示我要JSON格式数据、.xml表示我要XML格式数据</span><br><span class="line">请求参数：默认是”format”</span><br><span class="line">请求头设置Accept参数：比如设置Accept为application/json表示要JSON格式数据</span><br></pre></td></tr></table></figure>



<h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping：通过设置method属性值</span><br><span class="line">@GetMapping、@PostMapping、@PutMapping、@DeleteMapping注解等同@RequestMapping注解配置method属性。</span><br></pre></td></tr></table></figure>



<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>浏览器为了安全有这么一个规定：同源策略，即只用同源才可以访问浏览器的数据，非同源不可访问。</p>
<p>同源：相同的http协议、相同的域名、相同的端口号。</p>
<p>前后端分离后，前端和后端不是同源。这种情况我们要实现前后的非同源访问，就是跨域访问。</p>
<table>
<thead>
<tr>
<th>跨域情况</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>主域相同子域不同</td>
<td><a href="http://www.baidu.com/a.js">http://www.baidu.com/a.js</a></td>
<td><a href="http://blog.baidu.com/b.js">http://blog.baidu.com/b.js</a></td>
</tr>
<tr>
<td>协议不同</td>
<td><a href="http://www.baidu.com/a.js">http://www.baidu.com/a.js</a></td>
<td><a href="https://www.baidu.com/b.js">https://www.baidu.com/b.js</a></td>
</tr>
<tr>
<td>域名对应真实ip</td>
<td><a href="http://www.baidu.com/a.js">http://www.baidu.com/a.js</a></td>
<td><a href="http://192.168.2.2/b.js">http://192.168.2.2/b.js</a></td>
</tr>
</tbody></table>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>三种方式：基于JavaScript标签的src方式，基于JQuery的JSONP方式，基于CORS的方式。</p>
<p>JSONP只能解决get方式。CORS可解决GET、POST。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><h5 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h5><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（ Cross-origin resource sharing ）。</p>
<p>它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能， IE 浏览器不能低于 IE10 </p>
<p>请求信息：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4oOue7PfNEI9C3s.png" alt="image-20200823082701342"></p>
<p>响应信息：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Q1OcS5LPMiTCZ4j.png" alt="image-20200823082826743"></p>
<p>前端设置请求头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动向请求头 header 中注入 Origin 。</span><br></pre></td></tr></table></figure>

<p>后端对响应拦截，设置响应头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器端需要向响应头 header 中注入 Access-Control-Allow-Origin</span><br></pre></td></tr></table></figure>

<h5 id="CORS实现跨域"><a href="#CORS实现跨域" class="headerlink" title="CORS实现跨域"></a>CORS实现跨域</h5><h6 id="CORS通过拦截器实现"><a href="#CORS通过拦截器实现" class="headerlink" title="CORS通过拦截器实现"></a>CORS通过拦截器实现</h6><p>跨域不提交cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AllowOriginInterceptor implements HandlerInterceptor &#123; </span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123; </span><br><span class="line">		// 跨域行为参考网址 http://www.cnblogs.com/renhaisong/p/6892341.html</span><br><span class="line">		if (request.getHeader(&quot;Origin&quot;) != null) &#123; </span><br><span class="line">            response.setContentType(&quot;text/html;charset=UTF-8&quot;); </span><br><span class="line">            // 允许哪一个URL </span><br><span class="line">            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); </span><br><span class="line">            // 允许那种请求方法 </span><br><span class="line">            response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE, PUT&quot;); </span><br><span class="line">            response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;); </span><br><span class="line">            System.out.println(&quot;正在跨域&quot;); </span><br><span class="line">		&#125;</span><br><span class="line">		return true; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跨域提交Cookie</p>
<p>注意：</p>
<ul>
<li><code>Access-Control-Allow-Credentials</code> 为 true 的时候， <code>Access-Control-Allow-Origin</code> 不能设置为”*”，否则报错。</li>
<li>如果有多个拦截器，把处理跨域请求的拦截器放到首位</li>
</ul>
<p>前端JQuery代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123; </span><br><span class="line">	url: &#x27;url&#x27;, </span><br><span class="line">	method:&#x27;请求方式&#x27;, //GET POST PUT DELETE </span><br><span class="line">	xhrFields:&#123; </span><br><span class="line">		withCredentials:true </span><br><span class="line">	&#125;,</span><br><span class="line">	success:function(data)&#123; </span><br><span class="line">		// do something </span><br><span class="line">	&#125;,</span><br><span class="line">	error:function()&#123; </span><br><span class="line">		// do something  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后端JAVA代码，采用springMVC拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AllowOriginInterceptor implements HandlerInterceptor &#123; </span><br><span class="line">	@Override </span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123; </span><br><span class="line">		// 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434 </span><br><span class="line">		if (request.getHeader(&quot;Origin&quot;) != null) &#123; </span><br><span class="line">			response.setContentType(&quot;text/html;charset=UTF-8&quot;); </span><br><span class="line">			// 允许哪一个URL访问 request.getHeader(&quot;Origin&quot;) 动态获取请求来的url</span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); </span><br><span class="line">			// 允许那种请求方法 </span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,HEAD&quot;); </span><br><span class="line">			// 本次预检请求的有效期 (&quot;0&quot;:每次异步请求都发起预检请求，允许跨域，再发出正式请求。&quot;3600&quot;：有效期1小时)</span><br><span class="line">			response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;0&quot;); </span><br><span class="line">			// 允许请求头里的参数列表 </span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token&quot;); </span><br><span class="line">			// 允许对方带cookie访问 </span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); </span><br><span class="line">			response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;); </span><br><span class="line">			System.out.println(&quot;可接待cookie跨域&quot;); </span><br><span class="line">		&#125;</span><br><span class="line">		return true; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端JAVA代码，采用过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component // 表示这是配置类，注入到Spring容器中。（不属于@Controller、@Services、@repository)</span><br><span class="line">public class CorsFilter implements Filter &#123;</span><br><span class="line"> </span><br><span class="line">     @Override</span><br><span class="line">     public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     @Override</span><br><span class="line">     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">         HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">         HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, httpRequest.getHeader(&quot;Origin&quot;)!=null ? httpRequest.getHeader(&quot;Origin&quot;):&quot;&quot;);</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httpRequest.getMethod());</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, httpRequest.getHeader(&quot;Access-Control-Request-Headers&quot;));</span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     @Override</span><br><span class="line">     public void destroy() &#123;</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="CORS通过注解方式"><a href="#CORS通过注解方式" class="headerlink" title="CORS通过注解方式"></a>CORS通过注解方式</h6><p>springMVC4.x以上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CrossOrigin</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper-入门</title>
    <url>/2020/08/25/Zookeeper-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Zookeeper的介绍，helloword，Curator,分布式锁，集群</p>
<span id="more"></span>

<h1 id="ZooKeeper-基础"><a href="#ZooKeeper-基础" class="headerlink" title="ZooKeeper-基础"></a>ZooKeeper-基础</h1><p>官网：</p>
<p>版本：ZooKeeper3.6</p>
<p>支持JDK8、11、12</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RBHqshvYfZPKdwb.png" alt="image-20200825064140355"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hadoop的一个子项目，用于管理服务。</p>
<ul>
<li>服务注册中心</li>
<li>服务配置</li>
<li>分布式锁</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Zookeeper-安装</p>
<h2 id="zookeeper命令行操作"><a href="#zookeeper命令行操作" class="headerlink" title="zookeeper命令行操作"></a>zookeeper命令行操作</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>zookeeper的结构类似Linux树形目录结构。</p>
<p>由一个个节点+节点之间的联系构成。</p>
<p>zookeeper的节点可以有子节点，并且可以存储少量信息（1M，如：地址信息，172.168.0.1）</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Iacr7Q6HEdUfAjK.png" alt="image-20200903180546203"></p>
<p>节点可以分为四大类：</p>
<ul>
<li>PERSISTENT 持久化节点 </li>
</ul>
<ul>
<li>EPHEMERAL 临时节点 ：-e</li>
</ul>
<ul>
<li>PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</li>
</ul>
<ul>
<li>EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es</li>
</ul>
<h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li>
<li><p>停止</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br></pre></td></tr></table></figure></li>
<li><p>重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh restart</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li>
<li><p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#未启动</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul>
<li><p>克隆会话</p>
</li>
<li><p>进入zookeeper的bin目录</p>
</li>
<li><p>连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#./zkCli.sh –server ip:port</span><br><span class="line">./zkCli.sh –server localhost:2181</span><br><span class="line">#或者</span><br><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Q74wNtbd5ixL8RG.png" alt="image-20200913123531063"></p>
</li>
</ul>
<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul>
<li><p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /</span><br><span class="line">#结果：[zookeeper]</span><br></pre></td></tr></table></figure></li>
<li><p>查看详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls -s /</span><br><span class="line">[zookeeper]cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<p>解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">czxid：节点被创建的事务ID </span><br><span class="line">ctime: 创建时间 </span><br><span class="line">mzxid: 最后一次被更新的事务ID </span><br><span class="line">mtime: 修改时间 </span><br><span class="line">pzxid：子节点列表最后一次被更新的事务ID</span><br><span class="line">cversion：子节点的版本号 </span><br><span class="line">dataversion：数据版本号 </span><br><span class="line">aclversion：权限版本号 </span><br><span class="line">ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 </span><br><span class="line">dataLength：节点存储的数据的长度 </span><br><span class="line">numChildren：当前节点的子节点个数 </span><br></pre></td></tr></table></figure></li>
<li><p>创建持久节点 默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] create /xiaorui</span><br><span class="line">Created /xiaorui</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /</span><br><span class="line">[xiaorui, zookeeper]</span><br></pre></td></tr></table></figure></li>
<li><p>获取节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] get /xiaorui</span><br><span class="line">null</span><br></pre></td></tr></table></figure></li>
<li><p>设置节点值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#set path value</span><br><span class="line">set /xiaorui han</span><br></pre></td></tr></table></figure></li>
<li><p>删除单个节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete /节点path</span><br></pre></td></tr></table></figure></li>
<li><p>删除带有子节点的节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deleteall /节点path</span><br></pre></td></tr></table></figure></li>
<li><p>临时节点 -e 会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create -e /节点path value</span><br></pre></td></tr></table></figure></li>
<li><p>顺序节点 -s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create -s /节点path value</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="zookeeper-JavaAPI操作"><a href="#zookeeper-JavaAPI操作" class="headerlink" title="zookeeper JavaAPI操作"></a>zookeeper JavaAPI操作</h2><h3 id="curator"><a href="#curator" class="headerlink" title="curator"></a>curator</h3><p>官网：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<p>简化原生JavaAPI对zookeeper的操作。</p>
<p>Apache的顶级项目</p>
<p>版本:与zookeeper版本对应</p>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><h4 id="导入curator-junit"><a href="#导入curator-junit" class="headerlink" title="导入curator+junit"></a>导入curator+junit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper-curator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--curator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日志--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>



<h4 id="操作curator"><a href="#操作curator" class="headerlink" title="操作curator"></a>操作curator</h4><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private CuratorFramework client;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 建立连接</span><br><span class="line">    */</span><br><span class="line">   @Before</span><br><span class="line">   public void testConnect() &#123;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        *</span><br><span class="line">        * @param connectString       连接字符串。zk server 地址和端口 &quot;192.168.3.3:2181&quot;</span><br><span class="line">        * @param sessionTimeoutMs    会话超时时间 单位ms</span><br><span class="line">        * @param connectionTimeoutMs 连接超时时间 单位ms</span><br><span class="line">        * @param retryPolicy         重试策略</span><br><span class="line">        */</span><br><span class="line">      /* //重试策略</span><br><span class="line">       RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000,10);</span><br><span class="line">       //1.第一种方式</span><br><span class="line">       CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.3.3:2181&quot;,</span><br><span class="line">               60 * 1000, 15 * 1000, retryPolicy);*/</span><br><span class="line">       //重试策略</span><br><span class="line">       RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10);</span><br><span class="line">       //2.第二种方式</span><br><span class="line">       //CuratorFrameworkFactory.builder();</span><br><span class="line">       client = CuratorFrameworkFactory.builder()</span><br><span class="line">               .connectString(&quot;192.168.3.3:2181&quot;)</span><br><span class="line">               .sessionTimeoutMs(60 * 1000)</span><br><span class="line">               .connectionTimeoutMs(15 * 1000)</span><br><span class="line">               .retryPolicy(retryPolicy)</span><br><span class="line">               .namespace(&quot;xiaoruiit&quot;)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       //开启连接</span><br><span class="line">       client.start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @After</span><br><span class="line">   public void close() &#123;</span><br><span class="line">       if (client != null) &#123;</span><br><span class="line">           client.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建节点：create 持久 临时 顺序 数据</span><br><span class="line">    * 1. 基本创建 ：create().forPath(&quot;&quot;)</span><br><span class="line">    * 2. 创建节点 带有数据:create().forPath(&quot;&quot;,data)</span><br><span class="line">    * 3. 设置节点的类型：create().withMode().forPath(&quot;&quot;,data)</span><br><span class="line">    * 4. 创建多级节点  /app1/p1 ：create().creatingParentsIfNeeded().forPath(&quot;&quot;,data)</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate() throws Exception &#123;</span><br><span class="line">       //2. 创建节点 带有数据</span><br><span class="line">       //如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span><br><span class="line">       String path = client.create().forPath(&quot;/app2&quot;, &quot;haha&quot;.getBytes());</span><br><span class="line">       System.out.println(path);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate2() throws Exception &#123;</span><br><span class="line">       //1. 基本创建</span><br><span class="line">       //如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span><br><span class="line">       String path = client.create().forPath(&quot;/app1&quot;);</span><br><span class="line">       System.out.println(path);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate3() throws Exception &#123;</span><br><span class="line">       //3. 设置节点的类型</span><br><span class="line">       //默认类型：持久化</span><br><span class="line">       String path = client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;/app3&quot;);</span><br><span class="line">       System.out.println(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate4() throws Exception &#123;</span><br><span class="line">       //4. 创建多级节点  /app1/p1</span><br><span class="line">       //creatingParentsIfNeeded():如果父节点不存在，则创建父节点</span><br><span class="line">       String path = client.create().creatingParentsIfNeeded().forPath(&quot;/app4/p1&quot;);</span><br><span class="line">       System.out.println(path);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/J3RLSxczs9OoTU7.png" alt="image-20200913185407017"></p>
<h5 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 查询节点：</span><br><span class="line">    * 1. 查询数据：get: getData().forPath()</span><br><span class="line">    * 2. 查询子节点： ls: getChildren().forPath()</span><br><span class="line">    * 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath()</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testGet1() throws Exception &#123;</span><br><span class="line">       //1. 查询数据：get</span><br><span class="line">       byte[] data = client.getData().forPath(&quot;/app1&quot;);</span><br><span class="line">       System.out.println(new String(data));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testGet2() throws Exception &#123;</span><br><span class="line">       // 2. 查询子节点： ls</span><br><span class="line">       List&lt;String&gt; path = client.getChildren().forPath(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(path);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testGet3() throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       Stat status = new Stat();</span><br><span class="line">       System.out.println(status);</span><br><span class="line">       //3. 查询节点状态信息：ls -s</span><br><span class="line">       client.getData().storingStatIn(status).forPath(&quot;/app1&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(status);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 修改数据</span><br><span class="line">    * 1. 基本修改数据：setData().forPath()</span><br><span class="line">    * 2. 根据版本修改: setData().withVersion().forPath()</span><br><span class="line">    * * version 是查询出来的。目的是为了让其他客户端或者线程不干扰我。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void testSet() throws Exception &#123;</span><br><span class="line">       client.setData().forPath(&quot;/app1&quot;, &quot;itcast&quot;.getBytes());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testSetForVersion() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       Stat status = new Stat();</span><br><span class="line">       //3. 查询节点状态信息：ls -s</span><br><span class="line">       client.getData().storingStatIn(status).forPath(&quot;/app1&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       int version = status.getVersion();//查询出来的 3</span><br><span class="line">       System.out.println(version);</span><br><span class="line">       client.setData().withVersion(version).forPath(&quot;/app1&quot;, &quot;haha&quot;.getBytes());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 删除节点： delete deleteall</span><br><span class="line">    * 1. 删除单个节点:delete().forPath(&quot;/app1&quot;);</span><br><span class="line">    * 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath(&quot;/app1&quot;);</span><br><span class="line">    * 3. 必须成功的删除:为了防止网络抖动。本质就是重试。  client.delete().guaranteed().forPath(&quot;/app2&quot;);</span><br><span class="line">    * 4. 回调：inBackground</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete() throws Exception &#123;</span><br><span class="line">       // 1. 删除单个节点</span><br><span class="line">       client.delete().forPath(&quot;/app1&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete2() throws Exception &#123;</span><br><span class="line">       //2. 删除带有子节点的节点</span><br><span class="line">       client.delete().deletingChildrenIfNeeded().forPath(&quot;/app4&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete3() throws Exception &#123;</span><br><span class="line">       //3. 必须成功的删除</span><br><span class="line">       client.delete().guaranteed().forPath(&quot;/app2&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete4() throws Exception &#123;</span><br><span class="line">       //4. 回调</span><br><span class="line">       client.delete().guaranteed().inBackground(new BackgroundCallback()&#123;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void processResult(CuratorFramework client, CuratorEvent event) throws Exception &#123;</span><br><span class="line">               System.out.println(&quot;删除了~&quot;);</span><br><span class="line">               System.out.println(event);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).forPath(&quot;/app1&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Watch监听"><a href="#Watch监听" class="headerlink" title="Watch监听"></a>Watch监听</h5><p>ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<p>Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</p>
<p>ZooKeeper提供了三种Watcher：</p>
<ul>
<li>NodeCache : 只是监听某一个特定的节点</li>
</ul>
<ul>
<li>PathChildrenCache : 监控一个ZNode的子节点. </li>
</ul>
<ul>
<li>TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li>
</ul>
<p><strong>implementation</strong></p>
<ul>
<li><p>Watch监听-NodeCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 演示 NodeCache：给指定一个节点注册监听器</span><br><span class="line">*/</span><br><span class="line">@Test</span><br><span class="line">public void testNodeCache() throws Exception &#123;</span><br><span class="line">    //1. 创建NodeCache对象</span><br><span class="line">    final NodeCache nodeCache = new NodeCache(client,&quot;/app1&quot;);</span><br><span class="line">    //2. 注册监听</span><br><span class="line">   	nodeCache.getListenable().addListener(new NodeCacheListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void nodeChanged() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;节点变了~&quot;);</span><br><span class="line">            //获取修改节点后的数据</span><br><span class="line">            byte[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">            System.out.println(new String(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span><br><span class="line">    	nodeCache.start(true);</span><br><span class="line">    	while (true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Watch监听-PathChildrenCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPathChildrenCache() throws Exception &#123;</span><br><span class="line">    //1.创建监听对象</span><br><span class="line">    PathChildrenCache pathChildrenCache = new PathChildrenCache(client,&quot;/app2&quot;,true);</span><br><span class="line">    //2. 绑定监听器</span><br><span class="line">    pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() &#123;    			</span><br><span class="line">    	@Override</span><br><span class="line">        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子节点变化了~&quot;);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">            //监听子节点的数据变更，并且拿到变更后的数据</span><br><span class="line">            //1.获取类型</span><br><span class="line">            PathChildrenCacheEvent.Type type = event.getType();</span><br><span class="line">            //2.判断类型是否是update</span><br><span class="line">            if(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                System.out.println(&quot;数据变了&quot;);</span><br><span class="line">                byte[] data = event.getData().getData();</span><br><span class="line">                System.out.println(new String(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //3. 开启</span><br><span class="line">    pathChildrenCache.start();</span><br><span class="line">    while (true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Watch监听-TreeCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 演示 TreeCache：监听某个节点自己和所有子节点们</span><br><span class="line">*/</span><br><span class="line">@Test</span><br><span class="line">public void testTreeCache() throws Exception &#123;</span><br><span class="line">    //1. 创建监听器</span><br><span class="line">    TreeCache treeCache = new TreeCache(client,&quot;/app2&quot;);</span><br><span class="line">    //2. 注册监听</span><br><span class="line">    treeCache.getListenable().addListener(new TreeCacheListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;节点变了&quot;);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //3. 开启</span><br><span class="line">    treeCache.start();</span><br><span class="line">    while (true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p><strong>介绍：</strong>后端项目使用分布式集群时，这时是多jvm环境，锁无法解决多机同步问题。出现了分布式锁。</p>
<p><strong>zookeeper分布式锁原理</strong>：客户端要获取锁，1.在请求下创建临时顺序子节点，2.若节点最小，则获得了锁，执行业务3.使用完锁，则删除该节点，释放锁。</p>
<p><strong>原理详解：</strong></p>
<p>1.客户端在lock节点下创建临时顺序节点。</p>
<p>2.获取lock下面的所有子节点，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁，执行业务代码。使用完锁后，将该节点删除。</p>
<p>3.如果自己创建的节点并非lock所有子节点中最小的，找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</p>
<p>4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤（监听比自己小一个节点的删除事件，判断自己是否是最小节点）。</p>
<p><strong>Curator实现分布式锁：</strong></p>
<ul>
<li><p>五种锁方案：</p>
<ul>
<li><p>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</p>
</li>
<li><p>InterProcessMutex：分布式可重入排它锁</p>
</li>
<li><p>InterProcessReadWriteLock：分布式读写锁</p>
</li>
<li><p>InterProcessMultiLock：将多个锁作为单个实体管理的容器</p>
</li>
<li><p>InterProcessSemaphoreV2：共享信号量</p>
</li>
</ul>
</li>
<li><p><strong>implementation：</strong></p>
<p><strong>InterProcessMutex 方式</strong></p>
<p>1.创建线程，加锁设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Ticket12306 implements Runnable&#123;</span><br><span class="line">    private int tickets = 20; //数据库的票数</span><br><span class="line">    private InterProcessMutex lock ;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">            lock.acquire(2, TimeUnit.SECONDS);</span><br><span class="line">                if(tickets &gt; 0)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;:&quot;+tickets);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                //释放锁</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建连接，初始化锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Ticket12306()&#123;</span><br><span class="line">    //重试策略</span><br><span class="line">    RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10);</span><br><span class="line">    //2.第二种方式</span><br><span class="line">    //CuratorFrameworkFactory.builder();</span><br><span class="line">    CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(&quot;192.168.3.3:2181&quot;)</span><br><span class="line">        .sessionTimeoutMs(60 * 1000)</span><br><span class="line">        .connectionTimeoutMs(15 * 1000)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .build();</span><br><span class="line">    //开启连接</span><br><span class="line">    client.start();</span><br><span class="line">    lock = new InterProcessMutex(client,&quot;/lock&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.多个线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LockTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket12306 ticket12306 = new Ticket12306();</span><br><span class="line">        //创建客户端</span><br><span class="line">        Thread t1 = new Thread(ticket12306,&quot;骆驼旅行&quot;);</span><br><span class="line">        Thread t2 = new Thread(ticket12306,&quot;分流抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><ul>
<li>leader 领导<ul>
<li>处理事务请求</li>
<li>集群内部各服务器的调度</li>
</ul>
</li>
<li>follower 跟随者<ul>
<li>处理客户端非事务请求，转发事务给leader服务器</li>
<li>参与leader选举投票</li>
</ul>
</li>
<li>observer 观察者<ul>
<li>处理客户端非事务请求，转发事务给leader服务器</li>
</ul>
</li>
</ul>
<h3 id="领导算法"><a href="#领导算法" class="headerlink" title="领导算法"></a>领导算法</h3><p><strong>介绍：</strong>服务器投票选举主服务器，名称为领导（leader）。</p>
<p><strong>逻辑：</strong></p>
<ul>
<li><p>服务器id越大，权重越大。</p>
</li>
<li><p>半数投票前，没加入一个服务器都重新投票和选举。</p>
</li>
<li><p>某个服务器得到半数投票后，角色变为leader。集群变为可用状态。</p>
</li>
<li><p>有leader角色后，新服务器加入集群，不会重新投票和选举。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>服务器id=1,2,3三个服务器，1,2,3依次启动。1启动，给自己投一票；2启动，1重新投票，投给2一票，2投给自己一票，2一共的了2票，超过半票，2的角色变为leader,1的角色为follower，<strong>集群启动</strong>；3启动，已经有leader角色，不投票，3的角色为follower.</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>集群</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-拦截器</title>
    <url>/2020/09/21/shiro-%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>可以处理每次请求的认证。</p>
<span id="more"></span>

<h1 id="shiro-拦截器"><a href="#shiro-拦截器" class="headerlink" title="shiro-拦截器"></a>shiro-拦截器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>需求：</p>
<ul>
<li><p>登录：</p>
<ul>
<li>是否请求跳转登录页面。<ul>
<li>是get的登录请求，返回登录页面。</li>
<li>是post的登录请求（输入了账号密码，要登录了）。</li>
<li>非登录请求，保存当前请求，重定向到登录页面。</li>
</ul>
</li>
</ul>
</li>
<li><p>认证：</p>
<ol>
<li>是否携带认证信息<ul>
<li>未携带认证信息，返回错误码</li>
</ul>
</li>
<li>认证信息是否正确</li>
<li>执行拦截器链<ul>
<li>路径匹配</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​        </p>
<h2 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h2><ol>
<li><p>新建模块</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20201006212116681.png" alt="image-20201006212116681"></p>
</li>
<li><p>导入maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;chapter5-interceptor&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.23&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;chapter5-interceptor&lt;/finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;8.1.8.v20121106&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;webAppConfig&gt;</span><br><span class="line">                        &lt;contextPath&gt;/$&#123;project.build.finalName&#125;&lt;/contextPath&gt;</span><br><span class="line">                    &lt;/webAppConfig&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;path&gt;/$&#123;project.build.finalName&#125;&lt;/path&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>web.xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app</span><br><span class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">        version=&quot;3.0&quot;</span><br><span class="line">        metadata-complete=&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--- shiro 1.2 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:shiro-interceptor.ini&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>shiro-interceptor.ini配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhang=123,admin</span><br><span class="line">wang=123</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line">admin=user:*,menu:*</span><br><span class="line"></span><br><span class="line">[filters]</span><br><span class="line">myFilter1=com.xiaoruiit.shiro.filter.MyOncePerRequestFilter</span><br><span class="line">myFilter2=com.xiaoruiit.shiro.filter.MyAdviceFilter</span><br><span class="line">myFilter3=com.xiaoruiit.shiro.filter.MyPathMatchingFilter</span><br><span class="line">myFilter4=com.xiaoruiit.shiro.filter.MyAccessControlFilter</span><br><span class="line">formLogin=com.xiaoruiit.shiro.filter.FormLoginFilter</span><br><span class="line">anyRoles=com.xiaoruiit.shiro.filter.AnyRolesFilter</span><br><span class="line">[urls]</span><br><span class="line">/test.jsp=formLogin,anyRoles[admin,user]</span><br><span class="line">/login.jsp=formLogin</span><br><span class="line">/**=myFilter1,myFilter2,myFilter3[config],myFilter4</span><br><span class="line">#/**=myFilter1</span><br></pre></td></tr></table></figure></li>
<li><p>动态url拦截器</p>
<p>MyIniWebEnviroment.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.env;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.util.ClassUtils;</span><br><span class="line">import org.apache.shiro.web.env.IniWebEnvironment;</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;</span><br><span class="line">import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.DefaultFilter;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.FilterChainResolver;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname MyIniWebEnviroment</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class MyIniWebEnviroment extends IniWebEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    // 动态实现url-拦截器的注册。需要将其配置到web.xml中·</span><br><span class="line">    @Override</span><br><span class="line">    protected FilterChainResolver createFilterChainResolver() &#123;</span><br><span class="line">        //在此处扩展自己的FilterChainResolver</span><br><span class="line">        //1、创建FilterChainResolver</span><br><span class="line">        PathMatchingFilterChainResolver filterChainResolver =</span><br><span class="line">                new PathMatchingFilterChainResolver();</span><br><span class="line">        //2、创建FilterChainManager</span><br><span class="line">        DefaultFilterChainManager filterChainManager = new DefaultFilterChainManager();</span><br><span class="line">        //3、注册Filter</span><br><span class="line">        for(DefaultFilter filter : DefaultFilter.values()) &#123;</span><br><span class="line">            filterChainManager.addFilter(filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));</span><br><span class="line">        &#125;</span><br><span class="line">        //4、注册URL-Filter的映射关系</span><br><span class="line">        filterChainManager.addToChain(&quot;/login.jsp&quot;, &quot;authc&quot;);</span><br><span class="line">        filterChainManager.addToChain(&quot;/unauthorized.jsp&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainManager.addToChain(&quot;/**&quot;, &quot;authc&quot;);</span><br><span class="line">        filterChainManager.addToChain(&quot;/**&quot;, &quot;roles&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">        //5、设置Filter的属性</span><br><span class="line">        FormAuthenticationFilter authcFilter =</span><br><span class="line">                (FormAuthenticationFilter)filterChainManager.getFilter(&quot;authc&quot;);</span><br><span class="line">        authcFilter.setLoginUrl(&quot;/login.jsp&quot;);</span><br><span class="line">        RolesAuthorizationFilter rolesFilter = (RolesAuthorizationFilter)filterChainManager.getFilter(&quot;roles&quot;);</span><br><span class="line">        rolesFilter.setUnauthorizedUrl(&quot;/unauthorized.jsp&quot;);</span><br><span class="line"></span><br><span class="line">        filterChainResolver.setFilterChainManager(filterChainManager);</span><br><span class="line">        return filterChainResolver;</span><br><span class="line">//        return super.createFilterChainResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>form表单过滤器</p>
<p>FormLoginFilter.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.web.filter.PathMatchingFilter;</span><br><span class="line">import org.apache.shiro.web.util.WebUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname FormLoginFilter</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class FormLoginFilter extends PathMatchingFilter &#123;</span><br><span class="line">    private String loginUrl = &quot;/login.jsp&quot;;//跳转失败时的地址</span><br><span class="line">    private String successUrl = &quot;/&quot;;//成功后跳转的地址</span><br><span class="line"></span><br><span class="line">    // 请求预处理</span><br><span class="line">    // 这里处理登录</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        if(SecurityUtils.getSubject().isAuthenticated()) &#123;</span><br><span class="line">            return true;//已经登录过</span><br><span class="line">        &#125;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line">        if(isLoginRequest(req)) &#123;</span><br><span class="line">            if(&quot;post&quot;.equalsIgnoreCase(req.getMethod())) &#123;//form表单提交</span><br><span class="line">                boolean loginSuccess = login(req); //登录</span><br><span class="line">                if(loginSuccess) &#123;</span><br><span class="line">                    return redirectToSuccessUrl(req, resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;//继续过滤器链</span><br><span class="line">        &#125; else &#123;//保存当前地址并重定向到登录界面</span><br><span class="line">            saveRequestAndRedirectToLogin(req, resp);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean redirectToSuccessUrl(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;</span><br><span class="line">        WebUtils.redirectToSavedRequest(req, resp, successUrl);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveRequestAndRedirectToLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;</span><br><span class="line">        WebUtils.saveRequest(req);</span><br><span class="line">        WebUtils.issueRedirect(req, resp, loginUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean login(HttpServletRequest req) &#123;</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            SecurityUtils.getSubject().login(new UsernamePasswordToken(username, password));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            req.setAttribute(&quot;shiroLoginFailure&quot;, e.getClass());</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isLoginRequest(HttpServletRequest req) &#123;</span><br><span class="line">        return pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AnyRolesFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.StringUtils;</span><br><span class="line">import org.apache.shiro.web.filter.AccessControlFilter;</span><br><span class="line">import org.apache.shiro.web.util.WebUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AnyRolesFilter extends AccessControlFilter &#123;</span><br><span class="line"></span><br><span class="line">    private String unauthorizedUrl = &quot;/unauthorized.jsp&quot;;</span><br><span class="line">    private String loginUrl = &quot;/login.jsp&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        String[] roles = (String[])mappedValue;</span><br><span class="line">        if(roles == null) &#123;</span><br><span class="line">            return true;//如果没有设置角色参数，默认成功</span><br><span class="line">        &#125;</span><br><span class="line">        for(String role : roles) &#123;</span><br><span class="line">            if(getSubject(request, response).hasRole(role)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//跳到onAccessDenied处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        Subject subject = getSubject(request, response);</span><br><span class="line">        if (subject.getPrincipal() == null) &#123;//表示没有登录，重定向到登录页面</span><br><span class="line">            saveRequest(request);</span><br><span class="line">            WebUtils.issueRedirect(request, response, loginUrl);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (StringUtils.hasText(unauthorizedUrl)) &#123;//如果有未授权页面跳转过去</span><br><span class="line">                WebUtils.issueRedirect(request, response, unauthorizedUrl);</span><br><span class="line">            &#125; else &#123;//否则返回401未授权状态码</span><br><span class="line">                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.servlet.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname MyOncePerRequestFilter</span><br><span class="line"> * @Description</span><br><span class="line"> *          自定义的拦截器实现扩展功能</span><br><span class="line"> *              1.动态 url -角色/权限访问控制的实现</span><br><span class="line"> *              2.根据 Subject 身份信息获取用户信息绑定到 Request</span><br><span class="line"> *              3.验证码验证</span><br><span class="line"> *              4.在线用户信息的保存</span><br><span class="line"> *          OncePerRequestFilter 保证一次请求只调用一次 doFilterInternal</span><br><span class="line"> *          需要将其配置在ini中</span><br><span class="line"> */</span><br><span class="line">public class MyOncePerRequestFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;=========once per request filter&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyAdviceFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.servlet.AdviceFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;User: Zhang Kaitao</span><br><span class="line"> * &lt;p&gt;Date: 14-2-3</span><br><span class="line"> * &lt;p&gt;Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class MyAdviceFilter extends AdviceFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;====预处理/前置处理&quot;);</span><br><span class="line">        return true;//返回false将中断后续拦截器链的执行</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;====后处理/后置返回处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;====完成处理/后置最终处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPathMatchingFilter</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.filter.PathMatchingFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MyPathMatchingFilter extends PathMatchingFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;url matches,config is &quot; + Arrays.toString((String[])mappedValue));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>MyAccessControlFilter</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.filter.AccessControlFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyAccessControlFilter extends AccessControlFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;access allowed&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;访问拒绝也不自己处理，继续拦截器链的执行&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>前端</p>
<p>login.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;.error&#123;color:red;&#125;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;error&quot;&gt;$&#123;error&#125;&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>test.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">login success</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Console</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=========once per request filter</span><br><span class="line">====预处理/前置处理</span><br><span class="line">url matches,config is [config]</span><br><span class="line">access allowed</span><br><span class="line">====后处理/后置返回处理</span><br><span class="line">====完成处理/后置最终处理</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>企业微信通讯录变更时同步到本地系统</title>
    <url>/2021/06/30/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>记录操作日志</p>
<span id="more"></span>

<h1 id="企业微信通讯录变更时同步到本地系统"><a href="#企业微信通讯录变更时同步到本地系统" class="headerlink" title="企业微信通讯录变更时同步到本地系统"></a>企业微信通讯录变更时同步到本地系统</h1><p><a href="https://open.work.weixin.qq.com/api/doc/90001/90143/91201">企业微信API文档</a></p>
<p>第三方微信sdk: com.github.binarywang  </p>
<h2 id="1-申请企业微信企业测试账号"><a href="#1-申请企业微信企业测试账号" class="headerlink" title="1.申请企业微信企业测试账号"></a>1.申请企业微信企业测试账号</h2><h2 id="2-根据企业微信文档写回调接口，配置回调接口属性"><a href="#2-根据企业微信文档写回调接口，配置回调接口属性" class="headerlink" title="2.根据企业微信文档写回调接口，配置回调接口属性"></a>2.根据企业微信文档写回调接口，配置回调接口属性</h2><h3 id="从企业微信后台获取配置属性"><a href="#从企业微信后台获取配置属性" class="headerlink" title="从企业微信后台获取配置属性"></a>从企业微信后台获取配置属性</h3><p>(1) 超级管理员登录企业微信后台</p>
<p>企业微信后台地址：</p>
<p><a href="https://work.weixin.qq.com/wework_admin/loginpage_wx?etype=expired#apps/contactsApi">https://work.weixin.qq.com/wework_admin/loginpage_wx?etype=expired#apps/contactsApi</a></p>
<p>(2) 获取参数</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Oty8GMBeUl91rZE.jpg" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SUDRf3VnXx4YBJb.jpg" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/w8eMCHcqxIvVgPK.jpg" alt="img"></p>
<h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(tags = &quot;企业微信-回调接口服务&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/callback/&#123;agentId&#125;&quot;)</span><br><span class="line">public class WxCallBackController &#123;</span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @GetMapping(produces = &quot;text/plain;charset=utf-8&quot;)</span><br><span class="line">    public String authGet(@PathVariable Integer agentId,</span><br><span class="line">                          @RequestParam(name = &quot;msg_signature&quot;, required = false) String signature,</span><br><span class="line">                          @RequestParam(name = &quot;timestamp&quot;, required = false) String timestamp,</span><br><span class="line">                          @RequestParam(name = &quot;nonce&quot;, required = false) String nonce,</span><br><span class="line">                          @RequestParam(name = &quot;echostr&quot;, required = false) String echostr) &#123;</span><br><span class="line">        this.logger.info(&quot;\n接收到来自微信服务器的认证消息：signature = [&#123;&#125;], timestamp = [&#123;&#125;], nonce = [&#123;&#125;], echostr = [&#123;&#125;]&quot;,</span><br><span class="line">                signature, timestamp, nonce, echostr);</span><br><span class="line"></span><br><span class="line">        if (StringUtils.isAnyBlank(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;请求参数非法，请核实!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final WxCpService wxCpService = WxCpConfiguration.getCpService(agentId);</span><br><span class="line">        if (wxCpService == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;未找到对应agentId=[%d]的配置&quot;, agentId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (wxCpService.checkSignature(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">            return new WxCpCryptUtil(wxCpService.getWxCpConfigStorage()).decrypt(echostr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;非法请求&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(produces = &quot;application/xml; charset=UTF-8&quot;)</span><br><span class="line">    public String post(@PathVariable Integer agentId,</span><br><span class="line">                       @RequestBody String requestBody,</span><br><span class="line">                       @RequestParam(&quot;msg_signature&quot;) String signature,</span><br><span class="line">                       @RequestParam(&quot;timestamp&quot;) String timestamp,</span><br><span class="line">                       @RequestParam(&quot;nonce&quot;) String nonce) &#123;</span><br><span class="line">        this.logger.info(&quot;\n接收微信请求：[signature=[&#123;&#125;], timestamp=[&#123;&#125;], nonce=[&#123;&#125;], requestBody=[\n&#123;&#125;\n] &quot;,</span><br><span class="line">                signature, timestamp, nonce, requestBody);</span><br><span class="line"></span><br><span class="line">        final WxCpService wxCpService = WxCpConfiguration.getCpService(agentId);</span><br><span class="line">        WxCpXmlMessage inMessage = WxCpXmlMessage.fromEncryptedXml(requestBody, wxCpService.getWxCpConfigStorage(),</span><br><span class="line">                timestamp, nonce, signature);</span><br><span class="line">        this.logger.debug(&quot;\n消息解密内容为：\n&#123;&#125; &quot;, JSONObject.toJSONString(inMessage));</span><br><span class="line">        WxCpXmlOutMessage outMessage = this.route(agentId, inMessage);</span><br><span class="line">        if (outMessage == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String out = outMessage.toEncryptedXml(wxCpService.getWxCpConfigStorage());</span><br><span class="line">        this.logger.debug(&quot;\n回复信息：&#123;&#125;&quot;, out);</span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private WxCpXmlOutMessage route(Integer agentId, WxCpXmlMessage message) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return WxCpConfiguration.getRouters().get(agentId).route(message);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            this.logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p>corpId,agentId,secret,token,aesKey</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 企业微信帐号</span><br><span class="line">wx:</span><br><span class="line">  cp:</span><br><span class="line">    application:</span><br><span class="line">      - corpId: ww234234223429bd7 # han申请的企业微信ID</span><br><span class="line">        appConfigs:</span><br><span class="line">            - agentId: 60023001 # 虚拟agentId 为注入配置使用</span><br><span class="line">              secret: q4asdfqedRasdfadfasdfasdfb5R93dRZasdfaXfkEk # 通讯录secret</span><br><span class="line">              token: uAasdfasdfasdf8u # 与企业微信回调一致</span><br><span class="line">              aesKey: AcYasdfasdfasdfasdfasdfasdfasd234234lAa # 与企业微信回调一致</span><br><span class="line">      - corpId: ww123123131213219d4 # 开发人员申请的企业微信ID</span><br><span class="line">        appConfigs:</span><br><span class="line">          - agentId: 40123002 # 虚拟agentId 为注入配置使用</span><br><span class="line">            secret: bSIyH1234123123123fsd1213123H1U</span><br><span class="line">            token:</span><br><span class="line">            aesKey:</span><br><span class="line">          - agentId: 62322303 # 虚拟agentId 为注入配置使用</span><br><span class="line">            secret: ix12312123123123123123b-NNc</span><br><span class="line">            token:</span><br><span class="line">            aesKey:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性读取"><a href="#属性读取" class="headerlink" title="属性读取"></a>属性读取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;wx.cp&quot;)</span><br><span class="line">public class EnterpriseWechatApplication &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;WxCpProperties&gt; application;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class WxCpProperties &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 设置企业微信的corpId</span><br><span class="line">     */</span><br><span class="line">    private String corpId;</span><br><span class="line"></span><br><span class="line">    private List&lt;AppConfig&gt; appConfigs;</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class AppConfig &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的AgentId</span><br><span class="line">         */</span><br><span class="line">        private Integer agentId;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的Secret</span><br><span class="line">         */</span><br><span class="line">        private String secret;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的token</span><br><span class="line">         */</span><br><span class="line">        private String token;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的EncodingAESKey</span><br><span class="line">         */</span><br><span class="line">        private String aesKey;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return JSONObject.toJSONString(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(EnterpriseWechatApplication.class)</span><br><span class="line">public class WxCpConfiguration &#123;</span><br><span class="line">    private LogHandler logHandler;</span><br><span class="line">    private NullHandler nullHandler;</span><br><span class="line">    private LocationHandler locationHandler;</span><br><span class="line">    private MenuHandler menuHandler;</span><br><span class="line">    private MsgHandler msgHandler;</span><br><span class="line">    private UnsubscribeHandler unsubscribeHandler;</span><br><span class="line">    private SubscribeHandler subscribeHandler;</span><br><span class="line">    private ContactChangeHandler contactChangeHandler;</span><br><span class="line">    private EnterAgentHandler enterAgentHandler;</span><br><span class="line"></span><br><span class="line">    // private WxCpProperties properties;</span><br><span class="line"></span><br><span class="line">    private EnterpriseWechatApplication enterpriseWechatApplication;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Integer, WxCpMessageRouter&gt; routers = Maps.newHashMap();</span><br><span class="line">    private static Map&lt;Integer, WxCpService&gt; cpServices = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public WxCpConfiguration(LogHandler logHandler, NullHandler nullHandler, LocationHandler locationHandler,</span><br><span class="line">                             MenuHandler menuHandler, MsgHandler msgHandler, UnsubscribeHandler unsubscribeHandler,</span><br><span class="line">                             SubscribeHandler subscribeHandler, ContactChangeHandler contactChangeHandler,EnterAgentHandler enterAgentHandler</span><br><span class="line">                             // , WxCpProperties properties</span><br><span class="line">            , EnterpriseWechatApplication enterpriseWechatApplication</span><br><span class="line">    ) &#123;</span><br><span class="line">        this.logHandler = logHandler;</span><br><span class="line">        this.nullHandler = nullHandler;</span><br><span class="line">        this.locationHandler = locationHandler;</span><br><span class="line">        this.menuHandler = menuHandler;</span><br><span class="line">        this.msgHandler = msgHandler;</span><br><span class="line">        this.unsubscribeHandler = unsubscribeHandler;</span><br><span class="line">        this.subscribeHandler = subscribeHandler;</span><br><span class="line">        // this.properties = properties;</span><br><span class="line">        this.enterpriseWechatApplication = enterpriseWechatApplication;</span><br><span class="line">        this.contactChangeHandler = contactChangeHandler;</span><br><span class="line">        this.enterAgentHandler = enterAgentHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Map&lt;Integer, WxCpMessageRouter&gt; getRouters() &#123;</span><br><span class="line">        return routers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static WxCpService getCpService(Integer agentId) &#123;</span><br><span class="line">        return cpServices.get(agentId);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    @PostConstruct // 初始化加载，加载Autowire之后</span><br><span class="line">    public void initServices() &#123;</span><br><span class="line">        this.enterpriseWechatApplication.getApplication().forEach(wxCpProperties -&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Map&lt;Integer, WxCpServiceImpl&gt; wxCpServiceMap = wxCpProperties.getAppConfigs().stream().map(a -&gt; &#123;</span><br><span class="line">                        WxCpRedissonConfigImpl configStorage = new WxCpRedissonConfigImpl(redissonClient);</span><br><span class="line">                        configStorage.setCorpId(wxCpProperties.getCorpId());</span><br><span class="line">                        configStorage.setAgentId(a.getAgentId());</span><br><span class="line">                        configStorage.setCorpSecret(a.getSecret());</span><br><span class="line">                        configStorage.setToken(a.getToken());</span><br><span class="line">                        configStorage.setAesKey(a.getAesKey());</span><br><span class="line"></span><br><span class="line">                        val service = new WxCpServiceImpl();</span><br><span class="line">                        service.setWxCpConfigStorage(configStorage);</span><br><span class="line">                        routers.put(a.getAgentId(), this.newRouter(service));</span><br><span class="line">                        return service;</span><br><span class="line">                    &#125;).collect(Collectors.toMap(service -&gt; service.getWxCpConfigStorage().getAgentId(), a -&gt; a));</span><br><span class="line"></span><br><span class="line">                    cpServices.putAll(wxCpServiceMap);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private WxCpMessageRouter newRouter(WxCpService wxCpService) &#123;</span><br><span class="line">        final val newRouter = new WxCpMessageRouter(wxCpService);</span><br><span class="line"></span><br><span class="line">        // 记录所有事件的日志 （异步执行）</span><br><span class="line">        newRouter.rule().handler(this.logHandler).next();</span><br><span class="line">		// 通讯录变更事件</span><br><span class="line">        newRouter.rule().async(false).msgType(WxConsts.XmlMsgType.EVENT)</span><br><span class="line">                .event(WxCpConsts.EventType.CHANGE_CONTACT).handler(this.contactChangeHandler).end();</span><br><span class="line">        // 默认</span><br><span class="line">        newRouter.rule().async(false).handler(this.msgHandler).end();</span><br><span class="line"></span><br><span class="line">        return newRouter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-gatway服务配置企业微信回调地址token过滤白名单"><a href="#3-gatway服务配置企业微信回调地址token过滤白名单" class="headerlink" title="3.gatway服务配置企业微信回调地址token过滤白名单"></a>3.gatway服务配置企业微信回调地址token过滤白名单</h2><p>bootstrap.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secure:</span><br><span class="line">  ignore:</span><br><span class="line">    urls: #配置白名单路径</span><br><span class="line">      - &quot;/wx/callback/**&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-使用企业微信回调接口工具测试"><a href="#4-使用企业微信回调接口工具测试" class="headerlink" title="4.使用企业微信回调接口工具测试"></a>4.使用企业微信回调接口工具测试</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/O5j1nR9WqNSMcD4.png" alt="image-20210630114634938"></p>
<h2 id="5-企业微信管理后台设置通讯录同步-接收事件服务器"><a href="#5-企业微信管理后台设置通讯录同步-接收事件服务器" class="headerlink" title="5.企业微信管理后台设置通讯录同步-接收事件服务器"></a>5.企业微信管理后台设置通讯录同步-接收事件服务器</h2><p>参考：<a href="https://open.work.weixin.qq.com/api/doc/90000/90135/90966">https://open.work.weixin.qq.com/api/doc/90000/90135/90966</a></p>
<h2 id="6-代码中获取通讯录变更事件，写变更时的处理逻辑"><a href="#6-代码中获取通讯录变更事件，写变更时的处理逻辑" class="headerlink" title="6.代码中获取通讯录变更事件，写变更时的处理逻辑"></a>6.代码中获取通讯录变更事件，写变更时的处理逻辑</h2><p>注意：失败重试+持久化需要同步的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ContactChangeHandler extends AbstractHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MdmService mdmService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public WxCpXmlOutMessage handle(WxCpXmlMessage wxMessage, Map&lt;String, Object&gt; context, WxCpService cpService,</span><br><span class="line">                                    WxSessionManager sessionManager) &#123;</span><br><span class="line">        String content = &quot;收到通讯录变更事件，内容：&quot; + JSONObject.toJSONString(wxMessage);</span><br><span class="line">        this.logger.info(content);</span><br><span class="line"></span><br><span class="line">        // 企业微信修改手机号、邮箱后调用wanma和crm接口，同步数据</span><br><span class="line">        if (WxCpConsts.EventType.CHANGE_CONTACT.equals(wxMessage.getEvent())) &#123;// 通讯录变更事件</span><br><span class="line">            if (WxCpConsts.ContactChangeType.UPDATE_USER.equals(wxMessage.getChangeType())) &#123;// 从通讯录变更-更新成员</span><br><span class="line">                log.info(&quot;企业微信更新成员消息：&quot; + wxMessage.toString());</span><br><span class="line">                // 通过微信userId查询变更人信息</span><br><span class="line">                Result&lt;MdmUserInfoDTO&gt; mdmUserInfoDTOResult = mdmService.queryUserDetailByWxUserId(wxMessage.getUserId());</span><br><span class="line">                if (mdmUserInfoDTOResult.getCode() != 0) &#123;</span><br><span class="line">                    log.error(&quot;通过wxUserId获取用户信息失败：&quot;, wxMessage.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                MdmUserInfoDTO oldUser = mdmUserInfoDTOResult.getData();</span><br><span class="line">                log.info(&quot;企业微信通讯录变更前用户信息：&quot; + mdmUserInfoDTOResult.getData().toString());</span><br><span class="line">                MdmUserInfoDTO newUser = new MdmUserInfoDTO();</span><br><span class="line">                newUser.setUserId(oldUser.getUserId());</span><br><span class="line">                newUser.setWxUserId(wxMessage.getUserId());// 变更信息的成员UserID</span><br><span class="line">                newUser.setGender(&quot;1&quot;.equals(wxMessage.getGender()) ? &quot;1&quot; : &quot;0&quot;);// 企业微信的性别 1男2女</span><br><span class="line">                newUser.setUserEmail(StringUtils.isNotBlank(wxMessage.getEmail()) ? AESUtil.encryptHex(wxMessage.getEmail()) : null);// 变更信息的邮箱 加密</span><br><span class="line">                newUser.setUserMobile(StringUtils.isNotBlank(wxMessage.getMobile()) ? AESUtil.encryptHex(wxMessage.getMobile()) : null);// 变更信息的手机号 加密</span><br><span class="line">                newUser.setUserName(wxMessage.getName());// 姓名</span><br><span class="line"></span><br><span class="line">                // 调用本地系统同步接口</span><br><span class="line">                Result result = mdmService.updateUser(newUser);</span><br><span class="line"></span><br><span class="line">                if (result.getCode() != 0) &#123;</span><br><span class="line">                    log.error(&quot;企业微信通讯录更新同步本地系统失败，同步数据：&quot;+newUser);</span><br><span class="line">                &#125;</span><br><span class="line">                //调用crm同步接口</span><br><span class="line">                Result result1 = mdmService.userDataSync(oldUser.getUserId());</span><br><span class="line">                if (result1.getCode() != 0) &#123;</span><br><span class="line">                    log.error(&quot;企业微信通讯录更新同步crm失败，同步userId：&quot;+oldUser.getUserId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new TextBuilder().build(content, wxMessage, cpService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-IP白名单配置定时更新任务，更新定时变化的企业微信IP"><a href="#7-IP白名单配置定时更新任务，更新定时变化的企业微信IP" class="headerlink" title="7.IP白名单配置定时更新任务，更新定时变化的企业微信IP"></a>7.IP白名单配置定时更新任务，更新定时变化的企业微信IP</h2><h3 id="7-1quartz设置定时任务"><a href="#7-1quartz设置定时任务" class="headerlink" title="7.1quartz设置定时任务"></a>7.1quartz设置定时任务</h3><p>任务job</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class WxIpWhitelistJob extends QuartzJobBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WxcpService wxcpService;//wx服务</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        log.info(&quot;拉取企业微信IP并更新白名单任务执行开始: ==&gt; ... &quot;);</span><br><span class="line">        wxcpService.ipWhitelist();</span><br><span class="line">        log.info(&quot;拉取企业微信IP并更新白名单任务执行开始: ==&gt; end &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动quartz服务时，将job和触发器加入scheduler(任务调度)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SchedulerInitListener implements CommandLineRunner &#123;// 启动监听并执行run</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws SchedulerException &#123;</span><br><span class="line">        List&lt;QuartzJob&gt; quartzJobs = quartzJobMapper.selectByExample(QuartzJobExample.newAndCreateCriteria()</span><br><span class="line">                .andStatusEqualTo(true).andIsDelEqualTo(false).example());// 从库汇中查询定时任务</span><br><span class="line">        if (!Optional.ofNullable(quartzJobs).isPresent() || quartzJobs.size() &lt;= 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (QuartzJob quartzJob : quartzJobs) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                quartzManager.addQuartzJob(quartzJob);// 将job和触发器加入scheduler(任务调度)</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.info(&quot;定时任务启动失败, jobName = &#123;&#125;, 异常信息: &#123;&#125;&quot;, quartzJob.getJobName(), e.getMessage());</span><br><span class="line">                quartzJob.setStatus(false);</span><br><span class="line">                quartzJobMapper.updateByPrimaryKeySelective(quartzJob);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class QuartzManager &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    public void addQuartzJob(QuartzJob quartzTask) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建jobDetail实例，绑定Job实现类</span><br><span class="line">            // 指明job的名称，所在组的名称，以及绑定job类</span><br><span class="line">            Class&lt;? extends QuartzJobBean&gt; jobClass = (Class&lt;? extends QuartzJobBean&gt;) (Class.forName(quartzTask.getBeanClass()).newInstance().getClass());</span><br><span class="line">            // 任务名称和组构成任务key</span><br><span class="line">            // 判断参数是否为空</span><br><span class="line">            JobDetail jobDetail = null;</span><br><span class="line">            if (!quartzTask.getParam().isEmpty()) &#123;</span><br><span class="line">                JSONObject jsonObject = quartzTask.getParam();</span><br><span class="line">                JobDataMap dataMap = new JobDataMap();</span><br><span class="line">                Set&lt;String&gt; strings = jsonObject.keySet();</span><br><span class="line">                strings.forEach(str -&gt; &#123;</span><br><span class="line">                    dataMap.put(str, jsonObject.getString(str));</span><br><span class="line">                &#125;);</span><br><span class="line">                jobDetail = JobBuilder.newJob(jobClass)</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        .usingJobData(dataMap)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                jobDetail = JobBuilder.newJob(jobClass)</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 定义调度触发规则</span><br><span class="line">            // 使用cornTrigger规则</span><br><span class="line">            // 触发器key</span><br><span class="line">            // 判断任务类型，生成对应类型的调度器</span><br><span class="line">            Trigger trigger = null;</span><br><span class="line">            if (JobTypeEnum.SIMPLE.getType().equals(quartzTask.getJobType())) &#123;</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        // 立即执行</span><br><span class="line">                        .startNow()</span><br><span class="line">                        .withSchedule(</span><br><span class="line">                                SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                                        // 执行间隔，单位：毫秒</span><br><span class="line">                                        .withIntervalInMilliseconds(quartzTask.getMilliSeconds())</span><br><span class="line">                                        // 一直执行</span><br><span class="line">                                        .repeatForever()</span><br><span class="line">                        )</span><br><span class="line">                        .build();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        .startAt(DateBuilder.futureDate(1, DateBuilder.IntervalUnit.SECOND))</span><br><span class="line">                        .withSchedule(CronScheduleBuilder.cronSchedule(quartzTask.getCronExpression())).startNow().build();</span><br><span class="line">            &#125;</span><br><span class="line">            // 把作业和触发器注册到任务调度中</span><br><span class="line">            if (Optional.ofNullable(jobDetail).isPresent() &amp;&amp; Optional.ofNullable(trigger).isPresent()) &#123;</span><br><span class="line">                scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            &#125;</span><br><span class="line">            // 启动</span><br><span class="line">            if (!scheduler.isShutdown()) &#123;</span><br><span class="line">                scheduler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2wx服务获取企业微信ip"><a href="#7-2wx服务获取企业微信ip" class="headerlink" title="7.2wx服务获取企业微信ip"></a>7.2wx服务获取企业微信ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(tags = &quot;企业微信-IP白名单接口&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/ip&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class WxIPController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wx.cp.application[0].appConfigs[0].agentId&#125;&quot;)</span><br><span class="line">    private Integer mobileAgentId;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MdmService mdmService;// 主数据服务</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;获取企业微信IP集合&quot;, notes = &quot;获取企业微信IP集合&quot;, httpMethod = &quot;POST&quot;)</span><br><span class="line">    @RequestMapping(&quot;/getIpList&quot;)</span><br><span class="line">    public Result getIpList() &#123;</span><br><span class="line">        log.info(&quot;开始获取企业微信IP集合: &quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            String[] callbackIp = WxCpTempConfiguration.getCpService(mobileAgentId).getCallbackIp();</span><br><span class="line">            log.info(&quot;获取企业微信IP集合成功: &quot;+Arrays.toString(callbackIp));</span><br><span class="line">            // 白名单更新企业微信IP</span><br><span class="line">            if (ArrayUtil.isNotEmpty(callbackIp))&#123;</span><br><span class="line">                mdmService.updateWxIp(callbackIp);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                log.error(&quot;获取的企业微信IP集合为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return Result.success();</span><br><span class="line">        &#125; catch (WxErrorException e) &#123;</span><br><span class="line">            log.info(&quot;获取企业微信IP集合失败: &quot;, e);</span><br><span class="line">            return Result.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3主数据服务更新企业微信ip"><a href="#7-3主数据服务更新企业微信ip" class="headerlink" title="7.3主数据服务更新企业微信ip"></a>7.3主数据服务更新企业微信ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   @Transactional(rollbackFor = Exception.class)</span><br><span class="line">   public Result updateWxIp(String[] callbackIp) &#123;</span><br><span class="line">       // 插入</span><br><span class="line">       LocalDateTime now = LocalDateTime.now().minusSeconds(30l);</span><br><span class="line">       if (ArrayUtils.isNotEmpty(callbackIp))&#123;</span><br><span class="line">           List&lt;MdmLoginIp&gt; mdmLoginIpList = new ArrayList&lt;&gt;();</span><br><span class="line">           for (String ip : callbackIp) &#123;</span><br><span class="line">               MdmLoginIp mdmLoginIp = new MdmLoginIp();</span><br><span class="line">               mdmLoginIp.setLoginIpId(IdWorker.nextId(CommonConstant.MDM_LOGIN_IP_ID_PREFIX));</span><br><span class="line">               mdmLoginIp.setLoginIp(ip);</span><br><span class="line">               mdmLoginIp.setIsDel(false);</span><br><span class="line">               mdmLoginIp.setCreateTime(LocalDateTime.now());</span><br><span class="line">               mdmLoginIp.setLoginIpType(&quot;QYWX&quot;);</span><br><span class="line">               mdmLoginIpList.add(mdmLoginIp);</span><br><span class="line">           &#125;</span><br><span class="line">           mdmLoginIpMapper.batchInsert(mdmLoginIpList);</span><br><span class="line">           // 删除</span><br><span class="line">           mdmLoginIpMapper.deleteByExample(MdmLoginIpExample.newAndCreateCriteria().andLoginIpTypeEqualTo(&quot;QYWX&quot;).andCreateTimeLessThan(now).example());</span><br><span class="line">           return Result.success();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return Result.error(&quot;ip集合为空&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>操作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法</title>
    <url>/2021/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数据结构和算法</p>
<span id="more"></span>

<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="代码效率-时间复杂度与空间复杂度"><a href="#代码效率-时间复杂度与空间复杂度" class="headerlink" title="代码效率-时间复杂度与空间复杂度"></a>代码效率-时间复杂度与空间复杂度</h3><p>代码运行效率用复杂度衡量。</p>
<p>代码运行消耗时间和空间。</p>
<p>现实中的例子：</p>
<ul>
<li>汽车在有红绿灯的十字路口通行。红绿灯时汽车等待，消耗时间。</li>
<li>汽车在建有立交桥的十字路口通行，不用等待，立交桥消耗空间。 </li>
</ul>
<p>时间、空间消耗和输入量密切相关，无法直接定量衡量。为了更客观的评判时间消耗和空间消耗，我们关注输入量与时间、空间的关系。即时间复杂度、空间复杂度。</p>
<p>时间复杂度与代码结构密切相关，空间复杂度与数据结构密切相关。</p>
<p>不同时间复杂度的计算次数例子：100万条数据的处理</p>
<ul>
<li>O(n²)，10的十二次方</li>
<li>O(n)，10的六次方</li>
<li>O(log n)，20次</li>
</ul>
<p>时间无价，空间有价。</p>
<p>数据结构：连接时间和空间复杂度</p>
<p>代码优化：</p>
<ol>
<li>暴力解法</li>
<li>剔除无效计算、无效存储。（递归、回溯、分治（包括二分法）、排序算法、查找算法、贪婪、动态规划）</li>
<li>使用数据结构，将时间复杂度向空间复杂度转移</li>
</ol>
<p>代码的时间复杂度和常量系数无关，代码的执行时间与常量系数有关。</p>
<h3 id="复杂度估算"><a href="#复杂度估算" class="headerlink" title="复杂度估算"></a>复杂度估算</h3><p>复杂度是关于输入数据量n的函数。</p>
<ul>
<li><p>我们假定输入量为n，代码执行n次，复杂度为O(n)；</p>
</li>
<li><p>我们假定输入量为n，代码执行k常数次，与输入量无关，则复杂度为O(1)；</p>
</li>
<li><p>不同数量级的多项复杂度相加时，去数量级高的值。O(n²)+O(n) = O(n²)</p>
</li>
</ul>
<p>常见的复杂度：</p>
<ul>
<li>顺序执行，O(1);</li>
<li>一层for循环，O(n);</li>
<li>两个顺序执行for循环，O(n);</li>
<li>两层嵌套for循环，O(n²);</li>
<li>二分查找，即二分分而治之，O(log n);</li>
</ul>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul>
<li><p>遍历</p>
</li>
<li><p>增</p>
<ul>
<li>中间增加，元素位置顺序改变</li>
<li>末尾增加</li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>中间删除，元素位置顺序改变</li>
<li>末尾删除</li>
</ul>
</li>
<li><p>查</p>
<p>能否在数据结构中找到此元素。</p>
<ul>
<li>基于位置查询（索引、下标）</li>
<li>基于数值特征查询（数值相等）</li>
</ul>
</li>
</ul>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>算法：递归、分治（二分是重点）、回溯、贪婪、动态规划</p>
<h3 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h3><p>分析数据处理顺序、数据操作，选择不同的数据结构。</p>
<p>不同数据结构特点[参考，按住Control点我](# 各类数据结构对比)</p>
<h3 id="Java-数据结构API"><a href="#Java-数据结构API" class="headerlink" title="Java 数据结构API"></a>Java 数据结构API</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 复制数组</span><br><span class="line">int[] arr = new int[]&#123;1,2&#125;;</span><br><span class="line">int[] ints = Arrays.copyOf(arr, arr.length);</span><br><span class="line"></span><br><span class="line">// 字符串转字符数组</span><br><span class="line">String word = &quot;abc&quot;;</span><br><span class="line">char[] wordChars = word.toCharArray();</span><br><span class="line"></span><br><span class="line">// 输出数组内容</span><br><span class="line">Arrays.toString(arr);</span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = new HashMap();</span><br><span class="line">map.put(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">map.get(&quot;a&quot;);</span><br><span class="line">map.size();</span><br><span class="line">map.containsKey(&quot;a&quot;);</span><br><span class="line">map.remove(&quot;a&quot;);</span><br><span class="line">// 遍历</span><br><span class="line">for (Map.Entry&lt;String,String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey()+ map.get(entry.getKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双端队列-链表"><a href="#双端队列-链表" class="headerlink" title="双端队列-链表"></a>双端队列-链表</h4><p>LinkedList</p>
<table>
<thead>
<tr>
<th></th>
<th>第一个（头）</th>
<th>最后一个（尾）</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>offerFirst(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>pollFirst()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>获取元素</td>
<td>peekFirst()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>入队</th>
<th>出队（拿最大元素</th>
</tr>
</thead>
<tbody><tr>
<td>数组线性结构</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链式线性结构</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉堆</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody></table>
<h4 id="优先队列（二叉堆）PriorityQueue"><a href="#优先队列（二叉堆）PriorityQueue" class="headerlink" title="优先队列（二叉堆）PriorityQueue"></a>优先队列（二叉堆）PriorityQueue</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化大小为k的元素为int[]的小根堆（顶为堆中数组元素int[1]最小）</span><br><span class="line">PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue(k, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(int[] newValue, int[] pileTop) &#123;// 小值放到堆顶</span><br><span class="line">    	return newValue[1] - pileTop[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据的组织形式。对数据组织成一定的结构。</p>
<h3 id="1-线性表-链表"><a href="#1-线性表-链表" class="headerlink" title="1.线性表-链表"></a>1.线性表-链表</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>n 个相同特性数据元素的有限序列。</p>
<p>在链表中存储的数据元素也叫作结点，一个结点存储的就是一条数据记录。每个结点的结构包括两个部分：</p>
<ul>
<li>第一是具体的数据值；</li>
</ul>
<ul>
<li>第二是指向下一个结点的指针。</li>
</ul>
<p>在链表的最前面，通常会有个头指针用来指向第一个结点。对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。</p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>有一个链表，它存储了 10 个同学的考试成绩。现在将一个同学的成绩插入到第4个位置。</p>
<p>链表在执行数据新增的时候非常容易，只需要把待插入结点的指针指向原指针的目标，把原来的指针指向待插入的结点，就可以了。</p>
<p>p   s(带插入) t</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.next = p.next;</span><br><span class="line">p.next = s;</span><br></pre></td></tr></table></figure>

<p>复杂度：O(1)</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.next = p.next.next;</span><br></pre></td></tr></table></figure>

<p>复杂度：O(1)</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li><p>按照位置序号来查找</p>
<p>一个一个地遍历去查找。</p>
<p>复杂度：O(n)</p>
</li>
<li><p>按照具体的成绩来查找</p>
<p>一个一个地遍历去查找。</p>
<p>复杂度：O(n)</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果处理数据时有顺序，数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。</p>
<ul>
<li>数据按照顺序存储，可以有序遍历数据。</li>
</ul>
<ul>
<li>按照数值的条件进行查找时，需要遍历，时间复杂度O(n)。</li>
<li>新增数据，复杂度是O(1)。伴随查找的动作，新增复杂度变为了O(n)</li>
<li>删除数据时，复杂度是O(1)。伴随查找的动作，新增复杂度变为了O(n)</li>
</ul>
<h4 id="链表算法题"><a href="#链表算法题" class="headerlink" title="链表算法题"></a>链表算法题</h4><ol>
<li><p>链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</p>
<p>分析：单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</p>
</li>
<li><p>求奇数结点链表的中间结点的数据</p>
<p>分析：未知长度的数据，获取总长度的一半。利用快慢指针，快指针是慢指针的前进速度的两倍，循环次数是数组长度的一半。</p>
</li>
<li><p>链表是否有环</p>
<p>快慢指针，有环时，慢指针循环一圈必定与快指针相遇一次。</p>
</li>
</ol>
<h3 id="2-线性表-栈"><a href="#2-线性表-栈" class="headerlink" title="2.线性表-栈"></a>2.线性表-栈</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>线性表的变种，元素先进后出。栈的数据新增操作只能在末端进行，不允许在栈的中间某个结点后新增数据。</p>
<p>数组或者链表的操作过于灵活，过多暴露了可操作的接口。这些没有意义的接口过多，当数据量很大的时候就会出现一些隐藏的风险。</p>
<h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>同链表，有表头和表尾</p>
<h4 id="数据操作-2"><a href="#数据操作-2" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增-1"><a href="#新增-1" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>顺序栈</p>
<p>java中使用List实现栈。</p>
<p>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。一般以 top 是否为 -1 来判定是否为空栈。当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</p>
<p>只在栈顶操作，时间复杂度O(1)</p>
</li>
<li><p>链栈</p>
<p>用链表的方式实现栈。</p>
<p>通常，可以把栈顶放在单链表的头部，如下图所示。由于链栈的后进先出，原来的头指针就毫无作用了。因此，对于链栈来说，是不需要头指针的。相反，它需要增加指向栈顶的 top 指针，这是压栈和出栈操作的重要支持。</p>
<p>只在栈顶操作，时间复杂度O(1)</p>
</li>
</ul>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>同新增</p>
<h5 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h5><p>同链表</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序</li>
<li>新增时间复杂度O(1)，但只能在栈顶操作</li>
<li>删除时间复杂度O(1)，但只能在栈顶操作</li>
<li>查询时间复杂度O(n)</li>
</ul>
<h4 id="栈算法题"><a href="#栈算法题" class="headerlink" title="栈算法题"></a>栈算法题</h4><ol>
<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。</li>
<li>链表每k个元素翻转，如：链表：123456，k=3，则结果 321654</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>浏览器回退页面效果。</li>
</ol>
<h3 id="3-线性表-队列"><a href="#3-线性表-队列" class="headerlink" title="3.线性表-队列"></a>3.线性表-队列</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>线性表的变种，元素先进先出。</p>
<p>队列的数据新增操作只能在末端进行，不允许在队列的中间某个结点后新增数据;</p>
<p>队列的数据删除操作只能在始端进行，不允许在队列的中间某个结点后删除数据。</p>
<h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="数据操作-3"><a href="#数据操作-3" class="headerlink" title="数据操作"></a>数据操作</h4><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序</li>
<li>新增时间复杂度O(1)，但只能在队尾操作</li>
<li>删除时间复杂度O(1)，但只能在队头操作</li>
<li>查询时间复杂度O(n)</li>
</ul>
<h4 id="队列算法题"><a href="#队列算法题" class="headerlink" title="队列算法题"></a>队列算法题</h4><ol>
<li>约瑟夫环问题。已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</li>
</ol>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>面对数据处理顺序非常敏感的问题时，使用队列。</p>
<ul>
<li><p>可以确定队列长度最大值时，建议使用循环队列。</p>
</li>
<li><p>无法确定队列长度时，应考虑使用链式队列。</p>
</li>
</ul>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>LinkedList</p>
<table>
<thead>
<tr>
<th></th>
<th>第一个（头）</th>
<th>最后一个（尾）</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>offerFirst(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>pollFirst()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>获取元素</td>
<td>peekFirst()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>普通队列：先进先出；后进先出</p>
<p>优先队列：出队顺序和入队顺序无关；和优先级相关。优先级最高的在队首</p>
<p>底层可以使用不同的数据结构：</p>
<table>
<thead>
<tr>
<th></th>
<th>入队</th>
<th>出队（拿最大元素</th>
</tr>
</thead>
<tbody><tr>
<td>数组线性结构</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链式线性结构</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉堆</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody></table>
<p>PriorityQueue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化大小为k的元素为int[]的小根堆（顶为堆中数组元素int[1]最小）</span><br><span class="line">PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue(k, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(int[] newValue, int[] pileTop) &#123;// 小值放到堆顶</span><br><span class="line">    	return newValue[1] - pileTop[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="4-线性表衍生-数组"><a href="#4-线性表衍生-数组" class="headerlink" title="4.线性表衍生-数组"></a>4.线性表衍生-数组</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>存储一个固定大小的相同类型元素的顺序集合。</p>
<h4 id="存储结构-3"><a href="#存储结构-3" class="headerlink" title="存储结构"></a>存储结构</h4><p>数组在内存中是连续存放的，数组内的数据，可以通过索引值直接取出得到。</p>
<h4 id="数据操作-4"><a href="#数据操作-4" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增-2"><a href="#新增-2" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>数组的最后增加一个新的元素</p>
<p>对原数据产生没有任何影响。时间复杂度是 O(1)。</p>
</li>
<li><p>数组中间的某个位置新增数据</p>
<p>原数据的位置需要依次向后挪动 1 个位置。时间复杂度是 O(n)。</p>
</li>
</ul>
<h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><p>同新增</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><ul>
<li>根据位置值查找，时间复杂度是 O(1)。</li>
<li>根据数值查找，时间复杂度是 O(n)。</li>
</ul>
<h4 id="数组算法题"><a href="#数组算法题" class="headerlink" title="数组算法题"></a>数组算法题</h4><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序存储，遍历有序。</li>
<li>根据索引查找快，时间复杂度O(1)</li>
<li>根据数值查找，时间复杂度O(n)</li>
<li>中间位置删除数据，时间复杂度O(n)；末尾删除，时间复杂度O(1)。</li>
<li>中间位置新增数据，时间复杂度O(n)；末尾新增，时间复杂度O(1)。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>字符串（string） 是由 n 个字符组成的一个有序整体（ n &gt;= 0 ）。</p>
<p>特殊字符串：</p>
<ul>
<li><p>空串，指含有零个字符的串。例如，s = “”</p>
</li>
<li><p>空格串，只包含空格的串。例如，s = “   “</p>
</li>
<li><p>子串，串中任意连续字符组成的字符串叫作该串的子串。</p>
</li>
<li><p>原串通常也称为主串。</p>
<p>例如：a = “BEI”，b = “BEIJING”，c = “BJINGEI” 。</p>
<ul>
<li>对于字符串 a 和 b 来说，由于 b 中含有字符串 a ，所以可以称 a 是 b 的子串，b 是 a 的主串；</li>
<li>对于 c 和 a 而言，虽然 c 中也含有 a 的全部字符，但不是连续的 “BEI” ，所以串 c 和 a 没有任何关系。</li>
</ul>
</li>
</ul>
<h4 id="存储结构-4"><a href="#存储结构-4" class="headerlink" title="存储结构"></a>存储结构</h4><p>有顺序存储和链式存储两种。</p>
<ul>
<li><p>顺序存储</p>
<p>用一组地址连续的存储单元来存储串中的字符序列，一般是用定长数组来实现。</p>
</li>
<li><p>链式存储</p>
<p>由于串结构的特殊性（结构中的每个元素数据都是一个字符），如果也简单地将每个链结点存储为一个字符，就会造成很大的空间浪费。因此，一个结点可以考虑存放多个字符，如果最后一个结点未被占满时，可以使用 “#” 或其他非串值字符补全。</p>
</li>
</ul>
<h4 id="数据操作-5"><a href="#数据操作-5" class="headerlink" title="数据操作"></a>数据操作</h4><p>字符串的数据操作与线性表有很大差别。线性表更关注的是单个元素的操作，比如增删查一个元素，而字符串中更多关注的是查找子串的位置、替换等操作。</p>
<h5 id="新增-3"><a href="#新增-3" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>顺序存储</p>
<p>字符串的新增操作和数组相似，都牵涉对插入字符串之后字符的挪移操作，时间复杂度是 O(n)。</p>
</li>
</ul>
<h5 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h5><p>和新增相似</p>
<h5 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h5><p>需要做的是子串查找或字符串匹配。</p>
<p>在主串n中找模式串m，时间复杂度是 n 和 m 的函数。O(nm)</p>
<p>假设要从主串 s = “goodgoogle” 中找到 t = “google” 子串。</p>
<h4 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h4><ol>
<li>两个字符串的最大公共字串。如：a = “13452439”， b = “123456”。输出字符串”345”</li>
</ol>
<h3 id="6-树（二叉树、红黑树、堆、前缀树、线段树）"><a href="#6-树（二叉树、红黑树、堆、前缀树、线段树）" class="headerlink" title="6.树（二叉树、红黑树、堆、前缀树、线段树）"></a>6.树（二叉树、红黑树、堆、前缀树、线段树）</h3><p>博客 TODO</p>
<h3 id="7-哈希表"><a href="#7-哈希表" class="headerlink" title="7.哈希表"></a>7.哈希表</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>实现 “地址 = f (关键字)” 的映射关系</p>
<h4 id="存储结构-5"><a href="#存储结构-5" class="headerlink" title="存储结构"></a>存储结构</h4><p>特点：</p>
<ul>
<li><p>数据没有顺序。</p>
</li>
<li><p>数据存储与数据数值（关键字）有关。</p>
</li>
</ul>
<h4 id="数据操作-6"><a href="#数据操作-6" class="headerlink" title="数据操作"></a>数据操作</h4><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据没有顺序。</li>
<li>根据数值查找，时间复杂度O(1)</li>
<li>新增时间复杂度O(1)</li>
<li>删除时间复杂度O(1)</li>
</ul>
<h4 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h4><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>满足以下：</p>
<ul>
<li>不需要有序遍历数据</li>
<li>n次查询</li>
<li>可以提前预测数据量的大小。</li>
</ul>
<h3 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h3><h4 id="知识点-TODO"><a href="#知识点-TODO" class="headerlink" title="知识点 TODO"></a>知识点 TODO</h4><p>图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）</p>
<p>图的遍历：深度优先、广度优先</p>
<p>二部图的检测（Bipartite）（785）、树的检测、环的检测：有向图、无向图</p>
<p>拓扑排序</p>
<p>联合-查找算法（Union-Find）</p>
<p>最短路径：Dijkstra、Bellman-Ford</p>
<h3 id="各类数据结构对比"><a href="#各类数据结构对比" class="headerlink" title="各类数据结构对比"></a>各类数据结构对比</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th>链表</th>
<th>数组</th>
<th>字符串</th>
<th>栈</th>
<th>普通队列</th>
<th>优先队列（二叉堆）</th>
<th>二叉搜索树</th>
<th>前缀树</th>
<th>哈希表</th>
</tr>
</thead>
<tbody><tr>
<td>数据有序性</td>
<td></td>
<td>有</td>
<td>无</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查询时间复杂度</td>
<td>按位置</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>按数值</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(mn)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>？</td>
<td>O(logn)</td>
<td></td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>新增时间复杂度</td>
<td>中间</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td></td>
<td>O(1)</td>
</tr>
<tr>
<td>末尾</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>删除时间复杂度</td>
<td>中间</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td></td>
<td>O(1)</td>
</tr>
<tr>
<td>末尾</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><p>某个函数自己调用自己。</p>
<p>递归的使用条件需满足以下两个条件：</p>
<ul>
<li><p>可以拆解为除了数据规模以外，求解思路与原问题完全相同的子问题；</p>
</li>
<li><p>存在终止条件。</p>
</li>
</ul>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn(n) &#123;</span><br><span class="line">    // 第一步：判断输入合理性？</span><br><span class="line">    if (input is invalid) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第二步：递归结束条件?</span><br><span class="line">    if (match condition) &#123;</span><br><span class="line">        return some value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第三步：缩小问题规模</span><br><span class="line">    result1 = fn(n1)</span><br><span class="line">    result2 = fn(n2)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 第四步: 获取结果</span><br><span class="line">    return combine(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归算法题"><a href="#递归算法题" class="headerlink" title="递归算法题"></a>递归算法题</h4><ol>
<li>二叉树中序遍历</li>
<li>汉诺塔</li>
<li>斐波那契数列</li>
</ol>
<h3 id="2-分治"><a href="#2-分治" class="headerlink" title="2.分治"></a>2.分治</h3><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p>定义：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>特征：</p>
<ol>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ol>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><h4 id="分治算法题"><a href="#分治算法题" class="headerlink" title="分治算法题"></a>分治算法题</h4><ol>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>快速排序</li>
<li>归并排序</li>
<li>汉诺塔</li>
</ol>
<h3 id="3-回溯"><a href="#3-回溯" class="headerlink" title="3.回溯"></a>3.回溯</h3><h3 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4.排序算法"></a>4.排序算法</h3><h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><h3 id="5-查找算法"><a href="#5-查找算法" class="headerlink" title="5.查找算法"></a>5.查找算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>满足以下两点：</p>
<ul>
<li>时间复杂度O(logn)</li>
<li>数据有序</li>
</ul>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h4 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h4><h5 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h5><p>从起点出发，从规定的方向中选择其中一个不断地向前走，直到无法继续为止，然后尝试另外一种方向，直到最后走到终点。</p>
<p>解决连通性问题，从起点能不能到终点。</p>
<p>依赖栈，后进先出。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>给定一个二维矩阵代表一个迷宫，迷宫里面有通道，也有墙壁，通道由数字 0 表示，而墙壁由 -1 表示，有墙壁的地方不能通过，那么，能不能从 A 点走到 B 点。<img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/X7tLmsSGlF1JBE8.png" alt="image-20210829203111589"></p>
<h4 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h4><h3 id="6-贪婪"><a href="#6-贪婪" class="headerlink" title="6.贪婪"></a>6.贪婪</h3><h3 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h3>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-入门</title>
    <url>/2020/08/24/Rabbit-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>MQ介绍，RabbitMQ介绍，安装，配置，架构，五种常用工作模式helloword。</p>
<span id="more"></span>

<h1 id="RabbitMQ-入门"><a href="#RabbitMQ-入门" class="headerlink" title="RabbitMQ-入门"></a>RabbitMQ-入门</h1><h2 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h2><p>MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。</p>
<h2 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h2><p><a href="https://www.rabbitmq.com/">官网</a></p>
<p>RabbitMQ是一套开源（MPL）的消息队列服务软件，是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP) 的开源实现，由以高性能、健壮以及可伸缩性出名的 Erlang 写成。</p>
<p>6中工作模式</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uGEDs3AxXwRczCB.png" alt="image-20200905104518472"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4v8qjyHDd5lQgsA.png" alt="image-20200905104618032"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jwVKAkSuPQTY9hc.png" alt="image-20200905104735664"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/b7jon5FsHySYuhI.png" alt="image-20200905104809593"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IbzThmZocNSKgPU.png" alt="image-20200905104828048"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SAtoBasDdUVOjpF.png" alt="image-20200905104849361"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/q8ApBEWbc53CLfG.png" alt="image-20200905105120279"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>地址：</p>
<p>端口号：</p>
<p>​    5672</p>
<p>​    15672</p>
<p>​    25672</p>
<h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mnxAhU15GSg3blD.png" alt="image-20200906110051057"></p>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.6.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="生产者producer"><a href="#生产者producer" class="headerlink" title="生产者producer"></a>生产者producer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Produer</span><br><span class="line"> * @Description 生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;simple_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 要发送的信息</span><br><span class="line">        String message = &quot;hello rabbit&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>idea控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_131\bin\java.exe&quot;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">已发送消息：hello rabbit</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jHmQYtyl2TLdBSF.png" alt="image-20200906104944810"></p>
<p>rabbitMQ控制台</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/HnB2eFjsKPr8oCp.png" alt="image-20200906105002463"></p>
<h3 id="消费者consumer"><a href="#消费者consumer" class="headerlink" title="消费者consumer"></a>消费者consumer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class Consumer &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;simple_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        //不关闭资源，应该一直监听消息</span><br><span class="line">        //channel.close();</span><br><span class="line">        //connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>idea 控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_131\bin\java.exe&quot;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">路由key为：simple_queue</span><br><span class="line">交换机为：</span><br><span class="line">消息id为：1</span><br><span class="line">接收到的消息为：hello rabbit</span><br><span class="line">路由key为：simple_queue</span><br><span class="line">交换机为：</span><br><span class="line">消息id为：2</span><br><span class="line">接收到的消息为：hello rabbit</span><br></pre></td></tr></table></figure>

<p>rabbitMQ控制台</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/eytRlLufjD1VTsg.png" alt="image-20200906110949041"></p>
<h2 id="五种工作模式"><a href="#五种工作模式" class="headerlink" title="五种工作模式"></a>五种工作模式</h2><p>简单模式</p>
<p>工作模式</p>
<p>订阅模式pubsub</p>
<h3 id="helloword（简单模式）"><a href="#helloword（简单模式）" class="headerlink" title="helloword（简单模式）"></a>helloword（简单模式）</h3><p>即入门程序</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>架构图：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/z4wKmrSn5AsfLiR.png" alt="image-20200905110727987"></p>
<p>一个生产者，一个队列，多个消费者</p>
<p>producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Produer</span><br><span class="line"> * @Description 生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer_Work &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;Work_queues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        // 要发送的信息</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            String message = i + &quot;hello rabbit&quot;;</span><br><span class="line">            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>consumer1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class Consumer_Work1 &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;Work_queues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //一次只能接收并处理一个消息</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        //不关闭资源，应该一直监听消息</span><br><span class="line">        //channel.close();</span><br><span class="line">        //connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>consumer2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class Consumer_Work2 &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;Work_queues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //一次只能接收并处理一个消息</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        //不关闭资源，应该一直监听消息</span><br><span class="line">        //channel.close();</span><br><span class="line">        //connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先运行消费者1，再运行消费者2，最后运行生产者。</p>
<p>生产者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_131\bin\java.exe&quot;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">已发送消息：0hello rabbit</span><br><span class="line">已发送消息：1hello rabbit</span><br><span class="line">已发送消息：2hello rabbit</span><br><span class="line">已发送消息：3hello rabbit</span><br><span class="line">已发送消息：4hello rabbit</span><br><span class="line">已发送消息：5hello rabbit</span><br><span class="line">已发送消息：6hello rabbit</span><br><span class="line">已发送消息：7hello rabbit</span><br><span class="line">已发送消息：8hello rabbit</span><br><span class="line">已发送消息：9hello rabbit</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收到的消息为：1hello rabbit</span><br><span class="line">接收到的消息为：3hello rabbit</span><br><span class="line">接收到的消息为：5hello rabbit</span><br><span class="line">接收到的消息为：7hello rabbit</span><br><span class="line">接收到的消息为：9hello rabbit</span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收到的消息为：0hello rabbit</span><br><span class="line">接收到的消息为：2hello rabbit</span><br><span class="line">接收到的消息为：4hello rabbit</span><br><span class="line">接收到的消息为：6hello rabbit</span><br><span class="line">接收到的消息为：8hello rabbit</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oBApt1rbivZH3Xj.png" alt="image-20200906114842946"></p>
<h3 id="订阅模式（广播）"><a href="#订阅模式（广播）" class="headerlink" title="订阅模式（广播）"></a>订阅模式（广播）</h3><p>交换机类型：fanout</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jwVKAkSuPQTY9hc.png" alt="image-20200905104735664"></p>
<p><strong>Exchange（交换机）只转发消息，不存储消息</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<p>生产者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 发布与订阅使用的交换机类型为：fanout</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    //交换机名称</span><br><span class="line">    static final String FANOUT_EXCHAGE = &quot;fanout_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String FANOUT_QUEUE_1 = &quot;fanout_queue_1&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String FANOUT_QUEUE_2 = &quot;fanout_queue_2&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 声明交换机</span><br><span class="line">         * 参数1：交换机名称</span><br><span class="line">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE_1, true, false, false, null);</span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE_2, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(FANOUT_QUEUE_1, FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line">        channel.queueBind(FANOUT_QUEUE_2, FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            // 发送信息</span><br><span class="line">            String message = &quot;发布订阅模式--&quot; + i;</span><br><span class="line">            /**</span><br><span class="line">             * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">             * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">             * 参数3：消息其它属性</span><br><span class="line">             * 参数4：消息内容</span><br><span class="line">             */</span><br><span class="line">            channel.basicPublish(FANOUT_EXCHAGE, &quot;&quot;, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.FANOUT_QUEUE_1, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.FANOUT_QUEUE_1, Producer.FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;消费者1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(Producer.FANOUT_QUEUE_1, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.FANOUT_QUEUE_2, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.FANOUT_QUEUE_2, Producer.FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;消费者2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">        channel.basicConsume(Producer.FANOUT_QUEUE_2, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>队列与交换机绑定时，指定RoutingKey</p>
<p>消息发送时，指定消息的RoutingKey</p>
<p>队列根据RoutingKey接收消息。</p>
<p>交换机类型：direct</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/b7jon5FsHySYuhI.png" alt="image-20200905104809593"></p>
<p>producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由模式的交换机类型为：direct</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    //交换机名称</span><br><span class="line">    static final String DIRECT_EXCHAGE = &quot;direct_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String DIRECT_QUEUE_INSERT = &quot;direct_queue_insert&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String DIRECT_QUEUE_UPDATE = &quot;direct_queue_update&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 声明交换机</span><br><span class="line">         * 参数1：交换机名称</span><br><span class="line">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(DIRECT_QUEUE_INSERT, true, false, false, null);</span><br><span class="line">        channel.queueDeclare(DIRECT_QUEUE_UPDATE, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(DIRECT_QUEUE_INSERT, DIRECT_EXCHAGE, &quot;insert&quot;);</span><br><span class="line">        channel.queueBind(DIRECT_QUEUE_UPDATE, DIRECT_EXCHAGE, &quot;update&quot;);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        String message = &quot;新增了商品。路由模式；routing key 为 insert &quot; ;</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(DIRECT_EXCHAGE, &quot;insert&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        message = &quot;修改了商品。路由模式；routing key 为 update&quot; ;</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(DIRECT_EXCHAGE, &quot;update&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.DIRECT_QUEUE_INSERT, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.DIRECT_QUEUE_INSERT, Producer.DIRECT_EXCHAGE, &quot;insert&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.DIRECT_QUEUE_INSERT, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>consumer2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.DIRECT_QUEUE_UPDATE, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.DIRECT_QUEUE_UPDATE, Producer.DIRECT_EXCHAGE, &quot;update&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.DIRECT_QUEUE_UPDATE, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><p>交换机类型topic</p>
<p><code>#</code>：匹配0个或多个词</p>
<p><code>*</code>：匹配恰好1个词</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IbzThmZocNSKgPU.png" alt="image-20200905104828048"></p>
<p>producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通配符Topic的交换机类型为：topic</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    //交换机名称</span><br><span class="line">    static final String TOPIC_EXCHAGE = &quot;topic_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String TOPIC_QUEUE_1 = &quot;topic_queue_1&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String TOPIC_QUEUE_2 = &quot;topic_queue_2&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 声明交换机</span><br><span class="line">         * 参数1：交换机名称</span><br><span class="line">         * 参数2：交换机类型，fanout、topic、topic、headers</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        String message = &quot;新增了商品。Topic模式；routing key 为 xiaorui.insert &quot; ;</span><br><span class="line">        channel.basicPublish(TOPIC_EXCHAGE, &quot;xiaorui.insert&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        message = &quot;修改了商品。Topic模式；routing key 为 xiaorui.update&quot; ;</span><br><span class="line">        channel.basicPublish(TOPIC_EXCHAGE, &quot;xiaorui.update&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        message = &quot;删除了商品。Topic模式；routing key 为 xiaorui.delete&quot; ;</span><br><span class="line">        channel.basicPublish(TOPIC_EXCHAGE, &quot;xiaorui.delete&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.TOPIC_QUEUE_1, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, &quot;xiaorui.update&quot;);</span><br><span class="line">        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, &quot;xiaorui.delete&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.TOPIC_QUEUE_1, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.TOPIC_QUEUE_2, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.TOPIC_QUEUE_2, Producer.TOPIC_EXCHAGE, &quot;item.*&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.TOPIC_QUEUE_2, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
