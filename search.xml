<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux-xshell</title>
    <url>/2020/09/05/Linux-xshell/</url>
    <content><![CDATA[<p>Linux-xshell</p>
<span id="more"></span>

<h1 id="Linux-xshell"><a href="#Linux-xshell" class="headerlink" title="Linux-xshell"></a>Linux-xshell</h1><p>参考：<a href="https://www.cnblogs.com/shireenlee4testing/p/9469650.html">https://www.cnblogs.com/shireenlee4testing/p/9469650.html</a></p>
<p>IP地址、子网掩码和网关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim</span><br><span class="line">i</span><br><span class="line">esc</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/DxBGu8U452WTXsS.png" alt="image-20200905172230121"></p>
<p>设置DNS</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/M53vlbCtyou9X8I.png" alt="image-20200905172951580"></p>
<p>设置主机名</p>
<p><code>vim /etc/sysconfig/network</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SVFwH6GXMOlhdo9.png" alt="image-20200905174159032"></p>
<p><code>vim /etc/hostname</code></p>
<p>粘贴shift+insert</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8AoU4bkdBpELsDa.png" alt="image-20200905174437855"></p>
<p>连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh 192.168.3.3</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uDb9IGr5mtcEPi8.png" alt="image-20200905174104282"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-常用命令</title>
    <url>/2020/11/05/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux-常用命令</p>
<span id="more"></span>

<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux-常用命令"></a>Linux-常用命令</h1><p>cat 查看文件</p>
<p>more 查看file的内容</p>
<p>tar 解压</p>
<p>gzip 压缩</p>
<p>rpm 安装</p>
<p>yum 安装</p>
<p>rz 上载到linux</p>
<p>sz 下载到本地</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zumTHUjq8tgN1I5.png" alt="mmexport1560212361684"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-入门实践</title>
    <url>/2020/08/20/nginx-%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>入门实践</p>
<span id="more"></span>

<p>window环境nginx部署项目。</p>
<h1 id="nginx-入门实践"><a href="#nginx-入门实践" class="headerlink" title="nginx-入门实践"></a>nginx-入门实践</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oMKEpsxDd8q4zg7.png" alt="image-20200823214440256"></p>
<h2 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h2><p>一般80端口被占用，我改为了8082端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8082;# 80 改为了 8082</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">		# 省略...</span><br></pre></td></tr></table></figure>



<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>管理员身份运行<code>nginx.exe</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器输入<code>localhost:8082</code></p>
<h2 id="停止nginx"><a href="#停止nginx" class="headerlink" title="停止nginx"></a>停止nginx</h2><p>通过端口号查找进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\nginx-1.10.3&gt;netstat -aon|findstr &quot;8080&quot;</span><br><span class="line">  TCP    0.0.0.0:8080           0.0.0.0:0              LISTENING       24968</span><br></pre></td></tr></table></figure>

<p>杀进程失败</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\nginx-1.10.3&gt;taskkill -f -pid 24968</span><br><span class="line">错误: 无法终止 PID 为 24968 的进程。</span><br><span class="line">原因: 拒绝访问。</span><br></pre></td></tr></table></figure>

<p>解决：任务管理器手动结束进程</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4LfiVa8pSGuZjA7.png" alt="image-20200823213505090"></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>将静态目录放到<code>nginx/html</code>下，不包含项目目录时，访问时没有项目目录。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/d4SIRY9X86gAPrN.png" alt="image-20200823214145458"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ImWHST3pk1gfr8u.png" alt="image-20200823214213072"></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>项目-产品化</title>
    <url>/2020/10/08/%E9%A1%B9%E7%9B%AE-%E4%BA%A7%E5%93%81%E5%8C%96/</url>
    <content><![CDATA[<p>项目-产品化</p>
<span id="more"></span>

<h1 id="项目-产品化"><a href="#项目-产品化" class="headerlink" title="项目-产品化"></a>项目-产品化</h1><h2 id="什么是产品化"><a href="#什么是产品化" class="headerlink" title="什么是产品化"></a>什么是产品化</h2><p>对同一类型的项目经过多次迭代之后，项目开发变得稳定。这时，可将项目改造成为一个产品。</p>
<p>复用文档、架构、需求解析WBS。</p>
<p><strong>产品化的三个标准：</strong>时间标准，价格标准，开发标准。</p>
<p>架构师关注的开发标准：包括文档标准，迭代标准，交付标准，变更委员会标准，WBS标准（需求分解），技术标准（框架、数据库），代码规范和注释。</p>
<h3 id="软件公司经营模式"><a href="#软件公司经营模式" class="headerlink" title="软件公司经营模式"></a>软件公司经营模式</h3><ol>
<li>公司获得了足够融资，初创开始做的就是产品。如共享单车。</li>
<li>没有获得融资，或资金不足，，接项目进行公司的初步发展。或碍于销售渠道，必须前期开发项目。例如：税务行业、医疗行业的项目。</li>
</ol>
<h3 id="软件公司盈利模式"><a href="#软件公司盈利模式" class="headerlink" title="软件公司盈利模式"></a>软件公司盈利模式</h3><ol>
<li><p>单纯做项目。不断的接项目，卖项目。</p>
<p>如果和一些大客户有长期的合作关系，则公司的模式相对稳定，人员不会太多，盈利也不会太多。当没项目可做时，就需要解散项目组。</p>
</li>
<li><p>前期开发过不少项目，做了足够的积累，项目已经产品化了。这类公司会招聘一些销售人员推广自己的产品。</p>
</li>
<li><p>既卖产品又卖项目。</p>
</li>
<li><p>出售服务。</p>
<p>一般指运维。</p>
<p>另一种是SaaS模式（Software as a Service),意思是软件即服务。先投入大量资金做出来产品，发布到互联网，用户试用满意后购买这种产品（服务）。</p>
</li>
</ol>
<h2 id="软件产品化"><a href="#软件产品化" class="headerlink" title="软件产品化"></a>软件产品化</h2><ol>
<li><p>开发文档</p>
<p>需求说明书，概要设计，详细设计，干系人登记册，项目管理计划。可以根据积累整理一套模板。</p>
</li>
<li><p>产品风格</p>
<p>由美工和UI设计人员来设计界面。比如做灰色、蓝色、黑色三种界面风格的css样式。</p>
</li>
<li><p>前端框架</p>
</li>
<li><p>后端框架</p>
<p>涉及到架构复用，某个技术有漏洞时，要做到一整套框架中单个技术的可插拔。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>项目-完整流程</title>
    <url>/2020/10/08/%E9%A1%B9%E7%9B%AE-%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>项目-完整流程</p>
<span id="more"></span>

<h1 id="项目-完整流程"><a href="#项目-完整流程" class="headerlink" title="项目-完整流程"></a>项目-完整流程</h1><ol>
<li>售前工程师与客户建立关系</li>
<li>正式立项</li>
<li>需求调研</li>
<li>输出调研文档</li>
<li>开发技术选型</li>
<li>项目开工会</li>
<li>项目开发</li>
</ol>
<h2 id="售前工程师与客户建立关系"><a href="#售前工程师与客户建立关系" class="headerlink" title="售前工程师与客户建立关系"></a>售前工程师与客户建立关系</h2><p>与客户交流，包揽下客户的需求，我们可以做。</p>
<p>向客户提供资料，包括已经做成产品的东西，做项目的周期。</p>
<p>客户招投标或直接采购 。</p>
<h2 id="正式立项"><a href="#正式立项" class="headerlink" title="正式立项"></a>正式立项</h2><p>客户方立项</p>
<p>本公司立项</p>
<h2 id="需求调研"><a href="#需求调研" class="headerlink" title="需求调研"></a>需求调研</h2><p>项目经理+架构师+高级开发人员到客户公司调研。</p>
<p>客户开调研会，让客户方参加调研的人员配合乙方项目经理。</p>
<p>架构师回答技术问题。</p>
<p>项目经理确定调研内容、调研对象的主次。</p>
<p>写出需求文档让客户签字，可避免变更需求时没有参考的东西。</p>
<h2 id="输出调研文档"><a href="#输出调研文档" class="headerlink" title="输出调研文档"></a>输出调研文档</h2><h2 id="开发技术选型"><a href="#开发技术选型" class="headerlink" title="开发技术选型"></a>开发技术选型</h2><h2 id="项目开工会"><a href="#项目开工会" class="headerlink" title="项目开工会"></a>项目开工会</h2><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>项目执行阶段，代码开发</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>项目-开发模式</title>
    <url>/2020/10/08/%E9%A1%B9%E7%9B%AE-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>项目-开发模式</p>
<span id="more"></span>

<h1 id="项目-开发模式"><a href="#项目-开发模式" class="headerlink" title="项目-开发模式"></a>项目-开发模式</h1><p>项目开发模式分文瀑布式开发和敏捷开发。</p>
<p><strong>瀑布式开发：</strong>一步一步执行调研、开发、交互，对中间的成果不交付给客户。</p>
<p><strong>敏捷开发：</strong>12个月的开发期，分为12个交付版本，每个月部署一个版本给用户看。频繁与用户确认需求，频繁变更需求。</p>
<p>瀑布式开发适合已经非常成熟的产品，了解自己的产品，也了解用户需要什么样的东西，已经积累了完善的文档。包括需求设计、概要设计、详细设计。</p>
<p>敏捷开发适合频繁变更需求的项目。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>hbuilderX真机调试</title>
    <url>/2023/06/10/%E5%B7%A5%E5%85%B7/hbuilderX%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>hbuilderX真机调试</p>
<span id="more"></span>

<h1 id="hbuilderX真机调试"><a href="#hbuilderX真机调试" class="headerlink" title="hbuilderX真机调试"></a>hbuilderX真机调试</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>导入项目<br> <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20230610153503.png"></p>
</li>
<li><p>android机开启usb调试</p>
<p>  <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20230610154338.png"></p>
</li>
</ol>
<ol start="3">
<li><p>数据线连接电脑和android机，android机上弹框上选择允许调试<br> <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20230610154359.png"></p>
</li>
<li><p>运行项目到android机<br>  <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20230610153433.png"></p>
</li>
<li><p>修改项目请求后端地址<br> 需要android连接同一网段wifi。设置为本机地址。(cmd, ipconfig)<br> <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20230610154116.png"></p>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>android机上未弹框选择允许调试，更换数据线</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hbuilderX</tag>
      </tags>
  </entry>
  <entry>
    <title>Google浏览器调试</title>
    <url>/2022/04/01/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>Google浏览器调试</p>
<span id="more"></span>

<p>google浏览器开发者工具调试<br><a href="https://zhuanlan.zhihu.com/p/47697445">https://zhuanlan.zhihu.com/p/47697445</a></p>
<p><a href="https://www.bilibili.com/video/av3344698/">https://www.bilibili.com/video/av3344698/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA</title>
    <url>/2020/10/10/%E5%B7%A5%E5%85%B7/IDEA/</url>
    <content><![CDATA[<p>hbuilderX真机调试</p>
<span id="more"></span>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="1-日常"><a href="#1-日常" class="headerlink" title="1.日常"></a>1.日常</h3><p>Alt+鼠标左键 选中列</p>
<p>Ctrl+Alt+鼠标左键 跳转到方法的实现类</p>
<p>Ctrl+U 实现类跳转到接口</p>
<p>Ctrl + Alt + left(right) 返回上次光标位置</p>
<p>Alt+Insert，可以生成set/get等</p>
<p>Ctrl+Alt+L，格式化代码</p>
<p>Ctrl+R，替换文本</p>
<p>Ctrl+F，查找文本</p>
<p>Ctrl+Shift+Space，自动补全代码</p>
<p>Ctrl+空格，代码提示（与系统输入法快捷键冲突）</p>
<p>Alt+Shift+Up/Down，上/下移一行</p>
<p>Ctrl+Y，删除行</p>
<p>Ctrl+X，剪切行</p>
<p>Ctrl+D，复制并粘贴行</p>
<p>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）</p>
<p>Ctrl+Shift+Up/Down，向上/下移动语句</p>
<p>Ctrl + Alt + O 导入包</p>
<p>Ctrl + Alt + B 当前类的实现类</p>
<p>sout System.out.println()</p>
<p>psvm main主函数</p>
<p>fori for循环 Ctrl+J 查看其他快捷输出方式</p>
<p>Shift+F6 下划线转驼峰</p>
<h3 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h3><p>运行Shift+F10，调试Shift+F9</p>
<p>M：断点调试的时候用到的快捷键</p>
<p>F7 ：进入方法内部</p>
<p>F8：下一步，不进入方法</p>
<p>Alt+F8 查看变量值</p>
<p>Alt+F9 运行到光标处，无需打断点</p>
<p>运行到下一个断点：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20240202115417.png"></p>
<p>回退断点，断点调试超过时使用</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20240202115417.png"></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>Ctrl+F，搜索</p>
<p>Ctrl+R，搜索并替换</p>
<p>Ctrl + N 按文件内容搜索文件</p>
<p>Ctrl + Shift + N 按文件名搜索文件</p>
<p>Alt+F7(+Fn)搜索文字，</p>
<p>Ctrl + Shift + F 可根据jsp文件内容搜索到 jsp文件</p>
<p>Shift + Shift 搜索所有的文件</p>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>提取n行代码为一个方法 Ctrl + Alt + M</p>
<p>提炼方法的逆操作 Ctrl+alt+N</p>
<p>修改方法名、类名、变量名 ：选中方法名称、类名称、变量后，按Shift + F6</p>
<p>调出修改方法面板 Ctrl + F6</p>
<p>重构变量的类型 Ctrl+Shift+f6</p>
<p>快速提取常量（Constant） Ctrl+Alt+C</p>
<p>快速提取变量（Variable）Ctrl+Alt+V</p>
<p>快速提取成员变量（Filed Variable） Ctrl+Alt+F</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>F2(+Fn)，定位错误 ，上一个用Shift + F2(+Fn)</p>
<p>Alt + Enter 缺少包或局部变量</p>
<p>Ctrl + Shift + 回车 明显的语法错误自动处理</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Ctrl+E，最近的文件</p>
<p>Ctrl+Shift+E，最近更改的文件</p>
<p>Ctrl + W 基于语法快速选择代码，缩小选择范围Ctrl + Shift + W</p>
<p>Ctrl + P 参数提示</p>
<p>Ctrl+F12，可以显示当前文件的结构</p>
<p>Ctrl+H 类的继承关系</p>
<p>Ctrl+N，可以快速打开类</p>
<p>Ctrl+Shift+Insert，可以选择剪贴板内容并插入</p>
<p>Ctrl+Enter，导入包，自动修正</p>
<p>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作</p>
<p>Alt+Shift+C，最近的更改</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul>
<li><p>人工智能</p>
<p>copilot</p>
<p>Machinet.net chatgpt4</p>
</li>
<li><p>代码生成</p>
<p>lombok</p>
<p>代码生成器  GenerateAllSetter  对象生成set&amp;get使用： Alt+Enter</p>
<p>easycode</p>
<p>translation 翻译</p>
<p>camelCase 大小写</p>
<p>RoboPOJOGenerator  json 生成类。 新建类改为 new RoboPOJOGenerator</p>
<p>GsonFormat json转java类</p>
<p>POJO to JSON 对象转JSON</p>
</li>
<li><p>跳转</p>
<p>spring-assistant   yml工具</p>
<p>Free Mybatis tool</p>
</li>
<li><p>可视化&amp;增强可视化</p>
<p>彩色括号 Rainbow Brackets Lite </p>
<p>控制台日志工具：Grep Console</p>
<p>MyBatis Log Free</p>
<p>jclasslib Java字节码查看. 使用：选种类。左上脚view → Show Bytecode With jclasslib</p>
<p>visualVM Launcher JVM监控</p>
<p>diagrams draw.io查看</p>
<p>类调用时序图 SequenceDiagram</p>
<p>Maven helper</p>
<p>bug 预检查：FindBugs</p>
</li>
</ul>
<h2 id="导入项目设置"><a href="#导入项目设置" class="headerlink" title="导入项目设置"></a>导入项目设置</h2><p>1.设置jdk</p>
<p>​    <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240208115531202.png" alt="image-20240208115531202"></p>
<p>2.设置源代码目录</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240208115540944.png" alt="image-20240208115540944"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea_Easycode</title>
    <url>/2021/11/25/%E5%B7%A5%E5%85%B7/Idea_Easycode/</url>
    <content><![CDATA[<p>Idea_Easycode</p>
<span id="more"></span>

<h1 id="Idea-Easycode"><a href="#Idea-Easycode" class="headerlink" title="Idea_Easycode"></a>Idea_Easycode</h1><ol>
<li>安装插件</li>
<li>使用</li>
<li>修改配置</li>
</ol>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>配置数据源</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/QHrNAMhRp9iFJ3O.png" alt="image-20211125192509212"></p>
</li>
<li><p>生成代码</p>
</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tr1gyqNlvUIeQ2Y.png" alt="image-20211125192626644"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/qFDZoSXy49BaT3r.png" alt="image-20211125155516299"></p>
<h2 id="EasyCode配置"><a href="#EasyCode配置" class="headerlink" title="EasyCode配置"></a>EasyCode配置</h2><ol>
<li><p>全局配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ZQWuphvagdEY8eD.png" alt="image-20211125192833707"></p>
</li>
<li><p>实体entity</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Uu1zW2q3wlynFeE.png" alt="image-20211125193131971"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!&#123;init.vm&#125;</span><br><span class="line">$!&#123;define.vm&#125;</span><br><span class="line"></span><br><span class="line">##使用宏定义设置回调（保存位置与文件后缀）</span><br><span class="line">#save(&quot;/domain&quot;, &quot;.java&quot;)</span><br><span class="line"></span><br><span class="line">##使用宏定义设置包后缀</span><br><span class="line">#setPackageSuffix(&quot;domain&quot;)</span><br><span class="line"></span><br><span class="line">##使用全局变量实现默认包导入</span><br><span class="line">$!&#123;autoImport.vm&#125;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Builder;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;实体类&quot;)</span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Builder</span><br><span class="line">@ApiModel(value = &quot;$!&#123;tableInfo.comment&#125;&quot;)</span><br><span class="line">public class $!&#123;tableInfo.name&#125; implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = $!tool.serial();</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line"></span><br><span class="line">    #if($&#123;column.comment&#125;)@ApiModelProperty(value = &quot;$&#123;column.comment&#125;&quot;)</span><br><span class="line">    #end</span><br><span class="line">private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">#end</span><br><span class="line">#*#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">##使用宏定义实现get,set方法</span><br><span class="line">#getSetMethod($column)</span><br><span class="line">#end*#</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>dao</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20211126141831605.png" alt="image-20211126141831605"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Mapper&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/mapper&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;mapper;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.domain.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import org.apache.ibatis.annotations.Param;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表数据库访问层</span><br><span class="line"> *</span><br><span class="line"> * @author $!author</span><br><span class="line"> * @since $!time.currTime()</span><br><span class="line"> */</span><br><span class="line">public interface $!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询指定行数据，分页</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 查询条件</span><br><span class="line">     * @return 对象列表</span><br><span class="line">     */</span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByLimit($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 统计总行数</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 查询条件</span><br><span class="line">     * @return 总行数</span><br><span class="line">     */</span><br><span class="line">    long count($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量新增数据（MyBatis原生foreach方法）</span><br><span class="line">     *</span><br><span class="line">     * @param entities List&lt;$!&#123;tableInfo.name&#125;&gt; 实例对象列表</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int insertBatch(@Param(&quot;entities&quot;) List&lt;$!&#123;tableInfo.name&#125;&gt; entities);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量新增或按主键更新数据（MyBatis原生foreach方法）</span><br><span class="line">     *</span><br><span class="line">     * @param entities List&lt;$!&#123;tableInfo.name&#125;&gt; 实例对象列表</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     * @throws org.springframework.jdbc.BadSqlGrammarException 入参是空List的时候会抛SQL语句错误的异常，请自行校验入参</span><br><span class="line">     */</span><br><span class="line">    int insertOrUpdateBatch(@Param(&quot;entities&quot;) List&lt;$!&#123;tableInfo.name&#125;&gt; entities);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据主键修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int deleteById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>xml</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ySmTcsKPUN91eB4.png" alt="image-20211126142103838"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JFS1vTI6qYOhREP.png" alt="image-20211126142311759"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入mybatis支持</span><br><span class="line">$!&#123;mybatisSupport.vm&#125;</span><br><span class="line"></span><br><span class="line">##设置保存名称与保存位置</span><br><span class="line">$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, &quot;Mapper.xml&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($modulePath, &quot;/src/main/resources/mapper/auto&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;$!&#123;tableInfo.savePackageName&#125;.mapper.$!&#123;tableInfo.name&#125;Mapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap type=&quot;$!&#123;tableInfo.savePackageName&#125;.domain.$!&#123;tableInfo.name&#125;&quot; id=&quot;$!&#123;tableInfo.name&#125;Map&quot;&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">        &lt;result property=&quot;$!column.name&quot; column=&quot;$!column.obj.name&quot; jdbcType=&quot;$!column.ext.jdbcType&quot;/&gt;</span><br><span class="line">#end</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询单个--&gt;</span><br><span class="line">    &lt;select id=&quot;queryById&quot; resultMap=&quot;$!&#123;tableInfo.name&#125;Map&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">          #allSqlColumn()</span><br><span class="line"></span><br><span class="line">        from $!tableInfo.obj.name</span><br><span class="line">        where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询指定行数据--&gt;</span><br><span class="line">    &lt;select id=&quot;queryAllByLimit&quot; resultMap=&quot;$!&#123;tableInfo.name&#125;Map&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">          #allSqlColumn()</span><br><span class="line"></span><br><span class="line">        from $!tableInfo.obj.name</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                and $!column.obj.name = #&#123;$!column.name&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--统计总行数--&gt;</span><br><span class="line">    &lt;select id=&quot;count&quot; resultType=&quot;java.lang.Long&quot;&gt;</span><br><span class="line">        select count(1)</span><br><span class="line">        from $!tableInfo.obj.name</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                and $!column.obj.name = #&#123;$!column.name&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--新增所有列--&gt;</span><br><span class="line">    &lt;insert id=&quot;insert&quot; keyProperty=&quot;$!pk.name&quot;&gt;</span><br><span class="line">        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)</span><br><span class="line">        values (#foreach($column in $tableInfo.fullColumn)#&#123;$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;insertBatch&quot; keyProperty=&quot;$!pk.name&quot;&gt;</span><br><span class="line">        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;entities&quot; item=&quot;entity&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        (#foreach($column in $tableInfo.fullColumn)#&#123;entity.$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;insertOrUpdateBatch&quot; keyProperty=&quot;$!pk.name&quot;&gt;</span><br><span class="line">        insert into $!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.fullColumn)$!column.obj.name#if($velocityHasNext), #end#end)</span><br><span class="line">        values</span><br><span class="line">        &lt;foreach collection=&quot;entities&quot; item=&quot;entity&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            (#foreach($column in $tableInfo.fullColumn)#&#123;entity.$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">        on duplicate key update</span><br><span class="line">        #foreach($column in $tableInfo.fullColumn)$!column.obj.name = values($!column.obj.name)#if($velocityHasNext),</span><br><span class="line">        #end#end</span><br><span class="line"></span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键修改数据--&gt;</span><br><span class="line">    &lt;update id=&quot;update&quot;&gt;</span><br><span class="line">        update $!&#123;tableInfo.obj.name&#125;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">#foreach($column in $tableInfo.otherColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                $!column.obj.name = #&#123;$!column.name&#125;,</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">        where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键删除--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteById&quot;&gt;</span><br><span class="line">        delete from $!&#123;tableInfo.obj.name&#125; where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>TODO</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/makejavas/EasyCode">https://github.com/makejavas/EasyCode</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>代码生成</tag>
      </tags>
  </entry>
  <entry>
    <title>idea远程debug</title>
    <url>/2021/01/15/%E5%B7%A5%E5%85%B7/idea%E8%BF%9C%E7%A8%8Bdebug/</url>
    <content><![CDATA[<p>idea远程debug</p>
<span id="more"></span>

<h1 id="idea远程debug"><a href="#idea远程debug" class="headerlink" title="idea远程debug"></a>idea远程debug</h1><h2 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ad1xS8bLz9Zp4Rj.png" alt="image-20220115090445006"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SDGkAmnpY4u526g.png" alt="image-20220115090523364"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/CsPIOGn14L9AbxW.png" alt="image-20220115091433546"></p>
<h2 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NF5rToK6HZnGJ12.png" alt="image-20220115091125401"></p>
<h2 id="k8s配置"><a href="#k8s配置" class="headerlink" title="k8s配置"></a>k8s配置</h2><p>配置服务的对外暴露端口</p>
<h2 id="启动idea"><a href="#启动idea" class="headerlink" title="启动idea"></a>启动idea</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/QWSLMPVlJFEpDXv.png" alt="image-20220115091623947"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a href="https://www.cnblogs.com/wkynf/p/15115295.html">参考</a></h2>]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman设置全局登录token</title>
    <url>/2022/04/01/%E5%B7%A5%E5%85%B7/Postman%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>Postman设置全局登录token</p>
<span id="more"></span>



<p>[toc]</p>
<h1 id="Postman设置全局登录token"><a href="#Postman设置全局登录token" class="headerlink" title="Postman设置全局登录token"></a>Postman设置全局登录token</h1><h2 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1.环境变量"></a>1.环境变量</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8SeHulaU7bLYjq1.png" alt="image-20220401102209319"></p>
<h2 id="2-登录后设置变量脚本"><a href="#2-登录后设置变量脚本" class="headerlink" title="2.登录后设置变量脚本"></a>2.登录后设置变量脚本</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/HroL9S2qK5IsyFU.png" alt="image-20220401102317100"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> token = pm.response.json().data.token;</span><br><span class="line"></span><br><span class="line">pm.environment.set(<span class="string">&quot;Authorization&quot;</span>, token);</span><br></pre></td></tr></table></figure>

<h2 id="3-项目设置所有请求的请求头"><a href="#3-项目设置所有请求的请求头" class="headerlink" title="3.项目设置所有请求的请求头"></a>3.项目设置所有请求的请求头</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6ixvUhoW3MK2LEl.png" alt="image-20220401102539896"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pm.request.headers.add(&#123;</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span>: <span class="string">&quot;Authorization&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>: pm.environment.get(<span class="string">&quot;Authorization&quot;</span>)    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.request.headers.add(&#123;</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span>: <span class="string">&quot;userId&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>: pm.environment.get(<span class="string">&quot;userId&quot;</span>)    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-选择环境变量"><a href="#4-选择环境变量" class="headerlink" title="4.选择环境变量"></a>4.选择环境变量</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/cnrwO2etkZRVBK8.png" alt="image-20220401103138690"></p>
<h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h2><p>变量优先级：</p>
<ol>
<li>请求上的请求头</li>
<li>环境变量</li>
<li>全局变量</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>token</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ</title>
    <url>/2023/10/28/213Java%E6%A1%86%E6%9E%B6/MQ/</url>
    <content><![CDATA[<p>MQ</p>
<span id="more"></span>

<h2 id="MQ总览"><a href="#MQ总览" class="headerlink" title="MQ总览"></a>MQ总览</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>异步，削峰，解耦，大数据量分批</p>
<h3 id="引入复杂度"><a href="#引入复杂度" class="headerlink" title="引入复杂度"></a>引入复杂度</h3><p>重复消费，中间数据不一致，降低可用性，复杂度提高</p>
<h3 id="防止重复消费"><a href="#防止重复消费" class="headerlink" title="防止重复消费"></a>防止重复消费</h3><ol>
<li>幂等</li>
<li>redis分布式锁</li>
<li>分区顺序MQ</li>
<li>mysql唯一键</li>
</ol>
<h3 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h3><p>原因：生产速率大于消费速率</p>
<ul>
<li>用户流量突然增大</li>
<li>广播消息，服务器扩容10倍以上</li>
<li>消费者服务问题<ul>
<li>bug</li>
<li>数据库，下游服务网络问题</li>
</ul>
</li>
</ul>
<p>解决消息积压：</p>
<ol>
<li><p>增加消费能力</p>
<ul>
<li>直接增加消费者数量；增加消费者服务器、多线程消费</li>
<li>单个消费改为批量消费</li>
<li>提前写消息积压时的特殊消费逻辑。</li>
<li>将Topic分发到多个临时Topic，新的多台consumer消费临时Topic</li>
</ul>
</li>
<li><p>降低生产速率</p>
<ol>
<li>限流</li>
</ol>
</li>
<li><p>进一步对MQ削峰填谷</p>
<p>白天丢弃消息，晚上通过日志找到消息补发到MQ中</p>
</li>
</ol>
<p>避免消息积压</p>
<ul>
<li>监控和告警，监控消息队列的消息数量、延迟等指标</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>问题：部分MQ消费速度为0，消息积压</li>
<li>原因：修改饮品菜谱后，广播清除所有服务器的JVM本地缓存，节日扩容引起了单个MQ消费速率超高，占用了所有消费限制。生产+消费一共8万。</li>
<li>解决<br>临时：缩容<br>后期：取消广播，本地缓存时间降低到2分钟，接受2分钟的数据延迟</li>
</ul>
<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>定时任务比较成功消费MQ的数据是否正确</p>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li><p>异步消息</p>
</li>
<li><p>同步消息</p>
</li>
<li><p>顺序消息</p>
</li>
<li><p>定时消息</p>
</li>
<li><p>事务消息</p>
<p>修改状态原理：</p>
<ol>
<li>记录消息offset（相当于地址）</li>
<li>第一阶段提交</li>
<li>第二阶段根据offset查询到消息</li>
<li>修改状态</li>
</ol>
<p>offset实现查询消息的问题：通过offset修改数据，会产生很多脏页</p>
</li>
<li><p>消息重放</p>
<p>支持指定消息，指定时间段重放</p>
</li>
<li><p>消息堆积</p>
<p>可堆积亿条消息</p>
</li>
<li><p>消息防丢失</p>
</li>
<li><p>消息可靠性</p>
<ul>
<li>broker关闭、异常、操作系统异常后恢复，可保证消息不丢失。（刷盘方式是异步时丢失极少量数据）</li>
<li>机器无法开机、磁盘损坏，通过异步复制，可保证99%的消息不丢失；同步双写可避免单点问题，但很影响性能。</li>
<li>消息消费后，才会返回ACK，不返回ACK，消息会重新投递，消费一定次数后，会被投递到死信队列。</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240228075320819.png" alt="image-20240228075320819"></p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240228075354953.png" alt="image-20240228075354953"></p>
<h4 id="消息数据结构"><a href="#消息数据结构" class="headerlink" title="消息数据结构"></a>消息数据结构</h4><h4 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h4><ul>
<li><p>push（推，长轮询pull）</p>
<p>优点：实时性高，不用自己维护消费速率</p>
<p>缺点：消息量大的时候，消费者压力大</p>
<ul>
<li><p>拉去消息步骤</p>
<ol>
<li><p>消费者启动时创建一个后台线程，处理拉消息</p>
</li>
<li><p>判断有没有过多消息未消费，</p>
<ul>
<li><p>有的话，间隔一定时间再去执行拉消息步骤</p>
</li>
<li><p>没有的话，直接向MQ发送拉去消息的请求。</p>
<ul>
<li>有消息，立刻返回</li>
<li>没有消息，hold住请求，有消息时再放回</li>
</ul>
</li>
</ul>
</li>
<li><p>获取消息后，找用户自定义的消息处理逻辑，并执行；同时再次拉取消息。</p>
</li>
</ol>
</li>
<li><p>消费者控制消费压力</p>
<ul>
<li>基于未消费消息的数量</li>
<li>基于未消费消息内存占用</li>
</ul>
</li>
</ul>
</li>
<li><p>pull</p>
<p>优点：消费速率灵活可控</p>
<p>缺点：实时性差，需要主动维护消费速率</p>
</li>
</ul>
<h2 id="各类MQ区别"><a href="#各类MQ区别" class="headerlink" title="各类MQ区别"></a>各类MQ区别</h2><table>
<thead>
<tr>
<th></th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
<th>Kafaka</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
</tr>
<tr>
<td>单机性能</td>
<td>10万</td>
<td>万</td>
<td>10万</td>
</tr>
<tr>
<td>延迟</td>
<td>ms</td>
<td>us</td>
<td>ms</td>
</tr>
<tr>
<td>可用性</td>
<td></td>
<td>普通集群（主从架构），镜像集群</td>
<td></td>
</tr>
<tr>
<td>功能性</td>
<td>功能完备，扩展性强</td>
<td>相比RocketMQ缺事务、顺序消息。基于Erlang开发，并发能力强，延时低，管理界面丰富</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
        <tag>RocketMQ</tag>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring缓存</title>
    <url>/2021/11/13/213Java%E6%A1%86%E6%9E%B6/Spring%E6%B3%A8%E8%A7%A3+redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>Spring方法级别缓存，使用redis存储缓存数据</p>
<span id="more"></span>

<h1 id="Spring缓存"><a href="#Spring缓存" class="headerlink" title="Spring缓存"></a>Spring缓存</h1><p>Spring方法级别缓存，使用redis存储缓存数据</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设置一个类中多个方法的cacheNames，优先级低于具体方法上的cacheNames</span><br><span class="line">@CacheConfig(cacheNames = &quot;branch&quot;)</span><br><span class="line">// 缓存，key最好设置，防止重复；cacheManager在配置类中配置过期时间</span><br><span class="line">@Cacheable(key = &quot;&#x27;city_&#x27; + #city + &#x27;_&#x27; + #platform&quot;,cacheManager = &quot;branchByCity&quot;)</span><br><span class="line">// 配置清除方法，allEntries=true，才会在调用时一定清除缓存数据，默认为false</span><br><span class="line">@CacheEvict(cacheManager = &quot;branchByCity&quot;,value=&quot;branch&quot;, allEntries=true)</span><br><span class="line"></span><br><span class="line">//每次都会执行方法，并将结果存入指定的缓存中  未测试</span><br><span class="line">@CachePut(&quot;users&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>过期时间，结合redis配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableCaching</span><br><span class="line">@Configuration</span><br><span class="line">public class CacheConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;branchByCity&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        CaffeineCacheManager cacheManager = new CaffeineCacheManager(&quot;branch&quot;);</span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(10000)</span><br><span class="line">                .expireAfterWrite(120, TimeUnit.SECONDS)</span><br><span class="line">//                .weakKeys()</span><br><span class="line">                .recordStats());</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;branchExclusively&quot;)</span><br><span class="line">    public CacheManager cacheExclusivelyManager() &#123;</span><br><span class="line">        CaffeineCacheManager cacheManager = new CaffeineCacheManager(&quot;branchExclusivelys&quot;);</span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(10000)</span><br><span class="line">                .expireAfterWrite(120, TimeUnit.SECONDS)</span><br><span class="line">//                .weakKeys()</span><br><span class="line">                .recordStats());</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用redis作缓存</span><br><span class="line">     * @param factory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean(value = &quot;pointMallManager&quot;,autowireCandidate=false)</span><br><span class="line">    public CacheManager pointMallCacheManager(RedisConnectionFactory factory) &#123;</span><br><span class="line">        //初始化一个RedisCacheWriter</span><br><span class="line">        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(factory);</span><br><span class="line">        //设置CacheManager的值序列化方式为json序列化</span><br><span class="line">        RedisSerializer&lt;Object&gt; jsonSerializer = new GenericJackson2JsonRedisSerializer();</span><br><span class="line">        RedisSerializationContext.SerializationPair&lt;Object&gt; pair = RedisSerializationContext.SerializationPair.fromSerializer(jsonSerializer);</span><br><span class="line">        //设置默认超过期时间是600秒,不缓存null值</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfig = RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(pair).entryTtl(Duration.ofSeconds(600)).disableCachingNullValues();</span><br><span class="line">        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter, defaultCacheConfig);</span><br><span class="line">/*        CaffeineCacheManager cacheManager = new CaffeineCacheManager(&quot;pointMall&quot;, &quot;allSpecRemark&quot;);</span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                .initialCapacity(500)</span><br><span class="line">                .expireAfterWrite(10, TimeUnit.MINUTES)</span><br><span class="line">//                .weakKeys()</span><br><span class="line">                .recordStats());*/</span><br><span class="line"></span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="controller使用"><a href="#controller使用" class="headerlink" title="controller使用"></a>controller使用</h3><p>AppBranchClient接口单独抽离出供其他服务依赖，这是AppBranchClient的实现AppBranchRemote</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@CacheConfig(cacheNames = &quot;branch&quot;)</span><br><span class="line">public class AppBranchRemote implements AppBranchClient &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private IBranchService branchService;</span><br><span class="line"></span><br><span class="line">    @Cacheable(key = &quot;&#x27;findBranchExclusivelyById_&#x27; + #id&quot;,cacheManager = &quot;branchExclusively&quot;,cacheNames = &quot;branchExclusivelys&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Result&lt;BranchExclusivelyGoodsDto&gt; findBranchExclusivelyById(Long id) &#123;</span><br><span class="line">        BranchExclusivelyGoodsDto branchGoodsExclusivelyDto =null;</span><br><span class="line">        try&#123;</span><br><span class="line">            branchGoodsExclusivelyDto = branchService.findBranchExclusivelyById(id);</span><br><span class="line">        &#125;catch (IllegalArgumentException e)&#123;</span><br><span class="line">            return Result.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.success(branchGoodsExclusivelyDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清除缓存方法"><a href="#清除缓存方法" class="headerlink" title="清除缓存方法"></a>清除缓存方法</h3><p>接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface BranchCatchService &#123;</span><br><span class="line">    void clearBranchCatch();</span><br><span class="line"></span><br><span class="line">    void clearBranchExclusivelyCatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CacheConfig(cacheNames = &quot;branch&quot;)</span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class BranchCatchServiceImpl implements BranchCatchService &#123;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheManager = &quot;branchByCity&quot;,value=&quot;branch&quot;, allEntries=true)</span><br><span class="line">    @Override</span><br><span class="line">    public void clearBranchCatch()&#123;</span><br><span class="line">        log.info(&quot;清理门店缓存branchByCity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(cacheNames = &quot;branchExclusivelys&quot;, cacheManager = &quot;branchExclusively&quot;,value=&quot;branchExclusivelys&quot;, allEntries=true)</span><br><span class="line">    @Override</span><br><span class="line">    public void clearBranchExclusivelyCatch()&#123;</span><br><span class="line">        log.info(&quot;清理门店专供branchExclusively&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>XXLJOB使用</title>
    <url>/2023/05/09/213Java%E6%A1%86%E6%9E%B6/XXLJOB/</url>
    <content><![CDATA[<p>并发设计案例</p>
<span id="more"></span>

<h1 id="XXLJOB使用"><a href="#XXLJOB使用" class="headerlink" title="XXLJOB使用"></a>XXLJOB使用</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol>
<li><p>导包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--xxl jop定时任务--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      ...</span><br><span class="line">      config:</span><br><span class="line">        ...</span><br><span class="line">        shared-configs[0]:</span><br><span class="line">          data-id: xxl-job-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br><span class="line">          group: DEFAULT_GROUP</span><br><span class="line">          refresh: true</span><br></pre></td></tr></table></figure></li>
<li><p>执行器config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;xxl.job&quot;, matchIfMissing = false, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="line">public class JobExecutorConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span><br><span class="line">    private String adminAddresses;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span><br><span class="line">    private String accessToken;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span><br><span class="line">    private String appName;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span><br><span class="line">    private String ip;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span><br><span class="line">    private String logPath;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span><br><span class="line">    private int logRetentionDays;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public XxlJobSpringExecutor xxlJobExecutor() &#123;</span><br><span class="line">        log.info(&quot;[XxlJobSpringExecutor] config init&quot;);</span><br><span class="line">        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appName);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        return xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="建任务"><a href="#建任务" class="headerlink" title="建任务"></a>建任务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.sexytea.pss.task;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.sexytea.pss.importRece.ImportReceTaskServiceImpl;</span><br><span class="line">import com.xxl.job.core.biz.model.ReturnT;</span><br><span class="line"></span><br><span class="line">import com.xxl.job.core.handler.IJobHandler;</span><br><span class="line">import com.xxl.job.core.handler.annotation.XxlJob;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 同步数据</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> **/</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class SyncToHdcBranchTask extends IJobHandler &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ImportReceTaskServiceImpl importReceTaskService;</span><br><span class="line"></span><br><span class="line">    @XxlJob(&quot;syncToHdcBranchJob&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public ReturnT&lt;String&gt; execute(String s) throws Exception&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            log.info(&quot;execute SyncToHdcBranch begin&quot;);</span><br><span class="line">            importReceTaskService.triggerGetNoteAndGenerateRece();</span><br><span class="line">            log.info(&quot;execute SyncToHdcBranch end. cost &#123;&#125;ms&quot;, (System.currentTimeMillis() - startTime));</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            log.error(e.getCause().getMessage());</span><br><span class="line">            return ReturnT.FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">        return ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="XXLJOB页面配置"><a href="#XXLJOB页面配置" class="headerlink" title="XXLJOB页面配置"></a>XXLJOB页面配置</h2><ol>
<li><p>执行器</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ATD2nszSOGUK39u.png" alt="img"></p>
</li>
<li><p>任务</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WYQEiU6ue48BgoN.png" alt="img"></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></p>
]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>XXLJOB</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA-调试</title>
    <url>/2021/05/31/%E5%B7%A5%E5%85%B7/IDEA-%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>查询慢查询日志</p>
<span id="more"></span>

<h1 id="IDEA-调试"><a href="#IDEA-调试" class="headerlink" title="IDEA-调试"></a>IDEA-调试</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>下一步，跳入，强制跳入，跳出，回到初始断点处，运行到指定代码处，表达式计算，线程</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uhgEFic8QOAVN3x.png" alt="image-20210531155859215"></p>
<h2 id="回到初始断点处"><a href="#回到初始断点处" class="headerlink" title="回到初始断点处"></a>回到初始断点处</h2><p>注意：遇到分页插件之后断点，使用此功能会清除分页参数，导致查询全部。数据量大的情况下，idea会卡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (data.getPageNum() != null &amp;&amp; data.getPageSize() != null) &#123;</span><br><span class="line">	PageHelper.startPage(data.getPageNum(), data.getPageSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行到指定代码处"><a href="#运行到指定代码处" class="headerlink" title="运行到指定代码处"></a>运行到指定代码处</h2><p>运行到鼠标所在代码行处。</p>
<h2 id="表达式计算"><a href="#表达式计算" class="headerlink" title="表达式计算"></a>表达式计算</h2><p>for循环中此功能好用</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SJ7lYF2nadpyPio.png" alt="image-20210531160203192"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Stream</title>
    <url>/2021/01/14/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java-Stream/</url>
    <content><![CDATA[<p>Java-Stream</p>
<span id="more"></span>

<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// User与UserVo有相同含义不同字段时，List&lt;User&gt; 转 List&lt;UserVo&gt;</span><br><span class="line">List&lt;UserVo&gt; userVos = users.stream().map(it -&gt; &#123;</span><br><span class="line">    UserVo userVo = new UserVo;</span><br><span class="line">    userVO.setUserId(it.getUserId());</span><br><span class="line">    return userVo;</span><br><span class="line">&#125;).collect(toList());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java变量</title>
    <url>/2021/01/14/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>Java变量</p>
<span id="more"></span>

<h1 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java有成员变量和局部变量。成员变量又分为类变量（静态变量）和实例变量（全局变量）。</p>
<ul>
<li>类变量：类的属性，用static修饰。</li>
<li>实例变量：类的属性，不用static修饰。</li>
<li>局部变量：类中方法中的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Static <span class="keyword">int</span> allClicks = <span class="number">0</span>;<span class="comment">// 类变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">&quot;hello&quot;</span>;<span class="comment">// 实例变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><ul>
<li><p>生命周期</p>
<p>跟谁着类的加载和销毁。[[类的加载]]</p>
</li>
<li><p>空间分配</p>
<p>元空间。[[JVM内存分配]]</p>
</li>
</ul>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><ul>
<li><p>生命周期</p>
<p>跟谁着类的实例化对象。</p>
</li>
<li><p>空间分配</p>
<p>堆</p>
</li>
</ul>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li><p>生命周期</p>
<p>跟谁类的非静态方法。</p>
</li>
<li><p>空间分配</p>
<p>栈上分配。</p>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>[[策略模式]] [[String]]</p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2021/01/14/212Java%E8%AF%AD%E8%A8%80/JavaSE/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>final关键字</p>
<span id="more"></span>

<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>java关键字。用在变量、方法、类上有不同效果。</p>
<ul>
<li><p>变量 [[Java变量]]</p>
<p>变量初始化后不可修改（被重新赋值）。</p>
<ul>
<li><p>成员变量</p>
<p>只可以直接初始化、构造方法初始化、静态代码块初始化。<br>引用不可再变。</p>
</li>
<li><p>局部变量</p>
<p>可以在方法中使用时初始化。</p>
</li>
</ul>
</li>
<li><p>方法</p>
<p>方法不可被重写。可以防止子类通过重载父类方法执行恶心操作。</p>
<p>可以被重载</p>
</li>
<li><p>类</p>
<p>类不可被继承，不可改变引用，但可以修改引用中变量的值</p>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>[[策略模式]] String</p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>并发工具包</title>
    <url>/2023/09/22/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/04%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>并发工具包</p>
<span id="more"></span>

<h1 id="并发工具包"><a href="#并发工具包" class="headerlink" title="并发工具包"></a>并发工具包</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="14-15Lock和Condition"><a href="#14-15Lock和Condition" class="headerlink" title="14-15Lock和Condition"></a>14-15Lock和Condition</h3><p>Lock相比于synchronized解决了破坏死锁中的不可抢占条件。</p>
<p>Lock 用于解决互斥问题，Condition 用于解决同步问题。</p>
<p>如何解决：</p>
<ol>
<li>能够响应中断</li>
<li>支持超时</li>
<li>支持非阻塞获取锁，获取失败返回获取失败的结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        lock.lockInterruptibly();<span class="comment">// 可中断锁</span></span><br><span class="line"></span><br><span class="line">        lock.tryLock(<span class="number">1L</span>, TimeUnit.SECONDS);<span class="comment">// 支持超时的锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b = lock.tryLock();<span class="comment">// 非阻塞获取锁；尝试获取锁，获取不到就返回false，不会阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><ul>
<li><p>解决：防止funA()调用funB()产生死锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;funA&quot;</span>);</span><br><span class="line">        funB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;funB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可重入锁案例</span></span><br><span class="line">        LockTest lockTest = <span class="keyword">new</span> LockTest();</span><br><span class="line">        lockTest.funA();<span class="comment">// funA调用funB时，因为锁可冲入，可以调用成功，不会产生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义：可重入锁指的是在一个线程中可以多次获取同一把锁</p>
</li>
<li><p>实现：每次加锁成功，请求计数器+1，每次解锁，请求计数器-1；第一次加锁时，对对象写入当前线程id；计数器为0时，锁未被占用</p>
</li>
</ul>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><ul>
<li>非公平锁<ul>
<li>优点：</li>
<li>缺点</li>
</ul>
</li>
<li>公平锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;<span class="comment">// 非公平锁</span></span><br><span class="line">       sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="Lock可见性的实现"><a href="#Lock可见性的实现" class="headerlink" title="Lock可见性的实现"></a>Lock可见性的实现</h4><p>内部 volatile state，加锁时，读写status的值；</p>
<h4 id="锁的最佳实践"><a href="#锁的最佳实践" class="headerlink" title="锁的最佳实践"></a>锁的最佳实践</h4><ol>
<li>只在更新对象的成员变量时加锁。</li>
<li>只在访问可变的成员变量时加锁</li>
<li>尽量不在修改别的对象的方法时加锁</li>
</ol>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>Condition 实现了管程模型里面的条件变量.  </p>
<p>两个condition条件实现阻塞队列。</p>
<h4 id="Dubbo实现异步转同步"><a href="#Dubbo实现异步转同步" class="headerlink" title="Dubbo实现异步转同步"></a>Dubbo实现异步转同步</h4><p>将TCP层的线程异步通过阻塞线程转为线程同步</p>
<h3 id="16-Semaphore-信号量"><a href="#16-Semaphore-信号量" class="headerlink" title="16 Semaphore 信号量"></a>16 Semaphore 信号量</h3><p>解决：</p>
<ol>
<li>并发的互斥和同步问题</li>
<li>多个线程同时使用一个数据库连接池、线程池</li>
</ol>
<p>实现：</p>
<ul>
<li>1个计数器</li>
<li>1个等待队列</li>
<li>三个方法。 init()，acquire()，release()</li>
</ul>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);<span class="comment">// 1表示只有一个许可证</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();<span class="comment">// 获取许可证,计数器减1，如果计数器的值小于0，线程会被阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程1获取到许可证&quot;</span>);</span><br><span class="line">                System.out.println(semaphore.toString());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();<span class="comment">// 释放许可证，计数器加1，如果计数器的值小于等于0，会唤醒一个等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();<span class="comment">// 获取许可证</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程2获取到许可证&quot;</span>);</span><br><span class="line">                System.out.println(semaphore.toString());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();<span class="comment">// 释放许可证</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量实现限流器"><a href="#信号量实现限流器" class="headerlink" title="信号量实现限流器"></a>信号量实现限流器</h4><h3 id="17-ReadWriteLock"><a href="#17-ReadWriteLock" class="headerlink" title="17 ReadWriteLock"></a>17 ReadWriteLock</h3><p>使用场景：读多写少</p>
<p>类似于数据库的读和写。</p>
<p>读写不能升级为写锁</p>
<p>数据同步方案：</p>
<ol>
<li>MySQL作为数据源，通过近实时解析binlog识别数据变化</li>
<li>数据库和缓存双写</li>
</ol>
<h4 id="ReadWriteLock实现简单缓存demo"><a href="#ReadWriteLock实现简单缓存demo" class="headerlink" title="ReadWriteLock实现简单缓存demo"></a>ReadWriteLock实现简单缓存demo</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.xiaoruiit.knowledge.point.javaconcurrent.concurrent.ReadWriteLockTest	</span><br></pre></td></tr></table></figure>

<h3 id="18-StampedLock"><a href="#18-StampedLock" class="headerlink" title="18 StampedLock"></a>18 StampedLock</h3><p>支持写锁，悲观读锁，乐观读</p>
<p>不支持重入，不支持条件变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stampedLock.readLock()// 不支持中断</span><br><span class="line">stampedLock.readLockInterruptibly();// 支持中断</span><br></pre></td></tr></table></figure>

<p>低并发场景性能比ReadWriteLock更好一点</p>
<h3 id="19CountDownLatch和CyclicBarrier-线程步调一致"><a href="#19CountDownLatch和CyclicBarrier-线程步调一致" class="headerlink" title="19CountDownLatch和CyclicBarrier 线程步调一致"></a>19CountDownLatch和CyclicBarrier 线程步调一致</h3><p>可使用Future代替，使用更简单。</p>
<p>优化案例 TODO</p>
<h3 id="20并发容器"><a href="#20并发容器" class="headerlink" title="20并发容器"></a>20并发容器</h3><p>Java容器分类：List、Map、Set、Queue</p>
<p>并发容器：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230908103111740.png" alt="image-20230908103111740"></p>
<ul>
<li><p>List </p>
<ul>
<li><p>CopyOnWriteArrayList</p>
<p>缺点：</p>
<ul>
<li>写数据时，读数据存在短暂不一致</li>
<li>CopyOnWriteArrayList 迭代器是只读的，不支持增删改。  </li>
</ul>
<p>实现：</p>
<ul>
<li>写数据时，先copy一份数据为新数组，新数组写入数据，引用从旧数组指向新数组；</li>
<li>写数据时，可以从旧数组读数据。</li>
<li>写操作互斥  </li>
</ul>
<p>场景：写操作少，能容忍读写的短暂不一致。</p>
</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li><p>ConcurrentHashMap</p>
<p>缺点：key无序，key和value不能为空</p>
</li>
<li><p>ConcurrentSkipListMap</p>
<p>优点：运行复杂度稳定，O(logn)。key有序</p>
<p>缺点：key和value不能为空</p>
<p>场景：无法接收Concurrenthashmap偶尔的不稳定时，尝试ConcurrentSkipListMap</p>
<p>实现：跳表。</p>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p>ConcueentSkipListSet</p>
<p>对ConcurrentSkipListMap的简单封装</p>
</li>
<li><p>CopyOnWriteArraySet</p>
</li>
</ul>
</li>
<li><p>Queue</p>
<p>deque：双端队列；queue单端队列；Blocking：阻塞</p>
<p>只有ArrayBlockingQueue 和LinkedBlockingQueue 是支持有界的 。</p>
<p>使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患。  </p>
</li>
</ul>
<h3 id="21原子类：无锁工具类典范"><a href="#21原子类：无锁工具类典范" class="headerlink" title="21原子类：无锁工具类典范"></a>21原子类：无锁工具类典范</h3><h4 id="count-，无锁线程安全实现"><a href="#count-，无锁线程安全实现" class="headerlink" title="count++，无锁线程安全实现"></a>count++，无锁线程安全实现</h4><p>去除加锁、解锁CPU消耗。</p>
<p>增加cpu计算消耗来提升响应时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    AtomicLong count =</span><br><span class="line">    <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">        	count.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AtomicLong类的实现"><a href="#AtomicLong类的实现" class="headerlink" title="AtomicLong类的实现"></a>AtomicLong类的实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">long</span> expected,<span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>获取值</span><br><span class="line"><span class="number">2.</span>计算</span><br><span class="line"><span class="number">3.</span>调用CPU指令，比较并交换。</span><br><span class="line"><span class="number">4.</span>比较并交换失败时，循环<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>。循环过程也称自旋</span><br></pre></td></tr></table></figure>



<p>问题：</p>
<ol>
<li><p>ABA问题</p>
<ul>
<li><p>描述</p>
<p>假设 count 原本是 A，线程 T1 在获取到值是A，执行修改时；线程 T2 更新成了 B，之后又被 T3 更新回了 A；这样线程T1 虽然看到的还是是A，但是其实已经被其他线程更新过了  。</p>
</li>
<li><p>解决：增加版本号对比</p>
</li>
</ul>
</li>
</ol>
<p>一般来说，CAS适合轻量级的并发操作，也就是并发量并不多，而且等待时间不长的情况，否则就应该使用普通锁，进入阻塞状态，避免CPU空转。</p>
<p>不适用场景 todo：</p>
<p>应用场景：</p>
<p>​    在Java 8之后，也引入了新的原子操作类LongAdder和DoubleAdder，更加适合写多读少的并发情景。</p>
<h4 id="JAVA中原子类"><a href="#JAVA中原子类" class="headerlink" title="JAVA中原子类"></a>JAVA中原子类</h4><p>​    </p>
<h3 id="22Executor线程池"><a href="#22Executor线程池" class="headerlink" title="22Executor线程池"></a>22Executor线程池</h3><p>生产者和消费者共用一个线程池，生产者把线程池里的线程用光了，导致消费不了。 出现类似死锁现象。这种情况下通过线程池不太容易看，需要去计数。  所有线程都等待，还没有死锁，就查查为什么会等待。</p>
<p>不同业务定义不同的线程池。线程数量各自计算，然后做压测，优化有性能瓶颈的业务。</p>
<p>线程池可以对线程设置有业务意义的名称，方便排查问题。</p>
<p>线程池要使用有界队列，防止OOM。</p>
<p>拒绝策略一般和降级策略结合使用。降级策略：发到MQ、redis，存到数据库、访问降级等。</p>
<p>Java线程池的使用为什么不用获取、释放的模式，而是生产者-消费者模式？</p>
<ol>
<li>目的和使用场景：数据库线程池主要用于管理数据库连接和执行数据库操作的线程，以提高数据库的并发性能和资源利用率。它通常用于处理数据库的读写操作，如查询、更新、插入等。而Java线程池是用于管理Java应用程序中的线程，用于执行各种任务，如计算、IO操作、网络请求等。</li>
<li>线程资源：数据库线程池通常会预先创建一组数据库连接，这些连接可以被多个线程共享。每个线程在需要执行数据库操作时，从线程池中获取一个可用的数据库连接，并在操作完成后释放连接。Java线程池则是根据需要动态创建和销毁线程，根据任务的数量和系统负载来调整线程的数量。</li>
<li>线程管理：数据库线程池通常由数据库管理系统（DBMS）负责管理和维护，它会根据配置参数和系统负载来控制线程的数量和行为。DBMS会监控线程的状态、执行时间等指标，并根据需要进行线程的回收和重新创建。Java线程池则是由Java应用程序自己管理和控制，可以通过ThreadPoolExecutor等类来创建和配置线程池，并根据需要进行线程的创建和销毁。</li>
<li>任务调度：数据库线程池通常不涉及任务调度和优先级管理，它主要负责执行数据库操作。而Java线程池可以通过调度器（如ScheduledThreadPoolExecutor）来实现任务的定时执行和周期性执行，还可以通过设置任务的优先级来管理任务的执行顺序。</li>
</ol>
<p>TODO Java并发编程实战第八章：线程池的使用</p>
<h3 id="23Future"><a href="#23Future" class="headerlink" title="23Future"></a>23Future</h3><h3 id="24CompletableFuture异步编程"><a href="#24CompletableFuture异步编程" class="headerlink" title="24CompletableFuture异步编程"></a>24CompletableFuture异步编程</h3><p>Java 在 1.8 版本提供了CompletableFuture 来支持异步编程。</p>
<p>Java 9提供了更完善的Flow API. <a href="https://juejin.cn/post/6994712328197373989">https://juejin.cn/post/6994712328197373989</a></p>
<p>1.8JDK completableFuture 优先于使用future，优先于countdownLatch。</p>
<ul>
<li><p>优点</p>
<ol>
<li><p>无需手工维护线程</p>
</li>
<li><p>语义更清晰</p>
</li>
<li><p>代码简练，专注于业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      CompletableFuture&lt;Void&gt; f1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">     </span><br><span class="line">          sleep(<span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">          System.out.println(<span class="string">&quot;烧水&quot;</span>);</span><br><span class="line">     </span><br><span class="line">          sleep(<span class="number">15</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">     </span><br><span class="line">      CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &#123;<span class="comment">// 支持返回值</span></span><br><span class="line">          System.out.println(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">     </span><br><span class="line">          sleep(<span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">          System.out.println(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">     </span><br><span class="line">          sleep(<span class="number">2</span>);</span><br><span class="line">     </span><br><span class="line">          System.out.println(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">     </span><br><span class="line">          sleep(<span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;龙井&quot;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">     </span><br><span class="line">      CompletableFuture&lt;String&gt; f3 = f1.thenCombine(f2, (__, tf) -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;泡茶...&quot;</span>);</span><br><span class="line">     </span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;上茶：&quot;</span> + tf;</span><br><span class="line">      &#125;);</span><br><span class="line">     </span><br><span class="line">      System.out.println(f3.join());</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> millis)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(millis);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>注意</p>
<p>默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池，这个线程池默认创建的线程数是 CPU 的核数。</p>
<p>如果所有 CompletableFuture 共享一个线程池，那么一旦有任务执行一些很慢的 I/O 操作，就会导致线程池中所有线程都阻塞在 I/O 操作上，从而造成线程饥饿，进而影响整个系统的性能。所以，需要根据不同的业务类型创建不同的线程池，以避免互相干扰</p>
</li>
</ul>
<h4 id="四种条件-amp-异常捕获"><a href="#四种条件-amp-异常捕获" class="headerlink" title="四种条件&amp;异常捕获"></a>四种条件&amp;异常捕获</h4><p>四种现实条件，同OA流程图绘制中的四种条件。</p>
<ol>
<li><p>并行</p>
</li>
<li><p>串行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f1.thenApply(); <span class="comment">// 支持参数和返回值</span></span><br><span class="line">f1.thenAccept(); <span class="comment">// 支持参数，不支持返回值</span></span><br><span class="line">f1.thenRun();<span class="comment">// 不支持参数，也不支持返回值</span></span><br><span class="line">f1.thenCompose(); <span class="comment">// 除了新建一个子流程，最终结果和thenApply相同</span></span><br></pre></td></tr></table></figure></li>
<li><p>且</p>
<p>thenCombine、thenAcceptBoth 和 runAfterBoth</p>
</li>
<li><p>或</p>
<p>applyToEither、acceptEither 和runAfterEither</p>
</li>
</ol>
<ul>
<li><p>异常处理</p>
<p>exceptionally() 的使用非常类似于 try{}catch{}中的 catch{}，但是由于支持链式编程方式，所以相对更简单。</p>
<p>whenComplete() 和 handle() 系列方法就类似于 try{}finally{}中的 finally{}</p>
</li>
</ul>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数在处理异常以及复杂的异步任务关系时往往力不从心。</p>
<p>RxJava 解决了回调问题。Java 9 版本则提供了更加完备的 Flow API</p>
<h3 id="25CompleteService-任务解耦"><a href="#25CompleteService-任务解耦" class="headerlink" title="25CompleteService 任务解耦"></a>25CompleteService 任务解耦</h3><h3 id="26Fork-Join-任务分治"><a href="#26Fork-Join-任务分治" class="headerlink" title="26Fork/Join 任务分治"></a>26Fork/Join 任务分治</h3>]]></content>
      <categories>
        <category>Java语言</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发设计模式</title>
    <url>/2023/12/21/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/05%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>并发设计模式</p>
<span id="more"></span>

<h1 id="05-并发设计模式"><a href="#05-并发设计模式" class="headerlink" title="05 并发设计模式"></a>05 并发设计模式</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="28-利用不可变性解决并发问题-Immutability-模式"><a href="#28-利用不可变性解决并发问题-Immutability-模式" class="headerlink" title="28 利用不可变性解决并发问题-Immutability 模式"></a>28 利用不可变性解决并发问题-Immutability 模式</h3><p>读和写同时存在，会产生并发问题。只有读不会有并发问题。</p>
<p>不变性：一旦创建，或者第一次赋值后，就不允许修改。</p>
<p>JDK中的不可变类：String、Long、Integer、Double</p>
<p>不可变类的实现：</p>
<ol>
<li>属性都用final修饰，属性不能是一个对象。</li>
<li>方法只有只读方法。</li>
<li>类用final修饰，防止子类继承父类重写父类方法。</li>
</ol>
<p>String中字符串操作的字符替换操作如何实现的不可变？</p>
<ol>
<li>仅仅是原字符没有改变</li>
<li>new 出来一个新字符串，通过返回值返回替换后的字符串。</li>
</ol>
<h4 id="亨元模式"><a href="#亨元模式" class="headerlink" title="亨元模式"></a>亨元模式</h4><ul>
<li><p>解决：去除经常使用的不可变重复对象，降低内存占用</p>
</li>
<li><p>实现原理：创建对象时查询对象池中是否有，有的话，直接获取对象池中的对象；没有的话，创建出对象后，放入对象池中</p>
</li>
<li><p>例子：Integer类型的创建，JVM启动时，将-128至127创建出来，这个范围的数，使用时直接返回这个数的地址。</p>
</li>
<li><p>缺点：不适合做锁，对象池中的对象是共有的。</p>
</li>
</ul>
<h3 id="29-Copy-On-Write"><a href="#29-Copy-On-Write" class="headerlink" title="29 Copy On Write"></a>29 Copy On Write</h3><ul>
<li><p>解决：提升读多写少，弱一致性时，读操作的速度。</p>
</li>
<li><p>实现原理：修改时，先对原数据复制一份，修改复制的数据。</p>
</li>
<li><p>缺点：更消耗内存。在GC算法成熟，硬件发达的现在不是问题了。数组较大时不适用</p>
</li>
<li><p>例子</p>
<p>Docker容器镜像设计，git设计，函数式编程、String.replace方法</p>
<ol>
<li><p>操作系统进程复制</p>
<p>子进程复制父进程时，先共享同一个地址空间；父进程或子进程需要写入的时候复制修改部分的地址空间。</p>
<p>总结：延时复制，按需复制。</p>
</li>
<li><p>RPC维护路由表</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230925090436399.png" alt="image-20230925090436399"></p>
<ul>
<li><p>路由表的使用</p>
<ul>
<li><p>读</p>
<p>每次 RPC 调用都需要通过负载均衡器来计算目标服务的 IP 和端口号，而负载均衡器需要通过路由表获取接口的所有路由信息，也就是说，<br>每次 RPC 调用都需要访问路由表</p>
</li>
<li><p>写</p>
<p>每次服务的上下线，需要新增或删除一条路由信息</p>
</li>
<li><p>一致性</p>
<p>一个服务提供方从上线到反馈到客户端的路由表里，即便有 5 秒钟，也能接受。</p>
</li>
</ul>
</li>
<li><p>路由表实现 todo</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="30线程本地存储"><a href="#30线程本地存储" class="headerlink" title="30线程本地存储"></a>30线程本地存储</h3><p>ThreadLocal结构</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231009172650851.png" alt="image-20231009172650851"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部持有 ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyThread <span class="title">currentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.threadLocals = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap();</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先获取线程持有的ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = MyThread.currentThread().threadLocals;</span><br><span class="line">        <span class="comment">// 在 ThreadLocalMap 中查找变量</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        MyThread t = MyThread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//            map.set(this, value);// 不同线程哈希表中的key（ThreadLocal引用）相同，但不同线程的哈希表都是各自自己的，是不同的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(MyThread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.<span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(MyThread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部是数组而不是 Map</span></span><br><span class="line">        Entry[] table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 ThreadLocal 查找 Entry</span></span><br><span class="line">        <span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 省略查找逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Entry(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Entry 定义</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(ThreadLocal referent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(referent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ThreadLocalMap()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"><span class="comment">//            table = new ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY];</span></span><br><span class="line"><span class="comment">//            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span></span><br><span class="line"><span class="comment">//            table[i] = new ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue);</span></span><br><span class="line"><span class="comment">//            size = 1;</span></span><br><span class="line"><span class="comment">//            setThreshold(INITIAL_CAPACITY);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31等待唤醒机制"><a href="#31等待唤醒机制" class="headerlink" title="31等待唤醒机制"></a>31等待唤醒机制</h3><h3 id="32-Balking-多线程单例模式"><a href="#32-Balking-多线程单例模式" class="headerlink" title="32 Balking 多线程单例模式"></a>32 Balking 多线程单例模式</h3><ul>
<li><p>解决：多线程变量的改变和读取</p>
</li>
<li><p>实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchroized</span><br><span class="line">无需原子性时，可使用volatile</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="33-Thread-Per-Message模式"><a href="#33-Thread-Per-Message模式" class="headerlink" title="33 Thread-Per-Message模式"></a>33 Thread-Per-Message模式</h3><ul>
<li><p>解决：分工。</p>
</li>
<li><p>例子：</p>
<ul>
<li>生活：教育小朋友委托给老师；买房子委托房产中介</li>
<li>部分基于Thread实现分布式任务调度框架</li>
</ul>
</li>
<li><p>实现：</p>
<ul>
<li><p>原理：一个请求一个创建一个线程。</p>
</li>
<li><p>Thread实现</p>
<ul>
<li>缺点：与操作系统线程一致，创建销毁线程耗时，占用内存大，可能OOM，并发量低</li>
</ul>
</li>
<li><p>Fiber协程实现</p>
<p>创建成本相当于创建一个对象</p>
</li>
</ul>
<p>Java协程库Fiber</p>
<p>GO从语言上支持协程</p>
</li>
<li><p>问题：目前java语言中的协程是哪个Java版本开始提供，如何使用</p>
</li>
</ul>
<h3 id="34Worker-Thread模式"><a href="#34Worker-Thread模式" class="headerlink" title="34Worker-Thread模式"></a>34Worker-Thread模式</h3><p>车间工人工作的模式</p>
<ul>
<li><p>解决：</p>
</li>
<li><p>例子：</p>
<ul>
<li>生活中：车间的工人有活了就干活，没活了休息聊天</li>
</ul>
</li>
<li><p>实现原理：</p>
</li>
<li><p>注意</p>
<ol>
<li><p>线程死锁</p>
<p>描述：A、B两个任务使用同一个线程池，B任务依赖A任务的结果。B任务把线程池占满后，所有B任务会一直等待。</p>
<p>解决：A、B使用不同线程池</p>
</li>
<li><p>线程池超界、拒绝策略</p>
</li>
</ol>
</li>
</ul>
<h3 id="35线程两阶段终止"><a href="#35线程两阶段终止" class="headerlink" title="35线程两阶段终止"></a>35线程两阶段终止</h3><h4 id="子线程终止"><a href="#子线程终止" class="headerlink" title="子线程终止"></a>子线程终止</h4><ul>
<li><p>stop()</p>
<p>直接终止线程，如同直接终止运行的服务，电脑强制关机</p>
</li>
<li><p>interrupt()</p>
<ul>
<li><p>用途：终止内部一直循环执行某个逻辑的线程</p>
</li>
<li><p>实现：主线程内改变子线程终止属性为ture，由开发者在子线程内判断此属性值来决定关闭线程时机。</p>
</li>
<li><p>注意：捕获 InterruptedExpection异常时，需重置 interrupt标记位</p>
</li>
<li><p>场景：用子线程定时采集系统数据，终止采集的实现可使用interrupt</p>
</li>
<li><p>使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Thread rptThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started) &#123;<span class="comment">// 保证线程只启动一次</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        rptThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="comment">// 采集系统数据，存储</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Proxy采集系统数据，存储&quot;</span>);</span><br><span class="line">                <span class="comment">// 每隔两秒采集</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 重新设置线程中断状态</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到此处说明线程马上终止</span></span><br><span class="line">            started = <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        rptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rptThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>interrupt + 自实现终止标记</p>
<ul>
<li><p>用途：调用第三方接口时，防止第三方接口捕获了异常，没有重置线程终止标记位</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy2</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Thread rptThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (started) &#123;<span class="comment">// 保证线程只启动一次</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">        rptThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                <span class="comment">// 采集系统数据，存储</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Proxy2采集系统数据，存储&quot;</span>);</span><br><span class="line">                <span class="comment">// 每隔两秒采集</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Proxy2线程被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到此处说明线程马上终止</span></span><br><span class="line">            started = <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        rptThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        rptThread.interrupt();<span class="comment">// 如果线程休眠，可唤醒线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="线程池终止"><a href="#线程池终止" class="headerlink" title="线程池终止"></a>线程池终止</h4><ul>
<li><p>shutdown()</p>
<p>不再接受任务，等待任务执行完后关闭线程池</p>
</li>
<li><p>shutdownNow()</p>
<p>不再接受任务，并且中断线程池（interrupt()）中正在执行的任务，返回被剥夺执行任务</p>
</li>
</ul>
<h3 id="36生产者-消费者模式"><a href="#36生产者-消费者模式" class="headerlink" title="36生产者-消费者模式"></a>36生产者-消费者模式</h3><p>生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。  </p>
<ul>
<li><p>优点</p>
<p>解耦。灵活性高，通过固定交互数据结构，生产者和消费者可独立修改而不影响对方</p>
</li>
</ul>
<p>​    支持异步</p>
<p>​    可以调整生产者、消费者个数来平衡生产者、消费者速度，进而提高资源使用率</p>
<p>​    消费者可以批量消费生产者生产出的数据，进而提升性能。如：redis每秒刷盘策略</p>
<ul>
<li><p>缺点</p>
<p>增加复杂度，可能造成队列堆积，或者消费者闲置浪费资源</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>CopyOnWriteArrayList为什么写时复制全部，linux的fork()函数是复制部分？</p>
<p>CopyOnWriteArrayList和fork()函数的设计目标和使用场景不同。<br>CopyOnWriteArrayList是为了提供线程安全的读写操作，并且在读多写少的场景下具有较好的性能。它的设计目标是在读取操作上提供高性能和并发性，并且保证读取操作的一致性。为了实现这个目标，CopyOnWriteArrayList在写操作时会创建一个新的副本，从而保持读取操作的一致性。<br>而fork()函数是用于创建新进程的，它的设计目标是实现进程的复制。fork()函数使用写时复制技术来实现进程的快速复制，避免了不必要的内存复制开销。这种设计适用于进程的复制场景，但不适用于通用的集合操作。<br>此外，CopyOnWriteArrayList是Java集合框架中的一部分，它是为了提供线程安全的集合操作而设计的。而fork()函数是操作系统提供的系统调用，用于创建新进程。它们的设计和实现是基于不同的需求和上下文。</p>
</li>
<li><p>log4j的刷盘时机？</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《图解 Java 多线程设计模式》  </p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发设计案例</title>
    <url>/2023/12/28/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/06%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>并发设计案例</p>
<span id="more"></span>

<h1 id="06并发设计案例"><a href="#06并发设计案例" class="headerlink" title="06并发设计案例"></a>06并发设计案例</h1><h3 id="40Disruptor"><a href="#40Disruptor" class="headerlink" title="40Disruptor"></a>40Disruptor</h3><ul>
<li><p>优化点</p>
<ol>
<li><p>内存分配优化</p>
<ol>
<li><p>采用ringbuffer数据结构</p>
<p>数组序号长度为二的n次方，真实下标计算时使用二级制与，比模取余更快</p>
</li>
<li><p>数组中的对像在数组初始化时也全部初始化。提升CPU缓存命中率，防止垃圾回收。消费后不删除，生产时覆盖</p>
</li>
<li><p>避免伪共享</p>
<p>伪共享：由于共享缓存行导致缓存无效，只能从内存读取数据的场景。</p>
<p>共享：不同核可读取CPU缓存，而不用读取内存</p>
<p>takeIndex  通过填充字节来独占缓存行</p>
</li>
</ol>
</li>
<li><p>无锁生产、消费</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ul>
<li>使用复杂</li>
<li>占用内存高</li>
</ul>
</li>
</ul>
<h3 id="41-高性能数据库连接池HiKariCP"><a href="#41-高性能数据库连接池HiKariCP" class="headerlink" title="41 高性能数据库连接池HiKariCP"></a>41 高性能数据库连接池HiKariCP</h3><p>数据库连接池：c3p0、DBCP、Tomcat JDBC Connection Pool、Druid、HiKariCP  </p>
<p>池化资源作用：避免重量级资源的频繁创建和销毁  </p>
<p>HiKariCP性能高的原因：</p>
<ul>
<li><p>微观：从字节码的角度优化Java代码</p>
</li>
<li><p>宏观：两个数据结构</p>
<ul>
<li><p>FastList</p>
<p>将一个Connection创建的多个Statement 保存在数组 Fast中</p>
<ol>
<li>删除时从后往前遍历。添加Statement是S1,S2，关闭时一般是S2,S1</li>
<li>get(int index)   没有做越界检查。todo</li>
</ol>
</li>
<li><p>ConcurrentBag</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于存储所有的数据库连接</span></span><br><span class="line">CopyOnWriteArrayList&lt;T&gt; sharedList;</span><br><span class="line"><span class="comment">// 线程本地存储中的数据库连接</span></span><br><span class="line">ThreadLocal&lt;List&lt;Object&gt;&gt; threadList;</span><br><span class="line"><span class="comment">// 等待数据库连接的线程数</span></span><br><span class="line">AtomicInteger waiters;</span><br><span class="line"><span class="comment">// 分配数据库连接的工具,线程之间传递数据</span></span><br><span class="line">SynchronousQueue&lt;T&gt; handoffQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加连接</span></span><br><span class="line"><span class="comment">// 将这个连接加入到共享队列 sharedList 中</span></span><br><span class="line"><span class="comment">// 如果此时有线程在等待数据库连接，那么就通过 handoffQueue将这个连接分配给等待的线程</span></span><br><span class="line">add()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取连接</span></span><br><span class="line"><span class="comment">// 首先查看线程本地存储是否有空闲连接</span></span><br><span class="line">	<span class="comment">//1.如果有，则返回一个空闲的连接；</span></span><br><span class="line">	<span class="comment">//2. 如果线程本地存储中无空闲连接，则从共享队列中获取。</span></span><br><span class="line">	<span class="comment">//3. 如果共享队列中也没有空闲的连接，则请求线程需要等待</span></span><br><span class="line">borrow()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放连接</span></span><br><span class="line"><span class="comment">// 1.首先将数据库连接状态更改为 STATE_NOT_IN_USE</span></span><br><span class="line"><span class="comment">// 2.之后查看是否存在等待线程</span></span><br><span class="line">	<span class="comment">// 如果有，则分配给等待线程；</span></span><br><span class="line">	<span class="comment">// 如果没有，则将该数据库连接保存到线程本地存储里</span></span><br><span class="line">require()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>预分配到本地线程，减少了竞争<ol>
<li>使用ThreadLocal存储分配到本地线程的连接</li>
<li>使用CAS防止共享队列sharedList中的连接重复分配</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>其他并发模型</title>
    <url>/2023/12/30/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/07%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>其他并发模型</p>
<span id="more"></span>

<h1 id="07其他并发模型"><a href="#07其他并发模型" class="headerlink" title="07其他并发模型"></a>07其他并发模型</h1><h3 id="42-Actor模型"><a href="#42-Actor模型" class="headerlink" title="42 Actor模型"></a>42 Actor模型</h3><ul>
<li>功能<ol>
<li>通信能力。接收与发送消息</li>
<li>存储能力。存储消息</li>
<li>处理能力。单线程消费消息，没有并发问题</li>
</ol>
</li>
<li>缺点<ol>
<li>不能保证消息发送成功</li>
<li>不能保证消息顺序</li>
<li>不能保证消息一定被消费</li>
</ol>
</li>
<li>Java实现框架 Akka</li>
<li>与Java对比<ul>
<li>相比于Java对于对象的属性和行为定义，Actor定义的模型是消息通信，内部处理</li>
<li>Java更关注物体定义，物体间交流是弱化的；Actor关注交流，任何交流行为都定义为消息。自身的行为定义为发消息，别人的行为定义为收消息。</li>
<li>Java定义人的属性：眼睛、嘴、手、腿；行为：走路、说话。Actor定义人可以接受消息（声音类型、图像类型），可以发送消息（图像、声音）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE</title>
    <url>/2023/06/10/212Java%E8%AF%AD%E8%A8%80/JavaSE/2.1JavaSE/</url>
    <content><![CDATA[<p>JavaSE</p>
<span id="more"></span>

<h3 id="2-1JavaSE"><a href="#2-1JavaSE" class="headerlink" title="2.1JavaSE"></a>2.1JavaSE</h3><ol>
<li><a href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">面对对象五大基本原则</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li>对象引用</li>
<li>关键字</li>
<li>类与接口</li>
<li>异常</li>
<li>集合类</li>
<li>反射</li>
<li>多线程</li>
<li>版本新特性</li>
<li><a href="#JavaSE%E9%97%AE%E9%A2%98">JavaSE问题</a></li>
</ol>
<h4 id="面对对象五大基本原则"><a href="#面对对象五大基本原则" class="headerlink" title="面对对象五大基本原则"></a>面对对象五大基本原则</h4><ol>
<li><p>单一职责原则</p>
<p>一个类只负责一类事，不能包罗万象。</p>
<p>实际操作中职责的大小根据自己的经验来。可尝试定义死板的规则，如：一个方法不能超过10行！</p>
</li>
<li><p>开放封闭原则</p>
<p>对扩展开放，对修改封闭。即增加功能时，增加代码，而不是修改代码。目的：不影响原有代码</p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>依赖倒置原则</p>
</li>
<li><p>接口分离原则</p>
</li>
</ol>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>基本数据类型，数据类型转型，基础数据类型与 wrapper 数据类型的自动装箱与拆箱，String类型（String，StringBuffer，StringBuilder）</p>
<h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>基础类型堆上占用内存空间：<br>blooean<br>byte 1字节  -2的8次方~2的8次方-1<br>char 2字节<br>short 2字节<br>int 4字节<br>long 8字节<br>float<br>double</p>
<p>boolean、byte、char、short 这四种类型，在栈上占用的空间和 int一样<br>32位机器，都是4个字节<br>64位机器，都是8个字节</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>四种引用，强引用内存泄漏</p>
<h5 id="四种引用介绍"><a href="#四种引用介绍" class="headerlink" title="四种引用介绍"></a>四种引用介绍</h5><p>四种：强引用、软引用、弱引用、虚引用。</p>
<p>GC 时对四种引用处理策略不同。强引用不会被 GC 回收；软引用内存空间不足时会被 GC 回收；弱引用则在每次 GC 时被回收；虚引用必须和引用队列联合使用，主要用于跟踪一个对象被垃圾回收的过程。</p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>场景：一般都使用强引用</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>场景：缓存，内存不足时<br>HashMap直接做缓存容易引发内存泄漏</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>场景：对象缓存，如：ThreadLocal，WeakHashMap</p>
<p>WeakHashMap会在系统内存范围内，保存所有表项目，一旦内存不够，在每次GC时，没有被引用的表项很快会被清除掉，从而避免系统内存溢出。</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>用途：跟踪对象被垃圾回收的情况。<br>场景：对象被回收前执行某些清理操作。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>static,final,finally,finilize(),volatile,this,supper</p>
<h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>可以修饰类、变量、方法。<br>作用：形成静态代码块优化程序性能<br>特点：在类加载的时候执行一次<br>场景：字符串常量，枚举中的常量，factory对象赋值静态方法，单例对象，策略模式策略类查找定义</p>
<h5 id="final-final关键字"><a href="#final-final关键字" class="headerlink" title="final ![[final关键字]]"></a>final ![[final关键字]]</h5><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p>finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码</p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><ul>
<li>阻止指令重排序，这样就可以保证多线程变量读写的有序性。</li>
<li>强制变量的赋值会同步刷新回主内存，强制变量的读取会从主内存重新加载，保证不同的线程总是能够看到该变量的最新值。</li>
</ul>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>this表示当前对象引用。<br>只能在实例方法中使用，无法在静态方法中使用。</p>
<h5 id="supper"><a href="#supper" class="headerlink" title="supper"></a>supper</h5><p>表示父类（超类）对象的引用。</p>
<ol>
<li><strong>调用父类的方法：</strong> 使用 <code>super</code> 关键字可以在子类中调用父类的方法。通常用于在子类中覆盖（重写）父类的方法，但又想在子类中调用父类的方法。</li>
<li><strong>访问父类的实例变量</strong></li>
</ol>
<h5 id="transient"><a href="#transient" class="headerlink" title="transient"></a><code>transient</code></h5><p>用于标记类的成员变量，表示这些变量不应该被序列化。<br>场景：</p>
<ol>
<li>安全性，将密码、密钥等标记为 <code>transient</code>，可以防止它们被序列化。</li>
<li>减少序列化的时间，有些字段可能包含大量的数据，但在某些情况下并不需要被序列化。<h4 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h4></li>
</ol>
<h5 id="接口与抽象方法"><a href="#接口与抽象方法" class="headerlink" title="接口与抽象方法"></a>接口与抽象方法</h5><table>
<thead>
<tr>
<th></th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1.8 增加了默认方法。可以在向现有接口添加方法，而不影响现有实现。</td>
<td></td>
</tr>
<tr>
<td>类继承</td>
<td>多继承</td>
<td>单继承</td>
</tr>
<tr>
<td>构造器</td>
<td>可以有构造器</td>
<td>不能有构造器</td>
</tr>
<tr>
<td>场景</td>
<td>更适合定义行为规范。</td>
<td>更适合共享部分通用实现。</td>
</tr>
</tbody></table>
<h4 id="异常-深入拆解Java虚拟机-Java虚拟机基本原理-6-异常"><a href="#异常-深入拆解Java虚拟机-Java虚拟机基本原理-6-异常" class="headerlink" title="异常 [[深入拆解Java虚拟机-Java虚拟机基本原理#6.异常]]"></a>异常 [[深入拆解Java虚拟机-Java虚拟机基本原理#6.异常]]</h4><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>hashmap，ArrayList，LinkedList</p>
<h5 id="hashmap扩容原理"><a href="#hashmap扩容原理" class="headerlink" title="hashmap扩容原理"></a>hashmap扩容原理</h5><ul>
<li><p>1.7</p>
<ol>
<li>生成新数组，长度为原数组两倍</li>
<li>遍历原hashmap的每个元素，重新计算hash值，将其添加到新数组中</li>
<li>转移完成后，将新数组赋值给HashMap的table属性</li>
</ol>
</li>
<li><p>1.8</p>
<ol>
<li>元素个数超过了负载因子<code>*</code>当前容量时，触发扩容</li>
<li>生成新数组，长度为原数组的两倍</li>
<li>遍历老数组的所有元素，重新计算哈希码，将其放入新数组中。</li>
<li>如果元素在新桶中的索引位置上已经有其他元素存在了，那么新的元素会以链表或红黑树的形式插入到该位置。如果桶中的元素数量小于等于 8（TREEIFY_THRESHOLD），则会以链表的形式存储，如果大于 8，则会将链表转换为红黑树并插入。</li>
<li>转移完成后，将新数组赋值给HashMap的table属性。</li>
</ol>
</li>
</ul>
<h4 id="反射-深入拆解Java虚拟机-Java虚拟机基本原理-7-反射"><a href="#反射-深入拆解Java虚拟机-Java虚拟机基本原理-7-反射" class="headerlink" title="反射 [[深入拆解Java虚拟机-Java虚拟机基本原理#7.反射]]"></a>反射 [[深入拆解Java虚拟机-Java虚拟机基本原理#7.反射]]</h4><p>如何使用，使用场景</p>
<h4 id="多线程-TODO"><a href="#多线程-TODO" class="headerlink" title="多线程 TODO"></a>多线程 TODO</h4><p>作用，场景，线程状态转换，同步机制（CAS，synchronized和lock），线程池，java并发工具包 JUC，其他概念，线程分析工具，实战</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>最大化利用 CPU 和 I/O。</p>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><ol>
<li>web容器处理请求</li>
<li>异步，记录日志，操作记录。</li>
<li>同步数据，同步下游系统、企业微信数据。</li>
<li>定时向大量（100w以上）的用户发送邮件</li>
</ol>
<h5 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h5><p>6种状态<br>sleep，wait<br>相同：都会暂停线程<br>不同：<br>    1.sleep是thread的静态方法，wait是object类的方法<br>    2.线程sleep期间，占有资源的锁，wait释放了资源锁<br>    3.sleep在指定时间后继续执行，wait需要调用notify方法唤醒。</p>
<p>线程的状态：新建，就绪，运行，阻塞，死亡。</p>
<p>线程的创建：1.thread类 2.runnable接口3.callable接口</p>
<p>bug管理：mantis，ones<br><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/A1lMmGdBrfq5Op7.png" alt="image-20210615090422551"></p>
<h5 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h5><p>锁概念，CAS，synchronized，Lock，volatile关键字</p>
<h6 id="锁概念"><a href="#锁概念" class="headerlink" title="锁概念"></a>锁概念</h6><p>重量级锁、轻量级锁、自旋锁、偏向锁、重入锁、读写锁</p>
<h6 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h6><p>乐观锁的一种实现方式。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>并发高时CPU消耗大。并发高时，可能重复执行 读取数据→操作数据→值是否改变的过程，消耗CPU。</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Y6QB1utqgMzTPaH.png" alt="CAS流程"></p>
<p><strong>问题：</strong>CAS中的ABA</p>
<p><strong>描述：</strong>线程 T1 读取值 A 之后；发生两次写入，先由线程 T2 写回了 B，又由 T3 写回了 A；此时 T1 在写回比较时，值还是 A。</p>
<p><strong>解决：</strong></p>
<ol>
<li>状态位，版本号</li>
<li>JUC中的相关类。</li>
</ol>
<h6 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h6><p>记录了对象信息。</p>
<p>Java1.6为<code>Synchronized</code>做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度。</p>
<p><strong>锁升级过程</strong>：</p>
<p>第一个线程获得的是偏向锁。</p>
<p>第二个线程获得的是轻量级锁，底层是在用自旋锁。</p>
<p>自旋一定次数后，轻量级锁升级为重量级锁，线程进入blocked状态</p>
<p><strong>性能低的原因</strong>：</p>
<ol>
<li>重量级锁的线程会进入<code>BLOCKED</code>状态，而后在争夺到锁资源后恢复为<code>RUNNABLE</code>状态，其中涉及到操作系统用户模式和内核模式的转换，代价比较高。</li>
</ol>
<h6 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h6><p>AQS，ReentrantLock</p>
<p>synchronized与lock的区别？TODO<br>相同：都用来实现线程同步<br>不同：<br>    1.sy是Java中的关键字，lock是接口<br>    2.sy不会导致死锁，线程异常会释放锁。lock需要调用unlock主动释放。<br>    3.大量锁竞争时lock性能高很多。少量锁竞争性能差不多。</p>
<p>sy和reentrantlock（可重入锁）的区别？<br>相同：都是可重入锁，支持一个线程对资源重复加锁。<br>不同：<br>    1.sy依赖jvm，re依赖Java的api<br>    2.re有高级功能。1.等待可中断。2.支持公平锁。3.选择性通知。</p>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>作用，特点和使用场景，线程池参数，线程池执行流程，工作原理</p>
<h6 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h6><p>复用线程，创建线程、销毁线程都需要大量资源，用线程池复用线程节约资源，也提高了处理速度。</p>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><p>常见的线程池和使用场景？<br>    1.newCachedThreadPool：新建可缓存线程池，线程池中的线程数量超过处理需要时，可灵活回收。<br>    2.创建一个定长线程池，超出时在队列中等待。<br>线程池的工作队列？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor() // 单线程的线程池。保证顺序执行并且只有一个线程执行。定时拉取考勤。旧系统人员、部门、岗位数据</span><br><span class="line"></span><br><span class="line">Executors.newFixedThreadPool()// 固定大小的线程池。</span><br><span class="line">/* 1.cpu密集型。线程数=CPU核数+1（计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作）。</span><br><span class="line">	2.I/O 密集型。线程数=CPU核心数 * (1 + (I/O耗时 / CPU耗时))</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h6 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line">     * parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line">     *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line">     * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line">     *        pool</span><br><span class="line">     * @param keepAliveTime when the number of threads is greater than</span><br><span class="line">     *        the core, this is the maximum time that excess idle threads</span><br><span class="line">     *        will wait for new tasks before terminating.</span><br><span class="line">     * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line">     * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line">     *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line">     *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line">     * @param threadFactory the factory to use when the executor</span><br><span class="line">     *        creates a new thread</span><br><span class="line">     * @param handler the handler to use when execution is blocked</span><br><span class="line">     *        because the thread bounds and queue capacities are reached</span><br><span class="line">     */</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h6><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/trKIAo2JmuThCYQ.png" alt="image-20210828095532683"></p>
<h6 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h6><p>内部通过队列+线程实现，需要线程处理新的任务时：</p>
<ol>
<li>线程池中的线程数量小于corePoolSize时，创建新的线程处理。</li>
<li>线程池的线程数量等于corePoolsize时，缓冲度列workQueue未满，任务加入缓冲队列。</li>
<li>线程池的线程数量大于等于corePoolsize时，缓冲度列workQueue已满，线程池的数量小于maximumPoolSize，新建线程处理。</li>
<li>线程池的线程数量等于corePoolsize时，缓冲度列workQueue已满，线程池的数量等于maximumPoolSize，通过handler指定策略处理。</li>
<li>当线程池中的线程数量⼤于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终⽌。</li>
</ol>
<h6 id="线程池个数"><a href="#线程池个数" class="headerlink" title="线程池个数"></a>线程池个数</h6><ol>
<li><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置数据库连接池线程数呢？</p>
<p>答：线程数=8*（1+100/5） = 168个。</p>
</li>
<li><p>上题的基础上如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</p>
<p>答：1个线程每秒处理的任务数是 1000/105。  1000QPS / （1000/105） = 105 个线程。</p>
</li>
</ol>
<h5 id="并发工具包：-JUC"><a href="#并发工具包：-JUC" class="headerlink" title="并发工具包： JUC"></a>并发工具包： JUC</h5><p>（concurrentHashMap，CopyOnWriteArrayList，Locks（Reentrantlock），AtomicXXX，Executor，Caller&amp;Future，Queue，LongAdder）</p>
<h6 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h6><p>扩容原理</p>
<ul>
<li>1.7 <ol>
<li>基于Segment分段实现</li>
<li>每个Segment相当于一个小的Hashmap</li>
<li>每个Segment内容会进行扩容，与HashMap扩容类似</li>
</ol>
</li>
</ul>
<p>segament</p>
<ul>
<li>1.8 <ol>
<li>某个线程put时，发现别的线程在扩容，加入该线程一块扩容。</li>
<li>某个线程put后，容量超过阈值，进行扩容。</li>
<li>扩容时先复制数组，将数据分段给子线程分别扩容。</li>
</ol>
</li>
</ul>
<h6 id="Reentrantlock"><a href="#Reentrantlock" class="headerlink" title="Reentrantlock"></a>Reentrantlock</h6><p>特点：</p>
<ul>
<li><p>使用 int 标记加锁</p>
</li>
<li><p>可重入锁，有公平锁和非公平锁两种实现，公平和非公平是对获取锁，阻塞唤醒是一样的。</p>
</li>
<li><p>可以多次加锁，需要多次释放锁。</p>
</li>
<li><p>需要手动加解锁。</p>
</li>
</ul>
<h6 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h6><p>底层原理：</p>
<ol>
<li>内部使用数组实现</li>
<li>添加元素的实现，加Reentrantlock锁，复制数组为两倍容量，添加元素，旧数组指向新数组。</li>
<li>添加元素时，写操作加锁，在新数组上进行，读操作在原数组进行</li>
</ol>
<p>总结：</p>
<ul>
<li><p>CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应 ⽤场景。</p>
</li>
<li><p>CopyOnWriteArrayList⽐较占内存，同时可能读到的数据不是实时最新的数据，所 以不适合实时性要求很⾼的场景 。</p>
</li>
</ul>
<h5 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h5><p>死锁的4个基本条件，竞争条件与临界区，线程间通信方式，JAVA提供的多线程机制，线程同步与异步、阻塞与非阻塞</p>
<h6 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h6><p>wait，notify，notifyAll</p>
<h6 id="JAVA提供的多线程机制"><a href="#JAVA提供的多线程机制" class="headerlink" title="JAVA提供的多线程机制"></a>JAVA提供的多线程机制</h6><p>ThreadLocal 用来保存线程独享的数据，Fork/Join 机制用于大任务的分割与汇总，Volatile 对多线程数据可见性的保证，线程的中断机制</p>
<h6 id="线程同步与异步，阻塞与非阻塞"><a href="#线程同步与异步，阻塞与非阻塞" class="headerlink" title="线程同步与异步，阻塞与非阻塞"></a>线程同步与异步，阻塞与非阻塞</h6><p>线程的同步与异步、阻塞与非阻塞，同步和异步的区别在于任务是否是同一个线程执行，阻塞与非阻塞的区别在于异步执行任务时，线程是会阻塞等待结果，还是会继续执行后续逻辑。</p>
<h5 id="线程分析工具"><a href="#线程分析工具" class="headerlink" title="线程分析工具"></a>线程分析工具</h5><p>线程分析工具与方法，例如会用 jstack 分析线程的运行状态，查找锁对象持有状况等。</p>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><p><a href="https://zhuanlan.zhihu.com/p/374561361">https://zhuanlan.zhihu.com/p/374561361</a></p>
<h4 id="版本特性-TODO"><a href="#版本特性-TODO" class="headerlink" title="版本特性 TODO"></a>版本特性 TODO</h4><p>Java特性：函数式接口</p>
<h5 id="V1-8"><a href="#V1-8" class="headerlink" title="V1.8"></a>V1.8</h5><p>Lambda表达式，Stream API，方法引用，接口默认方法，Metaspace（元空间）替换PermGen</p>
<h5 id="V1-9"><a href="#V1-9" class="headerlink" title="V1.9"></a>V1.9</h5><p>模块系统，默认G1回收器（1.7推出），接口私有方法，局部变量推断，Graal编译器</p>
<h5 id="V1-11"><a href="#V1-11" class="headerlink" title="V1.11"></a>V1.11</h5><p>ZGC，字符串API增强，内建HTTP Client</p>
<h4 id="JavaSE问题"><a href="#JavaSE问题" class="headerlink" title="JavaSE问题"></a>JavaSE问题</h4><ol>
<li><p>面向过程和面向对象的区别<br> 相同：都是解决问题的思路、方法<br> 不同：</p>
<ol>
<li>面向过程将解决问题拆解为一个个步骤，偏向底层和细节，强调对问题进行分解。</li>
<li>面对对像是把一个个问题抽象为一个个对象，通过对象之间的交互来实现功能。 如：HR来负责协调面试时间。</li>
</ol>
</li>
<li><p>类访问权限</p>
</li>
<li><p>重载与重写</p>
<pre><code>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。比如：构造函数的重载，无参构造+有参构造；比如：字符串的截取，一个是从开始位置截取到最后；还有一个同名方法是指定开始位置和结束位置。有意思的是，JVM运行字节码可以区分不同的返回类型，但Java转字节码是不允许相同参数不同返回值的。
重写：发生在父子类中，方法名、参数列表相同，如：对象重写equals、hashcode方法；  返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。
</code></pre>
</li>
<li><p>equals，hashcode方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认情况下，equals()方法比较的是两个对象的引用是否相等，即是否指向同一个对象实例。</span><br><span class="line">默认情况下，hashCode()方法返回的是堆上的实例对象的哈希值。相同的对象实例内容，hashCode()返回不同。</span><br><span class="line">HashSet、HashMap、HashTable等集合类，都会先根据对象的hashCode()方法来判断对象是否相等，不相等时，放入集合中；相等时，再根据equals()方法来判断是否真的相等。</span><br><span class="line">我们日常比较对象一般也是希望比较对象内容是否相同</span><br></pre></td></tr></table></figure></li>
<li><p>String、StringBuillder、StringBuffer</p>
<ul>
<li><p>介绍<br>String是线程安全的，不可被继承。会在静态区分配内存，new 对象时，会在堆上也分配。<br>StringBuilder是线程不安全的，比StringBuffer性能高10%-15%。在堆上分配<br>StringBuffer是线程安全的，在StringBuilder的基础上对方法增加了synchronized。</p>
</li>
<li><p>场景<br>单线程大量操作使用StringBuilder。<br>多线程大量操作使用StringBuffer。</p>
</li>
</ul>
</li>
<li><p>ArrayList和LinkedList的区别<br> ArrayList底层是数组，按占下标查找快，删除慢，需要移动删除位置之后的所有元素。我们一般查数据库返回的就是用ArrayList接收。<br> LinkedList底层是双向链表，查询慢，增删改快。以前使用Hutool导出excel数据无序使用过。</p>
</li>
<li><p>深拷贝和浅拷贝的区别是什么?<br> 浅拷贝:两个对象属性中的对象引用都指向同一个对象。修改一个对象的值，另一个也会改变。我们一般需要用深拷贝<br> 深拷贝:拷贝的时候，所有对象都会再new一次，会多占一些空间</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title>并发理论基础</title>
    <url>/2023/09/20/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/03%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>并发理论基础</p>
<span id="more"></span>

<h1 id="并发理论基础-笔记"><a href="#并发理论基础-笔记" class="headerlink" title="并发理论基础-笔记"></a>并发理论基础-笔记</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="并发解决的功能"><a href="#并发解决的功能" class="headerlink" title="并发解决的功能"></a>并发解决的功能</h3><p>分工、同步、互斥</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230901201839760.png" alt="image-20230901201839760"></p>
<h4 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h4><p>Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、WorkerThread 模式</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>一个线程执行完了一个任务，如何通知执行后续任务的线程开工。</p>
<p>Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了。主线程和异步线程之间的协作，Future 工具类已经帮我们解决了。除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。</p>
<p>在 Java 并发编程领域，解决协作问题的核心技术是管程，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。</p>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>互斥，指的是同一时刻，只允许一个线程访问共享变量。</p>
<p>分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫“线程安全”。</p>
<p>实现互斥的核心技术就是锁，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决互斥问题。</p>
<p>虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能呢？可以分场景优化，Java SDK 里提供的 ReadWriteLock、StampedLock就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。<br>除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 Thread Local 和 final 关键字，还有一种 Copy-on-write 的模式。</p>
<h3 id="01-可见性、原子性和有序性问题"><a href="#01-可见性、原子性和有序性问题" class="headerlink" title="01 可见性、原子性和有序性问题"></a>01 可见性、原子性和有序性问题</h3><p>语言中属于进阶知识。</p>
<p>会涉及很多底层知识。比如：操作系统</p>
<p>并发层序的Bug往往会诡异地出现，然后又诡异的消失。</p>
<ol>
<li>CPU增加缓存，均衡与内存的速度差异</li>
<li>操作系统增加了进程、线程，分时复用CPU，进而均衡CPU与I/O设备速度差异</li>
<li>编译程序优化指令执行次序。</li>
</ol>
<h4 id="1-不同缓存导致的可见性问题"><a href="#1-不同缓存导致的可见性问题" class="headerlink" title="1.不同缓存导致的可见性问题"></a>1.不同缓存导致的可见性问题</h4><p>一个线程对共享变量的修改，另一个线程能够立刻看到，称为可见性。</p>
<p>多核时代，每颗CPU都有自己的缓存，这是就需要解决不同CPU的不同缓存可见性。</p>
<h4 id="2-线程切换带来的原子性问题"><a href="#2-线程切换带来的原子性问题" class="headerlink" title="2.线程切换带来的原子性问题"></a>2.线程切换带来的原子性问题</h4><p>一个操作或多个操作在执行过程中不可中断的特性称为原子性。</p>
<p>如：一条高级语言语句<code>count++;</code>，由三条CPU指令执行，线程可能在三条指令中任意一条执行完时切换。</p>
<h4 id="3-编译优化带来的有序性问题"><a href="#3-编译优化带来的有序性问题" class="headerlink" title="3.编译优化带来的有序性问题"></a>3.编译优化带来的有序性问题</h4><p>如：双重校验锁的并发问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new 对象的指令。</p>
<ul>
<li>分配内存M</li>
<li>初始化Singleton对象</li>
<li>M的地址赋值给instance变量</li>
</ul>
<p>出现问题的步骤：</p>
<ol>
<li>对象未实例化，线程A拿到锁，申请内存M；</li>
<li>线程A 将M的地址赋值给instance变量，休眠。线程B开始执行，判断instance不为空，返回实例。</li>
<li>线程B执行过程中发现成员变量为空，报NULLException</li>
</ol>
<p>如果对instance进行volatile声明，禁止指令重排序，可以避免改情况发生。</p>
<h3 id="02-Java内存模型"><a href="#02-Java内存模型" class="headerlink" title="02 Java内存模型"></a>02 Java内存模型</h3><p>可见性、有序性的解决方法：禁用缓存和禁止编译优化指令重排。</p>
<p>全局禁用会导致程序性能低，Java内存模型提供了程序员按需禁用的方法。</p>
<p>按需禁用包含volatile、synchronized、final三个关键字，六项Happens-Before原则。</p>
<h4 id="JDK1-5对volatile增强"><a href="#JDK1-5对volatile增强" class="headerlink" title="JDK1.5对volatile增强"></a>JDK1.5对volatile增强</h4><p>线程 A 执行 writer() 方法，按照 volatile 语义，会把变量“v=true” 写入内存；假设线程 B 执行 reader() 方法，同样按照 volatile 语义，线程 B会从内存中读取变量 v，如果线程 B 看到 “v == true” 时，那么线程 B 看到的变量 x 是多少呢？  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">        v = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里 x 会是多少呢？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.5之前，x可能是0，也可能是42。</p>
<h4 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h4><p>前一个操作对于后一个来说是可见的。</p>
<ol>
<li><p>程序的顺序性原则</p>
</li>
<li><p>操作可见性的传递。x=42先执行，volatile v == true先执行，x就可以看到值为42</p>
</li>
<li><p>管程中锁的规则</p>
<p>线程B对于代码块加锁，可以看到线程A对代码块解锁前的x=12赋值操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 此处自动加锁</span></span><br><span class="line">    <span class="comment">// x 是共享变量, 初始值 =10</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 此处自动解锁</span></span><br></pre></td></tr></table></figure></li>
<li><p>线程start规则-线程启动</p>
<p>子线程B可以看到主线程A调用start()之前的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// 主线程调用 B.start() 之前</span></span><br><span class="line">    <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line">    <span class="comment">// 此例中，var==77</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"><span class="keyword">var</span> = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br></pre></td></tr></table></figure></li>
<li><p>线程join规则-线程等待</p>
<p>主线程 A 调用join()时，可以看到子线程 B 的操作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line">    <span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程 A 可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br><span class="line">B.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用 B.join() 之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码来源于【参考 1】</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">// 错误的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalFieldExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line">    y = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 此处就是讲 this 逸出，</span></span><br><span class="line">    global.obj = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 是有可能读到 0的。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://ifeve.com/java-memory-model-6/">JMM中文</a></p>
<h3 id="03-04-互斥锁"><a href="#03-04-互斥锁" class="headerlink" title="03-04 互斥锁"></a>03-04 互斥锁</h3><h4 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h4><p>保证原子性：对共享变量的修改是互斥的。</p>
<p>锁模型：</p>
<ol>
<li>我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；</li>
<li>我们要保护资源 R 就得为它创建一把锁 LR；</li>
<li>针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。</li>
<li>在锁 LR 和受保护资源之间，用一条线做了关联，这个关联关系非常重要。很多并发 Bug 的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的 Bug 非常不好诊断，因为潜意识里我们认为已经正确加锁了。  </li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230901201133435.png" alt="锁模型todo"></p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>锁是一种通用的技术方案，Java 语言提供的 synchronized 关键字，就是锁的一种实现。</p>
<p>synchronized 关键字可以用来修饰方法，也可以修饰代码块。</p>
<p>当修饰静态方法的时候，锁定的是当前类的 Class 对象。</p>
<p>当修饰非静态方法的时候，锁定的是类的当前实例对象 this。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 锁失败案例。线程A addOne value+1成功，但未解锁时，线程B掉可调用get方法，且拿到的值未+1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化。synchronized修饰get()方法后，线程A调用addOne()方法解锁前，线程B无法调用get()方法拿不到锁。</span></span><br><span class="line"><span class="comment">// sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁；更改state加1成功则拿到锁，执行完代码，state减1释放锁。和aqs机制差不多，只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>必须深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径。</p>
<h4 id="一把锁保护多个资源"><a href="#一把锁保护多个资源" class="headerlink" title="一把锁保护多个资源"></a>一把锁保护多个资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单机多线程直接锁JVM启动时的class对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Account.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>原子性的本质是多个操作的一致性，中间状态对外不可见。</p>
<h3 id="05细粒度锁-amp-死锁"><a href="#05细粒度锁-amp-死锁" class="headerlink" title="05细粒度锁&amp;死锁"></a>05细粒度锁&amp;死锁</h3><p>锁Account.class是串行化的粗粒度锁。</p>
<p>细粒度锁：如线程A先拿账户a的锁，拿到后，去拿账户b的锁，都拿到后执行转账操作；没有拿到就等待拿锁。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>例如：线程A拿到账户a的锁，等待拿账户b的锁；线程B拿到账户b的锁，等待拿到账户a的锁，就会造成死锁。</p>
<p>死锁的四个条件：</p>
<ol>
<li>互斥，共享资源只能被一个线程占用</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ol>
<p>避免死锁：</p>
<ol>
<li><p>互斥。除非不再共享资源</p>
</li>
<li><p>占有且等待。一次性申请所有资源</p>
<p>增加资源管理员，由资源管理员一次性申请所有资源。</p>
</li>
<li><p>不可抢占。可以在占有资源1，无法占有资源2时，先释放资源，等待一定的时间再抢资源。</p>
<p>Java语言层面的synchronized无法解决。SDK的java.util.concurrent包下的Lock解决了。</p>
</li>
<li><p>循环等待。可以对资源做从小到大序号排序，先申请资源序号小的，再申请资源序号大的，线性化申请资源。</p>
</li>
</ol>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>我们可以利用现实中的模型来构思解决方案， 这样方案更容易理解，看清本质。</p>
<p>现实中的模型中的细节容易被忽视，现实世界中，人太智能了，人之间智能的交流，会让我我们忽视死锁的产生，但两个线程不会智能的交流。</p>
<h3 id="06-“等待-通知”机制，优化循环等待"><a href="#06-“等待-通知”机制，优化循环等待" class="headerlink" title="06 “等待-通知”机制，优化循环等待"></a>06 “等待-通知”机制，优化循环等待</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line"><span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>, target))；</span><br></pre></td></tr></table></figure>

<p>如果apply耗时非常短，并发量不大，这个方案还不错。循环几次到几十次就一次性获取到转出账户和转入账户。</p>
<p>如果耗时长，或者兵法冲突量大时，循环等待就不适用了，这是拿锁需要上万次的循环，很消耗CPU。这是拿不到锁应该阻塞自己，拿到锁的线程释放资源后唤醒阻塞的线程。</p>
<h4 id="用synchronized实现“等待-通知”"><a href="#用synchronized实现“等待-通知”" class="headerlink" title="用synchronized实现“等待-通知”"></a>用synchronized实现“等待-通知”</h4><p>synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能实现。</p>
<ol>
<li>当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。 线程在进入等待队列的同时，会释放持有的互斥锁；</li>
<li>拿到锁的线程释放资源后调用 notify()，会通知等待队列（互斥锁的等待队列）中的线程。</li>
</ol>
<p>注意点：</p>
<ol>
<li>notify() 只能保证在通知时间点，条件是满足的。而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件<br>已经不满足了（保不齐有其他线程插队）。</li>
<li>被通知的线程要想重新执行，仍然需要获取到互斥锁（因为曾经获取的锁在调用 wait() 时已经释放了）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als;</span><br><span class="line">    <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Object from, Object to)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 经典写法</span></span><br><span class="line">      <span class="keyword">while</span>(als.contains(from) ||als.contains(to))&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          wait();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      als.add(from);</span><br><span class="line">      als.add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Object from, Object to)</span></span>&#123;</span><br><span class="line">      als.remove(from);</span><br><span class="line">      als.remove(to);</span><br><span class="line">      notifyAll();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wait和sleep的区别-todo"><a href="#wait和sleep的区别-todo" class="headerlink" title="wait和sleep的区别 todo"></a>wait和sleep的区别 todo</h4><ol>
<li>wait回释放资源，sleep不会释放资源</li>
</ol>
<h3 id="07-并发宏观角度的安全性、活跃性、性能问题"><a href="#07-并发宏观角度的安全性、活跃性、性能问题" class="headerlink" title="07 并发宏观角度的安全性、活跃性、性能问题"></a>07 并发宏观角度的安全性、活跃性、性能问题</h3><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>实际开发时关注是否对共享资源既修改又读取。</p>
<p>解决：互斥。CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。也称为锁</p>
<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><p>死锁、活锁、饥饿</p>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><ul>
<li>描述：互相同时争抢和释放资源。</li>
<li>解决：争强资源等待随机时间</li>
</ul>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><ul>
<li>描述</li>
<li>解决：<ol>
<li>保证资源充足</li>
<li>公平的分配资源，公平锁</li>
<li>避免持有锁的线程长时间执行。</li>
</ol>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>并发提升效率公式：S=1/((1-a)+a/n)  （阿姆达尔定律）</p>
<p>S：提升的效率倍数</p>
<p>a：可并行百分比</p>
<p>n：并行核数</p>
<p>解决：</p>
<ol>
<li>使用无锁的算法和数据结构</li>
<li>减少锁持有的时间。如：ConcurrentHashMap的分段锁；共享读，排他写。</li>
</ol>
<p>三个重要的性能指标：</p>
<ol>
<li>吞吐量</li>
<li>延迟</li>
<li>并发量</li>
</ol>
<h3 id="08-管程"><a href="#08-管程" class="headerlink" title="08 管程"></a>08 管程</h3><p>MESA模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorSallProduce</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;库存为0，等待进货&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;被唤醒后，开始执行await之后的代码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="string">&quot;卖出一件商品，库存为：&quot;</span> + count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count+=<span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;进货3件商品，库存为：&quot;</span> + count);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonitorSallProduce monitorSallProduce = <span class="keyword">new</span> MonitorSallProduce();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">6</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(monitorSallProduce::sall).start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(monitorSallProduce::produce).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230904175239015.png" alt="image-20230904175239015"></p>
<h4 id="notify使用注意"><a href="#notify使用注意" class="headerlink" title="notify使用注意"></a>notify使用注意</h4><p>尽量使用notifyAll()</p>
<ol>
<li>所有等待线程拥有相同的等待条件</li>
<li>所有等待线程被换唤醒后，执行相同的操作</li>
<li>只需要唤醒一个线程</li>
</ol>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.cn/post/7067876796775006215">https://juejin.cn/post/7067876796775006215</a></p>
<h3 id="09-10-11-Java线程"><a href="#09-10-11-Java线程" class="headerlink" title="09-10-11 Java线程"></a>09-10-11 Java线程</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期：各个状态，和状态间转换机制</p>
<h5 id="通用生命周期"><a href="#通用生命周期" class="headerlink" title="通用生命周期"></a>通用生命周期</h5><p>初始化，可运行，运行，休眠，结束</p>
<ul>
<li>初始化：操作系统无这个状态，JAVA中指的是JAVA线程被创建，操作系统线程还没创建</li>
<li>可运行：操作系统线程以创建，可分配CPU执行</li>
<li>运行：可运行状态的线程得到CPU，状态变为运行</li>
<li>休眠：运行状态的线程调用一个阻塞的API或者等待某个事件（LOCK的CONDITION)，线程进入休眠状态，释放CPU使用权。</li>
<li>终止：线程执行完，或者出现异常会进入终止状态。</li>
</ul>
<h5 id="Java生命周期"><a href="#Java生命周期" class="headerlink" title="Java生命周期"></a>Java生命周期</h5><p>初始化NEW，运行RUNNABLE，休眠(BLOCKED,WAITING,TIMED_WAITING)，结束TERMINATED</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230905144555459.png" alt="image-20230905144555459"></p>
<h5 id="Java线程状态转换"><a href="#Java线程状态转换" class="headerlink" title="Java线程状态转换"></a>Java线程状态转换</h5><ul>
<li><p>NEW→RUNNABLE</p>
<ol>
<li>继承Thread对象，重写run方法，调用start()</li>
<li>实现Runnable接口，实现run方法，创建线程对象，调用start()</li>
</ol>
</li>
<li><p>RUNNABLE与BLOCKED</p>
<p>RUNNABLE→BLOCKED线程等待synchronized的隐式锁；BLOCKED→RUNNABLE线程拿到synchronized的隐式锁；</p>
</li>
<li><p>RUNNABLE→WAITING</p>
<ol>
<li>获得 synchronized 隐式锁的线程，调用无参数的 Object.wait()   </li>
<li>调用无参数的 Thread.join() 方法</li>
<li>调用 LockSupport.park() 方法。Java 并发包中的锁，都是基于LockSupport.park()实现的</li>
</ol>
</li>
<li><p>RUNNABLE→TIMED_WAITING</p>
<ol>
<li>调用带超时参数的 Thread.sleep(long millis) 方法；</li>
<li>获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方</li>
</ol>
<p>法；</p>
<ol start="3">
<li>调用带超时参数的 Thread.join(long millis) 方法；</li>
<li>调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；</li>
<li>调用带超时参数的 LockSupport.parkUntil(long deadline) 方法  </li>
</ol>
</li>
<li><p>RUNNABLE→FINISH</p>
</li>
</ul>
<h5 id="stop与interrupt方法"><a href="#stop与interrupt方法" class="headerlink" title="stop与interrupt方法"></a>stop与interrupt方法</h5><p>stop()会直接杀死线程，不会调用程序员写的显示锁，如：调用ReentrantLock的unlock()释放锁。已标记为过期</p>
<p>interrupt()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 未休眠需要主动判断中断状态，休眠时抛出异常并重置中断状态</span><br><span class="line">// 休眠后，调用interrupt()，抛出InterruptedException异常，并重置中断状态</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">	Thread.sleep(<span class="number">100</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e)&#123; </span><br><span class="line"><span class="comment">// 重新设置中断标志位 </span></span><br><span class="line">th.interrupt(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h4><p>使用多线程的目的是提升性能。</p>
<p>性能度量：降低延迟，提高吞吐量</p>
<p>性能优化：Tomcat的连接数，Jdbc连接池链接数量</p>
<p>性能提升的方法：</p>
<ol>
<li>优化算法</li>
<li>提升CPU、I/O综合使用率</li>
</ol>
<p>理论线程数：</p>
<p>​    I/O密集型：CPU逻辑核数 * （1+（I/O耗时 / CPU耗时））</p>
<p>​    CPU密集型：CPU逻辑核数+1</p>
<p>实际线程数：</p>
<ol>
<li>不同场景的压测</li>
<li>计算CPU、I/O设备利用率和性能指标（响应时间、吞吐量）之间的关系。定时查看线程池利用率。</li>
</ol>
<p>I/O密集型：无特殊场景设置为 2*CPU核数+1。后续可压测，跟进线程池实际利用率</p>
<p>测试I/O耗时、CPU耗时：APM工具</p>
<p>线程池设置？</p>
<ol>
<li>线程数</li>
<li>队列数？</li>
</ol>
<p>每次列表查询新开多线程是否会有问题？</p>
<h4 id="线程内部"><a href="#线程内部" class="headerlink" title="线程内部"></a>线程内部</h4><p>每个线程都有自己的调用栈，调用栈各自的栈帧地址对应不同内存区域，局部变量在不同的内存区域中。</p>
<h3 id="12-如何写好并发程序"><a href="#12-如何写好并发程序" class="headerlink" title="12 如何写好并发程序"></a>12 如何写好并发程序</h3><h4 id="面对对象思想写并发程序"><a href="#面对对象思想写并发程序" class="headerlink" title="面对对象思想写并发程序"></a>面对对象思想写并发程序</h4><ol>
<li><p>封装共享变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">addOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> ++value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会发生变化的共享变量，建议用 final 关键字修饰 。</p>
<p>既能避免并发问题，也能表明字段不变的含义。 </p>
</li>
<li><p>识别多个共享变量间的约束条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockUpperLower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong upper = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lower = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; lower.get())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;upper &lt; lower&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        upper.set(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &gt; upper.get())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;lower &gt; upper&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lower.set(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StockUpperLower stockUpperLower = <span class="keyword">new</span> StockUpperLower();</span><br><span class="line">        stockUpperLower.setUpper(<span class="number">10</span>);</span><br><span class="line">        stockUpperLower.setLower(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stockUpperLower.setUpper(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;此线程执行upper.set(v)时，另一个线程执行lower.set(v); 可以越过if的判断条件设置出 upper &lt; lower&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stockUpperLower.setLower(<span class="number">7</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;库存上限：&quot;</span> + stockUpperLower.upper.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;库存下限：&quot;</span> + stockUpperLower.lower.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享变量之间的约束条件，反映在代码里，基本上都会有 if 语句。</p>
</li>
<li><p>制定共享变量访问策略</p>
<ol>
<li>避免共享</li>
<li>不变模式。JAVA领域少。其他领域如：Actor模式，CSP模式，函数式编程的基础</li>
<li>管程及其他同步工具。JAVA并发包提供的读写锁，并发容器同步工具</li>
</ol>
</li>
</ol>
<h4 id="写并发程序规则"><a href="#写并发程序规则" class="headerlink" title="写并发程序规则"></a>写并发程序规则</h4><ol>
<li><p>优先使用已有成熟的并发包，而不是自己实现</p>
</li>
<li><p>迫不得已时菜使用低级的同步原语？</p>
<p>低级同步源语指：synchronized、Lock、Semaphore</p>
</li>
<li><p>避免过早优化。安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。 性能瓶颈难以预估</p>
</li>
</ol>
<h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133</a></p>
<p><a href="https://ifeve.com/jmm-faq/">JSR133中文</a></p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2021/09/10/212Java%E8%AF%AD%E8%A8%80/JVM/JVM/</url>
    <content><![CDATA[<p>JVM</p>
<span id="more"></span>

<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><ol>
<li>内存管理</li>
<li>类加载</li>
<li>垃圾回收</li>
<li>Java监控工具</li>
<li>JVM优化</li>
<li>问题排查</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存区域划分，如何高效管理内存，为什么需要元空间</p>
<h3 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h3><ul>
<li>静态成员变量</li>
<li>动态成员变量</li>
<li>区域变量</li>
<li>短小紧凑的对象声明</li>
<li>庞大复杂的内存申请</li>
</ul>
<h3 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h3><p>JVM内存区域划分与多线程息息相关。</p>
<table>
<thead>
<tr>
<th></th>
<th>运作</th>
<th>保存的数据</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>方法区</td>
<td></td>
<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码；方法区也被称为永久代（在 JDK 7 及之前的版本）或元空间（在 JDK 8 及之后的版本）。</td>
<td>线程共享</td>
</tr>
<tr>
<td>堆</td>
<td>堆是 JVM 管理的内存中最大的一块。堆内存没有可用的空间时，会抛出 OOM 异常；垃圾回收器的主要工作区域</td>
<td>存放对象实例</td>
<td>线程共享</td>
</tr>
<tr>
<td>栈</td>
<td>线程在执行每个方法时都会同时创建一个栈帧，调用方法时执行入栈，方法返回时执行出栈。执行 Java 方法</td>
<td>存储局部变量表、操作栈、动态链接、方法出口等信息</td>
<td>线程私有</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>与栈类似。执行native方法</td>
<td>与栈类似</td>
<td>线程私有</td>
</tr>
<tr>
<td>程序计数器</td>
<td>为执行 Java 方法服务，执行 native 方法时，程序计数器为空。</td>
<td>保存线程所执行的字节码位置</td>
<td>线程私有</td>
</tr>
<tr>
<td>直接内存</td>
<td>不是 Java 虚拟机规范中定义的内存区域，但是它可以与 Java 堆和本地方法栈一样，被本地方法直接内存使用。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231228175634694.png" alt="image-20231228175634694"></p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>Java 虚拟机栈是基于线程的。一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</p>
<p>栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。</p>
<p>栈帧：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>返回地址</li>
</ul>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Jp73lS5DfAOzuc8.png" alt="image-20210914090143551"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>基于线程，与虚拟机栈配合完成计算操作。</p>
<p>程序计数器还存储了当前正在运行的流程，包括正在执行的指令、跳转、分支、循环、异常处理等。</p>
<h5 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h5><h6 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h6><h6 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h6><p>JNI，JNA直接申请内存。</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆是 JVM 上最大的内存区域，几乎申请的所有的对象，都是在这里存储的。</p>
<p>随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个过程，就叫作 GC（Garbage Collection）。</p>
<h3 id="JMM（内存访问模型）"><a href="#JMM（内存访问模型）" class="headerlink" title="JMM（内存访问模型）"></a>JMM（内存访问模型）</h3><p>解决：屏蔽掉各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台下都能达到一致的并发效果。本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行。</p>
<p>定义：程序中变量的访问规则。一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>所有的共享变量都存储在主内存中共享。每个线程有自己的工作内存，工作内存中保存的是主内存中变量的副本，线程对变量的读写等操作必须在自己的工作内存中进行，而不直接读写主内存的变量。</p>
<p>在多线程进行数据交互时，线程 A 给一个共享变量赋值后，由线程 B 来读取这个值，A 在自己的工作区内存中修改完变量，B 是不可见的，只有从 A 的工作区写回主内存，B 再从主内存读取自己的工作区才能进行进一步的操作。由于指令重排序的存在，这个写—读的顺序有可能被打乱。因此 JMM 需要提供原子性、可见性、有序性的保证。</p>
<h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><ul>
<li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li>
<li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li>
<li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li>
<li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li>
<li>静态成员变量跟随着类定义一起也存放在堆上。</li>
<li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。 </li>
</ul>
<h5 id="工作内存与主内存之间通信"><a href="#工作内存与主内存之间通信" class="headerlink" title="工作内存与主内存之间通信"></a>工作内存与主内存之间通信</h5><p>线程间通信必须要经过主内存。</p>
<h6 id="8个操作"><a href="#8个操作" class="headerlink" title="8个操作"></a>8个操作</h6><ul>
<li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<h6 id="执行8个操作的规则"><a href="#执行8个操作的规则" class="headerlink" title="执行8个操作的规则"></a>执行8个操作的规则</h6><ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 </li>
<li>不允许read和load、store和write操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 </li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 </li>
</ul>
<h5 id="JMM原子性、可见性、有序性"><a href="#JMM原子性、可见性、有序性" class="headerlink" title="JMM原子性、可见性、有序性"></a>JMM原子性、可见性、有序性</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/CubaYmjfPgIZR92.png" alt="image-20210908215014058"></p>
<ul>
<li><p>原子性：JMM 保证对除 long 和 double 外的基础数据类型的读写操作是原子性的。另外关键字 synchronized 也可以提供原子性保证。synchronized 的原子性是通过 Java 的两个高级的字节码指令 monitorenter 和 monitorexit 来保证的。</p>
</li>
<li><p>可见性：synchronized，volatile，final。volatile 强制变量的赋值会同步刷新回主内存，不强制变量的读取从主内存重新加载，允许其他线程能够看到该变量的最新值，但其他线程可能从本地缓存读取旧值</p>
</li>
<li><p>有序性：主要通过 volatile 和一系列 happens-before 原则。<code>synchronized</code>也可保证有序性。volatile 的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。</p>
<p>happens-before原则</p>
<ul>
<li>程序顺序原则，即一个线程内必须保证语义串行性；</li>
<li>锁规则，即对同一个锁的解锁一定发生在再次加锁之前；</li>
<li>happens-before 原则的传递性、线程启动、中断、终止规则等。</li>
</ul>
</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://ifeve.com/java-memory-model-6/">JMM中文</a></p>
<p><a href="https://jenkov.com/tutorials/java-concurrency/java-memory-model.html">JMM英文</a></p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载机制，加载与卸载流程，常用类加载器，类加载的双亲委派模式</p>
<h3 id="类加载机制-深入拆解Java虚拟机-Java虚拟机基本原理-3-类加载过程"><a href="#类加载机制-深入拆解Java虚拟机-Java虚拟机基本原理-3-类加载过程" class="headerlink" title="类加载机制 [[深入拆解Java虚拟机-Java虚拟机基本原理#3.类加载过程]]"></a>类加载机制 [[深入拆解Java虚拟机-Java虚拟机基本原理#3.类加载过程]]</h3><p>类的加载指将编译好的Class类文件中的字节码读入内存中，将其放在方法区并创建对应的Class对象。</p>
<p>类的加载分为：加载，链接（验证、准备、解析），初始化。</p>
<h3 id="加载与卸载"><a href="#加载与卸载" class="headerlink" title="加载与卸载"></a>加载与卸载</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vABTth1JG25pfKl.png" alt="image-20210908220024062"></p>
<ol>
<li>加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个 Class 对象。</li>
</ol>
<ol start="2">
<li><p>验证是对类文件内容验证。目的在于确保 Class 文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
</li>
<li><p>准备阶段是进行内存分配。为类变量也就是类中由 static 修饰的变量分配内存，并且设置初始值。虚方法的动态方法列表。 这里要注意，初始值是 0 或者 null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用 final 修饰的静态变量，因为 final 在编译的时候就会分配。</p>
</li>
<li><p>解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。 符号引用：即方法路径；直接应用：内存地址。转换过程类似与域名和IP地址</p>
</li>
<li><p>初始化，主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。</p>
<h4 id="常用类加载器"><a href="#常用类加载器" class="headerlink" title="常用类加载器"></a>常用类加载器</h4></li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8fNvy1RFKgWoIQZ.png" alt="image-20210908220842507"></p>
<p>Java 自带的三种类加载器分别是：BootStrap 启动类加载器、扩展类加载器和应用加载器（也叫系统加载器），最后一个是自定义加载器。图右边的桔黄色文字表示各类加载器对应的加载目录。启动类加载器加载 java home 中 lib 目录下的类，扩展加载器负责加载 ext 目录下的类，应用加载器加载 classpath 指定目录下的类。</p>
<h3 id="类加载的双亲委派模式"><a href="#类加载的双亲委派模式" class="headerlink" title="类加载的双亲委派模式"></a>类加载的双亲委派模式</h3><p>Java 的类加载使用双亲委派模式，即一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器，如上图中蓝色向上的箭头。如果父类加载器能够完成类加载，就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。</p>
<p><strong>优点：</strong> 避免类的重复加载，另外也避免了 Java 的核心 API 被篡改</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><p>Tomcat部署多个应用。</p>
<p>默认类加载器认为相同包名、类名是同一个类。tomcat通过实现自定义类加载器实现不同应用下相同包名、类型不是同一个类。</p>
</li>
<li><p>热部署。</p>
<p>监听类，动态替换。</p>
</li>
</ol>
<h3 id="越过双亲委派"><a href="#越过双亲委派" class="headerlink" title="越过双亲委派"></a>越过双亲委派</h3><p>java.lang下的类无法越过。</p>
<p>编写同名类放在 ***包下， 优先级高于rt.jar。场景：比Java团队早发现了Java原生类的bug。</p>
<h2 id="GC（垃圾回收）"><a href="#GC（垃圾回收）" class="headerlink" title="GC（垃圾回收）"></a>GC（垃圾回收）</h2><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/paOEbr7j5hnDY6k.png" alt="image-20210917172452911"></p>
<h3 id="分代回收思想"><a href="#分代回收思想" class="headerlink" title="分代回收思想"></a>分代回收思想</h3><p>堆内存分代管理。回收年轻代和老年代。</p>
<p>原因：1.大部分对象很快不再使用（如：普通列表数据）；2.一部分对象不会立即无用，但也不会持续很长时间。（缓存对象）</p>
<ul>
<li><p>年轻代 8:1:1</p>
<p>年轻代主要用来存放新创建的对象，年轻代分为 Eden 区和两个 Survivor 区。大部分对象在 Eden 区中生成。当 Eden 区满时，还存活的对象会在两个 Survivor 区交替保存，达到一定次数的对象会晋升到老年代。</p>
</li>
<li><p>老年代</p>
<p>存放从年轻代晋升而来的，存活时间较长的对象。</p>
</li>
<li><p>永久代</p>
<p>主要保存类信息等内容，这里的永久代是指对象划分方式，不是专指 1.7 的 PermGen，或者 1.8 之后的 Metaspace。</p>
</li>
</ul>
<h3 id="垃圾回收算法-TODO图"><a href="#垃圾回收算法-TODO图" class="headerlink" title="垃圾回收算法 TODO图"></a>垃圾回收算法 TODO图</h3><p>回收方法:</p>
<ul>
<li><p>标记：根据 GC Roots 遍历所有的可达对象，即活跃对象。</p>
</li>
<li><p>清除：把未被标记的对象回收掉。会有碎片问题</p>
</li>
<li><p>复制：提供一个对等的内存空间，将存活的对象复制过去，然后清除原内存空间。如：HashMap 的扩容。</p>
</li>
<li><p>整理：移动所有存活的对象，且按照内存地址顺序依次排列，然后将末端内存地址以后的内存全部回收。</p>
</li>
<li><p>引用计数：通过对象被引用的次数来确定对象是否被使用。</p>
<p>  <strong>缺点：</strong>是无法解决循环引用的问题。</p>
</li>
</ul>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li><p>介绍：需要 from 和 to 两块相同大小的内存空间，对象分配时只在 from 块中进行，回收时把存活对象复制到 to 块中，并清空 from 块，然后交换两块的分工，即把 from 块作为 to 块，把 to 块作为 from 块。</p>
</li>
<li><p>优点：时间效率最高。</p>
</li>
<li><p>缺点：会造成一定的空间浪费，空间利用率低</p>
</li>
<li><p>场景：年轻代回收，HashMap扩容</p>
</li>
</ul>
<h4 id="标记-清除-Sweep"><a href="#标记-清除-Sweep" class="headerlink" title="标记-清除 Sweep"></a>标记-清除 Sweep</h4><p>效率一般</p>
<ul>
<li>缺点：会造成内存碎片问题。</li>
<li>场景：老年代的CMS垃圾回收器。<a href="#CMS">CMS</a></li>
</ul>
<h4 id="标记-整理-Compact"><a href="#标记-整理-Compact" class="headerlink" title="标记-整理 Compact"></a>标记-整理 Compact</h4><p>效率比前两者要差，但没有空间浪费，也消除了内存碎片问题。</p>
<h3 id="垃圾回收内存划分和GC过程"><a href="#垃圾回收内存划分和GC过程" class="headerlink" title="垃圾回收内存划分和GC过程"></a>垃圾回收内存划分和GC过程</h3><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><ul>
<li>活动线程相关的各种引用。</li>
<li>类的静态变量的引用。</li>
<li>JNI 引用。</li>
</ul>
<h4 id="引用级别"><a href="#引用级别" class="headerlink" title="引用级别"></a>引用级别</h4><p>内存空间不足，系统撑不住了，JVM 就会抛出 OutOfMemoryError 。</p>
<p>强、软、弱、虚。</p>
<ul>
<li>强引用：GC不会回收</li>
<li>软引用：GC后内存不足时，GC回收软引用对象。<code>SoftReference&lt;Object&gt; softRef = new SoftReference(object);</code></li>
<li>JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</li>
<li>虚引用：主要用来跟踪对象被垃圾回收的活动。可以监控 GC 发生。</li>
</ul>
<h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>发生在年轻代的 GC。</p>
<h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p>发生在老年代的 GC。</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>全堆垃圾回收。比如 Metaspace 区不足引起年轻代和老年代的回收。</p>
<p>触发条件:</p>
<ul>
<li>当老年代无法再分配内存的时候；</li>
<li>元空间不足的时候；</li>
<li>显示调用System.gc的时候。</li>
<li>CMS垃圾回收器MinorGC出现promotion failure,age提升到老年代失败。</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>使用标记-清除法。[标记-清除](#标记-清除 Sweep)</p>
<p>收集范围：老年代</p>
<p>优点：并发收集，停顿小</p>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="卡表（Card-Table）"><a href="#卡表（Card-Table）" class="headerlink" title="卡表（Card Table）"></a>卡表（Card Table）</h6><p>用途：用于记录和维护 年轻代和老年代之间的对象引用关系。</p>
<p>具体实现：标记卡页状态的一个集合，每个卡表项对应一个卡页。如果年轻代有对象分配，而且老年代有对象指向这个新对象， 那么这个老年代对象所对应内存的卡页，就会标识为 dirty。</p>
<h6 id="Bitmap（位图）和布隆过滤器"><a href="#Bitmap（位图）和布隆过滤器" class="headerlink" title="Bitmap（位图）和布隆过滤器"></a>Bitmap（位图）和布隆过滤器</h6><p>作用：加快过滤是否有跨代的引用</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol>
<li>初始标记，GC Roots 直达的对象。STW</li>
<li>并发标记，标记所有可达的对象</li>
<li>重新标记，标记并发标记过程中变活的对象和新生对象。STW</li>
<li>并发清理，清理除标记对象外的对象。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>CMS 在执行过程中，用户线程还需要运行，会保留30% 左右内存空间供用户使用。</li>
<li>内存碎片问题，Full GC 的整理阶段，会造成较长时间的停顿；</li>
<li>使用更多的 CPU 资源，在应用运行的同时进行堆扫描；</li>
<li>停顿时间是不可预期的。</li>
</ul>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>使用标记-整理算法</p>
<p>收集范围：老年代和新生代</p>
<p>优点：内存碎片少。</p>
<p>通过回收区域可变，控制回收垃圾的时间。设置默认回收停顿时间200ms</p>
<p>内存划分：n 个不连续的小堆区（Region，1MB到32MB之间），逻辑上分年轻代（Eden，Survior）、老年代（Old)、Humongous Region。</p>
<h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="RSet"><a href="#RSet" class="headerlink" title="RSet"></a>RSet</h6><p>用途：用于记录和维护 Region 之间的对象引用关系。</p>
<p>具体实现：</p>
<ul>
<li><p>RSet 记录了本 Region中的对象被其他 Region 中的对象引用的关系。</p>
</li>
<li><p>RSet只保存了老年代的引用。</p>
<ul>
<li>年轻代的回收是针对所有年轻代 Region 的。</li>
<li>老年代回收之前，会先对年轻代进行回收。这时，Eden 区变空了，回收过程中会扫描 Survivor 分区。</li>
</ul>
</li>
<li><p>占用5%或更多的空间。</p>
</li>
<li><p>为了维护 RSet，程序运行的过程中，写入字段就会产生一个 post-write barrier 。为了减少这个开销，将内容放入 RSet 的过程是异步的。</p>
</li>
</ul>
<h6 id="CSet"><a href="#CSet" class="headerlink" title="CSet"></a>CSet</h6><p>保存一次 GC 中将执行垃圾回收Region集合。GC会把CSet 中的所有存活数据（Live Data）转移。</p>
<h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><h6 id="Minor-GC-1"><a href="#Minor-GC-1" class="headerlink" title="Minor GC"></a>Minor GC</h6><p>所有的 Eden 区都满了，G1 会启动一次年轻代垃圾回收过程。</p>
<ol>
<li>扫描根：GC Roots，加上 RSet 记录的其他 Region 的外部引用。</li>
<li>更新RSset：处理 dirty card queue 中的卡页，更新RSet。</li>
<li>处理RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
<li>复制对象：对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的 Region。年龄和晋升同CMS</li>
<li>处理引用：Soft、Weak、Phantom、Final、JNI Weak 等引用。</li>
</ol>
<h6 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h6><p>堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动。（-XX:InitiatingHeapOccupancyPercent 进行配置）</p>
<ol>
<li>初始标记</li>
<li>Root区扫描</li>
<li>并发标记</li>
<li>重新标记</li>
<li>清理阶段：Region 里全是垃圾，在这个阶段会立马被清除掉。不全是垃圾的 Region，并不会被立马处理，它会在 Mixed GC 阶段，进行收集。</li>
</ol>
<h6 id="混合清理"><a href="#混合清理" class="headerlink" title="混合清理"></a>混合清理</h6><p>Concurrent Marking 阶段，已经统计了老年代的垃圾占比。在 Minor GC 之后，如果判断这个占比达到了某个阈值，下次就会触发 Mixed GC。这个阈值，由 -XX:G1HeapWastePercent 参数进行设置（默认是堆大小的 5%）。</p>
<h5 id="大对象回收"><a href="#大对象回收" class="headerlink" title="大对象回收"></a>大对象回收</h5><p>大对象直接分配在大对象区域，回收与小对象不同</p>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><ul>
<li>数据结构<ul>
<li>小堆区（2MB以下）<ul>
<li>年轻代</li>
<li>老年代</li>
</ul>
</li>
<li>大堆区（2MB以上）<ul>
<li>年轻代</li>
<li>老年代</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java监控工具"><a href="#Java监控工具" class="headerlink" title="Java监控工具"></a>Java监控工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p><code>jps</code>将打印所有正在运行的 Java 进程。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231121185100105.png" alt="image-20231121185100105"></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><code>jinfo pid</code> 将打印目标 Java 进程的配置参数</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231121185504263.png" alt="image-20231121185504263"></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p><code>-class</code>将打印类加载相关的数据，<code>-compiler</code>和<code>-printcompilation</code>将打印即时编译相关的数据</p>
<p>查看目标 Java 进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 间隔1秒查看一次垃圾回收信息</span><br><span class="line">jstat -gcutil $pid 1000</span><br><span class="line">-gc #显示和 GC 相关的 堆信息</span><br><span class="line">-gccause: 显示垃圾回收 的相关信息（同 -gcutil），同时显示 最后一次 或 当前 正在发生的垃圾回收的 诱因；</span><br><span class="line">-gcnew: 显示 新生代 信息；</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/QFiqXPyjYgplVfZ.png" alt="image-20210918164545621"></p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>线程分析&amp;GC统计</p>
<p>获取线程运行情况，线程阻塞、是否有死锁。</p>
<p>垃圾回收情况，ygc和fullgc的次数和时间。</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>1.JVM中堆内容各个区域的使用情况，占用大小</p>
<p>2.各个对象实例个数，占用大小</p>
<h3 id="JMC飞行记录器"><a href="#JMC飞行记录器" class="headerlink" title="JMC飞行记录器"></a>JMC飞行记录器</h3><p>默认性能影响1%，分析模板下影响2%</p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>分析JVM堆。即dump下的 <code>*.hrpof</code> 文件</p>
<p><a href="https://www.eclipse.org/mat/previousReleases.php">官方下载</a> 注意：1.12 需要JDK1.11；1.8.1对应JDK1.8</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>打开软件<code>MemoryAnalyzer.exe</code></p>
<ol>
<li><p>获取dump</p>
<ol>
<li><p>选择一个 <code>*.hrpof</code> 文件</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6zxYTXMPIbywjNF.png" alt="image-20210922123531300"></p>
</li>
<li><p>获取本地java程序的dump</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/GYWd3DeMIvs1Krg.png" alt="image-20210922140921212"></p>
</li>
</ol>
</li>
<li><p>视图介绍</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/R3q4OTtyZiPonFa.png" alt="image-20210922150517410"></p>
</li>
<li><p>视图-overview</p>
<p>概览</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/47agCotwRcOuD1K.png" alt="image-20210922140237489"></p>
</li>
<li><p>视图-histogram</p>
<p>柱状图显示对象个数和大小</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vLitX8BcKaqdwP4.png" alt="image-20210922135107115"></p>
<p>过滤</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6NczhR1D3l8tduU.png" alt="image-20210922144737997"></p>
<p>引用间跳转</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/2fcBFwqINVmKtsl.png" alt="image-20210922144847604"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/MA2p6vyrbhW3fuX.png" alt="image-20210922145321429"></p>
<p>多个dump对比</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/P9o7em2KfxGbIUH.png" alt="image-20210922145202733"></p>
</li>
<li><p>视图-dominator_tree</p>
<p>支配树，树结构显示对象占内存的百分比</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/yk39v6s18UdqAxN.png" alt="image-20210922124019171"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/s3ACBgIYOQVvEam.png" alt="image-20210922145138086"></p>
</li>
<li><p>视图-leak suspects</p>
<p>泄漏疑点</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/twjavzihAuy4m7L.png" alt="image-20210922135239578"></p>
</li>
<li><p>视图-thread_overview</p>
<p>线程视图。展示了线程内对象的引用关系，以及方法调用关系</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/L1u3dw2WgJpaoeZ.png" alt="image-20210922145833421"></p>
</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>导入堆内存到MAT</li>
<li>查看泄漏疑点报告并结合代码分析</li>
<li>从柱状视图和支配树视图找到大对象，分析大对象</li>
<li>详细分析。结合柱状图和支配树视图，配合引入引出和各种排序、过滤，多份堆内存对比</li>
</ol>
<h2 id="JVM优化"><a href="#JVM优化" class="headerlink" title="JVM优化"></a>JVM优化</h2><p>linux查看JVM 参数<code>UseAdaptiveSizePolicy</code>默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -XX:+UseG1GC  2&gt;&amp;1 | grep UseAdaptiveSizePolicy</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version --打印JVM启动参数(可以看默认垃圾回收器)</span><br></pre></td></tr></table></figure>

<h3 id="业务要求"><a href="#业务要求" class="headerlink" title="业务要求"></a>业务要求</h3><p>高并发的互联网业务，传统的报表业务；服务响应时间RT，不允许长尾请求；功能完整度要求比较高，不能运行到一半宕机。</p>
<h3 id="内存区域大小"><a href="#内存区域大小" class="headerlink" title="内存区域大小"></a>内存区域大小</h3><p>机器是 4C8GB 的，分配给了 JVM 8GB/3*2= 5460MB 的空间。那么年轻代大小就有 5460MB/3=1820MB。Eden 区的大小约 1456MB</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseG1GC 垃圾回收器为 G1</span><br><span class="line">-Xmx5440M 堆的最大值，一般为操作系统的 2/3 大小。</span><br><span class="line">-Xms5440M 堆的初始值，一般设置成和 Xmx 一样的大小来避免动态扩容。</span><br><span class="line">-Xmn 表示年轻代的大小，默认新生代占堆大小的 1/3。G1不设置，自动动态调整。</span><br><span class="line">-XX:MaxMetaspaceSize=256M 元空间最大值 idea下4G左右（16G内存条）</span><br><span class="line">-XX:MetaspaceSize 元空间初始的大小，默认20M+816B</span><br><span class="line">-XX:MaxDirectMemorySize=100M 直接内存最大值</span><br><span class="line">-XX:ReservedCodeCacheSize=268435456 JIT编译后的代码存放区大小（256M）</span><br><span class="line">-Xss1M 栈大小默认1M</span><br></pre></td></tr></table></figure>

<h3 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+AlwaysPreTouch 启动时就把参数里指定的内存全部初始化，启动时间会慢一些，但运行速度会增加。</span><br><span class="line">-XX:SurvivorRatio：默认值为 8，表示伊甸区和幸存区的比例。</span><br><span class="line">-XX:MaxTenuringThreshold CMS下默认为 6，G1 下默认为 15，这个值和我们前面提到的对象提升有关</span><br><span class="line">-XX:+PrintTenuringDistribution JVM在每次新生代GC时，打印出幸存区中对象的年龄分布。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-Xloggc:/tmp/logs/gc_%p.log</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=/tmp/logs</span><br><span class="line">-XX:ErrorFile=/tmp/logs/hs_error_pid%p.log</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>-verbose:gc</th>
<th>打印GC日志</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+PrintGCDetails</td>
<td>打印详细 GC 日志</td>
</tr>
<tr>
<td>-XX:+PrintGCDateStamps</td>
<td>系统时间</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationStoppedTime</td>
<td>打印 STW 时间</td>
</tr>
<tr>
<td>-XX:+PrintTenuringDistribution</td>
<td>打印对象年龄分布</td>
</tr>
<tr>
<td>-Xloggc:/tmp/logs/gc_%p.log</td>
<td>GC 内容输出到文件</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>OOM 时 Dump 信息</td>
</tr>
<tr>
<td>-XX:HeapDumpPath=/tmp/logs</td>
<td>Dump 文件保存路径</td>
</tr>
<tr>
<td>-XX:ErrorFile=/tmp/logs/hs_error_pid%p.log</td>
<td>错误日志存放路径</td>
</tr>
<tr>
<td>-XX:-OmitStackTraceInFastThrow</td>
<td>不缩减异常日志</td>
</tr>
</tbody></table>
<h3 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h3><ul>
<li><p>吞吐量优先，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。参数：-XX:+UseParallelGC。</p>
</li>
<li><p>对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1、ZGC、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。</p>
</li>
<li><p>年轻代：</p>
<ul>
<li>ParNew：追求降低用户停顿时间，强交互弱计算。</li>
<li>Parallel Scavenge：追求 CPU 吞吐量，弱交互强计算。</li>
</ul>
</li>
<li><p>堆大小小于2 G</p>
<p>堆空间很小，存活的对象有限，所以回收速度一般很快。</p>
<ul>
<li> jdk8使用默认的并行垃圾回收器</li>
<li>jdk11使用g1，出现明显的卡顿，切换回并行垃圾回收。</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收器优化"><a href="#垃圾回收器优化" class="headerlink" title="垃圾回收器优化"></a>垃圾回收器优化</h3><ul>
<li><p>CMS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- G1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-XX:MaxGCPauseMillis 设置目标停顿时间，默认200ms<br>-XX:G1HeapRegionSize 设置小堆区大小，这个值为 2 的次幂<br>-XX:InitiatingHeapOccupancyPercent 当整个堆内存使用达到一定比例，开始回收垃圾。默认45%<br>-XX:ConcGCThreads：表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 其他参数</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>XX:AutoBoxCacheMax：用于加大 IntegerCache，默认缓存-128到127</p>
</li>
<li><p>Djava.security.egd=file:/dev/./urandom：使用 urandom 随机生成器，在进行随机数获取时，速度会更快。</p>
</li>
<li><p>XX:-OmitStackTraceInFastThrow：用于减少异常栈的输出，并进行合并。虽然会对调试有一定的困扰，但能在发生异常时显著增加性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### G1运行的JVM启动命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>java <br>   -XX:+UseG1GC <br>   -XX:MaxGCPauseMillis=100 <br>   -XX:InitiatingHeapOccupancyPercent=45 <br>   -XX:G1HeapRegionSize=16m <br>   -XX:+ParallelRefProcEnabled <br>   -XX:MaxTenuringThreshold=3 <br>   -XX:+AlwaysPreTouch <br>   -Xmx5440M <br>   -Xms5440M <br>   -XX:MaxMetaspaceSize=256M <br>   -XX:MetaspaceSize=256M <br>   -XX:MaxDirectMemorySize=100M <br>   -XX:ReservedCodeCacheSize=268435456 <br>   -XX:-OmitStackTraceInFastThrow <br>   -Djava.security.egd=file:/dev/./urandom <br>   -verbose:gc <br>   -XX:+PrintGCDetails <br>   -XX:+PrintGCDateStamps <br>   -XX:+PrintGCApplicationStoppedTime <br>   -XX:+PrintGCApplicationConcurrentTime  <br>   -XX:+PrintTenuringDistribution <br>   -XX:+PrintClassHistogramBeforeFullGC <br>   -XX:+PrintClassHistogramAfterFullGC <br>   -Xloggc:/tmp/logs/gc_%p.log <br>   -XX:+HeapDumpOnOutOfMemoryError <br>   -XX:HeapDumpPath=/tmp/logs <br>   -XX:ErrorFile=/tmp/logs/hs_error_pid%p.log <br>   -Djava.rmi.server.hostname=127.0.0.1 <br>   -Dcom.sun.management.jmxremote <br>   -Dcom.sun.management.jmxremote.port=14000 <br>   -Dcom.sun.management.jmxremote.ssl=false <br>   -Dcom.sun.management.jmxremote.authenticate=false <br>   -javaagent:/opt/test.jar <br>   MainRun</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### GC日志分析</span><br><span class="line"></span><br><span class="line">GCLog文件拿到`gceasy.io`在线网站上即可展示图形化结果，方便分析。</span><br><span class="line"></span><br><span class="line">例子1：老年代问题-溢出，GC之后，堆空间还一直上升。</span><br><span class="line"></span><br><span class="line">![image-20210919100635161](https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/e4aolcp1xVZs92z.png)</span><br><span class="line"></span><br><span class="line">### 堆内存分析</span><br><span class="line"></span><br><span class="line"> jmap 可以 dump 一份内存，然后使用 MAT 工具进行具体原因的分析。mat可单独安装使用</span><br><span class="line"></span><br><span class="line">### 生产垃圾回收器配置</span><br><span class="line"></span><br><span class="line">1. 内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的 2/3，超过 8GB 的堆，优先选用 G1。</span><br><span class="line">2. 然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。（G1不用）</span><br><span class="line">3. 接下来是专项优化，判断的主要依据是系统容量、访问延迟、吞吐量等，如果服务是高并发的，对 STW 的时间会非常敏感。我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，很容易定位到问题。</span><br><span class="line"></span><br><span class="line">#### 可能的问题</span><br><span class="line"></span><br><span class="line">- 进程占用的内存资源比使用 Xmx 设置得要多，进行堆外内存排查。</span><br><span class="line">- jstack 可以获取 JVM 的执行栈，并且能够看到线程的一些阻塞状态。arthas 进行瞬时态的获取，定位到瞬时故障。</span><br><span class="line"></span><br><span class="line">## 问题排查</span><br><span class="line"></span><br><span class="line">### 故障现场保留</span><br><span class="line"></span><br><span class="line">问题与系统相关的变更收集：代码变更、网络变更，数据量变化。</span><br><span class="line"></span><br><span class="line">历史态：CPU、系统内存</span><br><span class="line"></span><br><span class="line">瞬时态：lsof、heap</span><br><span class="line"></span><br><span class="line">### GC监控</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### CPU飙升排查</span><br><span class="line"></span><br><span class="line">场景：</span><br><span class="line"></span><br><span class="line">- 高并发下启用SWAP，使用内存时一直与磁盘上的虚拟内存打交道。速度很慢</span><br><span class="line">- GC频繁</span><br><span class="line">  - 大量请求生成大量对象，堆内存满了，GC回收对象少，一直GC</span><br><span class="line">  - 内存泄漏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">排查过程：</span><br><span class="line"></span><br><span class="line">1. top命令查找进程,Shift+P 排序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  top</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. top -Hp #pid 查找占用CPU最多的线程ID</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  top -Hp #pid</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. printf 函数，将十进制的 tid 转化成十六进制。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  printf %x $tid</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 使用 jstack 命令，查看 Java 进程的线程栈。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  jstack $pid &gt;$pid.log</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 使用 less 命令查看生成的文件，并查找刚才转化的十六进制 tid，找到发生问题的线程上下文。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  less $pid.log</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 把内存 dump 一份下来，使用 MAT 等工具分析具体原因了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  jmap </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 进程死掉，本身没留下信息</span><br><span class="line"></span><br><span class="line">- 依靠linux的dmesg信息</span><br><span class="line"></span><br><span class="line">- 死亡之前的一些监控信息和日志信息。 </span><br><span class="line"></span><br><span class="line">### OOM排查</span><br><span class="line"></span><br><span class="line">区域，常见场景，排查过程</span><br><span class="line"></span><br><span class="line">#### 区域</span><br><span class="line"></span><br><span class="line">虚拟机栈、本地方法栈、方法区、直接内存、堆</span><br><span class="line"></span><br><span class="line">#### 常见场景</span><br><span class="line"></span><br><span class="line">- 错误的引用方式，发生了内存泄漏。没有及时的切断与 GC Roots 的关系。</span><br><span class="line">  - 内存容量太小</span><br><span class="line">  - 错误的引用方式，发生了内存泄漏。</span><br><span class="line">    - 比如线程池里的线程，在复用的情况下忘记清理 ThreadLocal 的内容。</span><br><span class="line">    - 静态HashMap缓存</span><br><span class="line">  - 接口没有进行范围校验，外部传参超出范围。比如数据库查询时的每页条数等。</span><br><span class="line"></span><br><span class="line">#### 溢出模拟</span><br><span class="line"></span><br><span class="line">##### 堆老年代溢出</span><br><span class="line"></span><br><span class="line">![image-20210919100635161](https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/e4aolcp1xVZs92z.png)</span><br><span class="line"></span><br><span class="line">##### 元空间溢出</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>XX:MaxMetaspaceSize=16M</p>
</li>
<li><p>XX:MetaspaceSize=16M</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">Dumping heap to d:\java_pid25244.hprof ...</span><br><span class="line">Heap dump file created [13560045 bytes in 0.064 secs]</span><br><span class="line">Exception in thread &quot;Thread-2&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line"></span><br><span class="line">![image-20210919155158024](https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/9WZNmHRXTavfexI.png)</span><br><span class="line"></span><br><span class="line">##### 直接内存溢出</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>XX:MaxDirectMemorySize=30M</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Exception in thread &quot;Thread-2&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line"></span><br><span class="line">##### 栈溢出</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Xss128k</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line"></span><br><span class="line">##### 进程异常退出</span><br><span class="line"></span><br><span class="line">什么都没留下。</span><br><span class="line"></span><br><span class="line">- 原因: 和 Linux 的内存管理有关。随着使用内存越用越多。当 SWAP 也用的差不多了，会尝试释放 cache；当这两者资源都耗尽。oom-killer 会在系统内存耗尽的情况下，选择性的干掉一些进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="查看被动终结进程信息"><a href="#查看被动终结进程信息" class="headerlink" title="查看被动终结进程信息"></a>查看被动终结进程信息</h1><p> dmesg -T<br> ```</p>
</li>
<li><p>直接调用 System.exit() 函数。</p>
</li>
<li><p>没有使用<code>nohup</code>启动</p>
</li>
<li><p>关闭服务的时候，使用了“kill -9”，应该使用“kill -15”。</p>
</li>
</ul>
<h4 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h4><h3 id="堆外内存排查"><a href="#堆外内存排查" class="headerlink" title="堆外内存排查"></a>堆外内存排查</h3><h4 id="使用堆外内存场景"><a href="#使用堆外内存场景" class="headerlink" title="使用堆外内存场景"></a>使用堆外内存场景</h4><p>Metaspace内存</p>
<ul>
<li>Spring 等一些使用动态代理的框架生成了很多类</li>
</ul>
<p>直接内存：</p>
<ul>
<li><p>Unsafe 类申请的直接内存。如：native方法</p>
</li>
<li><p>JNI 对直接内存的操作。</p>
</li>
<li><p>netty申请的内存。</p>
</li>
</ul>
<p>外部的应用程序</p>
<ul>
<li>使用了 Process 接口，直接调用了外部的应用程序</li>
</ul>
<h4 id="排查方法"><a href="#排查方法" class="headerlink" title="排查方法"></a>排查方法</h4><p> top 命令，看 RES 段占用的值，如果这个值大大超出我们设定的最大堆内存，则证明堆外内存占用了很大的区域。</p>
<p> gdb 命令可以将物理内存 dump 下来，通常能看到里面的内容。</p>
<p>更加复杂的分析可以使用 Perf 工具，或者谷歌开源的 GPerftools。找到那些申请内存最多的 native 函数。</p>
<h2 id="JVM问题"><a href="#JVM问题" class="headerlink" title="JVM问题"></a>JVM问题</h2><ol>
<li>什么场景下会触发 FullGC？<ol>
<li>年轻代晋升时，或大对象、大数组转入时，老年代空间不足</li>
<li>1.7永久代空间不足，1.8元空间不足</li>
<li>年轻代晋升时，本地晋升1MB，老年代剩余5MB，但统计之前晋升平均大小（如6MB）大于老年代剩余空间（如5MB）；</li>
</ol>
</li>
<li>如何防止FullGC<ol>
<li>合理设计和使用数据结构<ol>
<li>不要创建过大的对象及数组</li>
<li>频繁创建和销毁的对象使用对象池和缓存。如Spring的IOC容器，基础数据查询缓存。</li>
</ol>
</li>
<li>避免时间长操作，可以采用异步处理、分批处理减少单次操作耗时</li>
<li>定期分析内存使用情况</li>
</ol>
</li>
<li>Java8为什么用元空间取代了方法区<br>直接原因：HotSpot和JRockit代码合并，JRockit中无方法区<br>元空间优点：<ol>
<li>方法区从JVM内存移到了本地内存中，内存上限不再需要是固定的，减少方法区内存不足</li>
<li>元空间采用了动态调整内存逻辑，资源利用率高，扩展性强</li>
<li>方法区的垃圾回收从FullGC 改为了底层垃圾收集器并发进行</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机基本原理</title>
    <url>/2024/01/10/212Java%E8%AF%AD%E8%A8%80/JVM/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>JVM</p>
<span id="more"></span>

<h1 id="Java虚拟机基本原理"><a href="#Java虚拟机基本原理" class="headerlink" title="Java虚拟机基本原理"></a>Java虚拟机基本原理</h1><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231114163800316.png" alt="image-20231114163800316"></p>
<h2 id="1-Java代码运行"><a href="#1-Java代码运行" class="headerlink" title="1.Java代码运行"></a>1.Java代码运行</h2><p>机器码：CPU能理解的代码格式。机器码是一个个的字节。</p>
<p>C语言运行：编译为机器码，在机器上执行。为了理解机器码，可以用反汇编工具将机器码反编译为汇编代码。</p>
<p>Java语言运行的初始设计：设计一个面向Java语言的特性的虚拟机，将Java代码转化为虚拟机能识别的指令序列，即Java字节码（.class文件)。</p>
<p>Java虚拟机可以由硬件实现，但更为常见的是运行在现有平台windows、linux上。</p>
<p>虚拟机的好处：</p>
<ol>
<li>跨平台</li>
<li>代码托管环境。<ol>
<li>代码运行</li>
<li>无关业务逻辑，而代码需要的处理（内存管理，垃圾回收，数组越界，动态类型，安全权限）</li>
</ol>
</li>
<li>利用运行信息优化代码执行效率。</li>
</ol>
<h3 id="Java虚拟机如何运行Java字节码"><a href="#Java虚拟机如何运行Java字节码" class="headerlink" title="Java虚拟机如何运行Java字节码"></a>Java虚拟机如何运行Java字节码</h3><p>虚拟机主要区域划分：</p>
<ol>
<li>方法区</li>
<li>堆</li>
<li>PC寄存器（程序计数器）</li>
<li>Java方法栈</li>
<li>本地方法栈（native方法）</li>
</ol>
<p>虚拟机的执行：</p>
<ol>
<li>加载。将class文件加载到虚拟机中的方法区。</li>
<li>运行。<ol>
<li>调用进入一个Java方法，Java虚拟机在当前线程的Java方法栈中生成一个栈帧，用来存放局部变量和字节码的操作数。</li>
<li>当退出当前执行的方法时，Java虚拟机弹出当前线程的当前栈帧，并舍弃。</li>
</ol>
</li>
</ol>
<p>字节码→机器码：</p>
<p>字节码无法直接在硬件上执行。是虚拟机可识别的操作码。类似于机器可识别的机器码。</p>
<p>字节码转化为机器码有两种方式：</p>
<ol>
<li>解释执行。运行时，逐行解释为机器码。优点：无需等待编译。</li>
<li>即时编译（JIT）。将一个方法中包含的所有字节码编译为机器码后再执行。优点：峰值运行速度快。</li>
</ol>
<p>大部分代码使用解释执行。执行次数多的代码会被即时编译先先编译为机器码，之后直接执行机器码。</p>
<p>优点：即时编译可以收集运行时信息，理论上，即时编译后的代码比C++运行速度更高。</p>
<p>Java7开始，HotSpot默认采用分层编译：热点方法先被C1编译，然后C1编译后的热点方法进一步被C2编译。</p>
<p>HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。</p>
<h2 id="2-Java基本类型"><a href="#2-Java基本类型" class="headerlink" title="2.Java基本类型"></a>2.Java基本类型</h2><p>Java之前的语言Smalltalk，万物皆对象</p>
<p>基本类型：工程上的考虑，速度和内存占用比引用类型的性能好</p>
<p>boolean。Java虚拟机使用1位int的数值0,1来表示 false，true。高位到地位的转换，使用掩码（去除高位）实现。</p>
<p>浮点值的运算</p>
<ol>
<li>+0.0F</li>
<li>-0.0F</li>
<li>NaN</li>
</ol>
<p>占用内存：</p>
<ul>
<li>栈上64位机器，boolean,byte,char,short,int都占用8个字节</li>
<li>堆上byte1个字节，char,short是2个字节，int8个字节</li>
</ul>
<p>加载：</p>
<p>Java 虚拟机的算数运算几乎全部依赖于操作数栈。我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。</p>
<h2 id="3-类加载过程"><a href="#3-类加载过程" class="headerlink" title="3.类加载过程"></a>3.类加载过程</h2><p>Java语言类型：</p>
<p>基本类型</p>
<p>引用类型</p>
<ol>
<li>类</li>
<li>接口</li>
<li>数组类</li>
<li>泛型</li>
</ol>
<p>基本类型是JVM直接定义好的。数组类由JVM直接生成。</p>
<p>类加载器加载的类型：类、接口</p>
<p>类字节流形式：.class文件，程序内部生成，网络字节流</p>
<ol>
<li><p>加载</p>
<p>读取各类字节流，用类加载器加载到JVM中。</p>
<p>类加载器分类：</p>
<ol>
<li><p>启动类加载器</p>
<p>C++编写的bootstrap class loader。</p>
</li>
<li><p>扩展类加载器（Java9升级为平台类加载器）</p>
</li>
<li><p>应用类加载器</p>
<p>加载应用程序路径下的类。主要指系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径</p>
</li>
<li><p>自定义类加载器</p>
</li>
</ol>
<p>双亲委派机制：优先用自己的父类加载器去加载类，无法找到时，再自己去加载</p>
<p>类的唯一性是由类加载器实例以及类的全名一同确定的。</p>
</li>
<li><p>链接</p>
<ol>
<li><p>验证</p>
<p>验证类是否符合Java虚拟机规范</p>
</li>
<li><p>准备</p>
<p>静态字段内存分配；实现虚方法的动态绑定的方法表</p>
</li>
<li><p>解析</p>
<p>编译生成的类之间的符号引用改为实际引用</p>
</li>
</ol>
</li>
<li><p>初始化</p>
<p>静态字段、常量赋值。</p>
<p>其他直接赋值操作，执行所有静态代码块中的代码</p>
</li>
</ol>
<h2 id="4-5-JVM如何执行方法"><a href="#4-5-JVM如何执行方法" class="headerlink" title="4-5.JVM如何执行方法"></a>4-5.JVM如何执行方法</h2><h3 id="方法编译"><a href="#方法编译" class="headerlink" title="方法编译"></a>方法编译</h3><ul>
<li><p>重载方法</p>
<ul>
<li><p>定义：Java语言：相同名称，不同参数</p>
</li>
<li><p>重载方法的选择</p>
<ol>
<li>不考虑自动拆装箱和可变长参数下选取重载方法</li>
<li>1中未找到，则可考虑拆装箱。</li>
<li>2中未找到，考虑拆装箱+可变长参数</li>
</ol>
<p>一个阶段中找到了多个方法，则选择一个形式参数类型最为贴切的方法。优先选择更明确的子类。</p>
</li>
</ul>
</li>
<li><p>重写方法</p>
<ul>
<li><p>定义：</p>
<ul>
<li>JVM：相同名称，相同参数且返回值类型相同</li>
</ul>
</li>
<li><p>重写方法的选择</p>
</li>
</ul>
</li>
</ul>
<h3 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h3><p>JVM如何识别方法：类名+方法名+方法描述符（参数类型+返回类型）</p>
<p>静态绑定的条件：私有实例方法、构造方法、静态方法、final修饰的方法、接口默认方法</p>
<p>方法调用的五种指令：</p>
<ol>
<li>invokestatic：静态方法</li>
<li>invokespecial:私有实例方法、构造器、接口默认方法、使用super关键字调用父类的实例方法或者构造器</li>
<li>invokevirtual：非私有实例方法</li>
<li>invokeinterface:接口方法</li>
<li>invokedynamic：动态方法</li>
</ol>
<p>符号引用解析为实际引用：</p>
<p>方法指向类C。1,2,3指令的解析：</p>
<ol>
<li><p>在类中查找符合名字和描述符的方法</p>
</li>
<li><p>在C的父类中继续搜索，直到Object类</p>
</li>
<li><p>在C所实现或间接实现的接口中搜索非私有、非静态方法，找到多个时，任意返回一个。</p>
<p>C所实现或间接实现的接口？？？</p>
</li>
</ol>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>invokevirtual、invokeinterface</p>
<p>动态绑定：在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。</p>
<p>需要动态绑定的方法：非final修饰的invokevirtual、invokeinterface</p>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231114103508468.png" alt="image-20231114103508468"></p>
<p>每个类都有一个方法表，存储索引和当前类及其祖先类中非私有的实例方法（包括抽象方法）的对应关系。</p>
<p>对于重写的父类方法，子类的索引和父类的索引值相同。</p>
<p>解析符号引用是将符号值转化为方法表的索引值。（实际上不是索引值）</p>
<p>加载中第二步链接中的第二个阶段，使用方法表这种数据结构提供方法之间的引用的索引值。</p>
<h3 id="动态绑定相对于静态绑定的额外操作"><a href="#动态绑定相对于静态绑定的额外操作" class="headerlink" title="动态绑定相对于静态绑定的额外操作"></a>动态绑定相对于静态绑定的额外操作</h3><ol>
<li>访问栈上的调用者</li>
<li>读取调用者的动态类型</li>
<li>读取该类型的方法表</li>
<li>读取方法表中某个索引值所对应的目标方法</li>
</ol>
<h3 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h3><p>用途：加快动态绑定。</p>
<p>原理：缓存虚方法调用中调用者的动态类型，以及该类型对应的方法。</p>
<p>单态缓存：只缓存了一种动态类型以及它所对应的目标方法。JVM使用的是单态缓存。</p>
<p>多态方法，遇到缓存中类型不匹配时，退化为不使用缓存，使用方法表找目标方法。</p>
<h3 id="调用方法开销"><a href="#调用方法开销" class="headerlink" title="调用方法开销"></a>调用方法开销</h3><p>内联缓存无法消除调用方法开销。方法内联可以消除</p>
<ol>
<li>记录程序在方法中的位置。</li>
<li>创建栈帧，压入、弹出栈帧</li>
</ol>
<h2 id="6-异常"><a href="#6-异常" class="headerlink" title="6.异常"></a>6.异常</h2><h3 id="遇到异常时Java代码执行"><a href="#遇到异常时Java代码执行" class="headerlink" title="遇到异常时Java代码执行"></a>遇到异常时Java代码执行</h3><p>try,catch,finaly</p>
<ol>
<li>try</li>
<li>挨个遍历catch</li>
<li>finaly</li>
<li>重新抛出异常</li>
</ol>
<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>Error，涵盖程序不应捕获的异常。当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。<br>Exception，涵盖程序可能需要捕获并且处理的异常。<br><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/20231228151409.png"></p>
<p>Throwable</p>
<p>Exception error</p>
<p>RunException</p>
<h3 id="JVM中遇到异常的执行"><a href="#JVM中遇到异常的执行" class="headerlink" title="JVM中遇到异常的执行"></a>JVM中遇到异常的执行</h3><p>每个类的方法编译时，都会构建异常表。每捕获一个异常，会有一条信息。    </p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231114162239034.png" alt="image-20231114162239034"></p>
<p>遇到异常时，JVM从上到下遍历该方法的异常表，匹配到相应类型时，程序运行交给此类型对应的字节码；未找到时，弹出刚方法的栈帧，接着遍历当前方法的异常表</p>
<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>好处：</p>
<ol>
<li>简化关闭资源。</li>
<li>自动添加了supressed异常（避免原异常消失）。</li>
</ol>
<h2 id="7-反射"><a href="#7-反射" class="headerlink" title="7.反射"></a>7.反射</h2><h3 id="反射方法使用"><a href="#反射方法使用" class="headerlink" title="反射方法使用"></a>反射方法使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;？&gt; aclass = Class.forName(&quot;Reflect&quot;);</span><br><span class="line">Method method = aclass.getMethod(&quot;test&quot;,int.class);</span><br><span class="line">method.invoke(null, 0);</span><br></pre></td></tr></table></figure>

<h3 id="反射场景"><a href="#反射场景" class="headerlink" title="反射场景"></a>反射场景</h3><p>接口访问的日志记录，我使用了AOP，里边用到了反射的invoke方法</p>
<p>idea中代码可用字段提示。</p>
<p>spring依赖反转的实现</p>
<h3 id="反射实现与性能"><a href="#反射实现与性能" class="headerlink" title="反射实现与性能"></a>反射实现与性能</h3><ul>
<li><p>具体实现：</p>
<ul>
<li><p>本地实现：</p>
<p>native，使用了c++。先调用委派实现，然后调用本地实现，然后进入目标方法</p>
<ul>
<li>优点：是第一次使用动态实现的3-4倍。</li>
</ul>
</li>
<li><p>动态实现：</p>
<p>先生成字节码，然后直接调用目标方法。</p>
<ul>
<li>优点：生成字节码后，速度是本地实现的20倍。动态实现无需经过Java到C++再到Java的切换</li>
</ul>
</li>
</ul>
</li>
<li><p>委派实现：为了在本地实现和动态实现之间动态切换，在本地实现、动态实现上而封装的。</p>
</li>
</ul>
<p>性能差距：1.3→6.7</p>
<p>指定动态实现：-Dsun.reflect.inflationThreshold= 来调整。默认值15</p>
<p>反射调用不使用本地实现机制：-Dsun.reflect.noInflation=true</p>
<p>修改存储动态实现个数：-XX:TypeProfileWidth。默认值2</p>
<h4 id="影响反射性能"><a href="#影响反射性能" class="headerlink" title="影响反射性能"></a>影响反射性能</h4><ol>
<li>方法内联，目标方法是否可内联到当前方法中</li>
<li>拆装箱</li>
<li>变量逃逸分析，是否可优化为栈上分配</li>
<li>权限检查。method.setAccessible(true);  // 关闭权限检查</li>
</ol>
<h2 id="8-9-JVM执行方法中的invokedynamic指令"><a href="#8-9-JVM执行方法中的invokedynamic指令" class="headerlink" title="8-9 JVM执行方法中的invokedynamic指令"></a>8-9 JVM执行方法中的invokedynamic指令</h2><h3 id="方法句柄"><a href="#方法句柄" class="headerlink" title="方法句柄"></a>方法句柄</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodHandle</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethodHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line"></span><br><span class="line">        MethodType methodType = MethodType.methodType(<span class="keyword">void</span>.class, Object.class);</span><br><span class="line"></span><br><span class="line">        MethodHandle methodHandle = l.findVirtual(MethodHandleTest.class, <span class="string">&quot;testMethodHandle&quot;</span>, methodType);</span><br><span class="line"></span><br><span class="line">        methodHandle.invokeExact(<span class="keyword">new</span> MethodHandleTest(), <span class="keyword">new</span> Object());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>方法句柄是一个强类型的，能够被直接执行的引用 [2]。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。</p>
<p>invokeExact：Java 编译器会根据所传入参数的声明类型来生成方法描述符。</p>
<p> invoke：自动适配参数类型</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>方法句柄没有运行时权限检查，因此，应用程序需要负责方法句柄的管理。</p>
<p>方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。</p>
<h3 id="调用invokedynamic指令的实现"><a href="#调用invokedynamic指令的实现" class="headerlink" title="调用invokedynamic指令的实现"></a>调用invokedynamic指令的实现</h3><p>java7引入invokedynamic。</p>
<p>每一条 invokedynamic 指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。</p>
<p>将调用点（CallSite）是一个抽象的 Java 类，原本由 Java 虚拟机控制的方法调用以及方法链接暴露给了应用程序控制。</p>
<h3 id="lamada实现-amp-性能"><a href="#lamada实现-amp-性能" class="headerlink" title="lamada实现&amp;性能"></a>lamada实现&amp;性能</h3><p>将函数式接口内容生成静态函数，然后用invokedynamic指令调用。</p>
<p>lamada也会被方法内联和逃逸分析优化。</p>
<p>性能基本没差别。</p>
<h2 id="10Java对象的内存使用"><a href="#10Java对象的内存使用" class="headerlink" title="10Java对象的内存使用"></a>10Java对象的内存使用</h2><h3 id="对象内容"><a href="#对象内容" class="headerlink" title="对象内容"></a>对象内容</h3><ul>
<li><p>隐藏的对象头</p>
<ul>
<li><p>标记字段</p>
<p>占用8个字节</p>
<ul>
<li>锁信息</li>
<li>哈希码</li>
<li>GC信息</li>
</ul>
</li>
<li><p>类型指针</p>
<p>指向该对象的类。</p>
<p>64位机器，默认使用压缩指针，占用4个字节。</p>
<p>起始位置默认8字节对齐，可以标记 2的32次方 * 8 个 = 32G内存的地址。-XX:ObjectAlignmentInBytes，默认值为 8</p>
</li>
</ul>
</li>
<li><p>字段</p>
<ul>
<li>父类所有字段</li>
<li>自身所有字段</li>
</ul>
</li>
</ul>
<h3 id="对象占用内存举例"><a href="#对象占用内存举例" class="headerlink" title="对象占用内存举例"></a>对象占用内存举例</h3><p>64位机器，32G内存，默认8字节对齐</p>
<p>Integer，对象头占用12字节，int属性占用4个字节。共占用16个字节</p>
<h3 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h3><p>优点：节省对齐可能浪费的空间</p>
<p>规则：</p>
<ol>
<li><p>如果一个字段占用C字节，那么该字段的偏移量需要对齐至对象起始地址的NC。</p>
<p>Long类型的long字段，对象占了12字节，但long字段需要从16字节开始，中间空4个字节。</p>
</li>
<li><p>子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。</p>
</li>
<li><p>使用了压缩指针的64位机器，子类第一个字段对齐至4N；关闭压缩指针，子类第一个字段对齐至8N。</p>
</li>
</ol>
<h2 id="11-12垃圾回收"><a href="#11-12垃圾回收" class="headerlink" title="11-12垃圾回收"></a>11-12垃圾回收</h2><p>堆空间消亡对象的内存回收，回收后用于新对象。</p>
<h3 id="垃圾识别"><a href="#垃圾识别" class="headerlink" title="垃圾识别"></a>垃圾识别</h3><h4 id="引用技术法"><a href="#引用技术法" class="headerlink" title="引用技术法"></a>引用技术法</h4><p>缺点：循环引用的对象，即使是真的垃圾，也识别不了。</p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><ul>
<li><p>介绍：除了roots对象可达的对象外，其他对象为垃圾对象。</p>
</li>
<li><p>roots对象种类</p>
<p>可从堆外指向堆内的堆外对象</p>
<ul>
<li>栈帧里的局部变量</li>
<li>已加载类的静态变量</li>
<li>JNI handles</li>
<li>未停止多线程中的对象</li>
</ul>
</li>
</ul>
<h5 id="stop-the-wold和安全点"><a href="#stop-the-wold和安全点" class="headerlink" title="stop-the-wold和安全点"></a>stop-the-wold和安全点</h5><ul>
<li><p>stop-the-wold</p>
<ul>
<li>介绍：垃圾回收线程等待所有线程进入安全点，再执行标记和清理。</li>
<li>原因：可达性分析对象时，对象的引用有可能被修改，有未标记为可达，却在清理时被修改为可达，这时被当成垃圾回收就出问题了。所以可以被修改的地方，需要暂停下来，等标记清理完成后，再继续执行。</li>
</ul>
</li>
<li><p>安全点：使堆栈不会被修改的机制。</p>
<p>检测的位置接收到要求停留在安全点时，挂起当前线程。</p>
<ul>
<li>使用JNI调用本地方法时：入口处进行安全点检测</li>
<li>解释执行字节码</li>
<li>执行即时编译器生成的机器码：生产机器码时，子啊生成代码的方法出口和非计数循环插入安全点检测</li>
<li>线程阻塞</li>
</ul>
</li>
</ul>
<h3 id="垃圾清除"><a href="#垃圾清除" class="headerlink" title="垃圾清除"></a>垃圾清除</h3><p>方式：</p>
<ul>
<li><p>直接清除</p>
<ul>
<li>缺点：内存碎片，总内存够，但无法分配</li>
</ul>
</li>
<li><p>压缩（整理）</p>
<p>即把存活的对象聚集到内存区域的起始位置</p>
<ul>
<li>缺点：压缩算法的性能开销</li>
</ul>
</li>
<li><p>复制</p>
<p>把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。</p>
<ul>
<li>缺点：堆空间利用率低。</li>
</ul>
</li>
</ul>
<h3 id="垃圾分代"><a href="#垃圾分代" class="headerlink" title="垃圾分代"></a>垃圾分代</h3><p>程序中对象实际生存时间、次数不同。</p>
<p>根据存在时间，次数将对象分为年轻代、老年代。根据不同代可以使用不同的回收算法加快回收。比如：年轻代使用复制算法；老年代使用清除、压缩算法。</p>
<p>年轻代：存在时间很短、使用次数很少就消亡。比如：一次列表查询，返回给前端的实体对象。</p>
<p>老年代：存在时间很长、使用次数很多。比如：数据库配置类生成的对象，程序运行期间一直被使用。</p>
<h3 id="年轻代回收"><a href="#年轻代回收" class="headerlink" title="年轻代回收"></a>年轻代回收</h3><h4 id="年轻代空间划分"><a href="#年轻代空间划分" class="headerlink" title="年轻代空间划分"></a>年轻代空间划分</h4><p>初始值 E（8） ：S（2（From（1）：To (1)）。程序运行期间，JVM根据对象生成速度，自动调整E 和 S区大小。</p>
<p>可设置参数固定E区 和 S区大小。</p>
<p>默认对象复制超过15次，或者年轻代单个Survivor区空间占用大于50%时，复制次数多的会升级为老年代。</p>
<h4 id="对象申请空间"><a href="#对象申请空间" class="headerlink" title="对象申请空间"></a>对象申请空间</h4><p>堆空间线程共享，但不能让两个线程的私有对象共用相同的内存，即避免线程内存竞争。</p>
<ol>
<li>首次new 对象时，线程向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。</li>
<li>接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。</li>
<li>如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。</li>
</ol>
<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><ul>
<li><p>原因</p>
<p>老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。可以避免扫描整个老年代。</p>
</li>
<li><p>实现</p>
<p>将整个堆划分为每个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。有指向新生代对象引用的卡标识为脏卡。</p>
<p>在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。</p>
<p>然后复制存活对象到另一个S区，并更新指向该对象的引用，更新引用的同时，设置引用所在的卡的标识位为脏卡。</p>
</li>
</ul>
<h4 id="缓存行实现"><a href="#缓存行实现" class="headerlink" title="缓存行实现"></a>缓存行实现</h4><p>byte数组实现，64B的缓存行。可以加载64张卡，即32KB内存。任意线程对缓存行的引用更新操作，都会让整个缓存行中的内容写回主存。</p>
<h2 id="13Java内存模型"><a href="#13Java内存模型" class="headerlink" title="13Java内存模型"></a>13Java内存模型</h2><p>乱序执行种类：</p>
<ul>
<li>即时编译器重排序</li>
<li>处理器乱序执行</li>
<li>内存系统重排序</li>
</ul>
<p>即时编译器对代码不影响单线程结果的乱序优化：</p>
<ol>
<li><p>延迟加载数据到寄存器，减少栈空间占用时间</p>
<p>可能在 b = 1之后再将a加载到寄存器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>,b =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test&#123;</span><br><span class="line">    <span class="keyword">int</span> z1 = a;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>无意义语句移出循环</p>
</li>
</ol>
<h3 id="代码顺序"><a href="#代码顺序" class="headerlink" title="代码顺序"></a>代码顺序</h3><p>后边的代码依赖（读或写）到了前边的代码时，代码的顺序性规定。</p>
<p>如果后者没有观测前者的运行结果，即后者没有数据依赖于前者，那么它们可能会被重排序。</p>
<ul>
<li>单线程代码的顺序按语法从上至下</li>
<li>解锁在加锁之前</li>
<li>volatile字段的写操作在此字段的读操作之前</li>
<li>线程的启动操作在该线程的第一个操作之前</li>
<li>线程的最后一个操作在线程终止之前</li>
<li>A线程对B线程的中断操作在B线程接收中断时间之前</li>
<li>构造器的最后一个操作在析构器之前。</li>
<li>happens-before具有传递性</li>
</ul>
<h3 id="内存模型的实现"><a href="#内存模型的实现" class="headerlink" title="内存模型的实现"></a>内存模型的实现</h3><p>Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。</p>
<p>内存屏障种类：读读、读写、写写、写读</p>
<p>即时编译器会针对前面提到的每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。有内存屏障，即时编译器不会重排序。</p>
<p>处理器：x86_64架构内存屏障：只有写读。对与x86_64架构机器，只有写读屏障会替换为具体的指令。</p>
<p>JVM使用的指令是lock add DWORD PTR [rsp],0x0。即强制刷新处理器的写缓存到主内存。主内存写操作后无效化其他处理器对此数据所在缓存行的数据。</p>
<h4 id="锁、volatile，final"><a href="#锁、volatile，final" class="headerlink" title="锁、volatile，final"></a>锁、volatile，final</h4><p>在解锁时，Java 虚拟机需要强制刷新缓存。</p>
<p>volatile 字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操作。适合读多写少。</p>
<p>volatile标记的字段不会被分配到寄存器中，每次加载到寄存器计算需要去内存读取。</p>
<h2 id="sychronized实现"><a href="#sychronized实现" class="headerlink" title="sychronized实现"></a>sychronized实现</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/010e6380ccee4b20e70ebf3474eef600.png" alt="010e6380ccee4b20e70ebf3474eef600"></p>
<p>偏向锁→轻量级锁（自旋）→重量级锁</p>
<p>线性执行：所有线程大部分时间使用同一资源的情况。如：数据库插入大量数据，使用MQ打散拆分时，需要用顺序MQ线性执行。</p>
<p>重量级锁保证共享变量的同步。针对多个线程同时竞争同一把锁的情况。</p>
<p>轻量级锁，针对线程少量竞争同一把锁的情况。避免很快能拿到锁，却执行了耗资源的操作系统线程阻塞和唤醒操作</p>
<p>偏向锁只会在第一次请求时采用 CAS 操作，在锁对象的标记字段中记录下当前线程的地址。在之后的运行过程中，持有该偏向锁的线程的加锁操作将直接返回。</p>
<h3 id="sychronized编译"><a href="#sychronized编译" class="headerlink" title="sychronized编译"></a>sychronized编译</h3><p>锁对象编译生成的字节码包含monitorenter 指令以及多个 monitorexit 指令。</p>
<p>方法的访问标记包括 ACC_SYNCHRONIZED。该标记表示在进入该方法时，Java 虚拟机进行 monitorenter 操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java 虚拟机进行 monitorexit 操作。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>为了尽量避免昂贵的线程阻塞、唤醒操作，Java 虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。</p>
<p>与线程阻塞相比，自旋状态的线程处于运行状况，只不过跑的是无用指令。可能会浪费大量的处理器资源。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="加锁操作"><a href="#加锁操作" class="headerlink" title="加锁操作"></a>加锁操作</h4><ol>
<li>Java 虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。</li>
<li>Java 虚拟机会尝试用 CAS（compare-and-swap）操作替换锁对象的标记字段。<ol>
<li>如果是轻量级锁的状态标记，替换为锁记录地址，获取到轻量级锁；</li>
<li>如果不是<ol>
<li>该线程重复获取同一把锁。将锁记录清零，以代表该锁被重复获取。</li>
<li>其他线程持有该锁，膨胀为重量级锁，阻塞当前线程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h4><ol>
<li>当前锁记录（你可以将一个线程的所有锁记录想象成一个栈结构，每次加锁压入一条锁记录，解锁弹出一条锁记录，当前锁记录指的便是栈顶的锁记录）的值为 0，则代表重复进入同一把锁，直接返回。</li>
<li>Java 虚拟机会尝试用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址。<ol>
<li>如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。</li>
<li>如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，Java 虚拟机会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。</li>
</ol>
</li>
</ol>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时（而且 epoch 值相等，如若不等，那么当前线程可以将该锁重偏向至自己），Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。</p>
<h4 id="类偏向锁失效-amp-撤销"><a href="#类偏向锁失效-amp-撤销" class="headerlink" title="类偏向锁失效&amp;撤销"></a>类偏向锁失效&amp;撤销</h4><ul>
<li><p>失效介绍</p>
<p>如果某一类锁对象的总撤销数超过了一个阈值20（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 Java 虚拟机会宣布这个类的偏向锁失效。</p>
</li>
<li><p>失效&amp;撤销实现</p>
<p>在每个类中维护一个 epoch 值，当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。</p>
<p>在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值。</p>
<p>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态。</p>
</li>
<li><p>撤销介绍</p>
<p>如果总撤销数超过阈值40（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
</li>
</ul>
<h2 id="16-17即时编译"><a href="#16-17即时编译" class="headerlink" title="16-17即时编译"></a>16-17即时编译</h2><h3 id="五种编译"><a href="#五种编译" class="headerlink" title="五种编译"></a>五种编译</h3><ol start="0">
<li><p>解释执行</p>
</li>
<li><p>不带profiling的C1编译</p>
<p>终态，不会再被别的编译</p>
</li>
<li><p>带少量profiling(方法调用次数和循环回边计数)的C1编译。</p>
<p>比全量profiling的C1编译快30%</p>
</li>
<li><p>全量profiling的C1编译</p>
</li>
<li><p>C2编译</p>
<p>比C1编译快30%</p>
<p>终态，不会再被别的编译</p>
</li>
</ol>
<h3 id="编译的选择"><a href="#编译的选择" class="headerlink" title="编译的选择"></a>编译的选择</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231117191235574.png" alt="image-20231117191235574"></p>
<h3 id="编译的配置"><a href="#编译的配置" class="headerlink" title="编译的配置"></a>编译的配置</h3><p>关闭分层编译，会直接使用C2编译。</p>
<p>在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的和，超过由参数 -XX:CompileThreshold 指定的阈值时（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000），便会触发即时编译。</p>
<h3 id="Graal-编译-todo"><a href="#Graal-编译-todo" class="headerlink" title="Graal 编译 todo"></a>Graal 编译 todo</h3><p>Java10引入</p>
<h3 id="profilling收集种类"><a href="#profilling收集种类" class="headerlink" title="profilling收集种类"></a>profilling收集种类</h3><ol>
<li>方法调用次数</li>
<li>循环回边次数</li>
<li>分支跳转</li>
<li>instance类型判断</li>
<li>非私有实例方法调用指令、强制类型转换 checkcast 指令</li>
<li>引用类型的数组存储 aastore 指令</li>
<li>等</li>
</ol>
<h3 id="优化类别"><a href="#优化类别" class="headerlink" title="优化类别"></a>优化类别</h3><p>if else 剪枝。一直跳转一个分支，会只编译一个分支，遇到判断相同时，跳转到此条件。剪枝还会联动其他优化，如：方法内联。</p>
<p>instanceof 剪枝</p>
<h3 id="优化失败处理"><a href="#优化失败处理" class="headerlink" title="优化失败处理"></a>优化失败处理</h3><p>通过预埋陷阱，检测到执行了未优化的分支时，回退到解释执行</p>
<h3 id="instanceof-判断"><a href="#instanceof-判断" class="headerlink" title="instanceof 判断"></a>instanceof 判断</h3><p>如果 instanceof 的目标类型是 final 类型，那么 Java 虚拟机仅需比较测试对象的动态类型是否为该 final 类型。</p>
<p>如果目标类型不是 final 类型，比如说 Exception，那么 Java 虚拟机需要从测试对象的动态类型开始，依次测试该类，该类的父类、祖先类，该类所直接实现或者间接实现的接口是否与目标类型一致。</p>
<h2 id="18即时编译器的中间表达形式"><a href="#18即时编译器的中间表达形式" class="headerlink" title="18即时编译器的中间表达形式"></a>18即时编译器的中间表达形式</h2><p>编译器分为前端和后端。</p>
<p>​    前端会对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达形式，也就是 IR（Intermediate Representation ）。</p>
<p>​    后端会对 IR 进行优化，然后生成目标代码。</p>
<p>Java字节码不适合做IR，因为现代编译器一般采用静态单赋值（Static Single Assignment，SSA）IR（每个变量只能被赋值一次）。</p>
<p>即时编译器会将 Java 字节码转换成 SSA IR。</p>
<p>SSA IR可以使用工具表达为图。</p>
<p>如果是为了可读性高，无需优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x1=<span class="number">4</span>*<span class="number">1024</span> 经过常量折叠后变为 x1=<span class="number">4096</span></span><br><span class="line"></span><br><span class="line">x1=<span class="number">4</span>; y1=x1 经过常量传播后变为 x1=<span class="number">4</span>; y1=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">y1=x1*<span class="number">3</span> 经过强度削减后变为 y1=(x1&lt;&lt;<span class="number">1</span>)+<span class="function">x1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(<span class="number">2</span>&gt;<span class="number">1</span>)</span></span>&#123;y1=<span class="number">1</span>;&#125;<span class="keyword">else</span>&#123;y2=<span class="number">1</span>;&#125;经过死代码删除后变为 y1=<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="19Java字节码"><a href="#19Java字节码" class="headerlink" title="19Java字节码"></a>19Java字节码</h2><h3 id="基于栈的计算模型"><a href="#基于栈的计算模型" class="headerlink" title="基于栈的计算模型"></a>基于栈的计算模型</h3><p>每当为 Java 方法分配栈桢时，Java 虚拟机需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p>
<p>执行每一条指令之前，Java 虚拟机会提前将指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p>
<p>栈{</p>
<p>​    栈帧{</p>
<p>​        操作数栈，</p>
<p>​        局部变量数组[]</p>
<p>​    }</p>
<p>}</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>字节码程序可以将计算的结果缓存在局部变量区之中。</p>
<p>依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<h3 id="Java字节码"><a href="#Java字节码" class="headerlink" title="Java字节码"></a>Java字节码</h3><h3 id="操作数栈字节码"><a href="#操作数栈字节码" class="headerlink" title="操作数栈字节码"></a>操作数栈字节码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop // 弹出（舍弃）栈顶元素</span><br><span class="line">dup // 复制栈顶元素。常用于复制 new 指令所生成的未经初始化的引用。</span><br></pre></td></tr></table></figure>

<h4 id="变量加载-amp-存储字节码"><a href="#变量加载-amp-存储字节码" class="headerlink" title="变量加载&amp;存储字节码"></a>变量加载&amp;存储字节码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iload // 加载int类型 </span><br><span class="line">fload // 加载float类型</span><br><span class="line">aload // 加载引用类型</span><br><span class="line">istore // 存储int类型</span><br><span class="line"></span><br><span class="line">iaload // 加载int[]</span><br><span class="line">astore_1 [o] // 加载局部变量数组下标为1，名称为o的Object对象</span><br><span class="line"></span><br><span class="line">iconst // 加载-1至5之间的int值</span><br><span class="line">lconst // 加载0,1的long值</span><br><span class="line">idc // 加载常量池中的常量值</span><br></pre></td></tr></table></figure>

<h4 id="方法调用字节码"><a href="#方法调用字节码" class="headerlink" title="方法调用字节码"></a>方法调用字节码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokevirtual</span><br><span class="line">invokestatic</span><br><span class="line">invokespecial</span><br><span class="line">invokedynamic</span><br><span class="line">invokeinterface</span><br></pre></td></tr></table></figure>



<h4 id="返回字节码"><a href="#返回字节码" class="headerlink" title="返回字节码"></a>返回字节码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return //无返回值</span><br><span class="line">ireturn // 返回int</span><br><span class="line">athrow</span><br><span class="line"></span><br><span class="line">iflt 6 // 控制流指令均附带一个或者多个字节码偏移量，代表需要跳转到的位置。</span><br></pre></td></tr></table></figure>



<h4 id="计算字节码"><a href="#计算字节码" class="headerlink" title="计算字节码"></a>计算字节码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iadd // 加法，消耗栈顶的两个元素。</span><br><span class="line">iinc M N // 直接作用于局部变量区的指令是 （M 为非负整数，N 为整数）。该指令指的是将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for 循环中自增量的更新。还有自增、自减</span><br></pre></td></tr></table></figure>

<h3 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 目标类</span><br><span class="line">newarray 目标类</span><br><span class="line">anewarray 目标类 // 新建引用类型数组</span><br><span class="line">multianewarray // 新建多维数组</span><br><span class="line">instanceof 目标类</span><br><span class="line">checkcast 目标类</span><br><span class="line">monitorenter // 为栈顶对象加锁</span><br><span class="line">monitorexit // 为栈顶对象解锁</span><br><span class="line">getstatic // 静态字段访问</span><br><span class="line">getfield // 实例字段访问</span><br></pre></td></tr></table></figure>

<h2 id="20-21方法内联"><a href="#20-21方法内联" class="headerlink" title="20-21方法内联"></a>20-21方法内联</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>没有方法内联，调用一个方法前需要当前方法执行位置，为新方法创建并压入栈帧，访问字段，弹出栈帧，恢复当前方法执行。</p>
<p>方法内联不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化。</p>
<p>每当碰到方法调用字节码时，C2 将决定是否需要内联该方法调用。</p>
<p>内联越多，生成代码的执行效率越高。内联越多，编译时间越长，程序达到峰值性能的时刻将被推迟。</p>
<h3 id="方法内联规则"><a href="#方法内联规则" class="headerlink" title="方法内联规则"></a>方法内联规则</h3><ul>
<li><p>会内联</p>
<ol>
<li>自动拆箱总会被内联</li>
<li> -XX:CompileCommand 中的 inline 指令指定的方法</li>
</ol>
</li>
<li><p>不会内联</p>
<ol>
<li>调用字节码对应的符号引用未被解析</li>
<li>目标方法所在的类未被初始化</li>
<li>目标方法是 native 方法</li>
<li>Throwable 类的方法不能被其他类中的方法所内联</li>
<li>C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 -XX:MaxInlineLevel 调整），</li>
<li>C2 不支持1 层的直接递归调用（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。</li>
<li>由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法</li>
</ol>
</li>
<li><p>JVM方法内联参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:ReservedCodeCacheSize //编译生成的机器码会被部署到 Code Cache 之中。Code Cache 已满，即时编译已被关闭的警告信息（CodeCache is full. Compiler has been disabled)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231121164318808.png" alt="image-20231121164318808"></p>
</li>
</ul>
<h3 id="去虚化规则"><a href="#去虚化规则" class="headerlink" title="去虚化规则"></a>去虚化规则</h3><ol>
<li><p>类型</p>
<p>List list = new ArrayList(); </p>
<p>list.add(1);// 明确类型是 ArrayList，可以将ArrayList.add()方法进行内联</p>
</li>
<li><p>类层次分析</p>
<p>假设只有一种调用。其他可能性增加陷阱，命中陷阱，去优化。</p>
</li>
<li><p>增加条件去虚化</p>
<p>动态调用改为明确的多个if {}else{}调用来去虚化</p>
</li>
</ol>
<h2 id="22-虚拟机的intrinsic"><a href="#22-虚拟机的intrinsic" class="headerlink" title="22 虚拟机的intrinsic"></a>22 虚拟机的intrinsic</h2><p>使用高效的CPU指令替代本地实现。</p>
<p>Java9开始比较多。</p>
<p>intrinsic的本地方法也能够被方法内联。</p>
<h2 id="23-逃逸分析"><a href="#23-逃逸分析" class="headerlink" title="23 逃逸分析"></a>23 逃逸分析</h2><p>优化内容：</p>
<ul>
<li><p>锁消除</p>
</li>
<li><p>标量替换</p>
<p>方法内联后，没有逃逸出当前方法的对象。会使用标量替换来分配对象。没有使用栈上分配。</p>
<p>标量替换将原本对对象的字段的访问，替换为一个个局部变量的访问。</p>
<p>标量替换可能分配在栈上，也可能直接分配在寄存器上。标量替换分配的对像的一个个字段不再连续。</p>
</li>
<li><p>if条件部分逃逸分析（Graal编译器实现）</p>
</li>
</ul>
<p>堆上分配：堆上的内容对任何线程都是可见的。Java 虚拟机需要对所分配的堆内存进行管理。</p>
<h2 id="32JNI"><a href="#32JNI" class="headerlink" title="32JNI"></a>32JNI</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>Java 语言较难表达，甚至是无法表达的应用场景。</p>
<ol>
<li>我们希望使用汇编语言（如 X86_64 的 SIMD 指令）来提升关键代码的性能；</li>
<li>我们希望调用 Java 核心类库无法提供的，某个体系架构或者操作系统特有的功能。</li>
<li>等</li>
</ol>
<p>Java中<code>native</code>修饰的方法.</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在调用 native 方法前，Java 虚拟机需要将该 native 方法链接至对应的 C 函数上。</p>
<p>链接方式一：Java 虚拟机自动查找符合默认命名规范的 C 函数，并且链接起来。</p>
<ol>
<li>用<code>javac -h . org/example/Test.java</code>命令，将在当前文件夹（对应<code>-h</code>后面跟着的<code>.</code>）生成名为<code>org_example_Test.h</code>的头文件</li>
<li>编写.c文件，实现.h的方法</li>
<li>编译.c文件</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="系统预热作用"><a href="#系统预热作用" class="headerlink" title="系统预热作用"></a>系统预热作用</h3><p>缓存加载，C2分层编译执行，对象到老年代，偏向锁失效</p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2020/07/08/213Java%E6%A1%86%E6%9E%B6/SpringCloud/</url>
    <content><![CDATA[<p>SpringCloud</p>
<span id="more"></span>

<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><strong>描述：</strong>一套完整的微服务解决方案，一系列不同功能的微服务框架的集合。</p>
<p><strong>类别：</strong>Netflix（奈飞），Alibaba</p>
<p>源码：<a href="https://github.com/qiyisoft/sca">https://github.com/qiyisoft/sca</a></p>
<h2 id="各个组件"><a href="#各个组件" class="headerlink" title="各个组件"></a>各个组件</h2><ol>
<li>Nacos</li>
<li>Ribbon</li>
<li>OpenFeign</li>
<li>GateWay</li>
<li>Sentinel</li>
<li>SkyWalking</li>
<li>Seata</li>
<li>分布式锁</li>
<li>认证与授权  OAuth2+JWT+Security</li>
</ol>
<h3 id="1-注册中心Nacos"><a href="#1-注册中心Nacos" class="headerlink" title="1.注册中心Nacos"></a>1.注册中心Nacos</h3><p>特性，Nacos使用，Nacos的心跳机制和健康检查</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><strong>出现的背景：</strong>在以往单实例情况下，服务间通常采用点对点通信，即采用 IP+端口+接口的形式直接调用。考虑避免单点负载压力过大以及高可用的性能要求，通常会部署多实例节点保障系统的性能，但增加多实例后，调用方该如何选择哪个服务提供者进行处理呢？还有当服务提供者出现故障后，如何将后续请求转移到其他可用实例上呢？</p>
<p><strong>功能：</strong></p>
<ul>
<li><p>服务发现与管理</p>
</li>
<li><p>动态配置服务</p>
</li>
<li><p>动态DNS服务</p>
</li>
</ul>
<h4 id="Nacos注册中心使用"><a href="#Nacos注册中心使用" class="headerlink" title="Nacos注册中心使用"></a>Nacos注册中心使用</h4><h5 id="服务端部署"><a href="#服务端部署" class="headerlink" title="服务端部署"></a>服务端部署</h5><ol>
<li><p>环境准备</p>
<ol>
<li><p>操作系统CentOS7</p>
</li>
<li><p>安装JDK8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk-devel.x86_64 # 默认安装位置： /usr/lib/jvm/</span><br><span class="line"># 安装成功后验证Java版本</span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"># 编辑profile配置 JAVA_HOME 环境变量</span><br><span class="line">[root@server-1 ~]# vim /etc/profile</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.272.b10-1.el7_9.x86_64</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line"># source:在当前bash环境下读取并执行FileName中的命令。</span><br><span class="line">[root@server-1 ~]# source /etc/profile</span><br><span class="line"></span><br><span class="line"># 验证配置是否正确 ? java javac</span><br><span class="line">[root@server-1 ~]# echo $JAVA_HOME</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.272.b10-1.el7_9.x86_64</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>安装并启动</p>
<ol>
<li><p>获取安装包</p>
<p>访问 Nacos GitHub：<a href="https://github.com/alibaba/nacos/releases/%E8%8E%B7%E5%8F%96">https://github.com/alibaba/nacos/releases/获取</a> Nacos 安装包 nacos-server-1.4.0.tar.gz。</p>
</li>
<li><p>上传&amp;解压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@server-1 local]#  tar -xvf nacos-server-1.4.0.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@server-1 local]# cd nacos/bin</span><br><span class="line"># 以单点方式启动 Nacos</span><br><span class="line">[root@server-1 bin]# sh startup.sh -m standalone</span><br></pre></td></tr></table></figure>

<p>Nacos默认以后台模式启动，利用 tail 命令查看启动日志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@server-1 bin]# tail -f /usr/local/nacos/logs/start.out</span><br><span class="line">2020-12-06 21:03:18,759 INFO Tomcat started on port(s): 8848 (http) with context path &#x27;/nacos&#x27;</span><br><span class="line">2020-12-06 21:03:18,766 INFO Nacos Log files: /usr/local/nacos/nacos/logs</span><br><span class="line">2020-12-06 21:03:18,766 INFO Nacos Log files: /usr/loca/nacos/nacos/conf</span><br><span class="line">2020-12-06 21:03:18,766 INFO Nacos Log files: /usr/local/nacos/nacos/data</span><br><span class="line">2020-12-06 21:03:18,767 INFO Nacos started successfully in stand alone mode. use embedded storage</span><br></pre></td></tr></table></figure></li>
<li><p>对外开放7848/8848端口</p>
<p>8848 端口是 Nacos 对客户端提供服务的端口，7848 是 Nacos 集群通信端口，用于Nacos 集群间进行选举，检测等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@server-1 bin]# firewall-cmd --zone=public --add-port=8848/tcp --permanent</span><br><span class="line">success</span><br><span class="line">[root@server-1 bin]# firewall-cmd --zone=public --add-port=7848/tcp --permanent</span><br><span class="line">success</span><br><span class="line">[root@server-1 bin]# firewall-cmd  --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></li>
<li><p>从浏览器进入管理界面</p>
<p><a href="http://192.168.31.102:8848/nacos">http://192.168.31.102:8848/nacos</a></p>
<p>账号&amp;密码 nacos&amp;nacos</p>
<p>服务管理-&gt;服务列表，用于查看已注册微服务列表。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uZvoRUhxaAidn6J.png" alt="image-20210704204632363"></p>
</li>
</ol>
</li>
</ol>
<h5 id="微服务接入nacos"><a href="#微服务接入nacos" class="headerlink" title="微服务接入nacos"></a>微服务接入nacos</h5><ol>
<li><p>创建项目</p>
<p>idea工具，创建项目，选择Spring InitiaLizr</p>
<p>Custom可以选择阿里云镜像地址 <a href="http://start.aliyun.com/">http://start.aliyun.com</a></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IA7JXV2x534i8ky.png" alt="image-20210705063904157"></p>
</li>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- nacos依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- web 使微服务具备http相应能力 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置nacos相关属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 应用名称，默认也是在微服务中注册的微服务 ID</span><br><span class="line">spring.application.name=sample-service</span><br><span class="line"># 配置 Nacos 服务器的IP地址</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=192.168.31.102:8848</span><br><span class="line">#连接 Nacos 服务器使用的用户名、密码，默认为 nacos</span><br><span class="line">spring.cloud.nacos.discovery.username=nacos</span><br><span class="line">spring.cloud.nacos.discvery.password=nacos</span><br><span class="line">#微服务提供Web服务的端口号</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure></li>
<li><p>启动项目</p>
<p>启动日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Web 服务端口号 8081</span><br><span class="line">INFO 14188 o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8081 (http) with context path &#x27;&#x27;</span><br><span class="line">#微服务向 Nacos 注册成功，微服务 ID:sample-service</span><br><span class="line">INFO 14188  c.a.c.n.registry.NacosServiceRegistry    : nacos registry, DEFAULT_GROUP sample-service 192.168.47.1:8081 register finished</span><br><span class="line">#微服务启动成功</span><br><span class="line">INFO 14188  c.l.s.SampleServiceApplication           : Started SampleServiceApplication in 4.911 seconds (JVM running for 6.039)</span><br></pre></td></tr></table></figure></li>
<li><p>nacos查看刚刚注册的项目</p>
<p>浏览器打开 <a href="http://192.168.31.102:8848/nacos">http://192.168.31.102:8848/nacos</a> ，服务管理-服务列表</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/VBlXvnP7RG15dzM.png" alt="image-20210705065001740"></p>
</li>
</ol>
<h4 id="Nacos配置中心"><a href="#Nacos配置中心" class="headerlink" title="Nacos配置中心"></a>Nacos配置中心</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>场景：</p>
<ul>
<li>动态配置，无需重启服务</li>
<li>多实例批量修改</li>
<li>版本管理</li>
<li>配置文件多环境切换</li>
<li>变更推送</li>
<li>监听查询？</li>
</ul>
<p>微服务应用只持有应用启动的最小化配置，在应用启动时微服务应用所需的其他配置数据，诸如数据库连接字符串、各种用户名密码、IP 等信息均从配置中心远程下载。书写应用配置时不直接写入 application.yml 配置，而是直接在配置中心提供的 UI 进行设置。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><h6 id="部署配置中心"><a href="#部署配置中心" class="headerlink" title="部署配置中心"></a>部署配置中心</h6><ol>
<li><p>下载Nacos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.0.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>配置数据库，执行/nacos/conf/nacos-mysql.sql</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ebrgMFzcd8GhmJw.png" alt="image-20210715174758339"></p>
</li>
<li><p>配置Nacos数据源</p>
<p>打开 /usr/local/nacos/conf/application.properties，36行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### Count of DB: 数据库总数</span><br><span class="line">db.num=1</span><br><span class="line">### Connect URL of DB: 数据库连接,根据你的实际情况调整</span><br><span class="line">db.url.0=jdbc:mysql://192.168.31.10:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user=root</span><br><span class="line">db.password=root</span><br></pre></td></tr></table></figure></li>
<li><p>添加所有 Nacos 集群节点 IP 及端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制命令创建 cluster.conf 文件</span><br><span class="line">cp cluster.conf.example cluster.conf</span><br><span class="line"># 打开 cluster.conf，添加所有 Nacos 集群节点 IP 及端口</span><br><span class="line">vim cluster.conf</span><br><span class="line">192.168.31.10:8848</span><br></pre></td></tr></table></figure></li>
<li><p>按集群模式启动 Nacos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh /usr/local/nacos/bin/startup.sh</span><br></pre></td></tr></table></figure></li>
<li><p>访问配置页面</p>
<p><a href="http://192.168.31.10:8848/nacos/#/configurationManagement">http://192.168.31.10:8848/nacos/#/configurationManagement</a></p>
</li>
</ol>
<h6 id="微服务接入配置中心"><a href="#微服务接入配置中心" class="headerlink" title="微服务接入配置中心"></a>微服务接入配置中心</h6><ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Spring Boot Web模块 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Nacos注册中心starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Nacos配置中心starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<p>bootstrap.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># “微服务 id”-“环境名”.“文件扩展名” 三部分组合为有效的 data id，即order-service-dev.yml。data id 要和 Nacos 的设置大小写保持完全一致，这样在微服务启动时便自动会从 Nacos配置中心获取 order-service-dev.yml 配置并下载到本地完成启动过程。</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order-service #微服务id</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev #环境名</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config: #Nacos配置中心配置</span><br><span class="line">        file-extension: yml #文件扩展名</span><br><span class="line">        server-addr: 192.168.31.10:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">logging: #开启debug日志，本地使用</span><br><span class="line">  level:</span><br><span class="line">    root: debug</span><br></pre></td></tr></table></figure></li>
<li><p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.flag&#125;&quot;)</span><br><span class="line">    private String flag;</span><br><span class="line">    @Value(&quot;$&#123;custom.database&#125;&quot;)</span><br><span class="line">    private String database;</span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;flag:&quot; + flag + &quot;&lt;br/&gt; database:&quot; + database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置中心配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/QL6duYOJbgrkRpw.png" alt="image-20210716064049080"></p>
<p>Data ID，Group，描述，说明，配置格式，配置内容</p>
<p>Data ID：配置的唯一标识，格式固定为：{微服务id}-{环境名}.yml，这里填写 order-service-dev.yml，其中 dev 就是环境名代表这个配置文件是 order-service 的开发环境配置文件。</p>
<p>Group：指定配置文件的分组，这里设置默认分组 DEFAULT_GROUP 即可。</p>
<p>描述：说明 order-service-dev.yml 配置文件的用途。</p>
<p>配置格式：指定“配置内容”的类型，这里选择 YAML 即可。</p>
<p>配置内容：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/cRrm9WThZQDiFqg.png" alt="image-20210716064151924"></p>
<p>点击右下角的“发布”按钮完成设置。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RCZQ4m7iXcJLStD.png" alt="image-20210716065250910"></p>
<p>nacos_config 数据库的 config_info 表中也出现了对应配置数据。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/5wWpve8kFYgVS39.png" alt="image-20210716065315865"></p>
</li>
<li><p>启动服务并访问接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8000/test</span><br><span class="line">结果如下：</span><br><span class="line">flag:development</span><br><span class="line">database:192.168.10.31</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h6><p>####### 热加载</p>
<p>为了支持热加载，服务 A 的程序针对热加载需要作出如下变动：</p>
<p>第一，配置数据必须被封装到单独的配置 Bean 中；</p>
<p>第二，这个配置 Bean 需要被 @Configuration 与 @RefreshScope 两个注解描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration // 说明这是配置Bean</span><br><span class="line">@RefreshScope // 监听，当 Nacos 推送新的配置后，由这个注解负责接收并为属性重新赋值。</span><br><span class="line">public class CustomConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.flag&#125;&quot;)</span><br><span class="line">    private String flag;</span><br><span class="line">    @Value(&quot;$&#123;custom.database&#125;&quot;)</span><br><span class="line">    private String database;</span><br><span class="line">    public String getFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFlag(String flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDatabase() &#123;</span><br><span class="line">        return database;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDatabase(String database) &#123;</span><br><span class="line">        this.database = database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private CustomConfig customConfig;</span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;flag:&quot; + customConfig.getFlag() + &quot;&lt;br/&gt; database:&quot; + customConfig.getDatabase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动应用后，修改配置文件，并发布.</p>
<p>日志立即产生重新加载的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[192.168.31.10_8848] c.a.c.n.refresh.NacosContextRefresher    : Refresh Nacos config group=DEFAULT_GROUP,dataId=order-service-dev.yml,configInfo=server:</span><br><span class="line">  port: 8000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.10:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">custom: #自定义配置项</span><br><span class="line">  flag: development</span><br><span class="line">  database: 192.168.10.33</span><br><span class="line">[192.168.31.10_8848] c.a.nacos.client.config.impl.CacheData   : [fixed-192.168.31.10_8848] [notify-ok] dataId=order-service-dev.yml, group=DEFAULT_GROUP, md5=aeee8dceea709b3081d3c882ae2464b2, listener=com.alibaba.cloud.nacos.refresh.NacosContextRefresher$1@5bcff640</span><br></pre></td></tr></table></figure>



<p>####### 切换配置文件</p>
<p>在 Nacos 中设置生产环境的配置，Data Id 为 order-service-prd.yml，其中 prd 是 production 的缩写，代表生产环境配置。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hByRiAwsb7TYZKJ.png" alt="image-20210716163910649"></p>
<p>调整 order-service 的 bootstrap.yml 引导文件，最重要的地方是修改环境名为 prd，同时更换为生产环境 Nacos 的通信地址，打包后发布。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order-service #微服务id</span><br><span class="line">  profiles:</span><br><span class="line">    active: prd #环境名</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      config: #这里配置的是Nacos配置中心</span><br><span class="line">        file-extension: yml #指定文件扩展名</span><br><span class="line">        server-addr: 192.168.31.10:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br></pre></td></tr></table></figure>



<p>####### 管理基础配置数据</p>
<p>对比 order-service-dev.yml 与 order-service-prd.yml 发现，在不同环境的配置文件中普遍存在固定的配置项，例如：spring.application.name=order-service 配置项就是稳定的，且修改它会影响所有环境配置文件。对于这种基础的全局配置，我们可以将其存放到单独的 order-service.yml 配置中，在 order-service 服务启动时，这个不带环境名的配置文件必然会被加载。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/2XJKcliYNa4orgQ.png" alt="image-20210716164052286"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># order-service.yml</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order-service</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># order-service-dev.yml</span><br><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.10:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">custom: #自定义配置项</span><br><span class="line">  flag: development</span><br><span class="line">  database: 192.168.10.33</span><br></pre></td></tr></table></figure>



<h4 id="Nacos原理"><a href="#Nacos原理" class="headerlink" title="Nacos原理"></a>Nacos原理</h4><h5 id="心跳机制与健康检查"><a href="#心跳机制与健康检查" class="headerlink" title="心跳机制与健康检查"></a>心跳机制与健康检查</h5><p>微服务与Nacos服务器通信过程：</p>
<ol>
<li><p>微服务（客户端）启动后每过5秒，会由微服务内置的 Nacos 客户端主动向 Nacos 服务器发起心跳包（HeartBeat）。心跳包会包含当前服务实例的名称、IP、端口、集群名、权重等信息。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6sQtEHn1d2AibeK.png" alt="image-20210705065425475"></p>
</li>
<li><p>Nacos服务端收到心跳包后的处理</p>
<ol>
<li><p>首先根据 IP 与端口判断 Nacos 是否存在该服务实例？如果实例信息不存在，在 Nacos 中注册登记该实例。而注册的本质是将新实例对象存储在“实例 Map”集合中；</p>
</li>
<li><p>如果实例信息已存在，记录本次心跳包发送时间；</p>
</li>
<li><p>设置实例状态为“健康”；</p>
</li>
<li><p>推送“微服务状态变更”消息；</p>
</li>
<li><p>返回心跳包时间间隔。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IfNkQzc7jabWJBZ.png" alt="image-20210705065743612"></p>
</li>
</ol>
</li>
<li><p>实例的不健康状态与剔除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#心跳间隔。时间单位:秒。心跳间隔</span><br><span class="line">spring.cloud.nacos.discovery.heart-beat-interval=3</span><br><span class="line"></span><br><span class="line"># Nacos Server 默认每过 15 秒对“实例 Map”中的所有实例进行扫描，服务端6秒收不到客户端心跳，会将该客户端注册的实例设为不健康</span><br><span class="line">spring.cloud.nacos.discovery.heart-beat-timeout=15</span><br><span class="line"># Nacos Server 默认每过 20 秒对“实例 Map”中的所有“非健康”实例进行扫描，如发现“非健康”实例，随即从“实例 Map”中将该实例删除。</span><br><span class="line">spring.cloud.nacos.discovery.ip-delete-timeout=30</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="热加载原理"><a href="#热加载原理" class="headerlink" title="热加载原理"></a>热加载原理</h5><p>热加载介绍：Nacos 中支持配置热加载，在运行过程中允许直接对新的配置项进行重新加载而不需要手动重启。</p>
<p>配置中心长轮询机制：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zO37WGxuEXsCfmi.png" alt="image-20210716070234915"></p>
<p>Nacos 服务端收到请求之后，先检查配置是否发生了变更，如果没有，则设置一个定时任务，延期 29.5s 执行，并且把当前的客户端长轮询连接加入 allSubs 队列。这时候有两种方式触发该连接结果的返回：</p>
<p>• 第一种是在等待 29.5s 后触发自动检查机制，这时候不管配置有没有发生变化，都会把结果返回客户端。而 29.5s 就是这个长连接保持的时间。</p>
<p>• 第二种是在 29.5s 内任意一个时刻，通过 Nacos Dashboard 或者 API 的方式对配置进行了修改，这会触发一个事件机制，监听到该事件的任务会遍历 allSubs 队列，找到发生变更的配置项对应的 ClientLongPolling 任务，将变更的数据通过该任务中的连接进行返回，就完成了一次“推送”操作。</p>
<p>这样既能够保证客户端实时感知配置的变化，也降低了服务端的压力。其中，这个长连接的会话超时时间默认为 30s。</p>
<h3 id="2-微服务高可用-负载均衡Ribbon"><a href="#2-微服务高可用-负载均衡Ribbon" class="headerlink" title="2.微服务高可用-负载均衡Ribbon"></a>2.微服务高可用-负载均衡Ribbon</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>负载均衡</strong>将来自客户端的请求按照某种策略平均的分配到集群的每一个节点上，保证这些节点的 CPU、内存等设备负载情况大致在一条水平线，避免由于局部节点负载过高产生宕机，再将这些处理压力传递到其他节点上产生系统性崩溃。</p>
<p><strong>分类：</strong>按实现方式可区分为服务端负载均衡与客户端负载均衡。</p>
<p><strong>服务端负载均衡：</strong>客户端先发送请求到负载均衡服务器，然后由负载均衡服务器通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求。</p>
<p>服务器端负载均衡又分为两种，一种是硬件负载均衡，还有一种是软件负载均衡。</p>
<p>硬件负载均衡主要通过在服务器节点之前安装专门用于负载均衡的设备，常见的如：F5。</p>
<p>软件负载均衡则主要是在服务器上安装一些具有负载均衡功能的软件来完成请求分发进而实现负载均衡，常见的如：LVS 、 Nginx 、Haproxy。</p>
<p><strong>客户端负载均衡：</strong>客户端自己维护一个可用服务器地址列表，在发送请求前先通过负载均衡算法选择一个将用来处理本次请求的服务器，然后再直接将请求发送至该服务器。</p>
<p><strong>Ribbon负载均衡</strong>：是一个基于HTTP和TCP的客户端负载均衡器。Ribbon会到注册中心去获取服务端列表，然后进行按照负载均衡策略（如：轮询）访问以到达负载均衡的作用。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RiTYUtd58LmXC7e.png" alt="image-20210714160800742"></p>
<p>Ribbon 执行流程：</p>
<ol>
<li>订单服务（order-service）与商品服务（goods-service）实例在启动时向 Nacos 注册；</li>
<li>订单服务向商品服务发起通信前，Ribbon 向 Nacos 查询商品服务的可用实例列表；</li>
<li>Ribbon 根据设置的负载策略从商品服务可用实例列表中选择实例；</li>
<li>订单服务实例向商品服务实例发起请求，完成 RESTful 通信；</li>
</ol>
<h4 id="Ribbon-使用"><a href="#Ribbon-使用" class="headerlink" title="Ribbon-使用"></a>Ribbon-使用</h4><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><ol>
<li><p>提供者服务</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: customer-service #应用/微服务名字</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.102:8848 #nacos服务器地址</span><br><span class="line">        username: nacos #用户名密码</span><br><span class="line">        password: nacos</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@RestController</span><br><span class="line">public class ProviderController &#123;</span><br><span class="line">    @GetMapping(&quot;/provider/msg&quot;)</span><br><span class="line">    public String sendMessage()&#123;</span><br><span class="line">        return &quot;This is the message from provider service!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>消费者服务</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-service #应用/微服务名字</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #nacos服务器地址</span><br><span class="line">        username: nacos #用户名密码</span><br><span class="line">        password: nacos</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: debug</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<p>启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerServiceApplication &#123;</span><br><span class="line">    //Java Config声明RestTemplate对象</span><br><span class="line">    //在应用启动时自动执行restTemplate()方法创建RestTemplate对象，其BeanId为restTemplate。</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line">    private Logger logger = LoggerFactory.getLogger(ConsumerController.class);</span><br><span class="line">    //注入 Ribbon 负载均衡器对象</span><br><span class="line">    //在引入 starter-netflix-ribbo n后在 SpringBoot 启动时会自动实例化 LoadBalancerClient 对象。</span><br><span class="line">    //在 Controlle 使用 @Resource 注解进行注入即可。</span><br><span class="line">    @Resource</span><br><span class="line">    private LoadBalancerClient loadBalancerClient;</span><br><span class="line">    @Resource</span><br><span class="line">    //将应用启动时创建的 RestTemplate 对象注入 ConsumerController</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @GetMapping(&quot;/consumer/msg&quot;)</span><br><span class="line">    public String getProviderMessage() &#123;</span><br><span class="line">        //loadBalancerClient.choose()方法会从 Nacos 获取 provider-service 所有可用实例，</span><br><span class="line">        //并按负载均衡策略从中选择一个可用实例，封装为 ServiceInstance（服务实例）对象</span><br><span class="line">        //结合现有环境既是从192.168.31.111:80、192.168.31.112:80、192.168.31.113:80三个实例中选择一个包装为ServiceInstance</span><br><span class="line">        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;provider-service&quot;);</span><br><span class="line">        //获取服务实例的 IP 地址</span><br><span class="line">        String host = serviceInstance.getHost();</span><br><span class="line">        //获取服务实例的端口</span><br><span class="line">        int port = serviceInstance.getPort();</span><br><span class="line">        //在日志中打印服务实例信息</span><br><span class="line">        logger.info(&quot;本次调用由provider-service的&quot; + host + &quot;:&quot; + port + &quot; 实例节点负责处理&quot; );</span><br><span class="line">        //通过 RestTemplate 对象的 getForObject() 方法向指定 URL 发送请求，并接收响应。</span><br><span class="line">        //getForObject()方法有两个参数：</span><br><span class="line">        //1. 具体发送的 URL，结合当前环境发送地址为：http://192.168.31.111:80/provider/msg</span><br><span class="line">        //2. String.class说明 URL 返回的是纯字符串，如果第二参数是实体类， RestTemplate 会自动进行反序列化，为实体属性赋值</span><br><span class="line">        String result = restTemplate.getForObject(&quot;http://&quot; + host + &quot;:&quot; + port + &quot;/provider/msg&quot;, String.class);</span><br><span class="line">        //输出响应内容</span><br><span class="line">        logger.info(&quot;provider-service 响应数据:&quot; + result);</span><br><span class="line">        //向浏览器返回响应</span><br><span class="line">        return &quot;consumer-service 响应数据:&quot; + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>启动1个提供者，3个消费者</p>
<p>启动消费者，可以启动一个，修改端口后，再启动下一个</p>
</li>
<li><p>测试</p>
<p>默认轮询</p>
<p>访问：<a href="http://192.168.31.120/consumer/msg%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E6%97%A5%E5%BF%97">http://192.168.31.120/consumer/msg，查看后台日志</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本次调用由 provider-service 的 192.168.31.111:80 实例节点负责处理</span><br><span class="line">consumer-service 获得数据:This is the message from provider service!</span><br><span class="line">本次调用由 provider-service 的 192.168.31.112:80 实例节点负责处理</span><br><span class="line">consumer-service 获得数据:This is the message from provider service!</span><br><span class="line">本次调用由 provider-service 的 192.168.31.113:80 实例节点负责处理</span><br><span class="line">consumer-service 获得数据:This is the message from provider service!</span><br><span class="line">本次调用由 provider-service 的 192.168.31.111:80 实例节点负责处理</span><br><span class="line">consumer-service 获得数据:This is the message from provider service!</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="负载均衡策略配置"><a href="#负载均衡策略配置" class="headerlink" title="负载均衡策略配置"></a>负载均衡策略配置</h5><ul>
<li>RoundRobinRule：轮询策略，Ribbon 默认策略。默认超过 10 次获取到的 server 都不可用，会返回⼀个空的 server。</li>
</ul>
<ul>
<li><p>RandomRule：随机策略，如果随机到的 server 为 null 或者不可用的话。会不停地循环选取。</p>
</li>
<li><p>RetryRule：重试策略，⼀定时限内循环重试。默认继承 RoundRobinRule，也⽀持自定义注⼊，RetryRule 会在每次选取之后，对选举的 server 进⾏判断，是否为 null，是否 alive，并且在 500ms 内会不停地选取判断。而 RoundRobinRule 失效的策略是超过 10 次，RandomRule 没有失效时间的概念，只要 serverList 没都挂。</p>
</li>
<li><p>BestAvailableRule：最小连接数策略，遍历 serverList，选取出可⽤的且连接数最小的⼀个 server。那么会调用 RoundRobinRule 重新选取。</p>
</li>
<li><p>AvailabilityFilteringRule：可用过滤策略。扩展了轮询策略，会先通过默认的轮询选取⼀个 server，再去判断该 server 是否超时可用、当前连接数是否超限，都成功再返回。</p>
</li>
<li><p>ZoneAvoidanceRule：区域权衡策略。扩展了轮询策略，除了过滤超时和链接数过多的 server，还会过滤掉不符合要求的 zone 区域⾥⾯的所有节点，始终保证在⼀个区域/机房内的服务实例进行轮询。</p>
</li>
</ul>
<h5 id="配置文件修改策略"><a href="#配置文件修改策略" class="headerlink" title="配置文件修改策略"></a>配置文件修改策略</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">provider-service: #服务提供者的微服务id</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #设置对应的负载均衡类</span><br></pre></td></tr></table></figure>



<h3 id="3-服务间通信OpenFeign"><a href="#3-服务间通信OpenFeign" class="headerlink" title="3.服务间通信OpenFeign"></a>3.服务间通信OpenFeign</h3><p>OpenFeign 是Spring官方在 Netflix Feign 的基础上进行封装的技术，结合原有 Spring MVC 的注解，对 Spring Cloud 微服务通信提供了良好的支持。</p>
<p>OpenFeign 开发的方式与开发 Spring MVC Controller 颇为相似。</p>
<h4 id="OpenFeign使用"><a href="#OpenFeign使用" class="headerlink" title="OpenFeign使用"></a>OpenFeign使用</h4><p>feign使用流程：<br>    1.导包<br>    2.yml配置到eureka中<br>    3.启动类增加注解@EnableDiscoveryClient<br>    4.生产者消费者写一样的接口，者接口上写@feignclient<br>    5.生产者有订单接口的具体实现<br>    6.消费者写法同平常的controller</p>
<h5 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h5><ol>
<li><p>提供者服务</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: warehouse-service #应用/微服务名字</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.102:8848 #nacos服务器地址</span><br><span class="line">        username: nacos #用户名密码</span><br><span class="line">        password: nacos</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class WarehouseController &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询对应 skuId 的库存状况</span><br><span class="line">     * @param skuId skuId</span><br><span class="line">     * @return Stock 库存对象</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/stock&quot;)</span><br><span class="line">    public Stock getStock(Long skuId)&#123;</span><br><span class="line">        Map result = new HashMap();</span><br><span class="line">        Stock stock = null;</span><br><span class="line">        if(skuId == 1101l)&#123;</span><br><span class="line">            //模拟有库存商品</span><br><span class="line">            stock = new Stock(1101l, &quot;Apple iPhone 11 128GB 紫色&quot;, 32, &quot;台&quot;);</span><br><span class="line">            stock.setDescription(&quot;Apple 11 紫色版对应商品描述&quot;);</span><br><span class="line">        &#125;else if(skuId == 1102l)&#123;</span><br><span class="line">            //模拟无库存商品</span><br><span class="line">            stock = new Stock(1101l, &quot;Apple iPhone 11 256GB 白色&quot;, 0, &quot;台&quot;);</span><br><span class="line">            stock.setDescription(&quot;Apple 11 白色版对应商品描述&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //演示案例，暂不考虑无对应 skuId 的情况</span><br><span class="line">        &#125;</span><br><span class="line">        return stock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>消费者服务</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: order-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.102:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<p>启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients //启用OpenFeign</span><br><span class="line">public class OrderServiceApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OpenFeign通信接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">@FeignClient(&quot;warehouse-service&quot;) //说明当前接口为 OpenFeign 通信客户端，参数值 warehouse-service 为服务提供者 ID，这一项必须与 Nacos 注册 ID 保持一致。</span><br><span class="line">public interface WarehouseServiceFeignClient &#123;</span><br><span class="line">    @GetMapping(&quot;/stock&quot;)</span><br><span class="line">    public Stock getStock(@RequestParam(&quot;skuId&quot;) Long skuId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">@RestController</span><br><span class="line">public class OrderController &#123;</span><br><span class="line">    //利用@Resource将IOC容器中自动实例化的实现类对象进行注入</span><br><span class="line">    @Resource</span><br><span class="line">    private WarehouseServiceFeignClient warehouseServiceFeignClient;</span><br><span class="line">    /**</span><br><span class="line">     * 创建订单业务逻辑</span><br><span class="line">     * @param skuId 商品类别编号</span><br><span class="line">     * @param salesQuantity 销售数量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/create_order&quot;)</span><br><span class="line">    public Map createOrder(Long skuId , Long salesQuantity)&#123;</span><br><span class="line">        Map result = new LinkedHashMap();</span><br><span class="line">        //查询商品库存，像调用本地方法一样完成业务逻辑。</span><br><span class="line">        Stock stock = warehouseServiceFeignClient.getStock(skuId);</span><br><span class="line">        System.out.println(stock);</span><br><span class="line">        if(salesQuantity &lt;= stock.getQuantity())&#123;</span><br><span class="line">            //创建订单相关代码，此处省略</span><br><span class="line">            //CODE=SUCCESS代表订单创建成功</span><br><span class="line">            result.put(&quot;code&quot; , &quot;SUCCESS&quot;);</span><br><span class="line">            result.put(&quot;skuId&quot;, skuId);</span><br><span class="line">            result.put(&quot;message&quot;, &quot;订单创建成功&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //code=NOT_ENOUGN_STOCK代表库存不足</span><br><span class="line">            result.put(&quot;code&quot;, &quot;NOT_ENOUGH_STOCK&quot;);</span><br><span class="line">            result.put(&quot;skuId&quot;, skuId);</span><br><span class="line">            result.put(&quot;message&quot;, &quot;商品库存数量不足&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="OpenFeign执行流程"><a href="#OpenFeign执行流程" class="headerlink" title="OpenFeign执行流程"></a>OpenFeign执行流程</h5><ol>
<li>第一次访问 WarehouseServiceFeignClient （OpenFeign）接口时，Spring 自动生成接口的实现类并实例化对象。</li>
<li>调用 getStock() 方法时，Ribbon 获取 warehouse-service 可用实例信息，根据负载均衡策略选择合适实例。</li>
<li>OpenFeign 根据方法上注解描述的映射关系生成完整的 URL 并发送 HTTP 请求，如果请求方法是 @PostMapping，则参数会附加在请求体中进行发送。</li>
<li>warehouse-service 处理完毕返回 JSON 数据，消费者端 OpenFeign 接收 JSON 的同时反序列化到 Stock 对象，并将该对象返回。</li>
</ol>
<h5 id="高级配置-1"><a href="#高级配置-1" class="headerlink" title="高级配置"></a>高级配置</h5><p>负载均衡+数据压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># OpenFeign负载均衡策略，默认引用Ribbon实现客户端负载均衡</span><br><span class="line">warehouse-service: #服务提供者的微服务ID</span><br><span class="line">  ribbon:</span><br><span class="line">    #设置对应的负载均衡类</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br><span class="line">    </span><br><span class="line"># OpenFeign 数据压缩功能</span><br><span class="line">feign:</span><br><span class="line">  compression:</span><br><span class="line">    request:</span><br><span class="line">      # 开启请求数据的压缩功能</span><br><span class="line">      enabled: true</span><br><span class="line">      # 压缩支持的MIME类型</span><br><span class="line">      mime-types: text/xml,application/xml, application/json</span><br><span class="line">      # 数据压缩下限 1024表示传输数据大于1024 才会进行数据压缩(最小压缩值标准) 压缩后尺寸只相当于原始数据的 10%~30%，通过CPU计算，极大提高带宽利用率。CPU 负载长期超过 70% 不适合开启。</span><br><span class="line">      min-request-size: 1024</span><br><span class="line">    # 开启响应数据的压缩功能</span><br><span class="line">    response:</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure>

<p>替换默认通信组件</p>
<p>基于 Apache HttpClient、OKHttp 组件自带的连接池，可以更好地对 HTTP 连接对象进行重用与管理。</p>
<ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;11.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>应用入口，利用 Java Config 形式初始化 OkHttpClient 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class OrderServiceApplication &#123;</span><br><span class="line">    //Spring IOC容器初始化时构建okHttpClient对象</span><br><span class="line">    @Bean</span><br><span class="line">    public okhttp3.OkHttpClient okHttpClient()&#123;</span><br><span class="line">        return new okhttp3.OkHttpClient.Builder()</span><br><span class="line">                //读取超时时间</span><br><span class="line">                .readTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">                //连接超时时间</span><br><span class="line">                .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">                //写超时时间</span><br><span class="line">                .writeTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">                //设置连接池</span><br><span class="line">                .connectionPool(new ConnectionPool())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置启用 OKHttp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  okhttp:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="同类产品Dubbo"><a href="#同类产品Dubbo" class="headerlink" title="同类产品Dubbo"></a>同类产品Dubbo</h4><h3 id="4-微服务大门-网关GateWay"><a href="#4-微服务大门-网关GateWay" class="headerlink" title="4.微服务大门-网关GateWay"></a>4.微服务大门-网关GateWay</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><ul>
<li>用户身份鉴权</li>
<li>日志记录</li>
<li>黑白名单</li>
<li>反爬虫</li>
</ul>
<h5 id="网关作用"><a href="#网关作用" class="headerlink" title="网关作用"></a>网关作用</h5><ul>
<li>解耦</li>
<li>统一的一个入口，方便做统一的事。</li>
</ul>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Kou9hgpeLmkcZFC.png" alt="image-20210715142325376"></p>
<h5 id="Gateway特点"><a href="#Gateway特点" class="headerlink" title="Gateway特点"></a>Gateway特点</h5><ul>
<li><p>基于 NIO 异步处理，有更好的性能。</p>
</li>
<li><p> 配置简单</p>
</li>
<li><p>基于 JDK 8+ 开发</p>
</li>
<li><p>基于 Spring Framework 5 + Project Reactor + Spring Boot 2.0 构建</p>
</li>
<li><p>支持动态路由，能够匹配任何请求属性上的路由；</p>
</li>
<li><p>基于 HTTP 请求的路由匹配（Path、Method、Header、Host 等）</p>
</li>
<li><p>过滤器可以修改 HTTP 请求和 HTTP 响应（增加/修改 Header、增加/修改请求参数、改写请求 Path 等等）；</p>
</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><p>service-a提供了三个RESTFul接口</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/BgYNVWQMaxzSJrt.png" alt="image-20210715160003080"></p>
<p>service-b提供了三个接口</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zecDQKGs8IHd64n.png" alt="image-20210715160021668"></p>
<h5 id="Gatway-demo"><a href="#Gatway-demo" class="headerlink" title="Gatway-demo"></a>Gatway-demo</h5><ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Nacos客户端 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Spring Cloud Gateway Starter --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 对外提供Gateway应用监控指标 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>application.yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway #配置微服务id</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.101:8848 #nacos通信地址</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">    gateway: #让gateway通过nacos实现自动路由转发</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true #locator.enabled 开启自动转发，根据URL规则实现默认路由转发</span><br><span class="line">server:</span><br><span class="line">  port: 80 #服务端口号</span><br><span class="line">management: </span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27; #对外暴露actuator所有监控指标，便于监控系统收集跟踪</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 规则</span><br><span class="line">http://网关IP:端口/微服务id/URI</span><br><span class="line"></span><br><span class="line">http://192.168.31.103:80/service-a/list</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="高级配置-2"><a href="#高级配置-2" class="headerlink" title="高级配置"></a>高级配置</h5><p>路由、谓词和过滤器。</p>
<p>路由（Route）是指一个完整的网关地址映射与处理过程。（前端的请求经过网关，网关判断请求转发到）一个完整的路由包含两部分配置：谓词（Predicate）与过滤器（Filter）。前端应用发来的请求要被转发到哪个微服务上，是由谓词决定的；而转发过程中请求、响应数据被网关如何加工处理是由过滤器决定的。</p>
<h6 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h6><p>指定时点后路由规则生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">    - After=2020-10-04T00:00:00.000+08:00</span><br></pre></td></tr></table></figure>



<p>URI 符合映射规则时生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">    - Path=/b/**</span><br></pre></td></tr></table></figure>

<p>Header 包含指定请求头时生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">predicates:</span><br><span class="line">    - Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure>



<h6 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h6><p>对所有匹配的请求添加一个查询参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filters:</span><br><span class="line">- AddRequestParameter=foo,bar #在请求参数中追加foo=bar</span><br></pre></td></tr></table></figure>

<p>返回客户端之前,添加响应数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在Response中添加Header头，key=X-Response-Foo，Value=Bar。</span><br><span class="line"># 返回客户端之前，Header添加响应数据</span><br><span class="line">filters:</span><br><span class="line">- AddResponseHeader=X-Response,Blue</span><br></pre></td></tr></table></figure>

<p>返回 503 状态码的响应后，Retry 过滤器重新发起请求，最多重试 3 次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filters:</span><br><span class="line">#涉及过滤器参数时，采用name-args的完整写法</span><br><span class="line">- name: Retry #name是内置的过滤器名</span><br><span class="line">  args: #参数部分使用args说明</span><br><span class="line">    retries: 3</span><br><span class="line">    status: 503</span><br></pre></td></tr></table></figure>



<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.31.10:8848</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">    gateway: </span><br><span class="line">      # 网关跨域</span><br><span class="line">      globalcors:</span><br><span class="line">        cors-configurations:</span><br><span class="line">          &#x27;[/**]&#x27;:</span><br><span class="line">            # 允许携带认证信息</span><br><span class="line">            # 允许跨域的源(网站域名/ip)，设置*为全部</span><br><span class="line">            # 允许跨域请求里的head字段，设置*为全部</span><br><span class="line">            # 允许跨域的method， 默认为GET和OPTIONS，设置*为全部</span><br><span class="line">            # 跨域允许的有效期</span><br><span class="line">            allow-credentials: true</span><br><span class="line">            allowed-origins: &quot;*&quot;</span><br><span class="line">            allowed-headers: &quot;*&quot;</span><br><span class="line">            allowed-methods: &quot;*&quot;</span><br><span class="line">            max-age: 3600    </span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: false #不再需要Gateway路由转发</span><br><span class="line">      routes:  #路由规则配置</span><br><span class="line">        #第一个路由配置，service-a路由规则</span><br><span class="line">        - id: service_a_route #路由唯一标识</span><br><span class="line">          #lb开头代表基于gateway的负载均衡策略选择实例</span><br><span class="line">          uri: lb://service-a </span><br><span class="line">          #谓词配置</span><br><span class="line">          predicates:</span><br><span class="line">            #Path路径谓词，代表用户端URI如果以/a开头便会转发到service-a实例</span><br><span class="line">            - Path=/a/** </span><br><span class="line">            #After生效时间谓词，2020年10月15日后该路由才能在网关对外暴露</span><br><span class="line">            - After=2020-10-05T00:00:00.000+08:00[Asia/Shanghai]</span><br><span class="line">          #谓词配置</span><br><span class="line">          filters:</span><br><span class="line">            #忽略掉第一层前缀进行转发</span><br><span class="line">          - StripPrefix=1 </span><br><span class="line">            #为响应头附加X-Response=Blue 2020-10-15后此项为默认</span><br><span class="line">          - AddResponseHeader=X-Response,Blue </span><br><span class="line">        #第二个路由配置，service-b路由规则</span><br><span class="line">        - id: service_b_route</span><br><span class="line">          uri: lb://service-b</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/b/**</span><br><span class="line">          filters:</span><br><span class="line">            - StripPrefix=1</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27;</span><br></pre></td></tr></table></figure>



<p>跨域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 全局跨域配置</span><br><span class="line"> * 注意：前端从网关进行调用时需要配置</span><br><span class="line"> * 跨域配置文件在 src/main/resources/bootstrap.yml</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnBean(GlobalCorsProperties.class)</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private GlobalCorsProperties globalCorsProperties;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsWebFilter corsFilter() &#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());</span><br><span class="line">        globalCorsProperties.getCorsConfigurations().forEach((path,corsConfiguration)-&gt;source.registerCorsConfiguration(path, corsConfiguration));</span><br><span class="line">        return new CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="路由转发流程"><a href="#路由转发流程" class="headerlink" title="路由转发流程"></a>路由转发流程</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Za3zqJMVkTHtGsN.png" alt="image-20210715160939510"></p>
<h5 id="内部执行原理"><a href="#内部执行原理" class="headerlink" title="内部执行原理"></a>内部执行原理</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/qUYIulMLEQc4Be7.png" alt="image-20210715165118189"></p>
<ol>
<li>Spring Cloud Gateway 启动时基于 Netty Server 监听指定的端口（该端口可以通过 server.port 属性自定义）。当前端应用发送一个请求到网关时，进入 Gateway Handler Mapping 处理过程，网关会根据当前 Gateway 所配置的谓词（Predicate）来决定是由哪个微服务进行处理。</li>
<li>确定微服务后，请求向后进入 Gateway Web Handler 处理过程，该过程中 Gateway 根据过滤器（Filters）配置，将请求按前后顺序依次交给 Filter 过滤链进行前置（Pre）处理，前置处理通常是对请求进行前置检查，例如：判断是否包含某个指定请求头、检查请求的 IP 来源是否合法、请求包含的参数是否正确等。</li>
<li>当过滤链前置（Pre）处理完毕后，请求会被 Gateway 转发到真正的微服务实例进行处理，微服务处理后会返回响应数据，这些响应数据会按原路径返回被 Gateway 配置的过滤链进行后置处理（Post），后置处理通常是对响应进行额外处理，例如：将处理过程写入日志、为响应附加额外的响应头或者流量监控等。</li>
</ol>
<h3 id="5-服务流量控制Sentinel"><a href="#5-服务流量控制Sentinel" class="headerlink" title="5.服务流量控制Sentinel"></a>5.服务流量控制Sentinel</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>微服务环境下受制于网络、机器性能、算法、程序各方面影响，运行异常的情况也在显著提升，加上并发量不可控，需要做好异常保护。</p>
<p>微服务雪崩：在微服务项目中指由于突发流量导致某个服务不可用，从而导致上游服务不可用，并产生级联效应，最终导致整个系统不可用。例子：服务A调⽤服务B，此时⼤量请求突然请求服务A，假如服务A本身能抗住这些请 </p>
<p>求，但是如果服务B抗不住，导致服务B请求堆积，从而服务A请求堆积，直到服务A不可用。</p>
<p>如何避免雪崩效应：</p>
<ul>
<li><p>限流</p>
<p>控制请求的流入，让流量有序的进入应用，保证流量在一个可控的范围内。</p>
</li>
<li><p>服务降级</p>
<p>当应用处理时间超过规定上限后，无论服务是否处理完成，响应返回预先设置的异常信息。</p>
</li>
<li><p>服务熔断</p>
<p>设置服务为不可用，发送心跳包，服务可用后再给该服务发请求。</p>
</li>
</ul>
<h4 id="Sentinel介绍"><a href="#Sentinel介绍" class="headerlink" title="Sentinel介绍"></a>Sentinel介绍</h4><p>Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>特征：</p>
<ul>
<li>丰富的应用场景：承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，500 台以下规模的集群的汇总运行情况。</li>
<li>广泛的开源生态：Sentinel 提供开箱即用的与其他开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 整合只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li>完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/x87jf13ZR4sUMGp.png" alt="image-20210707065815664"></p>
<h4 id="Sentinel使用"><a href="#Sentinel使用" class="headerlink" title="Sentinel使用"></a>Sentinel使用</h4><h5 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h5><p>Sentinel 分为两个部分：Sentinel Dashboard和Sentinel 客户端。</p>
<ol>
<li><p>Sentinel Dashboard</p>
<p>Sentinel Dashboard 是 Sentinel 配套的可视化控制台与监控仪表盘套件，它支持节点发现，以及健康情况管理、监控（单机和集群）、规则管理和推送的功能。Sentinel Dashboard 是基于 Spring Boot 开发的 WEB 应用，打包后可以直接运行。</p>
<p>Sentinel Dashboard 监听9100端口实现与微服务的通信。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wpSfXP5nhziZxlR.png" alt="image-20210707070040503"></p>
<p>部署Sentinel Dashboard</p>
<ol>
<li><p>访问：<a href="https://github.com/alibaba/Sentinel/releases%EF%BC%8C%E4%B8%8B%E8%BD%BDSentinel">https://github.com/alibaba/Sentinel/releases，下载Sentinel</a> Dashboard</p>
</li>
<li><p>启动Dashboard</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar -Dserver.port=9100 sentinel-dashboard-1.8.0.jar</span><br></pre></td></tr></table></figure></li>
<li><p>SentinelUI界面</p>
<p><a href="http://192.168.31.10:9100/?fileGuid=xxQTRXtVcqtHK6j8">http://192.168.31.10:9100</a></p>
<p>账号&amp;密码 sentinel&amp;sentinel</p>
</li>
</ol>
</li>
<li><p>Sentinel 客户端</p>
<p>Sentinel 客户端需要集成在 Spring Boot 微服务应用中，用于接收来自 Dashboard 配置的各种规则，并通过 Spring MVC Interceptor 拦截器技术实现应用限流、熔断保护。</p>
<p>客户端配置</p>
<ol>
<li><p>创建工程，加入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Nacos客户端Starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Sentinel客户端Starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 对外暴露Spring Boot监控指标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置Nacos和Sentinel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sentinel-sample #应用名&amp;微服务id</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel: #Sentinel Dashboard通信地址</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: 192.168.31.10:9100</span><br><span class="line">      eager: true #取消控制台懒加载</span><br><span class="line">    nacos: #Nacos通信地址</span><br><span class="line">      server-addr: 192.168.31.10:8848</span><br><span class="line">      username: nacos</span><br><span class="line">      password: nacos</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web: #将所有可用的监控指标项对外暴露</span><br><span class="line">      exposure: #可以访问 /actuator/sentinel进行查看Sentinel监控项</span><br><span class="line">        include: &#x27;*&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>验证</p>
<p>访问Sentinel Dashboard</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SmIK6hzpMntxucF.png" alt="image-20210707070653681"></p>
</li>
<li><p>限流demo</p>
<ol>
<li><p>Sentinel Core 写一个Controller，启动微服务</p>
</li>
<li><p>在Sentinel Dashboard配置限流规则</p>
<p>每秒钟只允许 1QPS 访问，超出的请求直接服务降级返回异常。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/me4O8Vz79xwaHu1.png" alt="image-20210709064054534"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jH7dbni4Z9XAwMC.png" alt="image-20210709064208173"></p>
</li>
<li><p>验证</p>
<p>访问<a href="http://localhost/test_flow_rule%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8D%E5%A4%8D%E5%88%B7%E6%96%B0%E3%80%82">http://localhost/test_flow_rule，浏览器反复刷新。</a></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="Dashboard限流配置"><a href="#Dashboard限流配置" class="headerlink" title="Dashboard限流配置"></a>Dashboard限流配置</h5><p>在 Sentinel Dashboard 中“簇点链路”,找到需要限流的 URI，点击“+流控”进入流控设置。</p>
<p>Sentinel-Dashboard 加载链路使用懒加载模式，如果在簇点链路没有找到对应的 URI，需要先访问下这个功能对应的 URI </p>
<p>流控规则说明：</p>
<ul>
<li>资源名：要流控的 URI，在 Sentinel 中 URI 被称为“资源”；</li>
</ul>
<ul>
<li>针对来源：默认 default 代表所有来源，可以针对某个微服务或者调用者单独设置；</li>
</ul>
<ul>
<li>阈值类型：是按每秒访问数量（QPS）还是并发数（线程数）进行流控；</li>
</ul>
<ul>
<li><p>单机阈值：具体限流的数值是多少。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Ff2jsbUyaqguJm4.png" alt="image-20210709064702009"></p>
<p>高级选项：</p>
<ul>
<li><p>流控模式是指采用什么方式进行流量控制。</p>
<ul>
<li><p>直接模式</p>
<p>List 接口 QPS 超过 1个时限流，浏览器会出现“Blocked by Sentinel”。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/I5OrxevYB9oPqf3.png" alt="image-20210709064945827"></p>
</li>
<li><p>关联</p>
<p>同 List 接口关联的update 接口 QPS 超过 1 时，再次访问List 接口便会响应“Blocked by Sentinel”。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/dhXtnCGfoASHxFl.png" alt="image-20210709065247054"></p>
</li>
<li><p>链路</p>
<p>/check</p>
<p>​                        →   /list</p>
<p>/scan</p>
<p>两条链路都可以访问到/list</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NDAQT59pO3SBIuo.png" alt="image-20210709065449276"></p>
<p>当访问 check 接口的QPS 超过 1 时，List 接口就会被限流。而另一条链路从 scan 接口到List 接口的链路则不会受到任何影响。</p>
</li>
</ul>
</li>
<li><p>流控效果</p>
<ul>
<li><p>快速失败</p>
<p>指流量当过限流阈值后，直接返回响应并抛出 BlockException</p>
</li>
<li><p>Warm Up（预热）</p>
<p>用于应对瞬时大并发流量冲击。当遇到突发大流量 Warm Up 会缓慢拉升阈值限制，预防系统瞬时崩溃，这期间超出阈值的访问处于队列等待状态，并不会立即抛出 BlockException。</p>
<p>List 接口平时单机阈值 QPS 处于低水位：默认为 1000/3 (冷加载因子)≈333，当瞬时大流量进来，10 秒钟内将 QPS 阈值逐渐拉升至 1000，为系统留出缓冲时间，预防突发性系统崩溃。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/rcfAFk4eyGJHN2X.png" alt="image-20210709065732758"></p>
</li>
<li><p>排队等待</p>
<p>采用匀速放行的方式对请求进行处理。如下所示，假设现在有100个请求瞬间进入，那么会出现以下几种情况：</p>
<pre><code>单机 QPS 阈值=4，代表 250 毫秒匀速放行 1 个请求，其他请求队列等待，共需 25 秒处理完毕；

单机 QPS 阈值=200，代表 5 毫秒匀速放行一个请求，其他请求队列等待，共需 0.5 秒处理完毕；

如果某一个请求在队列中处于等待状态超过 2000 毫秒，则直接抛出 BlockException。
</code></pre>
<p>匀速队列只支持 QPS 模式，且单机阈值不得大于 1000。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Fb3B6cDGIEUQ48Y.png" alt="image-20210709070050680"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Dashboard熔断配置"><a href="#Dashboard熔断配置" class="headerlink" title="Dashboard熔断配置"></a>Dashboard熔断配置</h5><h6 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h6><p>微服务的熔断是指在某个服务接口在执行过程中频繁出现故障的情况，我们便认为这种状态是“不可接受”的，立即对当前接口实施熔断。在规定的时间内，所有送达该接口的请求都将直接抛出 BlockException，在熔断期过后新的请求进入看接口是否恢复正常，恢复正常则继续运行，仍出现故障则再次熔断一段时间，以此往复直到服务接口恢复。</p>
<h6 id="熔断过程"><a href="#熔断过程" class="headerlink" title="熔断过程"></a>熔断过程</h6><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hkiHbjWJ2cBzn8U.png" alt="image-20210716164340305"></p>
<h6 id="熔断设置"><a href="#熔断设置" class="headerlink" title="熔断设置"></a>熔断设置</h6><p>Sentinel Dashboard可以设置三种不同的熔断模式：慢调用比例、异常比例、异常数</p>
<ul>
<li><p>慢调用比例是指当接口在1秒内“慢处理”数量超过一定比例，则触发熔断。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ci4ITNDCKZbkBQM.png" alt="image-20210716164555605"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/gwBoQZT7CUGthS8.png" alt="image-20210716164729877"></p>
</li>
<li><p>异常比例是指 1 秒内按接口调用产生异常的比例（异常调用数/总数量）触发熔断。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/EBPzcNUxupmlZFf.png" alt="image-20210716164814290"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/azXZFPB4LtCkHSx.png" alt="image-20210716164900964"></p>
</li>
<li><p>异常数是指在 1 分钟内异常的数量超过阈值则触发熔断。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Nb7PvQVeIzUTXMB.png" alt="image-20210716164917058"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TtcCsGaJpfY3dqX.png" alt="image-20210716164932771"></p>
</li>
</ul>
<h5 id="Sentinel与Nacos配置中心整合"><a href="#Sentinel与Nacos配置中心整合" class="headerlink" title="Sentinel与Nacos配置中心整合"></a>Sentinel与Nacos配置中心整合</h5><ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Nacos 客户端 Starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Sentinel 客户端 Starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 对外暴露 Spring Boot 监控指标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sentinel-sample #应用名&amp;微服务 id</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel: #Sentinel Dashboard 通信地址</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: 192.168.31.10:9100</span><br><span class="line">      eager: true #取消控制台懒加载</span><br><span class="line">    nacos: #Nacos 通信地址</span><br><span class="line">      server-addr: 192.168.31.10:8848</span><br><span class="line">      username: nacos</span><br><span class="line">      password: nacos</span><br><span class="line">  jackson:</span><br><span class="line">    default-property-inclusion: non_null</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web: #将所有可用的监控指标项对外暴露</span><br><span class="line">      exposure: #可以访问 /actuator/sentinel进行查看Sentinel监控项</span><br><span class="line">        include: &#x27;*&#x27;</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: debug #开启 debug 是学习需要，生产改为 info 即可</span><br></pre></td></tr></table></figure></li>
<li><p>业务代码</p>
<p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class SentinelSampleController &#123;</span><br><span class="line">    //演示用的业务逻辑类</span><br><span class="line">    @Resource</span><br><span class="line">    private SampleService sampleService;</span><br><span class="line">    /**</span><br><span class="line">     * 流控测试接口</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/test_flow_rule&quot;)</span><br><span class="line">    public ResponseObject testFlowRule()&#123;</span><br><span class="line">        //code=0 代表服务器处理成功</span><br><span class="line">        return new ResponseObject(&quot;0&quot;,&quot;success!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 熔断测试接口</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/test_degrade_rule&quot;)</span><br><span class="line">    public ResponseObject testDegradeRule()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            sampleService.createOrder();</span><br><span class="line">        &#125;catch (IllegalStateException e)&#123;</span><br><span class="line">            //当 createOrder 业务处理过程中产生错误时会抛出IllegalStateException</span><br><span class="line">            //IllegalStateException 是 JAVA 内置状态异常，在项目开发时可以更换为自己项目的自定义异常</span><br><span class="line">            //出现错误后将异常封装为响应对象后JSON输出</span><br><span class="line">            return new ResponseObject(e.getClass().getSimpleName(),e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return new ResponseObject(&quot;0&quot;,&quot;order created!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果封装类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 封装响应数据的对象</span><br><span class="line"> */</span><br><span class="line">public class ResponseObject &#123;</span><br><span class="line">    private String code; //结果编码，0-固定代表处理成功</span><br><span class="line">    private String message;//响应消息</span><br><span class="line">    private Object data;//响应附加数据（可选）</span><br><span class="line"> </span><br><span class="line">    public ResponseObject(String code, String message) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    //Getter/Setter省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示用的业务逻辑类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class SampleService &#123;</span><br><span class="line">    //模拟创建订单业务</span><br><span class="line">    public void createOrder()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //模拟处理业务逻辑需要101毫秒</span><br><span class="line">            Thread.sleep(101);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;订单已创建&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p>访问 <a href="http://localhost/test_flow_rule">http://localhost/test_flow_rule</a></p>
</li>
</ol>
<h6 id="整合-流控规则持久化"><a href="#整合-流控规则持久化" class="headerlink" title="整合-流控规则持久化"></a>整合-流控规则持久化</h6><ol>
<li><p>增加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件增加配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: sentinel-sample #应用名&amp;微服务id</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel: #Sentinel Dashboard通信地址</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: 192.168.31.10:9100</span><br><span class="line">      eager: true #取消控制台懒加载</span><br><span class="line">      datasource:</span><br><span class="line">        flow: #数据源名称，可以自定义</span><br><span class="line">          nacos: #nacos配置中心</span><br><span class="line">            #Nacos内置配置中心，因此重用即可</span><br><span class="line">            server-addr: $&#123;spring.cloud.nacos.server-addr&#125; </span><br><span class="line">            dataId: $&#123;spring.application.name&#125;-flow-rules #定义流控规则data-id，完整名称为:sentinel-sample-flow-rules，在配置中心设置时data-id必须对应。</span><br><span class="line">            groupId: SAMPLE_GROUP #gourpId对应配置文件分组，对应配置中心groups项</span><br><span class="line">            rule-type: flow #flow固定写死，说明这个配置是流控规则</span><br><span class="line">            username: nacos #nacos通信的用户名与密码</span><br><span class="line">            password: nacos</span><br><span class="line">    nacos: #Nacos通信地址</span><br><span class="line">      server-addr: 192.168.31.10:8848</span><br><span class="line">      username: nacos</span><br><span class="line">      password: nacos</span><br></pre></td></tr></table></figure></li>
<li><p>nacos配置中添加 流控配置</p>
<p>同UI 页面配置同样的效果</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JN1Gg5CbQ8maZov.png" alt="image-20210717222155344"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;resource&quot;:&quot;/test_flow_rule&quot;, #资源名，说明对那个URI进行流控</span><br><span class="line">        &quot;limitApp&quot;:&quot;default&quot;,  #命名空间，默认default</span><br><span class="line">        &quot;grade&quot;:1, #类型 0-线程 1-QPS</span><br><span class="line">        &quot;count&quot;:2, #超过2个QPS限流将被限流</span><br><span class="line">        &quot;strategy&quot;:0, #限流策略: 0-直接 1-关联 2-链路</span><br><span class="line">        &quot;controlBehavior&quot;:0, #控制行为: 0-快速失败 1-WarmUp 2-排队等待</span><br><span class="line">        &quot;clusterMode&quot;:false #是否集群模式</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>验证流控是否生效</p>
<p>访问 <a href="http://localhost/test_flow_rule">http://localhost/test_flow_rule</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 服务启动时已向 Nacos 配置中心获取到流控规则。</span><br><span class="line">DEBUG 12728 --- [main] s.n.www.protocol.http.HttpURLConnection  : sun.net.www.MessageHeader@5432948015 pairs: &#123;GET /nacos/v1/cs/configs?dataId=sentinel-sample-flow-rules&amp;accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYxMDg3NTA1M30.Hq561OkXuAqPI20IBsnPIn0ia86R9sZgdWwa_K8zwvw&amp;group=SAMPLE_GROUP HTTP/1.1: null&#125;...</span><br></pre></td></tr></table></figure>

<p>在浏览器反复刷新，当 test_flow_rule 接口每秒超过 2 次访问，就会出现“Blocked by Sentinel (flow limiting)”的错误信息，说明流控规则已生效。</p>
</li>
<li><p>验证能否自动推送新规则</p>
<p>将Nacos 配置中心中流控规则 count 选项改为 1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;resource&quot;:&quot;/test_flow_rule&quot;, </span><br><span class="line">        &quot;limitApp&quot;:&quot;default&quot;,</span><br><span class="line">        &quot;grade&quot;:1, </span><br><span class="line">        &quot;count&quot;:1, #2改为1 </span><br><span class="line">        &quot;strategy&quot;:0, </span><br><span class="line">        &quot;controlBehavior&quot;:0, </span><br><span class="line">        &quot;clusterMode&quot;:false </span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>新规则发布后，sentinel-sample控制台会立即收到下面的日志，说明新的流控规则即时生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEBUG 12728 --- [.168.31.10_8848] s.n.www.protocol.http.HttpURLConnection  : sun.net.www.MessageHeader@41257f3915 pairs: &#123;GET /nacos/v1/cs/configs?dataId=sentinel-sample-flow-rules&amp;accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYxMDg3NTA1M30.Hq561OkXuAqPI20IBsnPIn0ia86R9sZgdWwa_K8zwvw&amp;group=SAMPLE_GROUP HTTP/1.1: null&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Spring Boot Actuator 提供的监控指标确认流控规则已生效。</p>
<p>访问 <a href="http://localhost/actuator/sentinel%EF%BC%8C%E5%9C%A8">http://localhost/actuator/sentinel，在</a> flowRules 这个数组中，可以看到 test_flow_rule 的限流规则</p>
</li>
</ol>
<h5 id="自定义资源流控"><a href="#自定义资源流控" class="headerlink" title="自定义资源流控"></a>自定义资源流控</h5><p>介绍：针对某一个 Service 业务逻辑方法进行限流熔断等规则设置。</p>
<p>实例：对 SampleSerivce.createOrder方法进行熔断保护</p>
<ol>
<li><p>声明切面类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SentinelSampleApplication &#123;</span><br><span class="line">    // 注解支持的配置Bean</span><br><span class="line">    @Bean</span><br><span class="line">    public SentinelResourceAspect sentinelResourceAspect() &#123;// 用于进行熔断的前置检查</span><br><span class="line">        return new SentinelResourceAspect();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SentinelSampleApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>声明资源点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示用的业务逻辑类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class SampleService &#123;</span><br><span class="line">    //资源点名称为createOrder</span><br><span class="line">    @SentinelResource(&quot;createOrder&quot;)</span><br><span class="line">    /**</span><br><span class="line">     * 模拟创建订单业务</span><br><span class="line">     * 抛出IllegalStateException异常用于模拟业务逻辑执行失败的情况</span><br><span class="line">     */</span><br><span class="line">    public void createOrder() throws IllegalStateException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //模拟处理业务逻辑需要101毫秒</span><br><span class="line">            Thread.sleep(101);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;订单已创建&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务测试接口，确认资源点已存在 Sentinel Dashboard</p>
<p>访问 <a href="http://localhost/test_degrade_rule">http://localhost/test_degrade_rule</a></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/HVl6ZXDU7MoWrpg.png" alt="image-20210717223343479"></p>
</li>
<li><p>获取熔断规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  flow: #之前的流控规则，直接忽略</span><br><span class="line">    ...</span><br><span class="line">  degrade: #熔断规则</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: $&#123;spring.cloud.nacos.server-addr&#125;</span><br><span class="line">      dataId: $&#123;spring.application.name&#125;-degrade-rules</span><br><span class="line">      groupId: SAMPLE_GROUP</span><br><span class="line">      rule-type: degrade #代表熔断</span><br><span class="line">     username: nacos</span><br><span class="line">     password: nacos</span><br></pre></td></tr></table></figure>

<p>确定配置，启动日志如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main] s.n.www.protocol.http.HttpURLConnection  : sun.net.www.MessageHeader@d96945215 pairs: &#123;GET /nacos/v1/cs/configs?dataId=sentinel-sample-degrade-rules&amp;accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYxMDg5MDMwNH0.ooHkFb4zX14klmHMuLXTDkHSoCrwI8LtN7ex__9tMHg&amp;group=SAMPLE_GROUP HTTP/1.1: null&#125;...</span><br></pre></td></tr></table></figure></li>
<li><p>配置熔断规则</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/98314Edx7vDbYsp.png" alt="image-20210717223826845"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    &quot;resource&quot;: &quot;createOrder&quot;, #自定义资源名</span><br><span class="line">    &quot;limitApp&quot;: &quot;default&quot;, #命名空间</span><br><span class="line">    &quot;grade&quot;: 0, #0-慢调用比例 1-异常比例 2-异常数</span><br><span class="line">    &quot;count&quot;: 100, #最大RT 100毫秒执行时间</span><br><span class="line">    &quot;timeWindow&quot;: 5, #时间窗口5秒</span><br><span class="line">    &quot;minRequestAmount&quot;: 1, #最小请求数</span><br><span class="line">    &quot;slowRatioThreshold&quot;: 0.1 #比例阈值</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>熔断机制</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Z2Br69nzmhYXpx4.png" alt="image-20210717224019474"></p>
<p>访问 Spring Boot Actuator<a href="http://localhost/actuator/sentinel%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%AD%A4%E6%97%B6">http://localhost/actuator/sentinel，可以看到此时</a> gradeRules 数组下 createOrder 资源点的熔断规则已被 Nacos推送并立即生效。</p>
</li>
<li><p>验证</p>
<p>连续访问 <a href="http://localhost/test_degrade_rule%EF%BC%8C%E5%BD%93%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E4%BE%BF%E4%BC%9A%E5%87%BA%E7%8E%B0">http://localhost/test_degrade_rule，当第二次访问时便会出现</a> 500 错误。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/N2kSujzBtmGxC3i.png" alt="image-20210717224132076"></p>
</li>
<li><p>完善异常提示</p>
<p>针对 RESTful 接口的统一异常处理需要实现 BlockExceptionHandler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component //Spring IOC实例化并管理该对象</span><br><span class="line">public class UrlBlockHandler implements BlockExceptionHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * RESTFul异常信息处理器</span><br><span class="line">     * @param httpServletRequest</span><br><span class="line">     * @param httpServletResponse</span><br><span class="line">     * @param e</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception &#123;</span><br><span class="line">        String msg = null;</span><br><span class="line">        if(e instanceof FlowException)&#123;//限流异常</span><br><span class="line">            msg = &quot;接口已被限流&quot;;</span><br><span class="line">        &#125;else if(e instanceof DegradeException)&#123;//熔断异常</span><br><span class="line">            msg = &quot;接口已被熔断,请稍后再试&quot;;</span><br><span class="line">        &#125;else if(e instanceof ParamFlowException)&#123; //热点参数限流</span><br><span class="line">            msg = &quot;热点参数限流&quot;; </span><br><span class="line">        &#125;else if(e instanceof SystemBlockException)&#123; //系统规则异常</span><br><span class="line">            msg = &quot;系统规则(负载/....不满足要求)&quot;;</span><br><span class="line">        &#125;else if(e instanceof AuthorityException)&#123; //授权规则异常</span><br><span class="line">            msg = &quot;授权规则不通过&quot;; </span><br><span class="line">        &#125;</span><br><span class="line">        httpServletResponse.setStatus(500);</span><br><span class="line">        httpServletResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        httpServletResponse.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">        //ObjectMapper是内置Jackson的序列化工具类,这用于将对象转为JSON字符串</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        //某个对象属性为null时不进行序列化输出</span><br><span class="line">        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        mapper.writeValue(httpServletResponse.getWriter(),</span><br><span class="line">                new ResponseObject(e.getClass().getSimpleName(), msg)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义资源点的异常处理</p>
<p>在 @SentinelResource 注解上额外附加 blockHandler属性进行异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示用的业务逻辑类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class SampleService &#123;</span><br><span class="line">    @SentinelResource(value = &quot;createOrder&quot;,blockHandler = &quot;createOrderBlockHandler&quot;)</span><br><span class="line">    /**</span><br><span class="line">     * 模拟创建订单业务</span><br><span class="line">     * 抛出 IllegalStateException 异常用于模拟业务逻辑执行失败的情况</span><br><span class="line">     */</span><br><span class="line">    public void createOrder() throws IllegalStateException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //模拟处理业务逻辑需要 101 毫秒</span><br><span class="line">            Thread.sleep(101);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;订单已创建&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void createOrderBlockHandler(BlockException e) throws IllegalStateException&#123;</span><br><span class="line">        String msg = null;</span><br><span class="line">        if(e instanceof FlowException)&#123;//限流异常</span><br><span class="line">            msg = &quot;资源已被限流&quot;;</span><br><span class="line">        &#125;else if(e instanceof DegradeException)&#123;//熔断异常</span><br><span class="line">            msg = &quot;资源已被熔断,请稍后再试&quot;;</span><br><span class="line">        &#125;else if(e instanceof ParamFlowException)&#123; //热点参数限流</span><br><span class="line">            msg = &quot;热点参数限流&quot;;</span><br><span class="line">        &#125;else if(e instanceof SystemBlockException)&#123; //系统规则异常</span><br><span class="line">            msg = &quot;系统规则(负载/....不满足要求)&quot;;</span><br><span class="line">        &#125;else if(e instanceof AuthorityException)&#123; //授权规则异常</span><br><span class="line">            msg = &quot;授权规则不通过&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalStateException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createOrderBlockHandler 方法的书写有两个要求</p>
<p>方法返回值、访问修饰符、抛出异常要与原始的 createOrder 方法完全相同。</p>
<p>createOrderBlockHandler 方法名允许自定义，但最后一个参数必须是 BlockException 对象，这是所有规则异常的父类，通过判断 BlockException 我们就知道触发了哪种规则异常。</p>
</li>
</ol>
<h4 id="Sentinel原理"><a href="#Sentinel原理" class="headerlink" title="Sentinel原理"></a>Sentinel原理</h4><p>Sentinel Dashboard 是Sentinel的控制端，当内置在微服务内的 Sentinel Core（客户端）接收到控制端新的限流、熔断规则后，微服务便会自动启用的相应的保护措施。</p>
<p>Sentinel执行流程：</p>
<ol>
<li>Sentinel Core与Sentinel Dashboard建立连接</li>
<li>Sentinel Dashboard 向Sentinel Core下发新的保护规则</li>
<li>Sentinel Core应用新的保护规则，实施限流、熔断等。</li>
</ol>
<p>Sentinel执行流程细节：</p>
<ol>
<li><p>建立连接</p>
<p>Sentinel core 初始化时，主动向application.yml中配置的Dashboard的IP地址发起连接请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Sentinel Dashboard通信地址</span><br><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    sentinel: </span><br><span class="line">      transport:</span><br><span class="line">        dashboard: 192.168.31.10:9100</span><br></pre></td></tr></table></figure>

<p>该请求以心跳包的方式定时向Dashboard发送，包含Sentinel Core 的AppName、IP、端口信息。</p>
<p>Sentinel Core持续接收Dashboard数据和发送心跳包使用8719 端口。</p>
<p>Sentinel Dashboard 接收到心跳包后，来自 Sentinel Core的AppName、IP、端口信息会被封装为 MachineInfo 对象放入 ConcurrentHashMap 保存在 JVM的内存中，以备后续使用。</p>
</li>
<li><p>Dashboard下发保护规则</p>
<ol>
<li>Dashboard 页面中设置了新的保护规则，</li>
<li>从当前的 MachineInfo 中提取符合要求的微服务实例信息</li>
<li>通过 Dashboard内置的 transport 模块将新规则打包推送到微服务实例的 Sentinel Core</li>
</ol>
</li>
<li><p>Sentinel Core应用新规则</p>
<ol>
<li><p>Sentinel Core收 到新规则</p>
</li>
<li><p>对本地规则进行更新。</p>
</li>
<li><p>依据规则处理请求。</p>
<p>Sentinel Core 为服务限流、熔断提供了核心拦截器 SentinelWebInterceptor，这个拦截器默认对所有请求 /** 进行拦截，然后开始请求的链式处理流程，在对于每一个处理请求的节点被称为 Slot（槽），通过多个槽的连接形成处理链，在请求的流转过程中，如果有任何一个 Slot 验证未通过，都会产生 BlockException，请求处理链便会中断，并返回“Blocked by sentinel” 异常信息。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WsMCDPGHZa3xVER.png" alt="image-20210708211817988"></p>
<p>默认 Slot 有7 个，前 3 个 Slot为前置处理，用于收集、统计、分析必要的数据；后 4 个为规则校验 Slot，从Dashboard  推送的新规则保存在“规则池”中，然后对应 Slot 进行读取并校验当前请求是否允许放行，允许放行则送入下一个 Slot 直到最终被  RestController 进行业务处理，不允许放行则直接抛出 BlockException 返回响应。</p>
<p>Slot具体职责：</p>
<ul>
<li>NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>
<li>ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT（运行时间）, QPS, thread count（线程总数）等，这些信息将用作为多维度限流，降级的依据；</li>
<li>StatistcSlot 则用于记录，统计不同维度的runtime 信息；</li>
<li>SystemSlot 则通过系统的状态，例如CPU、内存的情况，来控制总的入口流量；</li>
<li>AuthoritySlot 则根据黑白名单，来做黑白名单控制；</li>
<li>FlowSlot 则用于根据预设的限流规则，以及前面 slot 统计的状态，来进行限流；</li>
<li>DegradeSlot 则通过统计信息，以及预设的规则，来做熔断降级。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="6-应用性能监控SkyWalking"><a href="#6-应用性能监控SkyWalking" class="headerlink" title="6.应用性能监控SkyWalking"></a>6.应用性能监控SkyWalking</h3><p>博客地址 TODO</p>
<h4 id="Sleuth-Zipkin"><a href="#Sleuth-Zipkin" class="headerlink" title="Sleuth+Zipkin"></a>Sleuth+Zipkin</h4><h5 id="使用-Tracer-在访问链路中创建自定义的-Span"><a href="#使用-Tracer-在访问链路中创建自定义的-Span" class="headerlink" title="使用 Tracer 在访问链路中创建自定义的 Span"></a>使用 Tracer 在访问链路中创建自定义的 Span</h5><p>介绍：创建自定义的 Span 并纳入可视化监控机制中</p>
<p>场景：在业务系统中重点监控某些业务操作</p>
<p>版本1.X </p>
<p>实现：通过 Spring Cloud Sleuth 自带的 org.springframework.cloud.sleuth.Tracer 接口创建和管理自定义 Span。</p>
<p>版本：2.X </p>
<p>实现：使用 Brave 创建自定义 Span</p>
<p>代码：</p>
<ol>
<li><p>业务中添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Tracer tracer;// </span><br><span class="line"></span><br><span class="line">    public void perform() &#123;</span><br><span class="line">    	// 创建并启动了一个“spanName”新的 Span</span><br><span class="line">         Span newSpan = tracer.nextSpan().name(&quot;spanName&quot;).start();</span><br><span class="line">        //ScopedSpan newSpan = tracer.startScopedSpan(&quot;spanName&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            //执行业务逻辑</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">          newSpan.tag(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">          newSpan.annotate(&quot;myannotation&quot;);</span><br><span class="line">          newSpan.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NewSpan(name = &quot;myspan&quot;)//创建新span</span><br><span class="line">void myMethod(@SpanTag(&quot;mykey&quot;) String param);//生成一个键为“mykey”，值为 param 的新标签。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-分布式事务Seata"><a href="#7-分布式事务Seata" class="headerlink" title="7.分布式事务Seata"></a>7.分布式事务Seata</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><h5 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h5><ol>
<li><p>跨数据库操作</p>
</li>
<li><p>跨系统的分布式事务</p>
<p>与第三方系统（企业内外）集成可能遇到</p>
</li>
<li><p>跨服务的分布式事务</p>
</li>
<li><p>跨数据库与消息的分布式事务</p>
</li>
</ol>
<h5 id="分布式解决方案"><a href="#分布式解决方案" class="headerlink" title="分布式解决方案"></a>分布式解决方案</h5><p>分布式事务解决方案：二阶段提交（2PC）与三阶段提交（3PC）。</p>
<h6 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h6><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/rENSnD2kHyp7UYQ.png" alt="image-20210716171516747"></p>
<ol>
<li><p>阶段一，事务预处理阶段。</p>
<p>事务协调者会向各服务下达“处理本地事务”的通知，本地事务开始处理业务逻辑，如订单服务中负责创建新的订单记录；会员服务负责增加会员的积分；库存服务负责减少库存数量。被操作的所有数据都处于未提交（uncommit）的状态，会被排它锁锁定。本地事务都处理完成后，会通知事务协调者“本地事务处理完毕”。所有本地事务处理完毕后，进入阶段二。</p>
</li>
<li><p>阶段二，预提交阶段。</p>
<p>预提交阶段只是一个询问机制，以确认所有服务都已准备好，同时在此阶段协调者和参与者都设置了超时时间以防止出现长时间资源锁定。当阶段二所有服务返回“可以提交”，进入阶段三“提交阶段”。</p>
</li>
<li><p>阶段三，提交阶段</p>
<p>3PC 的提交阶段与 2PC 的提交阶段是一致的，在每一个数据库中执行提交实现数据的资源写入，如果协调者与服务通信中断导致无法提交，在服务端超时后在也会自动执行提交操作来保证资源释放。</p>
</li>
</ol>
<p>问题：预提交阶段引入了超时机制，让数据库资源不会被长期锁定，数据一致性也很可能因为超时后的强制提交被破坏。</p>
<p>解决：增加异步的数据补偿任务、日终跑批前的数据补偿、更完善的业务数据完整性的校验代码、引入数据监控及时通知人工补录。</p>
<h5 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h5><p>AT：需要数据库支持事务，使用简单。（自动解析sql生成反向SQL，用于回滚。）</p>
<p>TCC：开启、提交、回滚程序员控制，灵活，复杂（失败时，事务自动多次提交，还需考虑幂等性）</p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>AT 模式</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XdT9whlAurJ5H7q.png" alt="image-20210717093558206"></p>
<h5 id="部署TC-Seata-Server"><a href="#部署TC-Seata-Server" class="headerlink" title="部署TC-Seata-Server"></a>部署TC-Seata-Server</h5><ol>
<li><p>下载seata</p>
<p><a href="https://github.com/seata/seata/releases/download/v1.4.0/seata-server-1.4.0.tar.gz">https://github.com/seata/seata/releases/download/v1.4.0/seata-server-1.4.0.tar.gz</a></p>
</li>
<li><p>配置seata接入注册中心和配置中心， conf/registry.conf 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # Seata-Server支持以下几种注册中心，这里改为nacos，默认是file文件形式不介入任何注册中心。</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line">  # 负载均衡采用随机策略</span><br><span class="line">  loadBalance = &quot;RandomLoadBalance&quot;</span><br><span class="line">  loadBalanceVirtualNodes = 10</span><br><span class="line">  # nacos注册中心接入配置</span><br><span class="line">  nacos &#123;</span><br><span class="line">    # 应用名称</span><br><span class="line">    application = &quot;seata-server&quot;</span><br><span class="line">    #IP地址与端口</span><br><span class="line">    serverAddr = &quot;192.168.31.10:8848&quot;</span><br><span class="line">    # 分配应用组，采用默认值SEATA_GROUP即可</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    # 集群名称，采用默认值default即可</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    # Nacos接入用户名密码</span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#Seata-Server接入配置中心</span><br><span class="line">config &#123;</span><br><span class="line">  # Seata-Server支持以下配置中心产品，这里设置为nacos，默认是file即文件形式保存配置内容。</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line">  # 设置Nacos的通信地址</span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;192.168.31.10:8848&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    username = &quot;nacos&quot;</span><br><span class="line">    password = &quot;nacos&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>nacos配置中心初始化seata配置</p>
<p>官网找初始化脚本<a href="https://github.com/seata/seata/blob/1.4.0/script/config-center/config.txt">https://github.com/seata/seata/blob/1.4.0/script/config-center/config.txt</a></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/2pLJDeRSGi4NWKg.png" alt="image-20210717093755192"></p>
<p>在 /usr/local/seata-server-1.4.0 目录创建 config.txt文件，复制脚本内容到文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改</span><br><span class="line">store.db.url=jdbc:mysql://192.168.31.103:3309/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span><br><span class="line">store.db.user=root</span><br><span class="line">store.db.password=root</span><br></pre></td></tr></table></figure>

<p>下载运行脚本</p>
<p><a href="https://github.com/seata/seata/blob/1.4.0/script/config-center/nacos/nacos-config.sh">https://github.com/seata/seata/blob/1.4.0/script/config-center/nacos/nacos-config.sh</a></p>
<p>在 /usr/local/seata-server-1.4.0 目录创建 script 子目录。放入文件</p>
<p>运行导入脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh nacos-config.sh -h 192.168.31.10</span><br></pre></td></tr></table></figure>

<p>Nacos 后台<a href="http://192.168.31.10:8848/nacos">http://192.168.31.10:8848/nacos</a> ，会看到大量 SEATA_GROUP 分组的配置，Seata-Server 启动时自动读取</p>
</li>
<li><p>创建并初始化Seata-Server全局事务数据库</p>
<p>下载 SQL 脚本 <a href="https://github.com/seata/seata/blob/1.4.0/script/server/db/mysql.sql">https://github.com/seata/seata/blob/1.4.0/script/server/db/mysql.sql</a></p>
<p>MySQL中创建数据库 seata，执行SQL脚本创建全局事务表</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Z3HPVsqb5EUteAR.png" alt="image-20210717094319951"></p>
</li>
<li><p>启动 seata-server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh bin/seata-server.sh</span><br></pre></td></tr></table></figure>

<p>启动过程中提示数据库无法访问，说明 IP、端口配置有问题，可以通过 Nacos 配置中心设置 store.db.url 选项，而不是重新导入 config.txt。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/qkNpvbTioxBKyPE.png" alt="image-20210717094506894"></p>
</li>
</ol>
<h5 id="开发RM资源管理器"><a href="#开发RM资源管理器" class="headerlink" title="开发RM资源管理器"></a>开发RM资源管理器</h5><p>订单服务、会员服务、库存服务</p>
<h6 id="订单服务"><a href="#订单服务" class="headerlink" title="订单服务"></a>订单服务</h6><ol>
<li><p>创建seata-order数据库和 undo_log 表。Seata 强制要求在每个 RM 端数据库创建的表，用于存储反向 SQL 的元数据</p>
<p><a href="https://github.com/seata/seata/blob/1.4.0/script/client/at/db/mysql.sql">https://github.com/seata/seata/blob/1.4.0/script/client/at/db/mysql.sql</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 订单业务表 order</span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for order</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `order`;</span><br><span class="line">CREATE TABLE `order`  (</span><br><span class="line">  `order_id` int(255) NOT NULL AUTO_INCREMENT COMMENT &#x27;订单编号&#x27;,</span><br><span class="line">  `goods_id` int(32) NOT NULL COMMENT &#x27;商品编号&#x27;,</span><br><span class="line">  `member_id` int(32) NOT NULL COMMENT &#x27;会员编号&#x27;,</span><br><span class="line">  `quantity` int(255) NOT NULL COMMENT &#x27;购买数量&#x27;,</span><br><span class="line">  `points` int(255) NOT NULL COMMENT &#x27;增加会员积分&#x27;,</span><br><span class="line">  PRIMARY KEY (`order_id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for undo_log</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `undo_log`;</span><br><span class="line">CREATE TABLE `undo_log`  (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `context` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` int(11) NOT NULL,</span><br><span class="line">  `log_created` datetime(0) NOT NULL,</span><br><span class="line">  `log_modified` datetime(0) NOT NULL,</span><br><span class="line">  `ext` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE,</span><br><span class="line">  UNIQUE INDEX `ux_undo_log`(`xid`, `branch_id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure></li>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--Spring Boot JPA--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Web MVC--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Nacos客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--seata--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--seata 客户端最新版--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--seata与spring boot starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--JDBC驱动--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#seata配置</span><br><span class="line">seata:</span><br><span class="line">#  开启seata分布式事务</span><br><span class="line">  enabled: true</span><br><span class="line">#  事务服务分组名,与naocs一致</span><br><span class="line">  tx-service-group: my_test_tx_group</span><br><span class="line">#  是否启用数据源代理</span><br><span class="line">  enable-auto-data-source-proxy: true</span><br><span class="line">#  事务服务配置</span><br><span class="line">  service:</span><br><span class="line">    vgroup-mapping:</span><br><span class="line">#      事务分组对应集群名称</span><br><span class="line">      my_test_tx_group: default</span><br><span class="line">    grouplist:</span><br><span class="line">#      Seata-Server服务的IP地址与端口</span><br><span class="line">      default: 192.168.31.107:8091</span><br><span class="line">    enable-degrade: false</span><br><span class="line">    disable-global-transaction: false</span><br><span class="line">#    Nacos配置中心信息</span><br><span class="line">  config:</span><br><span class="line">    type: nacos</span><br><span class="line">    nacos:</span><br><span class="line">      namespace:</span><br><span class="line">      serverAddr: 192.168.31.10:8848</span><br><span class="line">      group: SEATA_GROUP</span><br><span class="line">      username: nacos</span><br><span class="line">      password: nacos</span><br><span class="line">      cluster: default</span><br><span class="line">#      Nacos注册中心信息</span><br><span class="line">  registry:</span><br><span class="line">    type: nacos</span><br><span class="line">    nacos:</span><br><span class="line">      application: seata-server</span><br><span class="line">      server-addr: 192.168.31.10:8848</span><br><span class="line">      group : SEATA_GROUP</span><br><span class="line">      namespace:</span><br><span class="line">      username: nacos</span><br><span class="line">      password: nacos</span><br><span class="line">      cluster: default</span><br><span class="line"># 应用配置</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: rm-order</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://192.168.31.103:3306/seata-order</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        username: nacos</span><br><span class="line">        password: nacos</span><br><span class="line">        server-addr: 192.168.31.10:8848</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: debug</span><br></pre></td></tr></table></figure></li>
<li><p>开发crud</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JPA实体类</span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;`order`&quot;) //对应order表</span><br><span class="line">public class Order &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @Column(name = &quot;order_id&quot;)</span><br><span class="line">    private Integer id; //订单编号</span><br><span class="line">    private Integer memberId; //会员编号</span><br><span class="line">    @Column(name = &quot;goods_id&quot;)</span><br><span class="line">    private Integer goodsId; //商品编号</span><br><span class="line">    private Integer points; //新增积分</span><br><span class="line">    private Integer quantity; //销售数量</span><br><span class="line">    public Order() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Order(Integer id, Integer memberId, Integer goodsId, Integer points, Integer quantity) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.memberId = memberId;</span><br><span class="line">        this.points = points;</span><br><span class="line">        this.goodsId = goodsId;</span><br><span class="line">        this.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">    //...getter &amp; setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface OrderRepository extends JpaRepository&lt;Order,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private OrderRepository orderRepository;</span><br><span class="line">    @Transactional</span><br><span class="line">    public Order createOrder(Integer orderId,Integer memberId,Integer goodsId,Integer points,Integer quantity)&#123;</span><br><span class="line">        return orderRepository.save(new Order(orderId, memberId,goodsId,points,quantity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class OrderController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private OrderService orderService;</span><br><span class="line">    @GetMapping(&quot;/create_order&quot;)</span><br><span class="line">    public String createOrder(Integer orderId,Integer memberId,Integer goodsId,Integer points,Integer quantity) throws JsonProcessingException &#123;</span><br><span class="line">        Map result = new HashMap&lt;&gt;();</span><br><span class="line">        Order order = orderService.createOrder(orderId,memberId,goodsId,points,quantity);</span><br><span class="line">        result.put(&quot;code&quot;, &quot;0&quot;);</span><br><span class="line">        result.put(&quot;message&quot;, &quot;create order success&quot;);</span><br><span class="line">        return new ObjectMapper().writeValueAsString(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置 DataSourceProxy 数据源代理类，用于seata自动生成 undo_log 回滚数据，以及自动完成 RM 端分布式事务的提交或回滚操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import io.seata.rm.datasource.DataSourceProxy;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">@Configuration</span><br><span class="line">public class DataSourceProxyConfig &#123;</span><br><span class="line">    //创建Druid数据源</span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    public DruidDataSource druidDataSource() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    //建立DataSource数据源代理</span><br><span class="line">    @Primary</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceProxy dataSource(DruidDataSource druidDataSource) &#123;</span><br><span class="line">        return new DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动 rm-order，访问 create_order 接口</p>
<p><a href="http://192.168.31.106:8002/create_order?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=200">http://192.168.31.106:8002/create_order?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=200</a></p>
</li>
</ol>
<h6 id="rm-points-积分服务"><a href="#rm-points-积分服务" class="headerlink" title="rm-points 积分服务"></a>rm-points 积分服务</h6><h6 id="rm-storage-库存服务"><a href="#rm-storage-库存服务" class="headerlink" title="rm-storage 库存服务"></a>rm-storage 库存服务</h6><h5 id="开发TM-事务管理器"><a href="#开发TM-事务管理器" class="headerlink" title="开发TM 事务管理器"></a>开发TM 事务管理器</h5><ol>
<li><p>创建 seata-mall 数据库和undo_log 表</p>
</li>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#seata配置与rm-order完全相同，省略</span><br><span class="line">seata:</span><br><span class="line">...</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: tm-mall</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://192.168.31.103:3305/seata-mall</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">...</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>启动类增加远程调用注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class TmMallApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TmMallApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开发三个远程调用接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//订单服务客户端</span><br><span class="line">@FeignClient(&quot;rm-order&quot;)</span><br><span class="line">public interface OrderFeignClient &#123;</span><br><span class="line">    @GetMapping(&quot;/create_order&quot;)</span><br><span class="line">    public String createOrder(@RequestParam(&quot;orderId&quot;) Integer orderId,</span><br><span class="line">                              @RequestParam(&quot;memberId&quot;) Integer memberId,</span><br><span class="line">                              @RequestParam(&quot;goodsId&quot;) Integer goodsId,</span><br><span class="line">                              @RequestParam(&quot;points&quot;) Integer points,</span><br><span class="line">                              @RequestParam(&quot;quantity&quot;) Integer quantity</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//积分服务客户端</span><br><span class="line">@FeignClient(&quot;rm-points&quot;)</span><br><span class="line">public interface PointsFeignClient &#123;</span><br><span class="line">    @GetMapping(&quot;/add_points&quot;)</span><br><span class="line">    public String addPoints(@RequestParam(&quot;memberId&quot;) Integer memberId, @RequestParam(&quot;points&quot;) Integer points);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//库存服务客户端</span><br><span class="line">@FeignClient(&quot;rm-storage&quot;)</span><br><span class="line">public interface StorageFeignClient &#123;</span><br><span class="line">    @GetMapping(&quot;/reduce_storage&quot;)</span><br><span class="line">    public String reduceStorage(@RequestParam(&quot;goodsId&quot;) Integer goodsId, @RequestParam(&quot;quantity&quot;) Integer quantity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开发 MallService，定义全局事务范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MallService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    OrderFeignClient orderFeignClient;</span><br><span class="line">    @Resource</span><br><span class="line">    PointsFeignClient pointsFeignClient;</span><br><span class="line">    @Resource</span><br><span class="line">    StorageFeignClient storageFeignClient;</span><br><span class="line"></span><br><span class="line">    @GlobalTransactional(name = &quot;seata-group-tx-mall&quot;, rollbackFor = &#123;Exception.class&#125;) // 全局事务注解,MallService.sale 方法时通知 TC 开启全局事务，sale 方法执行成功自动通知 TC 进行全局提交；sale 方法抛出异常时自动通知 TC 进行全局回滚。</span><br><span class="line">    public String sale(Integer orderId,Integer memberId,Integer goodsId,Integer points,Integer quantity) &#123;</span><br><span class="line">        String orderResult = orderFeignClient.createOrder(orderId,memberId,goodsId,points,quantity);</span><br><span class="line">        String pointsResult = pointsFeignClient.addPoints(memberId, points);</span><br><span class="line">        String storageResult = storageFeignClient.reduceStorage(goodsId, quantity);</span><br><span class="line">        return orderResult + &quot; / &quot; + pointsResult + &quot; / &quot; + storageResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>开发 MallController 对外暴露 sale 接口提供调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MallController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private MallService mallService;</span><br><span class="line">    @GetMapping(&quot;/sale&quot;)</span><br><span class="line">    public String sale(Integer orderId,Integer memberId,Integer goodsId,Integer points,Integer quantity)&#123;</span><br><span class="line">        return mallService.sale(orderId,memberId,goodsId,points,quantity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置 DataSourceProxyConfig，这是所有 TM 与 RM 都要设置的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceProxyConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    public DruidDataSource druidDataSource() &#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    @Primary</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceProxy dataSource(DruidDataSource druidDataSource) &#123;</span><br><span class="line">        return new DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>启动 Nacos、TC、TM、3 个 RM ，</p>
<ul>
<li><p>正常验证</p>
<p>访问 tm-mall 的 sale 接口。</p>
<p><a href="http://localhost:8001/sale?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=20">http://localhost:8001/sale?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=20</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## TM端日志</span><br><span class="line"># 启动全局事务</span><br><span class="line">i.seata.tm.api.DefaultGlobalTransaction  : Begin new global transaction [192.168.31.107:8091:100622589646344192]</span><br><span class="line">...</span><br><span class="line"># 全局事务已提交</span><br><span class="line">i.seata.tm.api.DefaultGlobalTransaction  : [192.168.31.107:8091:100622589646344192] commit status: Committed</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## RM日志</span><br><span class="line"># 分支事务已提交</span><br><span class="line">i.s.c.r.p.c.RmBranchCommitProcessor      : branch commit result:xid=192.168.31.107:8091:100622589646344192,branchId=100622590170632192,branchStatus=PhaseTwo_Committed,result code =Success,getMsg =null</span><br><span class="line"># 清空undo_log表</span><br><span class="line">i.s.r.d.undo.mysql.MySQLUndoLogManager   : batch delete undo log size 1</span><br></pre></td></tr></table></figure></li>
<li><p>异常验证</p>
<p>quantity 设置为 200，超出库存报错，看能否全局回滚。<br><a href="http://localhost:8001/sale?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=200">http://localhost:8001/sale?orderId=6&amp;memberId=1&amp;goodsId=2&amp;points=20&amp;quantity=200</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 程序报错</span><br><span class="line">java.lang.IllegalStateException: 商品库存不足。</span><br><span class="line"></span><br><span class="line">// TM 向 TC 发起全局回滚通知。</span><br><span class="line">i.seata.tm.api.DefaultGlobalTransaction  : Begin new global transaction [192.168.31.107:8091:100626590567763968]</span><br><span class="line">i.s.c.rpc.netty.AbstractNettyRemoting    : io.seata.core.rpc.netty.TmNettyRemotingClient@2e81af7d msgId:1726, body:globalStatus=Rollbacked,ResultCode=Success,Msg=null</span><br></pre></td></tr></table></figure>

<p>TC 向 RM 下达分支事务回滚通知，RM 收到通知做两件事：第一，根据 undo_log 表生成的反向 SQL，将之前写入的数据撤销；第二，删除 undo_log 数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i.s.r.d.undo.AbstractUndoLogManager      : Flushing UNDO LOG: &#123;&quot;@class&quot;:&quot;io.seata.rm.datasource.undo.BranchUndoLog&quot;,&quot;xid&quot;:&quot;192.168.31.107:8091:100626590567763968&quot;,&quot;branchId&quot;:100626590894919681...</span><br><span class="line">io.seata.rm.AbstractRMHandler            : Branch Rollbacking: 192.168.31.107:8091:100626590567763968 100626590894919681 jdbc:mysql://192.168.31.103:3306/seata-order</span><br><span class="line">i.s.r.d.undo.AbstractUndoLogManager      : xid 192.168.31.107:8091:100626590567763968 branch 100626590894919681, undo_log deleted with GlobalFinished</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><h4 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4843e7f2f94bb2d2f2a19fc973a5f21.jpg"></p>
<h3 id="8-分布式锁"><a href="#8-分布式锁" class="headerlink" title="8.分布式锁"></a>8.分布式锁</h3><p>用途：控制分布式系统中的不同主机之间对共享资源的访问。</p>
<ul>
<li>同一应用程序多实例下控制只有一个实例执行。</li>
<li>不同应用程序只有一个程序修改数据。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>定时拉取上游系统数据，部署了双节点。不用分布式锁，定时任务会执行两次。</li>
<li>防止同一用户对同一接口短时间多次点击。</li>
<li>秒杀系统的库存管理，避免超卖。</li>
</ul>
<h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><ul>
<li><p>zookeeper</p>
<p>介绍：利⽤的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式 锁的特点是⾼⼀致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱。先同步到一半以上从节点，再返回加锁成功；</p>
<p>流程：客户端要获取锁，1.在请求下创建临时顺序子节点，2.若节点最小，则获得了锁，执行业务3.使用完锁，则删除该节点，释放锁。</p>
<p>详细流程：</p>
<ol>
<li>客户端在lock节点下创建临时顺序节点。</li>
<li>2.获取lock下面的所有子节点，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁，执行业务代码。使用完锁后，将该节点删除。</li>
<li>3.如果自己创建的节点并非lock所有子节点中最小的，找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</li>
<li>4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤（监听比自己小一个节点的删除事件，判断自己是否是最小节点）。</li>
</ol>
</li>
<li><p>redis</p>
<p>介绍：利⽤redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是⾼可⽤， 因为redis保证的是AP，所以由它实现的分布式锁可能不可靠，不稳定（⼀旦redis中的数据出现了 不⼀致），可能会出现多个客户端同时加到锁的情况 。</p>
<p>框架redisson</p>
<p>流程：</p>
<ol>
<li>尝试获取锁，执行加锁lua脚本。用uuid+自己主线程ID加锁，设置锁过期时间默认30秒</li>
<li>若第一步未获取到锁，则去订阅解锁消息，当获取到锁剩余过期时间后，调用信号量方法堵塞住方法，知道被唤醒或等待超时。</li>
<li>一旦持有锁的线程释放了锁，就会广播解锁消息。第二步堵塞的线程就会被唤醒并重新尝试获取锁。</li>
<li>为了解决锁到期业务可能未执行完的情况，设置定时任务看门狗每隔10s给未完成的业务方法的锁续期30秒。</li>
<li>解锁时，判断是不是自己的锁，不是自己的锁不删除。</li>
</ol>
</li>
</ul>
<p> 代码：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisson.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"> redisson.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <a href="https://www.cnblogs.com/ludangxin/p/15145779.html">使用案例</a></p>
<p>存在的问题：主从节点不同步，锁丢失。从节点也获取到锁。<br>服务器4个节点不如3个节点。<br>持久化时每隔1秒刷新，机器宕机恢复时锁丢失。<br>解决：<br>    红锁：<br>        三个相等得Redis。<br>        超过半数Redis节点加锁成功才算加速成功。<br>    红锁得坑：<br>        不能配从节点</p>
<p>分布式锁的选择：<br>    Redis锁有时就是会丢失，很严格可以选择性能略低的zookeeper.<br>    参考concurrentHashMap的分段锁</p>
<h3 id="9-用户认证与授权"><a href="#9-用户认证与授权" class="headerlink" title="9.用户认证与授权"></a>9.用户认证与授权</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>认证：也就是说对于每一次访问请求，系统都能判断出访问者是否具有合法的身份标识。（是谁）</p>
<p>AT性）。）而每个资源都有一个拥有者（Resource Owner）。这些资源拥有者所拥有的资源统一存放在资源服务器（Resource Server）中。同时，协议规定需要有一台授权服务器（Authorization Server），即专门用来处理对访问请求进行授权的服务器。</p>
<p>对哪些调用关系进行认证与授权：客户端到服务、从服务到服务。</p>
<h5 id="授权协议OAuth2"><a href="#授权协议OAuth2" class="headerlink" title="授权协议OAuth2"></a>授权协议OAuth2</h5><p>OAuth2 协议中把需要访问的接口或服务统称为资源，而每个资源都有一个拥有者（Resource Owner）。这些资源拥有者所拥有的资源统一存放在资源服务器（Resource Server）中。同时，协议规定需要有一台授权服务器（Authorization Server），即专门用来处理对访问请求进行授权的服务器。</p>
<p>OAuth2 协议在客户端程序和资源服务器之间设置了一个授权层，所以客户端程序不能直接访问资源服务器，而是只能先登录授权层。资源拥有者会首先授权给客户端，客户端获得授权之后，向授权服务器申请一个 Token，Token 中就包含了权限范围和有效期。然后，客户端使用这个申请到的 Token 向资源服务器申请获取资源，资源服务器就根据 Token 的权限范围和有效期向客户端开放拥有者的资源。</p>
<p>对应到微服务系统中，服务提供者所充当的角色就是资源服务器，而服务消费者就是客户端。</p>
<p>OAuth 2.0 定义了四种授权方式，即密码模式、授权码模式、简化模式和客户端模式。</p>
<h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>介绍 博客地址TODO</p>
<h6 id="JJWT使用demo"><a href="#JJWT使用demo" class="headerlink" title="JJWT使用demo"></a>JJWT使用demo</h6><ol>
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.11.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.11.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;!-- or jjwt-gson if Gson is preferred --&gt;</span><br><span class="line">    &lt;version&gt;0.11.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>创建token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">public class JwtTestor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建Token</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void createJwt()&#123;</span><br><span class="line">        //私钥字符串</span><br><span class="line">        String key = &quot;1234567890_1234567890_1234567890&quot;;</span><br><span class="line">        //1.对秘钥做BASE64编码</span><br><span class="line">        String base64 = new BASE64Encoder().encode(key.getBytes());</span><br><span class="line">        //2.生成秘钥对象,会根据base64长度自动选择相应的 HMAC 算法</span><br><span class="line">        SecretKey secretKey = Keys.hmacShaKeyFor(base64.getBytes());</span><br><span class="line">        //3.利用JJWT生成Token</span><br><span class="line">        String data = &quot;&#123;\&quot;userId\&quot;:123&#125;&quot;; //载荷数据</span><br><span class="line">        String jwt = Jwts.builder().setSubject(data).signWith(secretKey).compact();</span><br><span class="line">        System.out.println(jwt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>验证token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 校验及提取JWT数据</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void checkJwt()&#123;</span><br><span class="line">    String jwt = &quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ7XCJ1c2VySWRcIjoxMjN9In0.1p_VTN46sukRJTYFxUg93CmfR3nJZRBm99ZK0e3d9Hw&quot;;</span><br><span class="line">    //私钥</span><br><span class="line">    String key = &quot;1234567890_1234567890_1234567890&quot;;</span><br><span class="line">    //1.对秘钥做BASE64编码</span><br><span class="line">    String base64 = new BASE64Encoder().encode(key.getBytes());</span><br><span class="line">    //2.生成秘钥对象,会根据base64长度自动选择相应的 HMAC 算法</span><br><span class="line">    SecretKey secretKey = Keys.hmacShaKeyFor(base64.getBytes());</span><br><span class="line">    //3.验证Token</span><br><span class="line">    try &#123;</span><br><span class="line">        //生成JWT解析器 </span><br><span class="line">        JwtParser parser = Jwts.parserBuilder().setSigningKey(secretKey).build();</span><br><span class="line">        //解析JWT</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parser.parseClaimsJws(jwt);</span><br><span class="line">        //得到载荷中的用户数据</span><br><span class="line">        String subject = claimsJws.getBody().getSubject();</span><br><span class="line">        System.out.println(subject);</span><br><span class="line">    &#125;catch (JwtException e)&#123;</span><br><span class="line">        //所有关于Jwt校验的异常都继承自JwtException</span><br><span class="line">        System.out.println(&quot;Jwt校验失败&quot;);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h5><p>实现 OAuth2 协议以及整合 JWT 认证</p>
<h4 id="基于网关的统一用户认证"><a href="#基于网关的统一用户认证" class="headerlink" title="基于网关的统一用户认证"></a>基于网关的统一用户认证</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/nxyI5Q34c7VdWPs.png" alt="image-20210713220029696"></p>
<h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><ol>
<li><p>认证中心微服务负责用户认证任务，在启动时从 Nacos 配置中心抽取 JWT 加密用私钥；</p>
</li>
<li><p>用户在登录页输入用户名密码，客户端向认证中心服务发起认证请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求示例</span><br><span class="line">http://usercenter/login #认证中心用户认证（登录）地址</span><br></pre></td></tr></table></figure></li>
<li><p>认证中心服务根据输入在用户数据库中进行认证校验，如果校验成功则返回认证中心将生成用户的JSON数据并创建对应的 JWT 返回给客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 响应数据示例</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;code&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;success&quot;,</span><br><span class="line">        &quot;data&quot;: &#123;</span><br><span class="line">            &quot;user&quot;: &#123;</span><br><span class="line">                &quot;userId&quot;: 1,</span><br><span class="line">                &quot;username&quot;: &quot;zhangsan&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ7XCJ1c2VySWRcIjoxLFwidXNlcm5hbWVcIjpcInpoYW5nc2FuXCIsXCJuYW1lXCI6XCLlvKDkuIlcIixcImdyYWRlXCI6XCJub3JtYWxcIn0ifQ.1HtfszarTxLrqPktDkzArTEc4ah5VO7QaOOJqmSeXEM&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在收到上述 JSON 数据后，客户端将其中 token 数据保存在 localstorage</p>
</li>
<li><p>客户端向具体某个微服务发起新的请求，这个 JWT 都会附加在请求头或者 cookie 中发往 API 网关，网关将 JWT 再次转发给用户认证服务，此时用户认证服务对 JWT 进行验签，验签成功，查询用户认证与授权的详细数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;user&quot;: &#123; #用户详细数据</span><br><span class="line">            &quot;userId&quot;: 1,</span><br><span class="line">            &quot;username&quot;: &quot;zhangsan&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">            &quot;grade&quot;: &quot;normal&quot;</span><br><span class="line">            &quot;age&quot;: 18,</span><br><span class="line">            &quot;idno&quot; : 130.......,</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;authorization&quot;:&#123; #权限数据</span><br><span class="line">            &quot;role&quot; : &quot;admin&quot;,</span><br><span class="line">            &quot;permissions&quot; : [&#123;&quot;addUser&quot;,&quot;delUser&quot;,&quot;...&quot;&#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>网关根据路由规则将请求与jwt数据和授权数据转发至具体的微服务。</p>
</li>
<li><p>具体的微服务收到上述 JSON 后，对当前执行的操作进行判断，检查是否拥有执行权限，权限检查通过执行业务代码，权限检查失败返回错误响应。</p>
</li>
</ol>
<h5 id="JWT续签"><a href="#JWT续签" class="headerlink" title="JWT续签"></a>JWT续签</h5><p>JWT存在的问题：JWT 生成后失效期是固定的， JWT 的设计本身就不允许生成完全相同的字符串。单靠 JWT  自身特性是无法做到续签。</p>
<p>需解决：很多业务中需要客户端在不改变 JWT 的前提下，实现 JWT 的“续签”功能。</p>
<p>业务问题：10分钟不操作，token失效，跳转登录页面。</p>
<p>解决方案：</p>
<ol>
<li>生成的 JWT  设为“永久生效”。</li>
<li>生成后存到redis集合A中，设置Expire 有效期5分钟。过期后转移到另一个集合B中，有效期5分钟。</li>
<li>前端发起请求不同时间段的处理。<ul>
<li>前端1-5分钟的请求。在redis的集合A中找到携带的token，处理业务。</li>
<li>前端6-10分钟的请求，<ul>
<li>在redis的集合A中未找到携带的token，在集合B中找到了，将集合B中的token移到集合A中。处理业务。</li>
</ul>
</li>
<li>前端超过10分钟的请求。在redis的集合A中未找到携带的token，在集合B中也没找到。返回到登录页面</li>
</ul>
</li>
</ol>
<h2 id="微服务缓存设计"><a href="#微服务缓存设计" class="headerlink" title="微服务缓存设计"></a>微服务缓存设计</h2><p>软件缓存分类：</p>
<ul>
<li>Web应用客户端缓存-浏览器</li>
<li>应用层静态资源缓存-前端-CDN、Nginx</li>
<li>服务层多级缓存-后端-内存（分布式Redis，进程内EhCache）</li>
</ul>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/upX2MQVylkYBsrN.png" alt="image-20210713161053321"></p>
<h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><p>浏览器层面我们主要是对 HTML 中的图片、CSS、JS、字体这些静态资源进行缓存。</p>
<p>示例：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/sWtRIoHXpZx8y1h.png" alt="image-20210713161225780"></p>
<p>通过HTTP 的 Expires 响应头控制静态图片的有效期。百度 Logo 的过期时间为 2031 年 2 月 8 日 9 时 26 分 31 秒。在这个时间段内，浏览器会将图片以文件形式缓存在本地，再次访问时会看到“from disk cache”的提示，此时浏览器不再产生与服务器的实际请求，会从本地直接读取缓存图片。</p>
<h3 id="应用层缓存"><a href="#应用层缓存" class="headerlink" title="应用层缓存"></a>应用层缓存</h3><p>浏览器负责读取Expires响应头， Expires 在应用层设置，也就是 CDN 与 Nginx 中进行设置。</p>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><h5 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h5><p>CDN 全称是 Content Delivery Network，即内容分发网络，是互联网静态资源分发的主要技术手段。</p>
<p><strong>场景：</strong>大量的上海用户同时要访问千里之外的北京服务器的资源，这么长的通信必然带来高延迟与更多不可控因素影响数据传输。</p>
<p><strong>应用：</strong>广域的互联网应用，CDN 几乎是必需的基础设施，它有效解决了带宽集中占用以及数据分发的问题。像 Web 页面中的图片、音视频、CSS、JS 这些静态资源，都可以通过 CDN 服务器就近获取。</p>
<p><strong>CDN执行流程</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/DSk5GjTXYl7FQBn.png" alt="image-20210713161811213"></p>
<p>在互联网应用中，因为 CDN 涉及多地域多节点组网，前期投入成本较高，更多的中小型软件公司通常会选择阿里云、腾讯云等大厂提供的 CDN 服务，通过按需付费的方式降低硬件成本。</p>
<p>阿里云、腾讯云 CDN 除了缓存文件之外，还提供了管理后台能为响应赋予额外的响应头。如下所示在阿里云 CDN 后台，就额外设置了 Cache-Control 响应头代表缓存有效期为 1 小时。这里我们额外提一下 Expires 与的 Cache-Control 的区别，Expires 是指定具体某个时间点缓存到期，而 Cache-Control 则代表缓存的有效期是多长时间。Expires 设置时间，Cache-Control 设置时长，根据业务场景不同可以使用不同的响应头。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zxDkd8cNZK4FeBn.png" alt="image-20210713162058257"></p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><h5 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h5><p>功能：</p>
<ul>
<li>反向代理</li>
<li>负载均衡</li>
<li>静态资源缓存与压缩功能</li>
</ul>
<h5 id="静态资源缓存配置"><a href="#静态资源缓存配置" class="headerlink" title="静态资源缓存配置"></a>静态资源缓存配置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置缓存目录</span><br><span class="line"></span><br><span class="line"># levels代表采用1:2也就是两级目录的形式保存缓存文件（静态资源css、js）</span><br><span class="line"></span><br><span class="line"># keys_zone定义缓存的名称及内存的使用，名称为babytun-cache ,在内存中开始100m交换空间</span><br><span class="line"></span><br><span class="line"># inactive=7d 如果某个缓存文件超过7天没有被访问，则删除</span><br><span class="line"></span><br><span class="line"># max_size=20g;代表设置文件夹最大不能超过20g，超过后会自动将访问频度（命中率）最低的缓存文件删除</span><br><span class="line"></span><br><span class="line">proxy_cache_path d:/nginx-cache levels=1:2 keys_zone=babytun-cache:100m inactive=7d max_size=20g;</span><br><span class="line"></span><br><span class="line">#配置xmall后端服务器的权重负载均衡策略</span><br><span class="line"></span><br><span class="line">upstream xmall &#123;</span><br><span class="line"></span><br><span class="line">    server 192.168.31.181 weight=5 max_fails=1 fail_timeout=3s;</span><br><span class="line"></span><br><span class="line">    server 192.168.31.182 weight=2;</span><br><span class="line"></span><br><span class="line">    server 192.168.31.183 weight=1;</span><br><span class="line"></span><br><span class="line">    server 192.168.31.184 weight=2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">	#nginx通过80端口提供Web服务</span><br><span class="line"></span><br><span class="line">	listen 80;</span><br><span class="line"></span><br><span class="line">	# 开启静态资源缓存</span><br><span class="line"></span><br><span class="line">	# 利用正则表达式匹配URL，匹配成功的则执行内部逻辑</span><br><span class="line"></span><br><span class="line">	# ~* 代表URL匹配不区分大小写</span><br><span class="line"></span><br><span class="line">	location ~* \.(gif|jpg|css|png|js|woff|html)(.*)&#123;</span><br><span class="line"></span><br><span class="line">           # 配置代理转发规则</span><br><span class="line"></span><br><span class="line">		proxy_pass http://xmall;</span><br><span class="line"></span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">		proxy_cache xmall-cache;</span><br><span class="line"></span><br><span class="line">		#如果静态资源响应状态码为200（成功）  302（暂时性重定向）时 缓存文件有效期1天</span><br><span class="line"></span><br><span class="line">		proxy_cache_valid 200 302 24h;</span><br><span class="line"></span><br><span class="line">		#301（永久性重定向）缓存保存5天</span><br><span class="line"></span><br><span class="line">		proxy_cache_valid 301 5d;</span><br><span class="line"></span><br><span class="line">		#其他情况</span><br><span class="line"></span><br><span class="line">		proxy_cache_valid any 5m;</span><br><span class="line"></span><br><span class="line">		#设置浏览器端缓存过期时间90天</span><br><span class="line"></span><br><span class="line">		expires 90d;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	#使用xmall服务器池进行后端处理</span><br><span class="line"></span><br><span class="line">	location /&#123;</span><br><span class="line"></span><br><span class="line">		proxy_pass http://xmall; </span><br><span class="line"></span><br><span class="line">		proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><p>部署方式分类：进程内缓存，分布式缓存</p>
<h5 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h5><p><strong>介绍：</strong>应用中开辟的一块内存空间，数据在运行时被载入这块内存，通过本地内存的低延迟、高吞吐的特性提高程序的访问速度。</p>
<p><strong>应用场景：</strong>进程内缓存在众多 Java  框架内都有广泛应用，例如 Hibernate、Mybatis 框架的一二级缓存、Spring MVC  的页面缓存都是进程内缓存的经典应用场景。</p>
<p><strong>开源实现：</strong>如 EhCache、Caffeine。</p>
<h5 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h5><p><strong>介绍：</strong>对多个服务数据的热点数据进行集中缓存。</p>
<p><strong>实现：</strong>基于 Redis 内存型 NoSQL 数据库，对多个应用的热点数据进行集中缓存。</p>
<h5 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h5><p><strong>介绍：</strong>进程内缓存结合分布式缓存。</p>
<p><strong>优点：</strong>性能高，分摊分布式缓存压力。查询相同数据时直接从本地 EhCache 缓存提取，不再产生新的网络通信，应用查询性能得到显著提高。</p>
<p><strong>缺点：</strong>复杂，增加数据一致性问题</p>
<p><strong>场景：</strong></p>
<ul>
<li>缓存的数据是稳定的。例如邮政编码、地域区块、归档的历史数据这些信息适合通过多级缓存减小 Redis 与数据库的压力。</li>
<li>瞬时可能会产生极高并发的场景。例如春运购票、双 11 零点秒杀、股市开盘交易等，瞬间的流量洪峰可能击穿 Redis 缓存，产生流量雪崩。这时利用预热的进程内缓存分摊流量，减少后端压力。</li>
<li>一定程度上允许数据不一致。例如某博客平台中你修改了自我介绍这样的非关键信息，此时在应用集群中其他节点缓存不一致也并不会带来严重影响，对于这种情况我们采用T+1的方式在日终处理时保证缓存最终一致就可以了。</li>
</ul>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p>​        在 Java 应用层面，只有 EhCache 的缓存不存在时，再去 Redis 分布式缓存获取，如果 Redis 也没有此数据再去数据库查询，数据查询成功后对 Redis 与 EhCahce 同时进行双写更新。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/rb5SG9kuczNo3Uy.png" alt="image-20210713170806678"></p>
<h6 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h6><p>不同应用EhCache数据一致性问题。</p>
<p>解决：引入 MQ 消息队列，利用 RocketMQ 的主动推送功能来向其他服务实例以及 Redis 缓存服务发起变更通知。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210713171323964.png" alt="image-20210713171323964"></p>
<h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><h3 id="软件部署发展过程"><a href="#软件部署发展过程" class="headerlink" title="软件部署发展过程"></a>软件部署发展过程</h3><h4 id="物理机部署"><a href="#物理机部署" class="headerlink" title="物理机部署"></a>物理机部署</h4><p>应用程序安装在物理服务器的操作系统中，应用程序直接通过操作系统获取物理服务器的 CPU、内存、硬盘等资源。</p>
<p>缺点：CPU 闲置、内存过剩等资源浪费。物理机价格高</p>
<h4 id="虚拟机部署"><a href="#虚拟机部署" class="headerlink" title="虚拟机部署"></a>虚拟机部署</h4><p>通过 VMWare 或者 VirtualBox 等虚拟化工具，可以将高性能物理服务器切割为若干虚拟机，这些虚拟机拥有自己独立的 CPU、内存、硬盘资源，并且这些资源彼此隔离不允许交叉访问。</p>
<p>运维工程师就可以为不同类型的应用分配不同的资源，如计算密集型的应用就多分配一些 CPU 核数，存储密集型应用就多分配一些内存与硬盘空间，并且这些资源可以在不停机的情况下实现动态调整，让服务器资源得到最大化的利用。</p>
<h4 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h4><p>通过将应用程序镜像化，再通过镜像直接生成一个个容器实现应用的快速部署发布；同时容器化技术不再强调资源隔离，所有容器底层通过 Docker 容器引擎与操作系统获取全局共享的物理机资源。</p>
<p>优点：</p>
<ul>
<li>标准化的部署过程。因为容器化关注应用本身，因此创建容器的过程就是部署应用的过程。容器将是标准化的产物，可能容器内部的应用程序功能各不相同，但对运维人员来说创建容器的命令与操作过程都是基本相同的，可以通过脚本快速批量的完成容器的创建。</li>
<li>更好的性能。相比虚拟机，容器化并不强调资源隔离，物理机的所有资源对于容器都是共享的，容器与底层资源之间通过 Docker 容器引擎与操作系统进行调度，这中间产生的损耗相比虚拟机小得多。</li>
</ul>
<h3 id="软件安装包-容器化技术Docker"><a href="#软件安装包-容器化技术Docker" class="headerlink" title="软件安装包-容器化技术Docker"></a>软件安装包-容器化技术Docker</h3><p>单独写TODO</p>
<h4 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h4><p>Docker 是一个开源的应用容器引擎，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，Docker 经过多年发展已经是容器化技术的标准。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>镜像，仓库，Dockerfile，容器，容器编排工具</p>
<ul>
<li><h5 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h5><p>类似于安装包，可以用安装包安装软件程序。</p>
<p>可以使用镜像在任何安装了 Docker 的 Linux 系统上快速部署应用程序。</p>
<p>jar包打成镜像后，可以用镜像在多个服务器快速部署。</p>
</li>
<li><p>仓库</p>
<p>仓库是存放镜像的地方，Docker 提供了 DockerHub 仓库站托管开发者的镜像文件，开发者可以利用 Pull 命令直接从仓库下载镜像到本地部署。</p>
<p>生产环境需要自己搭建HARBOR 仓库。如同代码仓库GitLab。</p>
</li>
<li><p>Dockerfile</p>
<p>描述将应用程序构建为镜像的过程。如：将jar构建为镜像。</p>
<p>运维可以用镜像屏蔽硬件系统差异在不同实例部署多个应用程序。</p>
</li>
<li><p>容器（Container）</p>
<p>安装包安装成功后是软件（应用程序）。</p>
<p>镜像部署成功后就是容器，容器是镜像的实例。</p>
</li>
<li><p>容器编排工具</p>
<p>容器编排工具的典型代表是 Google Kubernetes(K8S) 和 Docker Swarm，容器编排工具用于管理大规模集群中的容器实例。</p>
<p>服务器网络间自动实现互联互通，随着外部用户的访问压力的变化自动进行容器的扩容与收缩。</p>
<p>K8S 允许运维人员通过可视化的方式对容器进行动态调整，同时对所有运行节点也提供了实时监控。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ZVtFojsAMT1Jhrb.png" alt="image-20210714122334467"></p>
</li>
</ul>
<p>1.20后k8s放弃了docker部分功能,比如网络与volume,国内基本都是1.1x。</p>
<h3 id="DevOps执行流程"><a href="#DevOps执行流程" class="headerlink" title="DevOps执行流程"></a>DevOps执行流程</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/K3mRMefYSzPIavo.png" alt="image-20210714113050900"></p>
<p>执行流程：</p>
<ol>
<li>研发工程师将测试验收后的源码上传到 GitLab 服务器，并合并到生成分支（包含 Dockerfile，用来描述 Docker 镜像的构建过程）。</li>
<li>软件工程师或者配置管理员发起 Jekins 的自动化脚本，完成镜像的自动化构建与仓库推送。</li>
<li>上线日运维工程师接入 Kubernetes 管理端，发起 Deploy 部署命令，此时生产环境的 K8S 节点会从 HARBOR 仓库抽取最新版本的应用镜像，并在服务器上自动创建容器，最新版本的 Jar 文件在容器创建时也会随之启动开始对外提供服务。<ol>
<li>抽取新版本源码到 Jekins 服务器，利用 Jekins 服务器安装 Maven 自动完成编译、测试、打包的过程；产出jar文件</li>
<li>抽取 Dockerfile 到 Jekins 服务器，利用 Jekins 服务器安装的 Docker 完成镜像的构建工作，在构建过程中需要将上一步生成的 Jar 文件包含在内，在容器创建时自动执行这个 Jar 文件。</li>
<li>镜像生成后，还是通过 Jekins 服务器上的 Docker 将新版本镜像推送到 HARBOR 仓库。（HARBOR 用于创建 Docker 镜像的私有仓库）</li>
</ol>
</li>
<li>在校验无误后，本次上线宣告成功。</li>
</ol>
<p>真实环境异常因素：</p>
<ul>
<li>源码编译、打包时产生异常的快速应对机制</li>
<li>上线失败如何快速应用回滚</li>
<li>镜像构建失败的异常跟踪与补救措施</li>
</ul>
<h2 id="老项目升级为微服务策略"><a href="#老项目升级为微服务策略" class="headerlink" title="老项目升级为微服务策略"></a>老项目升级为微服务策略</h2><p>单体应用改造升级为微服务架构。</p>
<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>分布式事务54%</p>
<p>全链路跟踪43%</p>
<p>服务平滑上下线33%</p>
<h3 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h3><ul>
<li>改造是一步到位还是逐渐迭代？</li>
<li>微服务拆分的粒度是什么？</li>
<li>如何保证数据一致性？</li>
<li>新老交替过程中如何不影响公司业务进展？</li>
</ul>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul>
<li>严禁 Big Bang（一步到位）；</li>
<li>尽早体现价值；</li>
<li>优先分离做前后端；</li>
<li>新功能构建成微服务；</li>
<li>数据源不混用</li>
<li>利用 Spring AOP 开发低侵入的胶水代码；</li>
<li>基于 MQ 构建反腐层。</li>
</ul>
<h3 id="绞杀式升级"><a href="#绞杀式升级" class="headerlink" title="绞杀式升级"></a>绞杀式升级</h3><p>介绍：</p>
<p>​        一个由微服务组成的新应用程序，通过将新功能作为服务，并逐渐从单体应用中提取服务来实现。随着时间的推移，越来越多单体应用内的功能被逐渐剥离为独立的微服务，最终达到消灭单体应用的目的。</p>
<p>优点：</p>
<ul>
<li>升级改造过程中并不需要推翻原有的代码，而是在新老更迭的过程中一步步完成微服务架构的升级改造。</li>
<li>立即获得投资回报。</li>
</ul>
<h4 id="严禁-Big-Band"><a href="#严禁-Big-Band" class="headerlink" title="严禁 Big Band"></a>严禁 Big Band</h4><p>逐步重构单体应用，采用绞杀者应用策略，将应用变为单体与微服务的混合状态，随着时间增加一点点蚕食掉单体应用。</p>
<h4 id="尽早体现价值"><a href="#尽早体现价值" class="headerlink" title="尽早体现价值"></a>尽早体现价值</h4><p>按价值的重要性进行排序。</p>
<h4 id="优先分离做前后端"><a href="#优先分离做前后端" class="headerlink" title="优先分离做前后端"></a>优先分离做前后端</h4><p>前后端独立部署、扩展与维护。表示层在快速迭代部署时并不影响后端功能，可以轻松进行 A/B 测试。</p>
<h4 id="新功能构建成微服务"><a href="#新功能构建成微服务" class="headerlink" title="新功能构建成微服务"></a>新功能构建成微服务</h4><p>例如检索服务。增加了 API Gateway 网关，该网关对前端访问的 URL 进行路由。访问 search 接口，则请求被重定向到新创建的商品检索微服务，通过 ElasticSearch 这种专用的全文检索引擎提供更高级的查询功能；</p>
<h4 id="数据源不混用"><a href="#数据源不混用" class="headerlink" title="数据源不混用"></a>数据源不混用</h4><p>可使用 Alibaba Canal 做数据源同步，Canal 是阿里巴巴旗下的开源项目，纯 Java 开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，可自动实现从 MySQL 数据源向其他数据源同步数据的任务。</p>
<h4 id="旧功能修改"><a href="#旧功能修改" class="headerlink" title="旧功能修改"></a>旧功能修改</h4><h5 id="Spring-AOP-扩展"><a href="#Spring-AOP-扩展" class="headerlink" title="Spring AOP 扩展"></a>Spring AOP 扩展</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component(&quot;priceServiceAspect&quot;) //声明Bean Id</span><br><span class="line">@Aspect //定义切面类</span><br><span class="line">public class PriceServiceAspect&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PriceServiceFeignClient priceServiceFeignClient;</span><br><span class="line">    //利用环绕通知实现对PriceService.findByGoodsId的动态代理</span><br><span class="line">    @Around(&quot;execution(* com.lagou..PriceService.findByGoodsId(..)&quot;)</span><br><span class="line">    public Object selectGoods(ProceedingJoinPoint joinPoint)&#123;</span><br><span class="line">        //通过OpenFeign客户端向定价服务发起远程请求，替代JVM本地访问</span><br><span class="line">        return priceServiceFeignClient.selectGoods((Long)joinPoint.getArgs()[0]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="MQ构建反腐层"><a href="#MQ构建反腐层" class="headerlink" title="MQ构建反腐层"></a>MQ构建反腐层</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/pxrasmLu1MYvRcS.png" alt="image-20210713214025802"></p>
<h2 id="分布式sql"><a href="#分布式sql" class="headerlink" title="分布式sql"></a>分布式sql</h2><p> 不使用join而使用in,不同mysql实例不能使用join</p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-冒泡排序</title>
    <url>/2018/04/17/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序 如：从大到小排序，每次内循环将大数交换到前边，如同大数向上浮，故称为冒泡排序。</p>
<span id="more"></span>
<p>例如：从大到小排序：<br>从前向后判断相邻两个数的大小，*(a[j] &lt; a[j+1])*将小的换到后边，每次内循环完毕会将一个最小的数换到最下方。<br>每次内循环可排好一个数，每次内循环次数递减1 <em>j=a.length-i-1</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MaopaoRang &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a [] = &#123;3,16,18,5,35,6,18,2,15&#125;;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			for (int j = 0; j &lt; a.length-i-1; j++) &#123;</span><br><span class="line">				//比较相邻两个数的大小，不符合要求，则交换。</span><br><span class="line">				if(a[j] &lt; a[j+1] )&#123;</span><br><span class="line">					int t = a[j];</span><br><span class="line">					a[j] = a[j+1];</span><br><span class="line">					a[j+1] = t;</span><br><span class="line">					</span><br><span class="line">					//打印每次交换后的数组</span><br><span class="line">					for (int k = 0; k &lt; a.length; k++) &#123;</span><br><span class="line">						System.out.print(a[k]+&quot; &quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.print(&quot;*&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		//打印排序结果</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次交换后的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16 3 18 5 35 6 18 2 15 *16 18 3 5 35 6 18 2 15 *16 18 5 3 35 6 18 2 15 *16 18 5 35 3 6 18 2 15 *16 18 5 35 6 3 18 2 15 *16 18 5 35 6 18 3 2 15 *16 18 5 35 6 18 3 15 2 *</span><br><span class="line">18 16 5 35 6 18 3 15 2 *18 16 35 5 6 18 3 15 2 *18 16 35 6 5 18 3 15 2 *18 16 35 6 18 5 3 15 2 *18 16 35 6 18 5 15 3 2 *</span><br><span class="line">18 35 16 6 18 5 15 3 2 *18 35 16 18 6 5 15 3 2 *18 35 16 18 6 15 5 3 2 *</span><br><span class="line">35 18 16 18 6 15 5 3 2 *35 18 18 16 6 15 5 3 2 *35 18 18 16 15 6 5 3 2 *</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序2-排序算法</title>
    <url>/2019/10/15/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<p>遍历数组的同时，使本次相邻的俩个数是左小右大（左大右小）；</p>
<span id="more"></span>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>平均时间复杂度：O(n²)；最好情况：O(n)；最坏情况：O(n²)；</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place （占用常数内存，不占用额外内存）</p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡算法</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：遍历数组的同时，使本次相邻的俩个数是左小右大（左大右小）；每次循环少遍历一个数；定义一个标记，当某次没有交换时，数组已经有序。</span><br><span class="line"> */</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		int[] sourceArray = &#123;8,3,2,4,5&#125;;</span><br><span class="line">		</span><br><span class="line">		int[] arr = sort(sourceArray);</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;排序后：&quot;);</span><br><span class="line">		System.out.println(Arrays.toString(sourceArray));</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;排序前：&quot;);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public static int[] sort(int[] sourceArray) throws Exception&#123;</span><br><span class="line">		// 复制数组内容，int[] arr = sourceArray 排序后会改变原数组内容</span><br><span class="line">		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">		</span><br><span class="line">		for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">			// 若循环没有做交换，则数组有序。设定一个标记，若为true，排序已经完成。例如：数组为8,5,4,3,2，第一次循环数组没有做交换，则数组有序，直接返回。</span><br><span class="line">			boolean flag = true;</span><br><span class="line">			</span><br><span class="line">			for (int j = 0; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">				if (arr[j] &lt; arr[j+1]) &#123;</span><br><span class="line">					int temp = arr[j+1];</span><br><span class="line">					arr[j+1] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">					</span><br><span class="line">					flag = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if (flag) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-快速排序</title>
    <url>/2020/10/10/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>排序算法-快速排序</p>
<span id="more"></span>

<h1 id="排序算法-快速排序"><a href="#排序算法-快速排序" class="headerlink" title="排序算法-快速排序"></a>排序算法-快速排序</h1><p>平均时间复杂度：O(n log n)；最好情况：O(n²)；最坏情况：O(log n)；</p>
<p>空间复杂度：O(log n)</p>
<p>排序方式：In-place </p>
<p>稳定性：不稳定</p>
<p><strong>Implementation</strong>:</p>
<p>如何调整：quickSort1。循环一次数组，调整一次基准数：quickSort2。通过递归调整n此基准数，排序完成：quickSork3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ClassName: QuickSort &lt;br/&gt;</span><br><span class="line"> * Description: 快速排序&lt;br/&gt;</span><br><span class="line"> * date: 2020-09-29 21:33&lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author hxr&lt;br /&gt;</span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] old = &#123;7, 4, 1, 8, 5, 9, 7, 6&#125;;</span><br><span class="line">        int[] ints = quickSort3(old);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //7,4,1,8,5,9,7,6</span><br><span class="line">    // 一：一趟遍历数组排序</span><br><span class="line">    //    1.找一个基准数，把他拿出来standrad=old[0], old[0]是坑位。</span><br><span class="line">    //    2.从右向左找到比基准数小的放在坑位，坑位变成了右边比基准数大的位置</span><br><span class="line">    //    3.从左向右找到比基准数大的放在坑位。坑位变成了左边比基准数小的位置</span><br><span class="line">    //    4.重复2,3.</span><br><span class="line">    //    5.排序成功时i==j退出遍历</span><br><span class="line">    // 二：递归分治，</span><br><span class="line"></span><br><span class="line">    //0,1,2,3,4,5,6,7 数组下标</span><br><span class="line">    //sep1</span><br><span class="line">    //7,4,1,8,5,9,7,6 //坑位为old[0]</span><br><span class="line">    //sep2</span><br><span class="line">    //6,4,1,8,5,9,7,6 //sep2,坑位为old[7]</span><br><span class="line">    //sep3</span><br><span class="line">    //6,4,1,8,5,9,7,8 //sep3,坑位为old[3]</span><br><span class="line"></span><br><span class="line">    // sep4:</span><br><span class="line">    //6,4,1,5,5,9,7,8 //sep2,坑位为old[4]</span><br><span class="line"></span><br><span class="line">    // sep5: i==j</span><br><span class="line">    //6,4,1,5,7,9,7,8 //old[4] = standrad;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 一：一趟遍历数组排序</span><br><span class="line">    //    1.找一个基准数，把他拿出来standrad=old[0], old[0]是坑位。</span><br><span class="line">    //    2.从右向左找到比基准数小的放在坑位，坑位变成了右边比基准数大的位置</span><br><span class="line">    //    3.从左向右找到比基准数大的放在坑位。坑位变成了左边比基准数小的位置</span><br><span class="line">    public static int[] quickSort1(int[] old) &#123;</span><br><span class="line"></span><br><span class="line">        if (null == old || old.length == 0)</span><br><span class="line">            return null;</span><br><span class="line">        //sep1</span><br><span class="line">        int standrad = old[0];</span><br><span class="line">        //sep2</span><br><span class="line">        int j = old.length - 1;</span><br><span class="line">        for (; j &gt; 0; j--) &#123;</span><br><span class="line">            if (old[j] &lt; standrad) &#123;</span><br><span class="line">                old[0] = old[j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sep3</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; i &lt; old.length - 1; i++) &#123;</span><br><span class="line">            if (old[i] &gt; standrad) &#123;</span><br><span class="line">                old[j] = old[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 一：1.找一个基准数，把他拿出来standrad=old[0], old[0]是坑位。</span><br><span class="line">    //    2.从右向左找到比基准数小的放在坑位，坑位变成了右边比基准数大的位置</span><br><span class="line">    //    3.从左向右找到比基准数大的放在坑位。坑位变成了左边比基准数小的位置</span><br><span class="line">    //    4.重复2,3.</span><br><span class="line">    //    5.排序成功时i==j退出遍历</span><br><span class="line">    public static int[] quickSort2(int[] old) &#123;</span><br><span class="line">        int i = 0, j = old.length - 1;</span><br><span class="line">        quick(old, i, j);</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Integer quick(int[] old, int i, int j) &#123;</span><br><span class="line">        if (null == old || old.length == 0)</span><br><span class="line">            return null;</span><br><span class="line">        //sep1 选取基准数old[i],坑位下标为i</span><br><span class="line">        int standard = old[i];</span><br><span class="line"></span><br><span class="line">        //sep4 循环sep2和sep3，直到基准值调整完毕</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            //sep2 从右向左找到比基准值小的下标j，将下标的值old[j]放入旧坑位，下标j变为新坑位。</span><br><span class="line">            while (j &gt; i) &#123;</span><br><span class="line">                if (old[j] &lt; standard) &#123;</span><br><span class="line">                    old[i] = old[j];</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(&quot;旧坑的位置：&quot; + i + &quot;,新坑的位置：&quot; + j);</span><br><span class="line">                    System.out.println(Arrays.toString(old));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            //sep3 从左向右找到比基准值大的下标i，将下标的值old[i]放入旧坑位，下标i变为新坑位。</span><br><span class="line">            while (i &lt; j) &#123;</span><br><span class="line">                if (old[i] &gt; standard) &#123;</span><br><span class="line">                    old[j] = old[i];</span><br><span class="line">                    j--;</span><br><span class="line">                    System.out.println(&quot;旧坑的位置：&quot; + j + &quot;,新坑的位置：&quot; + i);</span><br><span class="line">                    System.out.println(Arrays.toString(old));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //sep5 退出时i==j，将基准值放入最后的坑位</span><br><span class="line">        old[i] = standard;</span><br><span class="line">        System.out.print(&quot;一趟遍历后的排序结果：&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(old));</span><br><span class="line"></span><br><span class="line">        // 返回基准位置的下标</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 一：一趟遍历数组排序</span><br><span class="line">    // 二：递归分治</span><br><span class="line">    public static int[] quickSort3(int[] old) &#123;</span><br><span class="line">        if (null == old || old.length == 0)</span><br><span class="line">            return null;</span><br><span class="line">        int start = 0, end = old.length - 1;</span><br><span class="line">        quick3(old, start, end);</span><br><span class="line">        return old;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void quick3(int[] old, int start, int end) &#123;</span><br><span class="line">        // 二、递归分治 退出条件</span><br><span class="line">        if (start &lt; end) &#123;</span><br><span class="line">            int i = start, j = end;</span><br><span class="line">            int standard = old[i];</span><br><span class="line">            while (i &lt; j) &#123;</span><br><span class="line">                while (j &gt; i) &#123;</span><br><span class="line">                    if (old[j] &lt; standard) &#123;</span><br><span class="line">                        old[i] = old[j];</span><br><span class="line">                        i++;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; j) &#123;</span><br><span class="line">                    if (old[i] &gt; standard) &#123;</span><br><span class="line">                        old[j] = old[i];</span><br><span class="line">                        j--;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            old[i] = standard;</span><br><span class="line">            System.out.print(&quot;一趟遍历后的排序结果：&quot;);</span><br><span class="line">            System.out.println(Arrays.toString(old));</span><br><span class="line"></span><br><span class="line">            // 二、递归分治</span><br><span class="line">            quick3(old, start, i - 1);</span><br><span class="line">            quick3(old, i + 1, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序-排序算法</title>
    <url>/2019/10/15/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>将第一个数当做有序序列（从小到大排列），将之后的数挨个插入到此有序序列里边。</p>
<span id="more"></span>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>平均时间复杂度：O(n²)；最好情况：O(n)；最坏情况：O(n²)；</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place </p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序 从小到大</span><br><span class="line"> * </span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：将第一个数当做有序序列（从小到大排列），将之后的数挨个插入到此有序序列里边。</span><br><span class="line"> * 每次取有序序列右边的第一个数（记为操作数）插入到有序序列，插入时，从右往左遍历有序序列，并判断操作数与遍历数的大小(1.操作数大，有序序列+操作数依然有序，不再遍历。2.操作数小，遍历数右移，接着遍历)。遍历完成后，将操作数插入到有序序列的准确位置。</span><br><span class="line"> * 优点：减少了交换次数</span><br><span class="line"> */</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = &#123; 8, 5, 3, 9, 1, 2, 4 &#125;;</span><br><span class="line">		for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">			// 记录有序序列右边的第一个数的数值，此后每趟排序右移一位。</span><br><span class="line">			int temp = arr[i];</span><br><span class="line"></span><br><span class="line">			int j = i;</span><br><span class="line">			while(j &gt; 0)&#123;</span><br><span class="line">				if (temp &lt; arr[j - 1]) &#123;</span><br><span class="line">					arr[j] = arr[j - 1];</span><br><span class="line">				&#125; else &#123;//比有序序列右边的数大，即比整个有序序列大。不需要再比较。</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 下标j以后的数比temp更大,插入到j位置</span><br><span class="line">			if (j != i) &#123;</span><br><span class="line">				arr[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 打印</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序-排序算法</title>
    <url>/2019/10/15/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。</p>
<span id="more"></span>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>平均时间复杂度：O(n+k)；最好情况：O(n+k)；最坏情况：O(n+k)；</p>
<p>空间复杂度：O(k)</p>
<p>排序方式：Out-place （占用常数内存，不占用额外内存）</p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 计数排序</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：申请数组中(max-min)大小的数组，统计数组中各元素的个数，并按元素与min的关系放入申请的数组中，即可输出有序数组。</span><br><span class="line"> */</span><br><span class="line">public class CountingSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] sourceArray = &#123; 8, 5, 6, 9, 5, 5, 5, 4 &#125;;</span><br><span class="line">		</span><br><span class="line">		// 对 arr 进行拷贝，不改变参数内容</span><br><span class="line">		int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">		sort(arr);</span><br><span class="line">		System.out.println(&quot;排序前：&quot;+Arrays.toString(sourceArray));</span><br><span class="line">		System.out.println(&quot;排序后：&quot;+Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int[] sort(int[] arr) &#123;</span><br><span class="line">		if (arr.length &gt; 1) &#123;</span><br><span class="line">			//假设下标为0的值最小，下标为1的值最大。</span><br><span class="line">			int min = 0;</span><br><span class="line">			int max = 1;</span><br><span class="line">			if (arr[0] &gt; arr[1] ) &#123;</span><br><span class="line">				min = 1;</span><br><span class="line">				max = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			//同时找出数组中的最大最小值</span><br><span class="line">			for (int i = 2; i &lt; arr.length; i++) &#123;</span><br><span class="line">				if (arr[i] &lt; arr[min]) &#123;</span><br><span class="line">					min = i;</span><br><span class="line">				&#125;</span><br><span class="line">				if (arr[i] &gt; arr[max]) &#123;</span><br><span class="line">					max = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//对统计数组每个数计数</span><br><span class="line">			int[] sort = counting(arr,arr[max],arr[min]);</span><br><span class="line">			System.out.println(&quot;数组中的数计数：&quot;+Arrays.toString(sort));</span><br><span class="line">			//重新排列arr,使有序</span><br><span class="line">			int minarr = arr[min];</span><br><span class="line">			for (int i = 0,j = 0; i &lt; sort.length;) &#123;</span><br><span class="line">				if (sort[i] &gt; 0) &#123;</span><br><span class="line">					arr[j] = minarr+i;</span><br><span class="line">					j++;</span><br><span class="line">					sort[i]--;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//对统计数组每个数计数</span><br><span class="line">	private static int[] counting(int[] arr, int max, int min) &#123;</span><br><span class="line">		int[] count = new int[max-min+1];</span><br><span class="line">		for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">			count[arr[i] - min] ++;</span><br><span class="line">		&#125;</span><br><span class="line">		return count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序-排序算法</title>
    <url>/2019/10/15/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>依次在数组中从小到大找数，在数组的头从前往后放。</p>
<span id="more"></span>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>平均时间复杂度：O(n²)；最好情况：O(n²)；最坏情况：O(n²)；</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place </p>
<p>稳定性：不稳定</p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @see https://github.com/MisterBooo/LeetCodeAnimation</span><br><span class="line"> * 核心：依次在数组中从小到大找数，在数组的头从前往后放。数组从前向后遍历，数据从前往后放if (min!=i)，遍历数组前边每次前进一下（i++）。</span><br><span class="line"> */</span><br><span class="line">public class ChoiceSort &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = &#123;8,5,3,2,4&#125;;</span><br><span class="line">		for (int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">			//假定 i最小,利用下标。只是找到最小，具体的数值在遍历完数组才用，利用下标即可。</span><br><span class="line">			int min = i;</span><br><span class="line">			//通过遍历数组寻找真的最小。</span><br><span class="line">			for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">				if (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">					min = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//将最小与未有序数据放到未有序的头</span><br><span class="line">			if (min!=i) &#123;</span><br><span class="line">				int temp2 = arr[min];</span><br><span class="line">				arr[min] = arr[i];</span><br><span class="line">				arr[i] = temp2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2021/07/23/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    <content><![CDATA[<p>数据结构和算法</p>
<span id="more"></span>

<h1 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构-树"></a>数据结构-树</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>结点和边组成的，不存在环的一种数据结构。</p>
<p>树满足递归定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根结点后，得到的若干个子结构也是树，通常称作子树。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zOi1UHoS8WhXdEa.png" alt="image-20210829212230523"></p>
<p>分支和层次关系</p>
<p>根节点</p>
<p>父节点</p>
<p>子节点</p>
<p>叶子节点：没有子节点</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>存储结构</p>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>时间复杂度：O(n)</p>
<ul>
<li><p>前(先)序遍历，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void preOrderTraverse(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    System.out.print(node.data + &quot; &quot;);</span><br><span class="line">    preOrderTraverse(node.left);</span><br><span class="line">    preOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>中序遍历，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 中序遍历</span><br><span class="line">public static void inOrderTraverse(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    inOrderTraverse(node.left);</span><br><span class="line">    System.out.print(node.data + &quot; &quot;);</span><br><span class="line">    inOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后序遍历，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 后序遍历</span><br><span class="line">public static void postOrderTraverse(Node node) &#123;</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line">    postOrderTraverse(node.left);</span><br><span class="line">    postOrderTraverse(node.right);</span><br><span class="line">    System.out.print(node.data + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2.二叉搜索树"></a>2.二叉搜索树</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>特性：</p>
<ul>
<li>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于本结点的值。</li>
<li>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</li>
<li>在二叉查找树中，会尽可能规避两个结点数值相等的情况。（《数据结构》严蔚敏-数值不能相同）</li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。</li>
</ul>
<h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>时间复杂度：O(logn)。</p>
<p>如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>时间复杂度为 O(logn)。</p>
<p>删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。分为下面三种情况。</p>
<ul>
<li>要删除的结点是某个叶子结点，则直接删除。将其父结点指针指向 null 即可。</li>
<li>如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>如果要删除的结点有两个子结点，则有两种可行的操作方式。<ul>
<li>第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。</li>
<li>第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。</li>
</ul>
</li>
</ul>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>时间复杂度为 O(logn)。</p>
<p>查询步骤：</p>
<ul>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序存储</li>
<li>遍历逻辑复杂一些</li>
<li>根据数值查询时间复杂度O(logn)</li>
<li>新增时间复杂度O(logn)</li>
<li>删除时间复杂度O(logn)</li>
</ul>
<h4 id="二叉搜索树算法题"><a href="#二叉搜索树算法题" class="headerlink" title="二叉搜索树算法题"></a>二叉搜索树算法题</h4><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h3 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="3.满二叉树"></a>3.满二叉树</h3><p>满二叉树，定义为只有最后一层无任何子结点，其他所有层上的所有结点都有两个子结点的二叉树。</p>
<h3 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="4.完全二叉树"></a>4.完全二叉树</h3><p>完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。</p>
<p>之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</p>
<h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><ul>
<li><p>链式存储法</p>
<p>也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针</p>
</li>
<li><p>顺序存储法-数组</p>
<p>按照规律把结点存放在数组里，如下图所示，为了方便计算，我们会约定把根结点放在下标为 1 的位置。随后，B 结点存放在下标为 2 的位置，C 结点存放在下标为 3 的位置，依次类推。</p>
<p>结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 * i 的位置，X 的右子结点总是存放在 2 * i + 1 的位置。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/qbQ3WFhRVlGHLM1.png" alt="image-20210829212930204"></p>
</li>
</ul>
<h3 id="5-二叉堆"><a href="#5-二叉堆" class="headerlink" title="5.二叉堆"></a>5.二叉堆</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>特点：</p>
<ul>
<li><p>二叉堆是一棵<strong>完全二叉树</strong></p>
</li>
<li><p>堆中某个节点的值总是不大于其父节点的值（所以也叫做<strong>大根堆</strong>），或者堆中某个节点的值总是不小于其父节点的值（所以也叫做<strong>小根堆</strong>）</p>
</li>
<li><p>注意：层次大的元素值不一定小于层次小的元素</p>
</li>
</ul>
<h4 id="数据操作-2"><a href="#数据操作-2" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h5><p>从倒数第一个非叶子节点（22）开始shift-Down，直到所有非叶子节点。</p>
<p>时间复杂度：O(n)</p>
<h5 id="新增-1"><a href="#新增-1" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>添加元素，依据完全二叉树，添加在最后</p>
</li>
<li><p>递归Shift Up，递归地和父节点比较，交换</p>
</li>
</ul>
<p>时间复杂度：O(logn)</p>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><ul>
<li>取出最大元素</li>
<li>完全二叉树最后的值放到堆顶</li>
<li>递归Shift down，堆顶递归的与孩子节点比较并交换</li>
</ul>
<p>时间复杂度：O(logn)</p>
<h3 id="6-红黑树-TODO"><a href="#6-红黑树-TODO" class="headerlink" title="6.红黑树 TODO"></a>6.红黑树 TODO</h3><h3 id="7-前缀（字典）树-Trie"><a href="#7-前缀（字典）树-Trie" class="headerlink" title="7.前缀（字典）树 Trie"></a>7.前缀（字典）树 Trie</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>字符串集合的前缀进行合并，每个根结点到叶子结点的链条就是一个字符串。</p>
<p>特点：</p>
<p>第一，根结点不包含字符；</p>
<p>第二，除根结点外每一个结点都只包含一个字符；</p>
<p>第三，从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XHE3T5UnkSswlrR.png" alt="image-20210829213733300"></p>
<h4 id="字典树算法题"><a href="#字典树算法题" class="headerlink" title="字典树算法题"></a>字典树算法题</h4><p>输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）</p>
<h3 id="8-线段树"><a href="#8-线段树" class="headerlink" title="8.线段树"></a>8.线段树</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>一种按照二叉树的形式存储数据的结构，每个节点保存的都是数组里某一段的总和。</p>
<p>适用于数据很多，而且需要频繁更新并求和的操作。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TNVpEio75FntMsK.png" alt="image-20210829214048328"></p>
<p>更新数组里某个元素的数值，时间复杂度 O(logn)。</p>
<p>对数组某个区间段里的元素进行求和，时间复杂度O(logn)</p>
<p>LeetCode 315. TODO</p>
<h3 id="9-树状数组"><a href="#9-树状数组" class="headerlink" title="9.树状数组"></a>9.树状数组</h3>]]></content>
      <categories>
        <category>编程基础</category>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法-二分查找</title>
    <url>/2020/07/29/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><em>二分查找</em>也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素有序排列。</p>
<span id="more"></span>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int binaySearch(int[] data, int des)&#123;</span><br><span class="line">       int start = 0;</span><br><span class="line">       int end = data.length-1;</span><br><span class="line">       while(start &lt;= end)&#123;// end = -1时打破循环</span><br><span class="line">           int middle = (end +start) &gt;&gt;&gt; 1;// 右移一位，相当于/2</span><br><span class="line">           if (des == data[middle])&#123;</span><br><span class="line">               return middle;</span><br><span class="line"></span><br><span class="line">           &#125; else if (des &lt; data[middle])&#123;</span><br><span class="line">               end = middle - 1;</span><br><span class="line"></span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               start = middle+1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两大数的积</title>
    <url>/2020/05/13/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E9%A2%98-%E4%B8%A4%E5%A4%A7%E6%95%B0%E7%9A%84%E7%A7%AF/</url>
    <content><![CDATA[<p>随机给定两个超大整数，实现计算两数之乘积。</p>
<span id="more"></span>

<h1 id="两大数的积"><a href="#两大数的积" class="headerlink" title="两大数的积"></a>两大数的积</h1><p>​        随机给定两个超大整数，实现计算两数之乘积。如“111111111111111”和“222222222222222”，输出乘积“24691358024691308641975308642”</p>
<p>思路：</p>
<pre><code>1.将两个数存到两个整数数组中
2.new 结果数据，长度为两个整数数组之和
3.两个数组逐位相乘后保存在结果数组中
4.处理进位，将数组中超过10的数据对10取余，数组前一位为/10
5.遍历结果数组。结果数组最前边为0时，处理掉。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class NumberTwoProduct &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;22&quot;;</span><br><span class="line">        String str2 = &quot;22&quot;;</span><br><span class="line"></span><br><span class="line">        //1.将两个数存到两个整数数组中</span><br><span class="line">        char[] num1 = str1.toCharArray();</span><br><span class="line">        char[] num2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        //2.new 结果数据，长度为两个整数数组之和</span><br><span class="line">        int[] result = new int[num1.length + num2.length];</span><br><span class="line"></span><br><span class="line">        //3.两个数组逐位相乘后保存在结果数组中</span><br><span class="line">        for (int i = 0; i &lt; num1.length; i++)&#123;</span><br><span class="line">            for (int j = 0; j &lt; num2.length; j++)&#123;</span><br><span class="line">                result[i + j + 1] += (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.处理进位，数组前一位为前一位+本位/10，数组本位为本位%10</span><br><span class="line">        for (int i = result.length -1 ; i &gt; 0; i--)&#123;</span><br><span class="line">            if (result[i] &gt;= 10)&#123;</span><br><span class="line">                result[i - 1] += result[i] / 10;</span><br><span class="line">                result[i] %= 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.从后往前遍历结果数组,去除最前边的0</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; result.length; i++)&#123;</span><br><span class="line">            if (i == 0 &amp;&amp; result[i] == 0 )</span><br><span class="line">                continue;</span><br><span class="line">            stringBuilder.append(result[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">        System.out.println(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进制转换</title>
    <url>/2020/05/13/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>实现将10进制数字字符串转换为16进制数字字符串。</p>
<span id="more"></span>

<h1 id="Java进制转换"><a href="#Java进制转换" class="headerlink" title="Java进制转换"></a>Java进制转换</h1><p>实现将10进制数字字符串转换为16进制数字字符串。如“155”，输出“0x9B”。</p>
<p>数学上如何进行进制转换：155%16为进制的最后一位，155/16%16为进制的倒数第二位，依次类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @see java.lang.Integer#toString(int i, int radix)</span><br><span class="line"> /</span><br><span class="line">public class ExchangeSystem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 155;</span><br><span class="line">        //代表进制的数组</span><br><span class="line">        char[] arr = new char[]&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;</span><br><span class="line">        StringBuilder result = new StringBuilder(&quot;0x&quot;);</span><br><span class="line">        while(a&gt;0)&#123;</span><br><span class="line">            //a%16为进制的最后一位，a/16%16为进制的倒数第二位</span><br><span class="line">            result.insert(2,arr[a%16]);</span><br><span class="line">            a /= 16;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以查看jdk进制转化的源码。java.lang.Integer的toString(int i, int radix)方法</p>
]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2020/01/08/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>为某个类提供代理，以控制对这个类的访问</p>
<span id="more"></span>

<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p><strong>问题：</strong>有时直接访问对象时带来一些问题，比如对象创建开销很大，或者某些主业务前后需要别的逻辑。</p>
<p><strong>解决方案：</strong>图片的加载很慢，可以默认图片先代替。主业务需要有事务控制、权限判断、日志记录。</p>
<p><strong>优点：</strong></p>
<p>​        1.职责清晰,程序员在业务类中只有增删改的具体实现，事务、权限、日志通过代理（AOP）织入业务类，事务、权限、日志的具体实现放在事务、权限、日志各自的类中。</p>
<p>​        2.增加了扩展性，事务、权限、日志可作为框架引入，并且引入的框架可自由组合。</p>
<h2 id="1-静态代理："><a href="#1-静态代理：" class="headerlink" title="1.静态代理："></a>1.静态代理：</h2><p>静态代理在使用时,需要定义接口,被代理对象与代理对象一起实现相同的接口。</p>
<p><strong>局限性：</strong></p>
<p>​    如果同时代理多个类，依然会导致类无限扩展</p>
<p>​    如果类中有多个方法，同样的逻辑需要反复实现</p>
<p><strong>例子：</strong>追求者找两个同学送礼物给女神，两个同学顺序可变</p>
<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//女神</span><br><span class="line">public class Girl &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Girl(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//送礼物 被代理对象的接口</span><br><span class="line">public interface SendGift &#123;</span><br><span class="line">    void sendHower();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//追求者</span><br><span class="line">public class Persuit implements SendGift&#123;</span><br><span class="line">    private Girl girl;</span><br><span class="line"></span><br><span class="line">    public Persuit(Girl girl)&#123;</span><br><span class="line">        this.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendHower() &#123;</span><br><span class="line">        System.out.println(girl.getName() + &quot;给你花&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//学生1</span><br><span class="line">public class Student1 implements SendGift&#123;</span><br><span class="line"></span><br><span class="line">    private SendGift sendGift;</span><br><span class="line"></span><br><span class="line">    public Student1(SendGift sendGift)&#123;</span><br><span class="line">        this.sendGift = sendGift;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendHower() &#123;</span><br><span class="line">        System.out.println(&quot;我是同学1，我是帮忙的&quot;);</span><br><span class="line"></span><br><span class="line">        sendGift.sendHower();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我是同学1，我帮忙结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student2 implements SendGift &#123;</span><br><span class="line">    private SendGift sendGift;</span><br><span class="line"></span><br><span class="line">    public Student2(SendGift sendGift)&#123;</span><br><span class="line">        this.sendGift = sendGift;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendHower() &#123;</span><br><span class="line">        System.out.println(&quot;我是同学2,我是帮忙的&quot;);</span><br><span class="line"></span><br><span class="line">        sendGift.sendHower();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我是同学2,我帮忙结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Girl girl = new Girl(&quot;zs&quot;);</span><br><span class="line">        Persuit persuit = new Persuit(girl);</span><br><span class="line">        </span><br><span class="line">        //先学生1，后学生2</span><br><span class="line">        Student2 student2 = new Student2(persuit);</span><br><span class="line">        Student1 student1 = new Student1(student2);</span><br><span class="line">        student1.sendHower();</span><br><span class="line"></span><br><span class="line">		//先学生2，后学生1</span><br><span class="line">		Student1 student1 = new Student1(persuit);</span><br><span class="line">        Student2 student2 = new Student2(student1);</span><br><span class="line">        student2.sendHower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<pre><code>//先学生1，后学生2
我是同学1，我是帮忙的
我是同学2,我是帮忙的
zs给你花
我是同学2,我帮忙结束
我是同学1，我帮忙结束

//先学生2，后学生1
我是同学2,我是帮忙的
我是同学1，我是帮忙的
zs给你花
我是同学1，我帮忙结束
我是同学2,我帮忙结束
</code></pre>
<p>测试类执行结果1的部分解释：</p>
<p>​    student1.sendHower();  </p>
<p>​    System.out.println(“我是同学1，我是帮忙的”);</p>
<p>​    sendGift.sendHower();</p>
<pre><code>/*
sendGift → student2
student2传入Student1的构造方法  public Student1(SendGift sendGift)&#123;
    this.sendGift = sendGift;
&#125;)
上边的sendGift.sendHower();即student2.sendHower();
*/
</code></pre>
<p>System.out.println(“我是同学2，我是帮忙的”);</p>
<p>再往下一样</p>
<h2 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h2><p><strong>首要条件：</strong>被代理类必须实现一个接口。</p>
<p><strong>应用场景：</strong>日志系统、事务提交或回退、拦截器、权限控制等。面对切面编程AOP的核心就是动态代理机制。</p>
<p>静态代理中每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类。所以我们想<strong>通过一个代理类完成全部的代理功能，那么我们就需要用动态代理</strong>.</p>
<p><strong>动态代理</strong>是在运行时，<strong>通过反射机制实现动态代理，能够代理各种类型的对象</strong>。</p>
<p>在Java中实现动态代理机制，需要<code>java.lang.reflect.InvocationHandler</code>接口和 <code>java.lang.reflect.Proxy</code>类的支持。</p>
<p>java.lang.reflect.InvocationHandler接口的方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args)</span><br><span class="line">        throws Throwable;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Object proxy<br> 被代理对象</p>
</li>
<li><p>Method method<br> 要调用的方法</p>
</li>
<li><p>Object[] args<br> 方法调用时所需要的参数</p>
<p>@return 被代理接口的实现类</p>
</li>
</ul>
<p><code>java.lang.reflect.Proxy</code>类中重要的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">  InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClassLoader loader<br> 类加载器</li>
<li>Class&lt;?&gt;[] interfaces<br> 得到被代理类全部的接口</li>
<li>InvocationHandler h<br> 得到InvocationHandler接口的子类的实例</li>
</ul>
<p><strong>Implementation</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Subject</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行request方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//无接口的鱼类</span><br><span class="line">public class Fish &#123;</span><br><span class="line">    public void getWater()&#123;</span><br><span class="line">        System.out.println(&quot;给我水&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动态代理类  实现动态代理的工具类</span><br><span class="line">public class ProxyHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    //用来代表被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @parm target 被动态代理类的实例</span><br><span class="line">     * @return 动态代理类的实例</span><br><span class="line">     */</span><br><span class="line">    public Object newProxyInstance(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line"></span><br><span class="line">        return  Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写InvocationHandler类的invoke方法，在被代理对象的方法中嵌入代码</span><br><span class="line">     *</span><br><span class="line">     * @param proxy 被代理对象</span><br><span class="line">     * @param method 要控制的被代理对象的方法</span><br><span class="line">     * @param args 被代理对象方法需要的参数</span><br><span class="line">     * @return Object 被代理接口的实现类。</span><br><span class="line">     *</span><br><span class="line">     * @see InvocationHandler#invoke(Object, Method, Object[])</span><br><span class="line">     * @see java.lang.reflect.Proxy</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;被代理对象方法执行前&quot;);</span><br><span class="line"></span><br><span class="line">        Object ret = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //调用目标方法</span><br><span class="line">            ret = method.invoke(target, args);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;调用发生异常&quot;);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;被代理对象方法执行后&quot;);</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//客户端测试类</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ProxyHandler handler = new ProxyHandler();</span><br><span class="line">        Subject subject = (Subject) handler.newProxyInstance(new ConcreteSubject());</span><br><span class="line">        subject.request();</span><br><span class="line"></span><br><span class="line">        ProxyHandler handler2 = new ProxyHandler();</span><br><span class="line">        //不能代理无接口的类Fish，Proxy中target.getClass().getInterfaces()报错</span><br><span class="line">        Fish fish = (Fish) handler.newProxyInstance(new ConcreteSubject());</span><br><span class="line">        fish.getWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试的控制台显示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">被代理对象方法执行前</span><br><span class="line">执行request方法</span><br><span class="line">被代理对象方法执行后</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to proxy.Fish</span><br><span class="line">	at proxy.Client.main(Client.java:10)</span><br></pre></td></tr></table></figure>

<h2 id="3-cglib代理"><a href="#3-cglib代理" class="headerlink" title="3.cglib代理"></a>3.cglib代理</h2><p>这里用的是spring的cglib代理，用到了spring-core.3.2.5.jar</p>
<p><strong>应用场景：</strong>Spring的AOP中，如果加入容器的目标对象有实现接口,用JDK代理.如果目标对象没有实现接口,用Cglib代理.</p>
<p><strong>原理：</strong>动态生成代理类继承被代理类，执行代理类的方法时拦截，在拦截方法中写调用目标的逻辑代码。</p>
<p><strong>结合实例的详细流程：</strong>动态生成代理类Proxy继承被代理类UserDao，执行代理类Proxy的重写父类Proxy的方法save()时，intercept方法拦截，在intercept方法中执行UserDao的save方法，可在save方法前后添加事务等其他业务代码。</p>
<p><strong>优点：</strong>被代理类不需要实现接口。</p>
<p><strong>注意：</strong>cglib代理是动态生成代理类去继承被代理类，final修饰的类无法被继承，方法被final修饰，无法重写。被static修饰，重写无效。 cglib生成对象比JDK动态代理开销更大。</p>
<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//被代理类 未实现接口</span><br><span class="line">public class UserDao &#123;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        System.out.println(&quot;保存数据&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.cglib.proxy.Enhancer;</span><br><span class="line">import org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line">import org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Cglib子类代理工厂</span><br><span class="line"> * 需要spring-core的jar包</span><br><span class="line"> *</span><br><span class="line"> * @see MethodInterceptor</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class ProxyFactory implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    //被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public  ProxyFactory(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @return 控制被代理对象的实例</span><br><span class="line">     */</span><br><span class="line">    public  Object getProxyInstance()&#123;</span><br><span class="line">        //cglib中的工具类</span><br><span class="line">        Enhancer en = new Enhancer();</span><br><span class="line">        //设置父类</span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line"></span><br><span class="line">        en.setCallback(this);</span><br><span class="line">        //创建实例</span><br><span class="line">        return en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * MethodInterceptor 的方法</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;开始事务&quot;);</span><br><span class="line"></span><br><span class="line">        //执行目标对象的方法</span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;开始事务&quot;);</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UserDao target = new UserDao();</span><br><span class="line"></span><br><span class="line">        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始事务</span><br><span class="line">保存数据</span><br><span class="line">开始事务</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/01/03/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式的介绍、原理、常用的实现方式。</p>
<span id="more"></span>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p> <strong>介绍</strong>：单例模式的类只有单个对象会被创建（实例化），向其他类只提供一种访问方式。可以全局访问.</p>
<p><strong>解决了什么</strong>：只能有一个实例操作资源。多个打印任务，正在打印的实例只存在一个。</p>
<p><strong>优点</strong>：减小了频繁创建和销毁类（GC）的系统开销。多线安全的单例模式解决了多线程问题。</p>
<p><strong>哪里用到了</strong>：要求只有一个对象的场景.Controller类中的Service类可用单例模式创建对象。Spring用单例模式管理注入容器的类。</p>
<p><strong>如何实现：</strong>使用一个私有静态变量、一个私有构造函数、以及一个公有静态函数来实现。</p>
<h2 id="Implementation（具体实现）："><a href="#Implementation（具体实现）：" class="headerlink" title="Implementation（具体实现）："></a>Implementation（具体实现）：</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iJUyFpWdfhulX9S.gif" alt="Singleton Implementation - UML Class Diagram"></p>
<h3 id="1-懒汉式"><a href="#1-懒汉式" class="headerlink" title="1.懒汉式"></a>1.懒汉式</h3><p><strong>优点：</strong>支持lazy loading 。私有静态变量 instance被延迟实例化，节约资源。</p>
<p><strong>缺点：</strong>不支持多线程。多线程环境下是不安全的，如果多个线程同时进入 <code>if (instance == null)</code> ，并且此时instance 为 null，会实例化多次instance。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    //私有化构造函数</span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">  	//对外提供唯一访问方法</span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">    	return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-饿汉式："><a href="#2-饿汉式：" class="headerlink" title="2.饿汉式："></a>2.饿汉式：</h3><p>类加载（classloader）就实例化 instance，避免了多线程问题，无lazy loading 的效果。<br><strong>优点：</strong>支持多线程。</p>
<p><strong>缺点：</strong>类加载时就实例化 instance，而不是使用时实例化instance，浪费内存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123; </span><br><span class="line">    private static Singleton instance = new Singleton(); </span><br><span class="line">    private Singleton ()&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123; </span><br><span class="line">        return instance; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-双重校验锁"><a href="#3-双重校验锁" class="headerlink" title="3.双重校验锁"></a>3.双重校验锁</h3><p><strong>优点：</strong>支持多线程，有lazy loading效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	//volatile防止JVM编译器指令重排</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getinstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">        	//对实例化的代码加锁</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个<code>if (instance == null)</code>，instance没有被实例化时，对实例化内容加锁。避免非必要加锁。</p>
<p>第二个<code>if (instance == null)</code>，第一次实例化instance时，防止多个线程在synchronized处等待并执行<code>instance = new Singleton()</code>；</p>
<p><strong>volatile 修饰instance的原因：</strong> JVM 具有指令重排的特性，多线程环境下会导致一个线程获得还没有初始化的实例。volatile可禁止JVM指令重排。</p>
<p><strong>具体描述：</strong></p>
<p>​    <code>instance = new Singleton();</code> </p>
<p>实例化对象的代码分为三个指令执行：</p>
<ol>
<li><p>为 instance 分配内存空间</p>
</li>
<li><p>初始化 instance </p>
</li>
<li><p>将 instance 指向分配的内存地址</p>
<p>线程 T1 执行了 1 和 3时，线程T2获取instance，T2会获得一个不该为null的instance。</p>
<p>volatile广泛存在于java并发系列中。</p>
</li>
</ol>
<h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><p><strong>优点：</strong> 支持lazy loading，多线程安全。实现简单。</p>
<p><strong>缺点：</strong> 只适用于静态域的情况。（菜鸟教程提到）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">    	private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">    	return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>private static class SingletonHolder静态内部类不会初始化对象，多次调用getInstance()得到的是同一个对象INSTANCE。</p>
<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举:"></a>5.枚举:</h3><p><strong>缺点：</strong> 无lazy loading。<br><strong>优点：</strong> 自动支持序列化机制，可防止反射，能避免多线程同步问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    //私有化构造函数</span><br><span class="line">    private User()&#123; &#125;</span><br><span class="line"> </span><br><span class="line">    //定义一个静态枚举类</span><br><span class="line">    static enum SingletonEnum&#123;</span><br><span class="line">        //创建一个枚举对象，该对象天生为单例</span><br><span class="line">        INSTANCE;</span><br><span class="line">        private User user;</span><br><span class="line">        //私有化枚举的构造函数</span><br><span class="line">        private SingletonEnum()&#123;</span><br><span class="line">            user=new User();</span><br><span class="line">        &#125;</span><br><span class="line">        public User getInstnce()&#123;</span><br><span class="line">            return user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //对外暴露一个获取User对象的静态方法</span><br><span class="line">    public static User getInstance()&#123;</span><br><span class="line">        return SingletonEnum.INSTANCE.getInstnce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance());</span><br><span class="line">        System.out.println(User.getInstance()==User.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为true</span><br></pre></td></tr></table></figure>

<p><strong>未完成：</strong> 静态内部类只适用于静态域，枚举如何避免多线程和反序列化，未防止反射破解单例。</p>
]]></content>
      <categories>
        <category>编程基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2020/01/05/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>主要功能：把对象的实例化部分抽取了出来，降低了系统中代码耦合度，增强了系统的扩展性。</p>
<span id="more"></span>

<p>工厂模式分为简单工厂模式，工厂方法模式和抽象工厂模式。</p>
<h1 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单工厂：简单工厂把对象的实例化单独放到一个类中去维护。</span><br><span class="line"> * 工厂角色：</span><br><span class="line"> *  用户类：不同用户需要不同的产品</span><br><span class="line"> *  产品类：不同的产品类对应不同的产品</span><br><span class="line"> *  工厂类：根据用户不同的需求产生不同的产品实例化对象</span><br><span class="line"> * 例子：</span><br><span class="line"> *  用户需要各种不同的产品，不同的客户类中创建了不同的产品类，产品类发生改变时，每个用户类内部需要改变。</span><br><span class="line"> *  简单工厂对客户类和产品类之间解耦。工厂类去对各个产品类实例化。每个客户类不去new产品类，而是通过访问Factory获得需要的产品类对象。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产品</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber3 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂</span><br><span class="line">public class Factory &#123;</span><br><span class="line">    public Product createProduct(int type) &#123;</span><br><span class="line">        if (type == 1) &#123;</span><br><span class="line">            return new ProductNumber1();</span><br><span class="line">        &#125; else if (type == 2) &#123;</span><br><span class="line">            return new ProductNumber2();</span><br><span class="line">        &#125;</span><br><span class="line">        return new ProductNumber3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h1><p>把对象实例化的管理放到一个核心工厂类和n个工厂子类中去维护。</p>
<p>核心工厂：接口，定义创建产品对象的接口方法。</p>
<p>工厂子类：实例化产品类。</p>
<p>新增产品时，只需新增产品子类和工厂子类，不需要改变原有工厂类代码。扩展性更好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产品 无改变</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂方法</span><br><span class="line">//核心工厂</span><br><span class="line">interface FactoryMethod &#123;</span><br><span class="line">    Product getProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂子类</span><br><span class="line">public class Factroy1 implements FactoryMethod &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct()&#123;</span><br><span class="line">        return new ProductNumber1() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//工厂子类</span><br><span class="line">public class Factroy2 implements FactoryMethod &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct()&#123;</span><br><span class="line">        return new ProductNumber2() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3.抽象工厂"></a>3.抽象工厂</h1><p>把对象实例化的管理放到一个核心工厂类的方法和n个工厂子类的方法中去维护。</p>
<p>新增新产品时，添加产品类，核心工厂和工厂子类添加对应的实现方法。</p>
<p>抽象工厂的优势：可新增同类型的工厂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//产品 无改变</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//核心工厂</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract Product  getProduct1();</span><br><span class="line">    public abstract Product  getProduct2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品实现</span><br><span class="line">public class ProductFactory extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct1() &#123;</span><br><span class="line">        return new ProductNumber1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct2() &#123;</span><br><span class="line">        return new ProductNumber2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//新增单一产品</span><br><span class="line">//产品 新增一个产品类</span><br><span class="line">public interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber1 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber2 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductNumber3 implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//核心工厂 新增获取产品的抽象方法</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract Product  getProduct1();</span><br><span class="line">    public abstract Product  getProduct2();</span><br><span class="line">    public abstract Product  getProduct3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品实现 新增产品的实现方法</span><br><span class="line">public class ProductFactory extends AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct1() &#123;</span><br><span class="line">        return new ProductNumber1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct2() &#123;</span><br><span class="line">        return new ProductNumber2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct3() &#123;</span><br><span class="line">        return new ProductNumber3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板模式</title>
    <url>/2020/01/06/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>将各个子类中的共有的实现方法放在父类实现。</p>
<span id="more"></span>

<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>解决了什么：代码复用。</p>
<p>解决方法： 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：养动物，养乌龟和养鱼都需要水，但喂的食物不同</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class RaiseAnimal &#123;</span><br><span class="line">    void water()&#123;</span><br><span class="line">        System.out.println(&quot;水&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    abstract void food();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RaiseTortoise extends  RaiseAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void food()&#123;</span><br><span class="line">        System.out.println(&quot;龟粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RaiseFish extends  RaiseAnimal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void food()&#123;</span><br><span class="line">        System.out.println(&quot;鱼粮&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Template &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RaiseAnimal raiseAnimal1 = new RaiseTortoise();</span><br><span class="line">        raiseAnimal1.water();</span><br><span class="line">        raiseAnimal1.food();</span><br><span class="line"></span><br><span class="line">        RaiseAnimal raiseAnimal2 = new RaiseFish();</span><br><span class="line">        raiseAnimal2.water();</span><br><span class="line">        raiseAnimal2.food();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<pre><code>水
龟粮
水
鱼粮
</code></pre>
]]></content>
      <categories>
        <category>编程基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>模板模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2020/02/04/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<span id="more"></span>

<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><strong>解决的问题：</strong>有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，使用反射+map替换。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p>if-else解决多个算法相似的代码逻辑时，为什么带来了复杂性？</p>
<p>if-else在逻辑上是有顺序的，而多个算法相似的代码逻辑上是平行的。平行的代码逻辑使用if-else结构是复杂化了的，阅读上不好理解，扩展性差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：spring源码中为实例bean注入属性值时需要判断属性值的类型，下边实例是对判断过程的优化</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong></p>
<p>对targetType进行if-else判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//准备环境</span><br><span class="line">TypedStringValue typedStringValue = new TypedStringValue(&quot;18&quot;);</span><br><span class="line">typedStringValue.setTargetType(Integer.class);</span><br><span class="line"></span><br><span class="line">//获取bean的属性值stringValue和属性值类型targetType</span><br><span class="line">String stringValue = typedStringValue.getValue();</span><br><span class="line">Class&lt;?&gt; targetType = typedStringValue.getTargetType();</span><br><span class="line"></span><br><span class="line">//根据targetType要转换的value</span><br><span class="line">Object valueToUse = null;</span><br><span class="line"></span><br><span class="line">if (targetType == Integer.class) &#123;</span><br><span class="line">	//进行转换</span><br><span class="line">	valueToUse = Integer.parseInt(stringValue);</span><br><span class="line">&#125; else if (targetType == String.class) &#123;</span><br><span class="line">	//进行转换</span><br><span class="line">	valueToUse = stringValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:bean的属性值和属性值类型</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class TypedStringValue &#123;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    private Class&lt;?&gt; targetType;</span><br><span class="line"></span><br><span class="line">    public TypedStringValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(String value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getTargetType() &#123;</span><br><span class="line">        return targetType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTargetType(Class&lt;?&gt; targetType) &#123;</span><br><span class="line">        this.targetType = targetType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>**
 * Description:策略的接口类
 *
 * @author hxr
 * @version 1.0
 */
public interface Strategy &#123;

    /**
     * Description: 判断propertype标签中的value标签的Class类型，转换value的值为Class类型
     * @author: hxr
     * @param:
     * @return:
     */
    Object exchageType(String stringValue);
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:整型类型策略类</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class IntegerTypeStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object exchageType(String stringValue) &#123;</span><br><span class="line">        return Integer.parseInt(stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:浮点类型策略类</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class FloatTypeStrategy implements Strategy&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object exchageType(String stringValue) &#123;</span><br><span class="line">        return Float.parseFloat(stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:向实例注入属性值，需要考虑属性值的类型</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class AbstractAutowiredCapableBeanFactory &#123;</span><br><span class="line">    // 策略类集合</span><br><span class="line">    private Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    public void initMap()&#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">        // 将策略类放入集合map中</span><br><span class="line">        map.put(Integer.class, IntegerTypeStrategy.class);</span><br><span class="line">        map.put(Float.class, FloatTypeStrategy.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取要使用的策略类</span><br><span class="line">    public Class&lt;?&gt; getbean(Class&lt;?&gt; targetType) &#123;</span><br><span class="line">        return map.get(targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成实例工具类</span><br><span class="line">    public Object creatObject(Class&lt;?&gt; object) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = object.getConstructor();</span><br><span class="line">            return constructor.newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: 策略模式+反射+map策略类集合优化if-else判断</span><br><span class="line"> *                  将stringValue转化为TypedStringValue.targetType的类型</span><br><span class="line"> *                  优化if-else判断targetType</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 准备环境</span><br><span class="line">        TypedStringValue typedStringValue = new TypedStringValue(&quot;18&quot;);</span><br><span class="line">        typedStringValue.setTargetType(Integer.class);</span><br><span class="line"></span><br><span class="line">        // 获取类型</span><br><span class="line">        Class&lt;?&gt; targetType = typedStringValue.getTargetType();</span><br><span class="line">        String stringValue = typedStringValue.getValue();</span><br><span class="line"></span><br><span class="line">        // 创建beanFactory</span><br><span class="line">        AbstractAutowiredCapableBeanFactory beanFactory = new AbstractAutowiredCapableBeanFactory();</span><br><span class="line">        // 初始化策略类</span><br><span class="line">        beanFactory.initMap();</span><br><span class="line">        // 通过targetTypemap 从策略类集合map获取需要执行的策略类。</span><br><span class="line">        Class&lt;?&gt; Object = beanFactory.getbean(targetType);</span><br><span class="line">        // 获取策略类实例</span><br><span class="line">        Strategy strategy = (Strategy)beanFactory.creatObject(Object);</span><br><span class="line"></span><br><span class="line">        // 执行策略类转换方法 将stringValue转化为Integer、Float、Double等类型</span><br><span class="line">        Object o1 = strategy.exchageType(stringValue);</span><br><span class="line">        System.out.println(o1.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化</title>
    <url>/2020/05/18/212Java%E8%AF%AD%E8%A8%80/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>序列化</p>
<p><escape><span id="more"></span></escape></p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul>
<li><p><strong>定义：</strong>将对象根据一定的格式转换为字节数组。</p>
</li>
<li><p><strong>需要序列化的原因：</strong>存储和网络传输都需要经过把一个对象状态保存成一种跨平台识别的字节格式，IO支持的数据格式是字节数组。</p>
</li>
<li><p><strong>用途：</strong>IO传输对象时，即跨平台存储，网络传输。</p>
</li>
<li><p><strong>实际场景：</strong>存到redis，微服务之间调用传输对象。</p>
</li>
<li><p><strong>做了什么：</strong>将要保存的数据，转换成字节码的形式，反序列化就是把字节码变成数据。</p>
</li>
</ul>
<h2 id="redis序列化"><a href="#redis序列化" class="headerlink" title="redis序列化"></a>redis序列化</h2><p>默认的<code>JdkSerializationRedisSerializer</code>存储时是二进制，redis中查看是乱码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Redis序列化配置</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());// key一般不是对象，String实现性能高</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());// value可能是对象，采用spring提供的Jackson序列化</span><br><span class="line">        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化"></a>java序列化</h2><ul>
<li><p><strong>实现原理</strong></p>
<p>通过<code>serialVersionUID</code>实现，JVM会在运行时判断类的<code>serialVersionUID</code>属性来验证版本一致性，如果传来的字节流中的serialVersionUID与本地相应类的serialVersionUID相同则认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<p>类实现了<code>Serializable </code>接口，JVM会根据类的整体信息生成<code>serialVersionUID</code>，类修改时，JVM会重新生成<code>serialVersionUID</code>。一般实践中会显示的定义类的<code>serialVersionUID</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java语言</category>
      </categories>
      <tags>
        <tag>序列化</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE-入门</title>
    <url>/2020/11/12/213Java%E6%A1%86%E6%9E%B6/JavaEE-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>JavaEE-入门</p>
<span id="more"></span>

<h1 id="JavaEE-入门"><a href="#JavaEE-入门" class="headerlink" title="JavaEE-入门"></a>JavaEE-入门</h1><p>介绍：基于JavaSE构建，为企业级应用推出的标准平台，用来开发B/S架构软件。</p>
<p>主要技术：<strong>JDBC</strong>、JNDI、EJB、RMI、<strong>Servlet</strong>、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。</p>
<ul>
<li>JDBC: Java 语言中用来<strong>规范客户端程序如何来访问数据库的应用程序接口</strong>，提供了诸如查询和更新数据库中数据的方法。</li>
<li>Servlet: Java 编写的<strong>服务器端程序</strong>。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。</li>
</ul>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbit-安装</title>
    <url>/2020/08/24/213Java%E6%A1%86%E6%9E%B6/Rabbit-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Linux环境，xshell</p>
<span id="more"></span>

<h1 id="Rabbit-安装"><a href="#Rabbit-安装" class="headerlink" title="Rabbit-安装"></a>Rabbit-安装</h1><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/sLeKaPM1DNQHgzu.png" alt="image-20200905175636998"></p>
<h2 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h2><p>上传</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/p9T2YVJsGDCWtUL.png" alt="image-20200905175921141"></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/MZLUJOX21luiYhC.png" alt="image-20200905180030092"></p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">警告：socat-1.7.3.2-1.1.el7.x86_64.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID 87e360b8: NOKEY</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">	tcp_wrappers 被 socat-1.7.3.2-1.1.el7.x86_64 需要</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm --nodeps --force</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wvzOrPg6LQVI2Tq.png" alt="image-20200905180800041"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/kLWq8jAdTK4E9Fs.png" alt="image-20200905180834609"></p>
<h2 id="开启管理界面"><a href="#开启管理界面" class="headerlink" title="开启管理界面"></a>开启管理界面</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启管理界面</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"># 修改默认配置信息</span><br><span class="line">vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app </span><br><span class="line"># 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/KtAXaeiVkYj9oEH.png" alt="image-20200905180938193"></p>
<p>端口号，默认账号</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20200905191508314.png" alt="image-20200905191508314"></p>
<p>最后一个红框的guest不放开会导致登录失败</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zZlH8m5TEfUKc1G.png" alt="image-20200905191659280"></p>
<h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/share/doc/rabbitmq-server-3.6.5/</span><br><span class="line"></span><br><span class="line">cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service rabbitmq-server start # 启动服务</span><br><span class="line">service rabbitmq-server stop # 停止服务</span><br><span class="line">service rabbitmq-server restart # 重启服务</span><br></pre></td></tr></table></figure>

<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>guest guest</p>
<p>添加虚拟机，添加账号</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/C5wtrn3K7Sc6V8o.png" alt="image-20200906093925469"></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>安装</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbit-应用问题解决</title>
    <url>/2020/08/29/213Java%E6%A1%86%E6%9E%B6/Rabbit-%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>消息可靠性解决，幂等性解决。</p>
<span id="more"></span>

<h1 id="Rabbit-应用问题解决方案"><a href="#Rabbit-应用问题解决方案" class="headerlink" title="Rabbit-应用问题解决方案"></a>Rabbit-应用问题解决方案</h1><h2 id="消息可靠性解决"><a href="#消息可靠性解决" class="headerlink" title="消息可靠性解决"></a>消息可靠性解决</h2><p>架构图</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/HiCon2weFsykGX9.png" alt="RabbitMQ消息可靠性保障"></p>
<p>解决思路：</p>
<ol>
<li>回调检查<ol>
<li>producer发送消息，consumer消费消息后，要发送确认消息。</li>
<li>producer发送消息后，等3分钟再发送一条同样的消息</li>
<li>对比延迟3分钟的消息和确认消息，有延迟消息无确认消息时，让producer重新发这一条消息。</li>
</ol>
</li>
<li>定时检查<ol>
<li>检查producer库中的消息和确认消息库是否一致，producer库中有，确认消息库中没有时，让producer重新发消息。</li>
</ol>
</li>
</ol>
<h2 id="幂等性解决"><a href="#幂等性解决" class="headerlink" title="幂等性解决"></a>幂等性解决</h2><p>解决方法：</p>
<ul>
<li>使用全局MessageID    </li>
<li>乐观锁</li>
</ul>
<h3 id="全局MessageID"><a href="#全局MessageID" class="headerlink" title="全局MessageID"></a>全局MessageID</h3><p>发送消息时发送MessageID，消费消息时去redis中判断是否存在MessageID。</p>
<ul>
<li><p>如果存在，则代表消息已经被消费。</p>
</li>
<li><p>如果不存在，则去消费该消息，消费完成后存储到redis中。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-与SpringBoot整合</title>
    <url>/2020/08/27/213Java%E6%A1%86%E6%9E%B6/RabbitMQ-%E4%B8%8ESpringBoot%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>RabbitMQ-与SpringBoot整合</p>
<span id="more"></span>

<h1 id="RabbitMQ-与SpringBoot整合"><a href="#RabbitMQ-与SpringBoot整合" class="headerlink" title="RabbitMQ-与SpringBoot整合"></a>RabbitMQ-与SpringBoot整合</h1><p>spring boot项目中只需要引入对应的amqp启动器依赖即可，可以方便的使用RabbitTemplate发送消息，使用注解接收消息。</p>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><p><strong>生产者工程：</strong></p>
<ol>
<li>导入依赖</li>
<li>application.yml文件配置RabbitMQ相关信息；</li>
<li>在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定</li>
<li>注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机</li>
</ol>
<p><strong>消费者工程：</strong></p>
<ol>
<li>导入依赖</li>
<li>application.yml文件配置RabbitMQ相关信息</li>
<li>创建消息处理类，用于接收队列中的消息并进行处理</li>
</ol>
<h2 id="生产者工程："><a href="#生产者工程：" class="headerlink" title="生产者工程："></a>生产者工程：</h2><ol>
<li><p>创建生产者工程 new module</p>
</li>
<li><p>导入maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!-- 父工程 --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- rabbit --&gt;</span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot-rabbitmq-producer&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 单元测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname ProducerApplication</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ProducerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class);//SpringApplication 不是SpringBootApplication</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置rabbit服务器信息</span><br><span class="line"># 地址、端口号、账号、密码</span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.3.3</span><br><span class="line">    port: 5672</span><br><span class="line">    username: xiaorui</span><br><span class="line">    password: xiaorui</span><br><span class="line">    virtual-host: learn</span><br></pre></td></tr></table></figure></li>
<li><p>编写配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.*;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname RabbitMQConfig</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    //交换机名称</span><br><span class="line">    public static final String ITEM_TOPIC_EXCHANGE = &quot;xiaorui_topic_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    public static final String ITEM_QUEUE = &quot;xiaorui_queue&quot;;</span><br><span class="line"></span><br><span class="line">    //声明交换机</span><br><span class="line">    @Bean(&quot;xiaoruiTopicExchange&quot;)</span><br><span class="line">    public Exchange topicExchange()&#123;</span><br><span class="line">        return ExchangeBuilder.topicExchange(ITEM_TOPIC_EXCHANGE).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //声明队列</span><br><span class="line">    @Bean(&quot;xiaoruiQueue&quot;)</span><br><span class="line">    public Queue xiaoruiQueue()&#123;</span><br><span class="line">        return QueueBuilder.durable(ITEM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //绑定队列和交换机</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding xiaoruiQueueExchange(@Qualifier(&quot;xiaoruiQueue&quot;) Queue queue, @Qualifier(&quot;xiaoruiTopicExchange&quot;) Exchange exchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(queue).to(exchange).with(&quot;xiaorui.#&quot;).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.rabbitmq;</span><br><span class="line"></span><br><span class="line">import com.xiaoruiit.config.RabbitMQConfig;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname ProducerTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, &quot;xiaorui.insert&quot;, &quot;新增，routing key 为xiaorui.insert&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, &quot;xiaorui.update&quot;, &quot;修改，routing key 为xiaorui.update&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE, &quot;xiaorui.delete&quot;, &quot;删除，routing key 为xiaorui.delete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/FQAyC9WMfvtZ8xe.png" alt="image-20200906221641322"></p>
</li>
</ol>
<h2 id="消费者工程"><a href="#消费者工程" class="headerlink" title="消费者工程"></a>消费者工程</h2><ol>
<li><p>创建工程</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot-rabbitmq-consumer&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname ConsumerApplication</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.3.3</span><br><span class="line">    port: 5672</span><br><span class="line">    username: xiaorui</span><br><span class="line">    password: xiaorui</span><br><span class="line">    virtual-host: learn</span><br></pre></td></tr></table></figure></li>
<li><p>消费者监听处理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.com.xiaoruiit.rabbitmq.listener;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class ConsumerListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 监听某个队列的消息</span><br><span class="line">     * @param message 接收到的消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = &quot;xiaorui_queue&quot;)</span><br><span class="line">    public void myListener1(String message)&#123;</span><br><span class="line">        System.out.println(&quot;消费者接收到的消息为：&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消费者接收到的消息为：新增，routing key 为xiaorui.insert</span><br><span class="line">消费者接收到的消息为：修改，routing key 为xiaorui.update</span><br><span class="line">消费者接收到的消息为：删除，routing key 为xiaorui.delete</span><br></pre></td></tr></table></figure></li>
<li><p>rabbitmq控制台</p>
</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/9VYKZrNWeSDgc4A.png" alt="image-20200906223020442"></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>整合</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-复习</title>
    <url>/2020/11/18/213Java%E6%A1%86%E6%9E%B6/RabbitMQ-%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>RabbitMQ-复习</p>
<span id="more"></span>

<h1 id="RabbitMQ-复习"><a href="#RabbitMQ-复习" class="headerlink" title="RabbitMQ-复习"></a>RabbitMQ-复习</h1><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p><strong>诞生业务背景</strong>:</p>
<ul>
<li>A 系统通过接口调用发送数据到 BCD 三个系统。一天后E 系统也要这个数据，有一天后 C 系统现在不需要了。</li>
<li>A 系统接收一个前端请求，需要在ABCD四个系统写入库，请求总延时是 3 + 300 + 400 + 200 = 903ms，接近 1s。而互联网类的企业，对于用户直接的操作，一般要求每个请求在 200 ms 以内完成。</li>
<li>每天 12:00 ~ 13:00 ，A系统每秒并发请求数量突然会暴增到 5k+ 条。可能会导致数据库崩溃，系统无法访问。其他时间，并发量小于100.</li>
</ul>
<p><strong>解决了什么</strong>：降低A系统其他系统的耦合，提升响应速度，将一个时间段的高并发量平均到其他时间段。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>解耦</li>
<li>提升响应速度</li>
<li>削峰</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>可用性降低，rabbitmq可能宕机。</li>
<li>复杂度提高</li>
<li>需要解决数据一致性<ul>
<li>消息丢失</li>
<li>重复消费</li>
</ul>
</li>
</ul>
<h2 id="不同消息中间件对比"><a href="#不同消息中间件对比" class="headerlink" title="不同消息中间件对比"></a>不同消息中间件对比</h2><p>RabbitMQ 基于erlang并发语言实现，性能好，延时最低。社区活跃</p>
<p>kafaka 大数据方面，日志收集，社区活跃。高可用的实现更好，本身是分布式的。用到了选举算法。</p>
<p>RocketMQ 阿里出品，已捐献给apache,社区不够活跃</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>介绍：基于erlang语言开发，延时低，并发性能高。</p>
<p>架构：</p>
<p>工作模式：7种。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p>一个生产者，一个交换机，多个队列，多个消费者</p>
<p>交换机类型 topic</p>
<p>生产者发送消息指定 路由 key.</p>
<p>队列绑定交换机，指定路由key，路由key 可以是通配符。</p>
<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h5><h5 id="消费者限流（削峰填谷）"><a href="#消费者限流（削峰填谷）" class="headerlink" title="消费者限流（削峰填谷）"></a>消费者限流（削峰填谷）</h5><h5 id="TTL（过期时间）"><a href="#TTL（过期时间）" class="headerlink" title="TTL（过期时间）"></a>TTL（过期时间）</h5><h5 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h5><h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><h5 id="消息追踪（rabbitmq-tracing）"><a href="#消息追踪（rabbitmq-tracing）" class="headerlink" title="消息追踪（rabbitmq_tracing）"></a>消息追踪（rabbitmq_tracing）</h5><h5 id="消息一致性解决"><a href="#消息一致性解决" class="headerlink" title="消息一致性解决"></a>消息一致性解决</h5><h5 id="幂等性解决"><a href="#幂等性解决" class="headerlink" title="幂等性解决"></a>幂等性解决</h5><h3 id="RabbitMQ高可用"><a href="#RabbitMQ高可用" class="headerlink" title="RabbitMQ高可用"></a>RabbitMQ高可用</h3><p>为了解决引入RabbitMQ带来的系统可用性降低。</p>
<p>解决方法：镜像集群模式。</p>
<h4 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h4><p><strong>介绍</strong>：将创建的queue的元数据（queue配置信息）和queue里的消息存储到多个实例上。</p>
<p><strong>如何使用镜像集群模式</strong>：</p>
<p>​        在RabbitMQ的管理控制台，就是在后台新增一个<strong>镜像集群模式</strong>策略，指定数据同步的节点。</p>
<p><strong>镜像集群模式缺点</strong>：性能开销大</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务</title>
    <url>/2020/07/29/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>MySQL中的InnoDB引擎实现了事务。</p>
<span id="more"></span>

<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>原子性：由undo log保证</p>
<p>隔离性：</p>
<p>一致性：由redo log保证</p>
<p>持久性：有redo log保证</p>
<h2 id="InnoDB架构"><a href="#InnoDB架构" class="headerlink" title="InnoDB架构"></a>InnoDB架构</h2><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/aV1sTqgQmh5Eowr.png" alt="image-20200728072518535"></p>
<h4 id="BufferPool-缓冲池"><a href="#BufferPool-缓冲池" class="headerlink" title="BufferPool 缓冲池"></a>BufferPool 缓冲池</h4><p>数据页</p>
<p>脏页</p>
<p>insert buffer 插入缓冲（插入比较复杂）</p>
<p>lock info 锁信息</p>
<p>data dictionary 表定义信息</p>
<p>undo log（数据的历史记录）</p>
<h4 id="Redo-log-Buffer"><a href="#Redo-log-Buffer" class="headerlink" title="Redo log Buffer"></a>Redo log Buffer</h4><h4 id="redo-log-的落盘机制"><a href="#redo-log-的落盘机制" class="headerlink" title="redo log 的落盘机制"></a>redo log 的落盘机制</h4><p>buffer pool</p>
<p>redo log buffer</p>
<p>OS Buffer（文件系统缓存）：存储应用程序命令的缓存，这是属于操作系统的。调用fsync可以将文件系统缓存写入到磁盘。</p>
<p>ib_logfiles（磁盘）：操作系统才能操作磁盘。</p>
<ol>
<li><p>默认落盘机制：</p>
<p>innodb_flflush_log_at_trx_commit =2</p>
<p>commit;// 记录到redo log buffer 并经过OSBuffer调用一次fsync写入到redo log file(磁盘)</p>
</li>
<li><p>innodb_flflush_log_at_trx_commit =0时：</p>
<p>commit;// 记录到 redo log buffer，隔固定时间，刷新到redo log file（磁盘）</p>
</li>
<li><p>innodb_flflush_log_at_trx_commit =1时：</p>
<p>commitj;//记录到 redo log buffer,并写入到 OS Buffer，操作系统隔固定时间刷新到磁盘。</p>
<p>这一级别下，操作系统不崩溃，数据也不会丢失。</p>
</li>
</ol>
<h4 id="buffer-pool-落盘机制"><a href="#buffer-pool-落盘机制" class="headerlink" title="buffer pool 落盘机制"></a>buffer pool 落盘机制</h4><h5 id="Double-write双写"><a href="#Double-write双写" class="headerlink" title="Double write双写"></a>Double write双写</h5><p>带给InnoDB存储引擎的是数据页的可靠性</p>
<p>Double write由两部分组成，一部分是内存中的double write buffer,大小为2MB，另一部分是物理磁盘上共享表空间连续的128个页，大小也是2MB。对缓冲池的脏页刷新时，通过memcpy函数将脏页先复制到内存中的double write buffer区域，之后通过double write buffer再分两次，每次1MB写入（系统）共享表空间的物理磁盘上，然后调用fsync函数，同步磁盘。完成double write页的写入后，再将double write buffer中的页写入各个表空间文件中。如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB可以从共享表空间中的double write 中找到该页的副本，将其复制到表空间文件中。</p>
<p>系统表空间和用户表空间各存一份。</p>
<h5 id="CheckPoint检查点"><a href="#CheckPoint检查点" class="headerlink" title="CheckPoint检查点"></a>CheckPoint检查点</h5><p>将脏页写入到磁盘的时机。</p>
<p>目的：</p>
<ul>
<li>缩短数据库的恢复时间</li>
<li>buffer pool 空间不够用时，将脏页刷新到磁盘</li>
<li>redo log不够用时，刷新脏页</li>
</ul>
<p>检查点分类</p>
<ul>
<li><p>sharp checkpoint：完全检查点，数据库正常关闭时，会触发把所有的脏页都写入到磁盘上</p>
</li>
<li><p>fuzzy checkpoint:正常使用时，模糊检查点，部分页写入磁盘。</p>
<ul>
<li><p>maste thread checkpoint</p>
<p>每秒或每10秒的速度从缓冲池的脏页列表中刷新一定比例的页到磁盘，异步。</p>
</li>
<li><p>flush_lru_list checkpoint</p>
<p>读取lru (Least Recently Used) list，找到脏页，写入磁盘。 最近最少使用</p>
</li>
<li><p>async/sync flush checkpoint</p>
<p>redo log fifile快满了，会批量的触发数据页回写，这个事件触发的时候又分为异步和同步，不可被覆盖的redolog占log file的比值：75%—&gt;异步、90%—&gt;同步。</p>
</li>
<li><p>dirty page too mush checkpoint</p>
<p>默认是脏页占比75%的时候，就会触发刷盘，将脏页写入磁盘</p>
</li>
</ul>
</li>
</ul>
<h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><h4 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h4><p>系统表空间（共享表空间）</p>
<ul>
<li>数据字典（data dictionary):记录数据库相关信息</li>
<li>double writer</li>
<li>insert buffer:内存insert buffer 数据，周期写入共享表空间</li>
<li>回滚段（rollback segments)</li>
<li>undo 空间：undo 页</li>
</ul>
<p>用户表空间（独立表空间）</p>
<ul>
<li>每个表的数据和索引都存在自己的表空间中</li>
<li>每个表的结构</li>
<li>undo 空间：undo 页</li>
<li>double write</li>
</ul>
<h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><p>​    两个重做日志文件，大小一致，循环写入。顺序IO循环存储，保证了数据存储的速度和持久性。（每一条SQL致使数据库的改变都真正存储到了磁盘，顺序IO又保证存数据的速度。）</p>
<p>两个redo log file文件。默认10M大小。（不需要很大，只要保证能存储数据库崩溃，buffer pool中没有写入得到磁盘的脏页、undo log写入到磁盘的redo log file即可。）</p>
<p>存储内容：</p>
<ul>
<li>执行SQL后表的记录（脏页的信息）</li>
<li>执行SQL前表的的记录（undo log页的信息)</li>
<li>索引页的信息</li>
</ul>
<h3 id="数据库事务，sql执行经过-undo和redo-的流程"><a href="#数据库事务，sql执行经过-undo和redo-的流程" class="headerlink" title="数据库事务，sql执行经过  undo和redo  的流程"></a>数据库事务，sql执行经过  undo和redo  的流程</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zxQ1Ppv59iWeyRC.png" alt="sql执行经过undo和redo的流程"></p>
<h2 id="事务并发问题："><a href="#事务并发问题：" class="headerlink" title="事务并发问题："></a>事务并发问题：</h2><h3 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h3><p>事务A读取到了事务B为提交的数据，事务B进行了回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">begin;</span><br><span class="line">update user set username = &quot;li&quot; where id =1;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">begin;</span><br><span class="line">select * from user where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	li	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">select * from user where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>



<h3 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h3><p>事务A因事务B修改了数据导致事务A两次读取的数据不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">begin;</span><br><span class="line">select * from user where id =1;</span><br><span class="line">#暂停</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">update user set username = &quot;li&quot; where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A：继续</span><br><span class="line">select * from user where id =1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	li	2019-11-28	男	北京</span><br></pre></td></tr></table></figure>

<h3 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h3><p>事务A因事务B插入了新的数据导致事务A两次读取的数据不一致（插入或删除）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A:</span><br><span class="line">begin;</span><br><span class="line">select * from user;</span><br><span class="line">#暂停</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务B:</span><br><span class="line">insert INTO `user` VALUES(4,&#x27;han&#x27;,2019-11-28,&#x27;nan&#x27;,&#x27;bei&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务A：继续</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	li	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	han	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<h2 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h2><p>RU读未提交（read-uncommitted）：事务A可读到事务B未提交的数据。</p>
<p>RC读已提交（read-committed）：事务A可读到事务B已提交的数据。</p>
<p>RR可重复读（repeatable-read）:事务B不会对A造成影响。</p>
<p>串行化（serializable）</p>
<h2 id="MySQL事务隔离级别与事务并发问题"><a href="#MySQL事务隔离级别与事务并发问题" class="headerlink" title="MySQL事务隔离级别与事务并发问题"></a>MySQL事务隔离级别与事务并发问题</h2><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>mysql的RR隔离级使用MVCC机制解决了不可重复读，使用间隙锁解决了幻读的发生。</p>
<p>RR不严格，纯select走readview，update不走readview。会引发一些问题。</p>
<h2 id="mysql的MVCC机制"><a href="#mysql的MVCC机制" class="headerlink" title="mysql的MVCC机制"></a>mysql的MVCC机制</h2><p>作用：未加读锁实现了事务并发时可重复读。</p>
<p>MVCC依赖undo log，ReadView和版本号。</p>
<p>每个事务都有自己的事务id，id使用当前的系统版本号，每有新的事务，系统版本号+1</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>聚簇索引记录中有三个隐藏列：row_id、trx_id、roll_pointer</p>
<ul>
<li>trx_id： 存储每次对某条聚簇索引记录进行修改的时候的事务id。</li>
<li>roll_pointer： 每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向undo log的老版本地址。</li>
</ul>
<p>undo log 的删除是由 purge Thead操作的</p>
<h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct read_view_t&#123;</span><br><span class="line">	ulint	type;</span><br><span class="line">	undo_no_t	undo_no;</span><br><span class="line">	trx_id_t	low_limit_no;</span><br><span class="line">	trx_id_t	low_limit_id;	// 高水位，大于此事务id的记录都不可见。</span><br><span class="line">	trx_id_t	up_limit_id;	// 低水位，小于此事务id的记录可见。</span><br><span class="line">	ulint	n_trx_ids;			// 活跃事务数量</span><br><span class="line">	trx_id_t*	trx_ids;		// 以逆序排列的当前获取活跃事务id的数组</span><br><span class="line">	trx_id_t	creator_trx_id;	// 创建当前视图的事务id</span><br><span class="line">	UT_LIST_NODE_T(read_view_t)	view_list;	// 事务系统中的一致性视图链表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>trx_id_t*    trx_ids; </p>
<ul>
<li>记录系统活跃事务的id数组。</li>
<li>除去本身事务的id，除去内存中commit的id</li>
<li>直到事务中的 select 不加锁语句执行时创建。update、delete不会创建。 </li>
</ul>
</li>
<li><p>trx_id_t    low_limit_id;</p>
<ul>
<li>因id倒数排列，代表活跃事务中最高版本的事务id</li>
<li>其他事务找到的行记录的trx_id &gt; low_limit_id时，找到的行记录不可见，去undo log中找老版本。</li>
</ul>
</li>
<li><p>trx_id_t    up_limit_id;</p>
<ul>
<li>因id倒数排列，代表活跃事务中最低版本的事务id</li>
<li>其他事务找到的行记录的trx_id &lt; up_limit_id时，找到的行记录可见，返回此行记录。</li>
</ul>
</li>
</ul>
<h4 id="判断行记录是否可见"><a href="#判断行记录是否可见" class="headerlink" title="判断行记录是否可见"></a>判断行记录是否可见</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*********************************************************************//**</span><br><span class="line">Checks if a read view sees the specified transaction.</span><br><span class="line">@return	true if sees */</span><br><span class="line">UNIV_INLINE</span><br><span class="line">bool</span><br><span class="line">read_view_sees_trx_id(</span><br><span class="line">	const read_view_t*	view,	/*!&lt; in: read view */</span><br><span class="line">	trx_id_t		trx_id)	/*!&lt; in: trx id */</span><br><span class="line">&#123;</span><br><span class="line">	if (trx_id &lt; view-&gt;up_limit_id) &#123;/*行记录的事务trx_id &lt; 活跃事务的*/</span><br><span class="line">		return(true);</span><br><span class="line">	&#125; else if (trx_id &gt;= view-&gt;low_limit_id) &#123;</span><br><span class="line">		return(false);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ulint	lower = 0;</span><br><span class="line">		ulint	upper = view-&gt;n_trx_ids - 1;</span><br><span class="line"></span><br><span class="line">		ut_a(view-&gt;n_trx_ids &gt; 0);</span><br><span class="line"></span><br><span class="line">		do &#123;</span><br><span class="line">			ulint		mid	= (lower + upper) &gt;&gt; 1;</span><br><span class="line">			trx_id_t	mid_id	= view-&gt;trx_ids[mid];</span><br><span class="line"></span><br><span class="line">			if (mid_id == trx_id) &#123;</span><br><span class="line">				return(FALSE);</span><br><span class="line">			&#125; else if (mid_id &lt; trx_id) &#123;</span><br><span class="line">				if (mid &gt; 0) &#123;</span><br><span class="line">					upper = mid - 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				lower = mid + 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (lower &lt;= upper);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*行记录的事务trx_id &lt; 活跃事务链表中的最小事务id，此条记录可被当前事务读取。*/</span><br><span class="line">if (trx_id &lt; view-&gt;up_limit_id) &#123;</span><br><span class="line">		return(true);</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*行记录的事务trx_id &gt;= 活跃事务链表中的最大事务id，此条记录不可被当前事务读取。*/</span><br><span class="line">else if (trx_id &gt;= view-&gt;low_limit_id) &#123;</span><br><span class="line">		return(false);</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#空表user,有id、name两列</span><br><span class="line">#例如：事务A，trx_id = 10</span><br><span class="line">begin;</span><br><span class="line">select * from user;//无数据</span><br><span class="line"></span><br><span class="line">#事务B，trx_id = 11</span><br><span class="line">insert into user values(1,1);</span><br><span class="line"></span><br><span class="line">#事务A</span><br><span class="line">select * from user;//无数据</span><br><span class="line"></span><br><span class="line">#解释：</span><br><span class="line">#找到了数据 id = 1,name = 1, trx_id = 11。</span><br><span class="line">#但是事务A (trx_id =10 &lt; trx_id = 11),所以此数据没有返回</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*二分查找算法，如果行记录的事务trx_id == 活跃事务链表的id，此条记录不可被当前事务读取。否则，可被读取。*/</span><br><span class="line">else &#123;</span><br><span class="line">		ulint	lower = 0;</span><br><span class="line">		ulint	upper = view-&gt;n_trx_ids - 1;</span><br><span class="line"></span><br><span class="line">		ut_a(view-&gt;n_trx_ids &gt; 0);</span><br><span class="line"></span><br><span class="line">		do &#123;</span><br><span class="line">			ulint		mid	= (lower + upper) &gt;&gt; 1;</span><br><span class="line">			trx_id_t	mid_id	= view-&gt;trx_ids[mid];</span><br><span class="line"></span><br><span class="line">			if (mid_id == trx_id) &#123;</span><br><span class="line">				return(FALSE);</span><br><span class="line">			&#125; else if (mid_id &lt; trx_id) &#123;</span><br><span class="line">				if (mid &gt; 0) &#123;</span><br><span class="line">					upper = mid - 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				lower = mid + 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (lower &lt;= upper);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong></p>
<p>原数据</p>
<table>
<thead>
<tr>
<th>trx_id</th>
<th>roll_pointer</th>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>undo中上一个版本的地址 0x001</td>
<td>1</td>
<td>zs</td>
</tr>
<tr>
<td>3</td>
<td>undo中上一个版本的地址 0x002</td>
<td>5</td>
<td>zs</td>
</tr>
<tr>
<td>13</td>
<td>undo中上一个版本的地址 0x003</td>
<td>10</td>
<td>13</td>
</tr>
</tbody></table>
<p>undo log的数据</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>trx_id</th>
<th>roll_pointer</th>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>0x001</td>
<td>2</td>
<td>undo中再上一个版本的地址 0x***</td>
<td>1</td>
<td>zs</td>
</tr>
<tr>
<td>0x002</td>
<td>1</td>
<td>undo中再上一个版本的地址 0x***</td>
<td>5</td>
<td>zs</td>
</tr>
<tr>
<td>0x003</td>
<td>3</td>
<td>undo中再上一个版本的地址 0x***</td>
<td>10</td>
<td>zs</td>
</tr>
</tbody></table>
<p>有trx_id 为6、7、8、9、10、11、12七个事务，7和11在内存中准备提交，当前事务为9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务的trx_id为9 执行</span><br><span class="line">begin;</span><br><span class="line">update role set name = &#x27;www&#x27; where id = 5;// 无关的sql</span><br><span class="line">select * from user; // 普通select执行时创建readview</span><br></pre></td></tr></table></figure>

<p>readview的部分数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trx_ids[12,10,8,6]</span><br><span class="line">low_limit_id = 12</span><br><span class="line">up_limit_id =6</span><br></pre></td></tr></table></figure>

<p>查出来的数据：</p>
<table>
<thead>
<tr>
<th>trx_id</th>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>1</td>
<td>zs</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>zs</td>
</tr>
<tr>
<td>3</td>
<td>10</td>
<td>zs</td>
</tr>
</tbody></table>
<p>第三条数据：因为 行记录(trx_id = 13) &gt; review-&gt;low_limit_id,此条行记录对事务9不可见，去undo log中找到行记录trx_id = 3 的记录返回。</p>
<h3 id="不同隔离级如何创建readview"><a href="#不同隔离级如何创建readview" class="headerlink" title="不同隔离级如何创建readview"></a>不同隔离级如何创建readview</h3><h5 id="RC隔离级"><a href="#RC隔离级" class="headerlink" title="RC隔离级"></a>RC隔离级</h5><p>RC隔离级别下，在每个语句开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(read<br>view)  </p>
<p>每个语句开始，拷贝新的readview，已提交的事务就不在列表中了。</p>
<p><strong>这么一个问题：</strong>RC隔离级下使用了MVCC机制，trx_id=5的事务A不应该读到trx_id=10的事务B提交的数据。因为事务B提交后的行记录(trx_id =10) &gt; view-&gt;low_limit_id(高水位)</p>
<p>解释：每个语句开始的时候拷贝新的readview，readview包括本事务的id，拷贝新的readview就会更新本事务的id，这样本事务的id = 5变为了id = 11，这样就可以看到事务B提交的 id = 10 的记录了。</p>
<h5 id="RR隔离级"><a href="#RR隔离级" class="headerlink" title="RR隔离级"></a>RR隔离级</h5><p>RR隔离级别下，在每个事务开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(readview)  ，直到事务结束，不会更新readview。不会看到readview事务链表中提交的事务数据。</p>
<h5 id="设置隔离级别："><a href="#设置隔离级别：" class="headerlink" title="设置隔离级别："></a>设置隔离级别：</h5><p>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</p>
<p>当前会话隔离级读已提交：</p>
<p>set session transaction isolation level read COMMITTED;  </p>
<h4 id="RR不严格的问题："><a href="#RR不严格的问题：" class="headerlink" title="RR不严格的问题："></a>RR不严格的问题：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session1</span><br><span class="line">begin;</span><br><span class="line">select * from user;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	123	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	hxr234	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session2</span><br><span class="line">insert into user values(5,&#x27;zala&#x27;,0000-00-00,&#x27;nan&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">#session1</span><br><span class="line">update user set username = &#x27;123&#x27; where id &gt; 1;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	123	0000-00-00	nan	bei</span><br><span class="line">4	123	0000-00-00	nan	bei</span><br><span class="line">5	123	0000-00-00	nan	beijing</span><br></pre></td></tr></table></figure>

<p>update 不走readview视图使第二次select查到了别的事务insert的数据。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-事务复习</title>
    <url>/2020/11/17/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E4%BA%8B%E5%8A%A1%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>Mysql-行列转换</p>
<span id="more"></span>

<h1 id="Mysql-事务复习"><a href="#Mysql-事务复习" class="headerlink" title="Mysql-事务复习"></a>Mysql-事务复习</h1><p>四大特性：原子性，一致性，持久性，隔离性。</p>
<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p>单个事务如何保证事务特性？关键点：1.事务回滚，2.事务结束提交。</p>
<ul>
<li><p>事务回滚通过undo log保证，undo log 记录了事务修改前的日志数据。</p>
</li>
<li><p>事务提交通过redo log file保证，事务 commit后，数据会持久化到redo log file（磁盘）中。 redo log file 快满时，持久化undo log中的数据，清空redo log file。</p>
</li>
</ul>
<p>具体的执行情况：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zxQ1Ppv59iWeyRC.png" alt="img"></p>
<p><strong>redo log file：</strong> 是顺序循环存储的日志文件，不像undo log是存储有关联关系的数据。redo log file 达到75%时，异步持久化undo log，redo log file达到90%时，使用同步操作持久化undo log。</p>
<h3 id="单个事务"><a href="#单个事务" class="headerlink" title="单个事务"></a>单个事务</h3><p>mysql中用undo log 和redo log file解决持久性问题。</p>
<p>事务进行一半系统崩溃，重启后如何保证事务的特性？</p>
<h3 id="事务并发"><a href="#事务并发" class="headerlink" title="事务并发"></a>事务并发</h3><p>多个事务之间产生什么样的影响？</p>
<p>不同的隔离级别下影响不同。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）RU</td>
<td>是</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>不可重复读（read-committed）RC</td>
<td>否</td>
<td>是</td>
<td align="center">是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）RR</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h4 id="mysql-mvcc"><a href="#mysql-mvcc" class="headerlink" title="mysql-mvcc"></a>mysql-mvcc</h4><p><strong>解决了什么</strong>：</p>
<p>​    mysql中RR隔离级别实现了，单事务内重复读一条数据，结果不变。</p>
<p>​    mysql中RC隔离级实现了，单事务内不会读取其他事务未提交的数据。</p>
<h4 id="SQL实例"><a href="#SQL实例" class="headerlink" title="SQL实例"></a>SQL实例</h4><p>RR隔离级SQL实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># session1</span><br><span class="line">begin;</span><br><span class="line">select * from tb_user where user_id = 1;</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	nie16226	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br><span class="line"></span><br><span class="line"># session2</span><br><span class="line">begin;</span><br><span class="line">update tb_user set pass_word = 123 where user_id = 1;</span><br><span class="line"></span><br><span class="line"># session1</span><br><span class="line">select * from tb_user where user_id = 1;#单个事务内查询结果不变</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	nie16226	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br><span class="line"></span><br><span class="line"># session2</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># session1</span><br><span class="line">select * from tb_user where user_id = 1;#单个事务内查询结果不变</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	nie16226	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br></pre></td></tr></table></figure>

<p>如何保证可重复读：开始事务时拷贝readview。</p>
<p>RC隔离级SQL实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置当前会话隔离级别为 读已提交</span><br><span class="line">set session transaction isolation level read COMMITTED; </span><br></pre></td></tr></table></figure>

<p>RU 隔离级SQL实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># session1</span><br><span class="line">set session transaction isolation level READ UNCOMMITTED;# 设置当前会话隔离级别为 读未提交</span><br><span class="line">begin;</span><br><span class="line">update tb_user set pass_word = 12345 where user_id = 1;</span><br><span class="line"></span><br><span class="line"># session2</span><br><span class="line">set session transaction isolation level READ UNCOMMITTED;</span><br><span class="line">begin;</span><br><span class="line">select * from tb_user where user_id = 1;#读取到session未提交的数据</span><br><span class="line"></span><br><span class="line">user_id	user_name	pass_word	create_time	last_edit_time	enable_status</span><br><span class="line">1	135**752195	12345	2018-07-02 22:39:50	2018-07-02 22:39:50	1</span><br></pre></td></tr></table></figure>

<h4 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h4><p><strong>三个关键点</strong>：undo log，ReadView，版本号。</p>
<p>事务流程（涉及undo log 和版本号）：每个事务以系统版本号为事务id，修改记录行时将事务id记录到隐藏列trx_id.隐藏列roll_pointer指向未修改的记录行。事务开始时copy  read_view。</p>
<p>read_view记录当前进行中的事务id， 事务id大的可以看到事务id小的记录。</p>
<h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>聚簇索引记录中了隐藏列trx_id、roll_pointer</p>
<h5 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h5><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><ul>
<li>结构：</li>
</ul>
<ul>
<li><p>判断可见性</p>
<ul>
<li>行记录事务id &gt; readview 最大事务id     <strong>不可见</strong>，通过回滚指针找上一个记录</li>
<li>行记录事务id &lt; readview 最小事务id     <strong>可见</strong></li>
<li>行记录事务id = readview 事务数组中id <strong>不可见</strong></li>
<li>行记录事务id &gt; readview 最小事务id &lt; readview  最大事务id != 事务数组中的id    <strong>可见</strong></li>
</ul>
</li>
<li><p>readview建立时机：</p>
<ul>
<li>RR 事务开始时建立。第二次执行select不会重新拷贝readview，事务B提交事务后，事务B的事务id仍存在于事务A的readview中。事务A不会读取到事务B提交的数据。</li>
<li>RC在事务中的每一条SQL语句执行时建立。其他事务未提交时，事务id存在于readview的事务数组中，不可见。</li>
</ul>
</li>
</ul>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p><strong>什么是幻读？</strong>因为事务B在事务A多次查询中间插入了数据，事务A读取结果不一致。</p>
<p><strong>RR隔离级是否解决了幻读？</strong> 解决了。</p>
<p><strong>如何解决的？</strong>MVCC+next key</p>
<p><strong>RR下的幻读：</strong></p>
<p>事务A update 全表后，查询到事务B insert的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session1</span><br><span class="line">begin;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	123	2019-11-28	男	北京</span><br><span class="line">3	han	0000-00-00	nan	bei</span><br><span class="line">4	hxr234	0000-00-00	nan	bei</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session2</span><br><span class="line">insert into user values(5,&#x27;zala&#x27;,0000-00-00,&#x27;nan&#x27;,&#x27;beijing&#x27;);</span><br><span class="line">#session1</span><br><span class="line">update user set username = &#x27;123&#x27; where id &gt; 1;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	username	birthday	sex	address</span><br><span class="line">1	zs	2019-11-28	男	北京</span><br><span class="line">3	123	0000-00-00	nan	bei</span><br><span class="line">4	123	0000-00-00	nan	bei</span><br><span class="line">5	123	0000-00-00	nan	beijing</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>RR为什么单事务读取数据一致？事务开始时拷贝readview。不再更新readview。</p>
<p>RC为什么出现重复读一条数据结果不一致？每一条语句执行时，拷贝readview。</p>
<p>RU为什么不会读取其他事务未提交的数据？其他事务id存在于readview中。select语句执行时 拷贝readview看到了其他事务的id。</p>
<p>RC可处理并发量大于RR？RR增加了间隙锁。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-基础+架构</title>
    <url>/2020/07/18/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E5%9F%BA%E7%A1%80+%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>mysql介绍；SQL的解析顺序；mysql架构，包括逻辑架构、物理结构</p>
<span id="more"></span>

<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="Mysql语言"><a href="#Mysql语言" class="headerlink" title="Mysql语言"></a>Mysql语言</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>数据库定义语言</p>
<p>creat database;</p>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>数据库操作语言</p>
<p>insert</p>
<p>update</p>
<p>delete</p>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>数据库查询语言</p>
<p>select</p>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>数据库控制语言</p>
<p>权限控制</p>
<h2 id="MySQL解析顺序"><a href="#MySQL解析顺序" class="headerlink" title="MySQL解析顺序"></a>MySQL解析顺序</h2><h3 id="写的顺序"><a href="#写的顺序" class="headerlink" title="写的顺序"></a>写的顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct</span><br><span class="line">	&lt; select_list&gt;</span><br><span class="line">from</span><br><span class="line">join 	 on</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h3 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a>解析顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 表</span><br><span class="line">from</span><br><span class="line"># 行过滤</span><br><span class="line">on</span><br><span class="line">join</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line"># 列过滤</span><br><span class="line">select</span><br><span class="line">distinct</span><br><span class="line"># 排序</span><br><span class="line">order by</span><br><span class="line"># 标准SQL之外</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><h4 id="逻辑架构图"><a href="#逻辑架构图" class="headerlink" title="逻辑架构图"></a>逻辑架构图</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/z4kJu5tmrUYOqLZ.jpg" alt="jiagou"></p>
<h4 id="简单执行流程"><a href="#简单执行流程" class="headerlink" title="简单执行流程"></a>简单执行流程</h4><p>​        连接器</p>
<p>查询缓存 分析器</p>
<p>​                优化器</p>
<p>​                执行器</p>
<p>​                存储引擎</p>
<h4 id="详细执行流程"><a href="#详细执行流程" class="headerlink" title="详细执行流程"></a>详细执行流程</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OTtLRi4J6ZAmUdf.jpg" alt="img"></p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ul>
<li><p>mysql通过文件系统对数据和索引进行存储。</p>
</li>
<li><p>物理结构上分为日志文件和数据索引文件。</p>
</li>
<li><p>日志文件使用顺序 I/O 存储，数据文件使用随机 I/O 存储。</p>
</li>
</ul>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p>错误日志</p>
<p>二进制日志：数据备份、恢复、主从使用，生产中开启</p>
<p>通用查询日志：记录所有东西，影响性能。</p>
<p>慢查询日志：SQL优化时使用，配置检测SQL执行时间，过滤并记录SQL。</p>
<p>重做日志</p>
<p>回滚日志</p>
<p>中继日志：主从使用</p>
<h4 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h4><h5 id="InnoDB数据文件"><a href="#InnoDB数据文件" class="headerlink" title="InnoDB数据文件"></a>InnoDB数据文件</h5><p>.frm 与表相关的信息，主要包括表结构定义信息</p>
<p>.ibd  使用独享表空间存储 数据+索引。一张表对应一个ibd文件。</p>
<p>ibdata 使用共享表空间存储 数据+索引。所有表共用一个或多个ibdata文件。</p>
<h5 id="MyISAM数据文件"><a href="#MyISAM数据文件" class="headerlink" title="MyISAM数据文件"></a>MyISAM数据文件</h5><p>.fmi 与表相关的信息，主要包括表结构定义信息</p>
<p>.myd 存储表数据信息</p>
<p>.myi 存储表数据文件的索引</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Mysql</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-索引</title>
    <url>/2020/07/24/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引原理</p>
<span id="more"></span>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><h2 id="索引优劣势"><a href="#索引优劣势" class="headerlink" title="索引优劣势"></a>索引优劣势</h2><p>优点：提高查询速度，以索引为条件。索引有序，可以用查找算法快速找到。否则只能遍历。</p>
<p>缺点：额外占存储空间，影响更新表效率。增删操作不应更新数据，还会更新索引。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>主键索引：主键自带</p>
<p>单列索引：普通索引，唯一索引，全文索引（鸡肋，对文本的索引。ES的效率更好）</p>
<p>组合索引：组合多个列</p>
<p>空间索引</p>
<p>位图索引：Oracle</p>
<h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>普通索引:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table(column(length)) ; </span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column(length)) ;</span><br></pre></td></tr></table></figure>

<p>唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table(column(length)) ; </span><br><span class="line">alter table table_name add unique index index_name(column);</span><br></pre></td></tr></table></figure>

<p>组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10)) ;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name ON table</span><br></pre></td></tr></table></figure>

<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM table_name</span><br></pre></td></tr></table></figure>



<p><strong>例子：</strong></p>
<p>show index from table_name</p>
<p>空间复杂度：O(1)</p>
<p>排序方式：In-place （占用常数内存，不占用额外内存）</p>
<p>稳定性：稳定</p>
<p><strong>Implementation</strong>:Primary</p>
<p>主键索引Primary  索引方式</p>
<table>
<thead>
<tr>
<th></th>
<th>Non_unique</th>
<th>key_name</th>
<th>seq_in_index</th>
<th>coulmn_name</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>0</td>
<td>primary</td>
<td>1</td>
<td>id</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>唯一索引</td>
<td>0</td>
<td>ids_loginname</td>
<td>1</td>
<td>loginname</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>组合索引</td>
<td>1</td>
<td>ids_age_sex_name</td>
<td>1</td>
<td>age</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>组合索引</td>
<td>1</td>
<td>ids_age_sex_name</td>
<td>2</td>
<td>sex</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>组合索引</td>
<td>1</td>
<td>ids_age_sex_name</td>
<td>3</td>
<td>name</td>
<td>btree（B+tree）</td>
</tr>
<tr>
<td>普通索引</td>
<td>1</td>
<td>ids_dep</td>
<td>1</td>
<td>dep</td>
<td>btree（B+tree）</td>
</tr>
</tbody></table>
<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><h3 id="索引使用的数据结构"><a href="#索引使用的数据结构" class="headerlink" title="索引使用的数据结构"></a>索引使用的数据结构</h3><p> 数据量：三层20G，四层几十T</p>
<p>  树演示网址：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>特点：</p>
<ul>
<li>所有数据存储在叶子节点。</li>
<li>叶子节点排成了一个链表</li>
<li>叶子节点的链表顺序取出可得到有序的数据</li>
</ul>
<h4 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h4><p>特点 ：</p>
<ul>
<li>数据存储在叶子节点和非叶子节点上。</li>
<li>无链表结构</li>
</ul>
<h3 id="索引树："><a href="#索引树：" class="headerlink" title="索引树："></a>索引树：</h3><p>每建立一个索引会建立一颗索引树</p>
<h3 id="非聚集索引-MyISAM"><a href="#非聚集索引-MyISAM" class="headerlink" title="非聚集索引-MyISAM"></a>非聚集索引-MyISAM</h3><p>主键索引：存储主键和指向数据的地址。</p>
<p>辅助索引：存储辅助索引值和指向数据的地址。</p>
<h3 id="聚集索引-InnoDB"><a href="#聚集索引-InnoDB" class="headerlink" title="聚集索引-InnoDB"></a>聚集索引-InnoDB</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>存储主键值和数据</p>
<p>索引是排序后建立的。主键的创建最好用自增整数。不要用大字符串比如 uuid —- 》 雪花算法 snowflflakes</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>存储索引值和主键值</p>
<h5 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h5><p>存储组合索引中的各个值和主键值</p>
<p>组合索引优点：一定程度上避免回表。回表：组合索引树没有要查询的列数据，根据组合索引树的主键回到主键索引树查找数据。</p>
<h2 id="索引使用场景"><a href="#索引使用场景" class="headerlink" title="索引使用场景"></a>索引使用场景</h2><p>什么情况建立索引</p>
<ul>
<li>主键自动创建主键索引</li>
<li>表数据量大，100万条。</li>
<li>频繁作为查询字段</li>
<li>多表关联查询，on两端都要建立索引</li>
<li>查询中排序的字段创建B+Tree，B+Tree可直接有序取出</li>
<li>覆盖索引，使用组合索引防止回表</li>
<li>统计或分组字段，应该创建索引</li>
</ul>
<p>什么情况没必要建立索引</p>
<ul>
<li><p>表数据量少</p>
</li>
<li><p>频繁更新，索引需要维护</p>
</li>
<li><p>查询字段使用频率低</p>
</li>
</ul>
<h2 id="索引的执行"><a href="#索引的执行" class="headerlink" title="索引的执行"></a>索引的执行</h2><p>数据量少时，返回的数据量超过一半时，不使用索引。数据量多时，返回的数据量超过1/3不使用索引。</p>
<p>组合索引的创建顺序是使用顺序。</p>
<p>最左前缀原则:</p>
<ol>
<li><p>前缀索引</p>
<p>like 常量% 使用索引</p>
<p>like %常量不使用索引</p>
</li>
<li><p>最左前缀</p>
</li>
</ol>
<p>​    按照索引的建立顺序搜索，范围查询（&gt;&lt;between）后的索引失效。</p>
<p>where id =1 and name =”han” and a &gt; 1 and b =1</p>
<h3 id="查看执行-计划"><a href="#查看执行-计划" class="headerlink" title="查看执行 计划"></a>查看执行 计划</h3><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</span><br></pre></td></tr></table></figure>

<p>id:</p>
<ul>
<li>每个 SELECT语句都会自动分配的一个唯一标识符. </li>
<li>id相同：执行顺序由上到下,id不同：如果是子查询，id号会自增，<strong>id越大，优先级越高</strong>。id相同的不同的同时存在</li>
<li>id列为null的就表示这是一个结果集，不需要使用它来进行查询。</li>
</ul>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type:"></a>select_type:</h5><ul>
<li>主要用于区别普通查询、联合查询(union、union all)、子查询等复杂查询。</li>
<li><strong>simple</strong>:表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个</li>
<li><strong>primary</strong>:一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个</li>
<li><strong>subquery</strong>:除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</li>
<li><strong>dependent subquery</strong>:与dependent union类似，表示这个subquery的查询要受到外部表查询的影响</li>
<li><strong>union</strong>:union连接的两个select查询，第一个查询是PRIMARY，除了第一个表外，第二个以后的表select_type都是union</li>
<li><strong>union result</strong>:包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</li>
<li><strong>derived</strong>:from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</li>
</ul>
<p>table:</p>
<ul>
<li>显示的查询表名，如果查询使用了别名，那么这里显示的是别名</li>
<li>如果不涉及对数据表的操作，那么这显示为null</li>
</ul>
<h5 id="type"><a href="#type" class="headerlink" title="type:"></a>type:</h5><h6 id="索引的类型（最好→最坏）："><a href="#索引的类型（最好→最坏）：" class="headerlink" title="索引的类型（最好→最坏）："></a>索引的类型（最好→最坏）：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system，const，eq_ref，ref，fulltext,ref_or_null,unique_subquery,index_subquery,range，index_merge，index，ALL </span><br></pre></td></tr></table></figure>

<p><strong>除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</strong></p>
<p>system：空表,数据只有一行。</p>
<p><strong>const（重要）</strong>：使用主键索引或唯一索引,返回1行记录。</p>
<p><strong>eq_ref（重要）</strong>:连接字段是<strong>主键或者唯一性索引</strong>。</p>
<p><strong>ref（重要）</strong>:<strong>针对非唯一性索引</strong>，使用<strong>等值（=）查询</strong>非主键。或者是使用了<strong>最左前缀规则索引的查询</strong>。</p>
<p>index 列过滤，回表。比如组合索引没命中全部字段，回主键索引树查询数据。</p>
<p>fulltext：全文索引检索。全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql优先选择使用全文索引</p>
<p>unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</p>
<p>index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p>
<p><strong>range（重要）</strong>：<strong>索引范围扫描</strong>，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</p>
<p>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引</p>
<p><strong>index（重要）</strong>：</p>
<ul>
<li><strong>条件出现在索引树中的节点。可能没有完全匹配索引。</strong></li>
<li><strong>索引全表扫描</strong>，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</li>
<li>explain select loginname from tuser; #单索引</li>
<li>explain select age from tuser; #组合索引</li>
</ul>
<p><strong>all（重要）</strong>：是全表扫描数据文件，然后再<strong>在server(layer(解析器、优化器))层进行过滤</strong>返回符合要求的记录。explain select * from tuser; </p>
<p>possible_keys：此次查询中可能选用的索引，一个或多个。</p>
<p>key：查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</p>
<p>key_len：用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，会计算具体使用到了多少个列的索引。</p>
<p>ref：</p>
<ul>
<li>如果是等值查询，这里会显示const</li>
<li>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li>
<li>如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</li>
</ul>
<p>rows：估算的扫描行数，不是精确值（InnoDB不是精确的值，MyISAM是精确的值</p>
<h5 id="extra（重要）："><a href="#extra（重要）：" class="headerlink" title="extra（重要）："></a>extra（重要）：</h5><p>包含不适合在其他列中显示单十分重要的额外的信息，这个列可以显示的信息非常多，有几十</p>
<p>种，常用的有下列几种：</p>
<ul>
<li><strong>using fifilesort（重要）</strong>：    <ul>
<li>排序时无法使用到索引时，就会出现这个。常见于order by和group by语句</li>
<li>MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li>
<li>MySQL中无法利用索引完成的排序操作称为“文件排序“</li>
</ul>
</li>
<li><strong>using index（重要）</strong>：<ul>
<li>查询时<strong>不需要回表查询</strong>，直接通过索引就可以获取查询的数据。</li>
<li>表示相应的SELECT查询中使用到了<strong>覆盖索引</strong></li>
<li>如果同时出现Using Where ，说明索引被用来执行查找索引键值</li>
<li>如果没有同时出现Using Where ，表明索引用来读取数据而非执行查找动作</li>
</ul>
</li>
<li><strong>using where（重要）</strong>：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</li>
<li><strong>using index condition</strong>：5.6.x之后支持<strong>ICP</strong>特性，可以把检查条件（非主键索引）也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。</li>
</ul>
<h2 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h2><p>口诀:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.全值匹配我最爱</span><br><span class="line">2.最佳左前缀法则</span><br><span class="line">3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</span><br><span class="line">4.存储引擎不能使用索引中范围条件右边的列</span><br><span class="line">5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）</span><br><span class="line">6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描(5.6之后主键是特例)</span><br><span class="line">7.is null，is not null 也无法使用索引（有特例）</span><br><span class="line">8.like以通配符开头（%abc..）mysql索引失效会变成全表扫描的操作（有特例）</span><br><span class="line">9.字符串不加单引号索引失效</span><br><span class="line">10.少用or，用它来连接时会索引失效</span><br></pre></td></tr></table></figure>

<p>索引字段上使用 is null 判断时，可使用索引</p>
<p>解决like ‘%字符串%’时，索引失效问题的方法？使用覆盖索引可以解决。 </p>
<p>explain select name , age,sex from tuser where name like ‘%a%’; </p>
<p><strong>2.最佳左前缀法则</strong></p>
<p>组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">带头索引不能死，中间索引不能断</span><br></pre></td></tr></table></figure>

<p>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且不跳过索引中的列。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-行列转换</title>
    <url>/2020/11/17/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>Mysql-行列转换</p>
<span id="more"></span>

<h1 id="Mysql-行列转换"><a href="#Mysql-行列转换" class="headerlink" title="Mysql-行列转换"></a>Mysql-行列转换</h1><h2 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h2><p>9行4列 转 3行5列</p>
<p><strong>原数据：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/t4TOU2ud87EDoaI.png" alt="image-20201117151521097"></p>
<p><strong>转换sql：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用了group by 根据user_id分组，然后用聚合函数行转列</span><br><span class="line">SELECT</span><br><span class="line">	user_id,</span><br><span class="line">	max( CASE course WHEN &#x27;数学&#x27; THEN	fenzhi ELSE	0 END ) &#x27;数学&#x27;,</span><br><span class="line">	max( CASE course WHEN &#x27;语文&#x27; THEN	fenzhi ELSE	0 END ) &#x27;语文&#x27;,</span><br><span class="line">	max( CASE course WHEN &#x27;英语&#x27; THEN	fenzhi ELSE	0 END ) &#x27;英语&#x27;</span><br><span class="line">FROM</span><br><span class="line">	u_score</span><br><span class="line">group BY user_id</span><br></pre></td></tr></table></figure>

<p><strong>转换后：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/GY76UltFiK9kPzA.png" alt="image-20201117152730552"></p>
<h2 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h2><p>列转行 4列3行 转 3列9行</p>
<p> <strong>原数据：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ToIHJPezNWsLl9t.png" alt="image-20201117153039324"></p>
<p><strong>转行SQL：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列转行 4列3行 转 3列9行</span><br><span class="line">SELECT</span><br><span class="line">	id,</span><br><span class="line">	&#x27;数学&#x27; AS course,</span><br><span class="line">	shuxue fenzhi</span><br><span class="line">FROM</span><br><span class="line">	score</span><br><span class="line">UNION ALL</span><br><span class="line">	SELECT</span><br><span class="line">		id,</span><br><span class="line">		&#x27;语文&#x27; AS course,</span><br><span class="line">		yuwen fenzhi</span><br><span class="line">	FROM</span><br><span class="line">		score</span><br><span class="line">	UNION ALL</span><br><span class="line">		SELECT</span><br><span class="line">			id,</span><br><span class="line">			&#x27;英语&#x27; AS course,</span><br><span class="line">			yingyu fenzhi</span><br><span class="line">		FROM</span><br><span class="line">			score;</span><br></pre></td></tr></table></figure>

<p><strong>转换后：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ndya57Fr4iqwZ89.png" alt="image-20201117153159494"></p>
<p><strong>求单人平均成绩大于80：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#单个学生的平均成绩&gt;80</span><br><span class="line">SELECT</span><br><span class="line">	*</span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">		SELECT</span><br><span class="line">			id,</span><br><span class="line">			avg(fenzhi) avg</span><br><span class="line">		FROM</span><br><span class="line">			(</span><br><span class="line">				SELECT</span><br><span class="line">					id,</span><br><span class="line">					&#x27;数学&#x27; AS course,</span><br><span class="line">					shuxue fenzhi</span><br><span class="line">				FROM</span><br><span class="line">					score</span><br><span class="line">				UNION ALL</span><br><span class="line">					SELECT</span><br><span class="line">						id,</span><br><span class="line">						&#x27;语文&#x27; AS course,</span><br><span class="line">						yuwen fenzhi</span><br><span class="line">					FROM</span><br><span class="line">						score</span><br><span class="line">					UNION ALL</span><br><span class="line">						SELECT</span><br><span class="line">							id,</span><br><span class="line">							&#x27;英语&#x27; AS course,</span><br><span class="line">							yingyu fenzhi</span><br><span class="line">						FROM</span><br><span class="line">							score</span><br><span class="line">			) sc</span><br><span class="line">		GROUP BY</span><br><span class="line">			id</span><br><span class="line">	) sc2</span><br><span class="line">WHERE</span><br><span class="line">	sc2.avg &gt; 80</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/UrwRJMESmHZuq8L.png" alt="image-20201117153241128"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-锁</title>
    <url>/2020/07/27/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E9%94%81/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>程序实现。使用版本号或者时间戳。</p>
<p>mysql实现效率并不好，redis实现更好。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>MySQLLayer层</p>
<p>MySQL 实现的表级锁定的争用状态变量：</p>
<p>表锁可查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;table%&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Variable_name				Value</span><br><span class="line">Table_locks_immediate		76</span><br><span class="line">Table_locks_waited			0</span><br><span class="line">Table_open_cache_hits		0</span><br><span class="line">Table_open_cache_misses		0</span><br><span class="line">Table_open_cache_overflows	0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- table_locks_immediate：产生表级锁定的次数(包括意向锁)； </span><br><span class="line">- table_locks_waited：出现表级锁定争用而发生等待的次数；</span><br></pre></td></tr></table></figure>

<ul>
<li>行锁升级为表锁的原因：update语句的条件没有使用索引。update where name = “han”，name没有使用索引。</li>
</ul>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MySQLLayer层</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>用处：显著提高对整个表修改时的性能</p>
<p>意向锁：</p>
<ul>
<li>InnoDB内部使用。</li>
<li>有两种：共享读锁，排他写锁。</li>
<li>意向锁不是真正的锁，只是一个标记。</li>
<li>获得行锁中的共享读锁之前会先获得意向读锁，获得行锁中的排他写锁之前会先获得意向写锁。</li>
</ul>
<p>原理：做整个表的update操作时，不用一行行看有没有行锁中的排他写锁。只需要看一次有没有意向写锁即可。</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB内部，行锁是通过锁住索引上的索引项来实现的。</p>
<h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h4><h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>共享读：lock in share mode</p>
<h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>排它写：</p>
<ul>
<li>手动：for update</li>
<li>自动：DML(insert、update、delete语句),select … for update</li>
<li>行锁升级为表锁的原因：update语句的条件没有使用索引。update where name = “han”，name没有使用索引。</li>
</ul>
<p>可能发生锁等待情况：</p>
<ul>
<li>行锁升级为表锁</li>
<li>update 长事务</li>
</ul>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>mysql默认的RR隔离级别+一些条件产生间隙锁，可防止幻读。RC隔离级别不产生。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
<p>id 主键，name 普通索引</p>
<p>在update gap set  name = 2 where name = 5时，间隙锁锁住相邻数据。</p>
<p>相邻数据：where 条件 name = 5 对应的id =5，相邻数据为id=3和id=7的记录。</p>
<p>​    具体锁住的数据：id=任意 &amp;&amp;name = [3,6]和 name = 7 &amp;&amp; id= [3,7]。</p>
<p>​    name = 7,id&lt;3 || id&gt;7,不锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session1:</span><br><span class="line">begin;</span><br><span class="line">update gap g SET g.name = 2 where g.name = 5; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#session2:</span><br><span class="line">insert into gap values(8,7);#可执行成功。</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>发生的原因：两个(或以上)的Session【加锁的顺序】不一致。</p>
<p>记录锁产生死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session1: begin;--开启事务未提交 --手动加行写锁 id=1 ，使用索引 update mylock set name=&#x27;m&#x27; where id=1; </span><br><span class="line">session2：begin;--开启事务未提交 --手动加行写锁 id=2 ，使用索引 update mylock set name=&#x27;m&#x27; where id=2; </span><br><span class="line">session1: update mylock set name=&#x27;nn&#x27; where id=2; -- 加写锁被阻塞 </span><br><span class="line">session2：update mylock set name=&#x27;nn&#x27; where id=1; -- 加写锁会死锁，不允许操作 </span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>间隙锁产生死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session1：start transaction ; select * from news where number=6 for update--产生间隙锁 </span><br><span class="line">session2：start transaction ; select * from news where number=7 for update--产生间隙锁 </span><br><span class="line">session1：insert into news values(9,7);--阻塞 </span><br><span class="line">session2：insert into news values(9,7); </span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>查看死锁情况：<code>show engine innodb status</code></p>
<p>如何避免死锁：</p>
<ul>
<li>注意程序的逻辑，不要交叉更新。如trx1:更新表A，更新表B，trx2：更新表B，更新表A。</li>
<li>保持事务轻量，占用少的锁资源。</li>
<li>提供运行速度，尽量避免子查询，尽量使用主键</li>
<li>尽快提交事务。</li>
<li>RR隔离级有Gap锁，RC隔离级无Gap锁，RC隔离级更不容易产生死锁。</li>
</ul>
<h2 id="SQL加锁分析"><a href="#SQL加锁分析" class="headerlink" title="SQL加锁分析"></a>SQL加锁分析</h2><p>加锁的条件：</p>
<p>1.系统的隔离级别？</p>
<p>2.where 条件 中的字段是否有索引？</p>
<h3 id="简单SQL"><a href="#简单SQL" class="headerlink" title="简单SQL"></a>简单SQL</h3><h4 id="RC隔离级"><a href="#RC隔离级" class="headerlink" title="RC隔离级"></a>RC隔离级</h4><ul>
<li><p>字段为主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where id = 1;// id = 1的记录加x锁（记录锁）</span><br></pre></td></tr></table></figure></li>
<li><p>唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where username = &#x27;zs&#x27;; //1.在唯一索引树的username=&#x27;zs&#x27;的记录加记录锁；2.通过唯一索引找到主键id = 1,在主键索引树上id=1的记录加记录锁</span><br></pre></td></tr></table></figure></li>
<li><p>普通索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where name = &#x27;张三&#x27;; //1.在普通索引树的name = &#x27;张三&#x27;的记录加记录锁（可能多条）；2.通过普通索引找到主键id = 10 和id =11,在主键索引树上id=10 和 id =11的记录加记录锁</span><br></pre></td></tr></table></figure></li>
<li><p>无索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where age = 80; //锁表 可查询</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RR隔离级"><a href="#RR隔离级" class="headerlink" title="RR隔离级"></a>RR隔离级</h4><ul>
<li><p>字段为主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from user where id = 3; // x锁+Gap锁（Next key Lock算法） 间隙锁</span><br></pre></td></tr></table></figure></li>
<li><p>唯一索引 唯一索引树X锁+Gap锁，主键索引树X锁+Gap锁</p>
</li>
<li><p>普通索引 普通索引树匹配的多条记录X锁+Gap锁，主键索引树X锁+Gap锁</p>
</li>
<li><p>无索引 锁表</p>
</li>
</ul>
<h4 id="Serializable-LBCC"><a href="#Serializable-LBCC" class="headerlink" title="Serializable(LBCC)"></a>Serializable(LBCC)</h4><p>每一条SQL都加锁，包括select</p>
<h3 id="复杂SQL"><a href="#复杂SQL" class="headerlink" title="复杂SQL"></a>复杂SQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 准备环境</span><br><span class="line">CREATE TABLE `blog` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `userid` int(11) DEFAULT NULL,</span><br><span class="line">  `blogid` int(11) DEFAULT NULL,</span><br><span class="line">  `pub` int(11) DEFAULT NULL,</span><br><span class="line">  `comment` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_pub_userid` (`pub`,`userid`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mBG6OTNK25ePEsb.png" alt="image-20200809184056603"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from blog where pub &gt; 1 and pub &lt; 15 and userid = 1 and comment is not NULL;</span><br></pre></td></tr></table></figure>

<p>数据库版本：5.6（包括5.6）</p>
<p>首先判断pub&gt;1 and pub &lt;15,将组合索引树的 pub = {3，5，10}加X锁，[1,20)加Gap锁（Mysql5.1，范围索引没有下推，5.6有索引下推，减少使用普通索引的回表次数）<br>然后 userid = 1，对组合索引树的pub = {5,10}加记录锁，通过ICP索引下推，不加Gap锁<br>comment is not null 无索引。将存储引擎的数据取到server层，对取出来的数据加X锁和Gap锁。</p>
<p><strong>Index key</strong>：pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</p>
<p><strong>Index Filter</strong>：userid = ‘hdc’ 。此条件，可以在index_pub_userid索引上进行过滤，但不属于Index Key。 </p>
<p><strong>Table Filter</strong>：comment is not NULL。此条件，在index_pub_userid索引上无法过滤，只能在聚簇索引上过滤。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-集群、主从复制、读写分离</title>
    <url>/2020/08/10/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E9%9B%86%E7%BE%A4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>集群、主从复制、读写分离</p>
<span id="more"></span>

<h1 id="Mysql-集群、主从复制、读写分离"><a href="#Mysql-集群、主从复制、读写分离" class="headerlink" title="Mysql-集群、主从复制、读写分离"></a>Mysql-集群、主从复制、读写分离</h1><p>从库备份主库，读写分离后，从库可以读，主库可以写和读。</p>
<p>单击mysql做不到：高可用、高并发、海量数据（5千万）</p>
<p>主从复制，读写分离原理：主库中事务提交后，写入到 bin log 中，从库I/O读取bin log日志到从库日志relay日志，然后从relay日志中将数据放入从库中。</p>
<p>从库备份主库。mysql中做配置，从主库的一定的位置开始复制。</p>
<h2 id="主从复制mysql配置："><a href="#主从复制mysql配置：" class="headerlink" title="主从复制mysql配置："></a>主从复制mysql配置：</h2><h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><p>1.修改my.cnf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启用二进制日志 </span><br><span class="line">log-bin=mysql-bin </span><br><span class="line">#服务器唯一ID，一般取IP最后一段 </span><br><span class="line">server-id=133 </span><br><span class="line">#指定复制的数据库(可选) </span><br><span class="line">binlog-do-db=test2 </span><br><span class="line">binlog-ignore-db=test </span><br><span class="line">#指定不复制的数据库(可选，mysql5.7) </span><br><span class="line">replicate-ignore-db=test1 </span><br><span class="line">#指定忽略的表（可选，mysql5.7） </span><br><span class="line">replicate-ignore-table = db.table1</span><br></pre></td></tr></table></figure>

<p>2.重启mysql服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p>3.主机给从机授权备份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>4.刷新权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>5.查询mater的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>

<p>主从备份： mysqldump</p>
<h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><p>1.修改my.cnf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=135</span><br></pre></td></tr></table></figure>



<p>2.重启并登录到mysql配置从服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line">#关闭</span><br><span class="line">stop slave</span><br><span class="line">#同步初始化 master_log_file、master_log_pos 以主机状态为主</span><br><span class="line">show master status</span><br><span class="line"></span><br><span class="line">change master to</span><br><span class="line">master_host= &#x27;192.168.56.101&#x27;,</span><br><span class="line">master_port=3306,</span><br><span class="line">master_user=&#x27;root&#x27;,</span><br><span class="line">master_password=&#x27;***&#x27;,</span><br><span class="line">master_log_file=&#x27;mysql-bin.000059&#x27;,</span><br><span class="line">master_log_pos=394;</span><br></pre></td></tr></table></figure>



<p>3.启动从服务器复制功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>



<p>4.检查从服务器复制功能状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line"># ......(省略)</span><br><span class="line"># Slave_IO_Running: Yes //此状态必须YES</span><br><span class="line"># Slave_SQL_Running: Yes //此状态必须YES</span><br><span class="line"># ......(省略)</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>向主机插入数据，看从机是否有数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入失败时解决方案：</span><br><span class="line">set global sql_slave_skip_counter =1; # 忽略一个错误 </span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>



<h3 id="主从延时"><a href="#主从延时" class="headerlink" title="主从延时"></a>主从延时</h3><ol>
<li><p>因为SQLThread和IOThread是默认单线程，当主机的tps(每秒事务处理数)高于从机的Thread所能承受范围，则会出现从机复制延时</p>
<p>解决：将thread改成多线程模式 MySQL5.6改表，MySQL5.7改GTID</p>
</li>
<li><p>网络延时</p>
<p>解决：主和从放在一个网内</p>
</li>
<li><p>IO延时</p>
<p>解决 ：slave server硬件升级</p>
</li>
</ol>
<p>解决方案： 利用分库分表中间件 Mycat、 sharding JDBC强制读取主库</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>一个库对外工作，性能限制在一个库。多个库对外工作，增加数据库负载能力。</p>
<p>主从集群中，让主库负责写和部分读，从库负责读。即读写分离。</p>
<h4 id="Mysql-Proxy"><a href="#Mysql-Proxy" class="headerlink" title="Mysql-Proxy"></a>Mysql-Proxy</h4><p>代理。负责路由SQL到Master或Slave</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https://downloads.mysql.com/archives/get/file/mysql-proxy-0.8.5-linux-el6- x86-64bit.tar.gz</span><br><span class="line"></span><br><span class="line">#解压缩</span><br><span class="line">tar -xf mysql-proxy-0.8.5-linux-el6-x86-64bit.tar.gz -C /plan</span><br></pre></td></tr></table></figure>

<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>创建mysql-proxy.cnf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql-proxy] </span><br><span class="line">user=root </span><br><span class="line">admin-username=root </span><br><span class="line">admin-password=123456 </span><br><span class="line">proxy-address=192.168.10.137:4040 </span><br><span class="line">proxy-backend-addresses=192.168.10.135:3306 </span><br><span class="line">proxy-read-only-backend-addresses=192.168.10.136:3306 </span><br><span class="line">proxy-lua-script=/root/mysql-proxy/share/doc/mysql-proxy/rw-splitting.lua </span><br><span class="line">log-file=/root/mysql-proxy/logs/mysql-proxy.log </span><br><span class="line">log-level=debug </span><br><span class="line">keepalive=true </span><br><span class="line">daemon=true</span><br></pre></td></tr></table></figure>

<p>修改mysql-proxy.cnf文件的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 660 mysql-proxy.cnf #可读写</span><br></pre></td></tr></table></figure>

<p>修改rw-splitting.lua</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40		min_idle_connections = 1,</span><br><span class="line">41		max_idle_connections = 2,</span><br></pre></td></tr></table></figure>

<p>Mysql-Ploxy启动域测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mysql-proxy --defaults-file=mysql-proxy.cnf配置文件的地址</span><br></pre></td></tr></table></figure>



<p>连接Mysql Proxy机器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456 -h192.168.56.102 -P4040; #注： 关闭防火墙</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>集群</tag>
        <tag>主从复制</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计模板</title>
    <url>/2024/02/09/215%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>架构</p>
<span id="more"></span>

<h2 id="备选方案模板"><a href="#备选方案模板" class="headerlink" title="备选方案模板"></a>备选方案模板</h2><ol>
<li>需求介绍</li>
</ol>
<p>[需求介绍主要描述需求的背景、目标、范围等]</p>
<p>随着前浪微博业务的不断发展，业务上拆分的子系统越来越多，目前系统间的调用都是同步调用，由此带来几个明显的系统问题：</p>
<ul>
<li>性能问题：当用户发布了一条微博后，微博发布子系统需要同步调用“统计子系统”“审核子系统”“奖励子系统”等共 8 个子系统，性能很低。</li>
<li>耦合问题：当新增一个子系统时，例如如果要增加“广告子系统”，那么广告子系统需要开发新的接口给微博发布子系统调用。</li>
<li>效率问题：每个子系统提供的接口参数和实现都有一些细微的差别，导致每次都需要重新设计接口和联调接口，开发团队和测试团队花费了许多重复工作量。</li>
</ul>
<p>基于以上背景，我们需要引入消息队列进行系统解耦，将目前的同步调用改为异步通知。</p>
<ol start="2">
<li>需求分析</li>
</ol>
<p>[需求分析主要全方位地描述需求相关的信息]</p>
<p><strong>5W</strong></p>
<p>[5W 指 Who、When、What、Why、Where。</p>
<p>Who：需求利益干系人，包括开发者、使用者、购买者、决策者等。</p>
<p>When：需求使用时间，包括季节、时间、里程碑等。</p>
<p>What：需求的产出是什么，包括系统、数据、文件、开发库、平台等。</p>
<p>Where：需求的应用场景，包括国家、地点、环境等，例如测试平台只会在测试环境使用。</p>
<p>Why：需求需要解决的问题，通常和需求背景相关]</p>
<p>消息队列的 5W 分析如下：</p>
<p>Who：消息队列系统主要是业务子系统来使用，子系统发送消息或者接收消息。</p>
<p>When：当子系统需要发送异步通知的时候，需要使用消息队列系统。</p>
<p>What：需要开发消息队列系统。</p>
<p>Where：开发环境、测试环境、生产环境都需要部署。</p>
<p>Why：消息队列系统将子系统解耦，将同步调用改为异步通知。</p>
<p><strong>1H</strong></p>
<p>[这里的 How 不是设计方案也不是架构方案，而是关键业务流程。消息队列系统这部分内容很简单，但有的业务系统 1H 就是具体的用例了，有兴趣的同学可以尝试写写 ATM 机取款的业务流程。如果是复杂的业务系统，这部分也可以独立成“用例文档”]</p>
<p>消息队列有两大核心功能：</p>
<ul>
<li>业务子系统发送消息给消息队列。</li>
<li>业务子系统从消息队列获取消息。</li>
</ul>
<p><strong>8C</strong></p>
<p>[8C 指的是 8 个约束和限制，即 Constraints，包括性能 Performance、成本 Cost、时间 Time、可靠性 Reliability、安全性 Security、合规性 Compliance、技术性 Technology、兼容性 Compatibility]</p>
<p>注：需求中涉及的性能、成本、可靠性等仅仅是利益关联方提出的诉求，不一定准确；如果经过分析有的约束没有必要，或成本太高、难度太大，这些约束是可以调整的。</p>
<p>性能：需要达到 Kafka 的性能水平。</p>
<p>成本：参考 XX 公司的设计方案，不超过 10 台服务器。</p>
<p>时间：期望 3 个月内上线第一个版本，在两个业务尝试使用。</p>
<p>可靠性：按照业务的要求，消息队列系统的可靠性需要达到 99.99%。</p>
<p>安全性：消息队列系统仅在生产环境内网使用，无需考虑网络安全；如消息中有敏感信息，消息发送方需要自行进行加密，消息队列系统本身不考虑通用的加密。</p>
<p>合规性：消息队列系统需要按照公司目前的 DevOps 规范进行开发。</p>
<p>技术性：目前团队主要研发人员是 Java，最好用 Java 开发。</p>
<p>兼容性：之前没有类似系统，无需考虑兼容性。</p>
<ol start="3">
<li>复杂度分析</li>
</ol>
<p>[分析需求的复杂度，复杂度常见的有高可用、高性能、可扩展等，具体分析方法请参考专栏前面的内容]</p>
<p>注：文档的内容省略了分析过程，实际操作的时候每个约束和限制都要有详细的逻辑推导，避免完全拍脑袋式决策，具体请参考<a href="http://time.geekbang.org/column/article/7563">专栏第 10 期</a>的分析。</p>
<p><strong>高可用</strong></p>
<p>对于微博子系统来说，如果消息丢了，导致没有审核，然后触犯了国家法律法规，则是非常严重的事情；对于等级子系统来说，如果用户达到相应等级后，系统没有给他奖品和专属服务，则 VIP 用户会很不满意，导致用户流失从而损失收入，虽然也比较关键，但没有审核子系统丢消息那么严重。</p>
<p>综合来看，消息队列需要高可用性，包括消息写入、消息存储、消息读取都需要保证高可用性。</p>
<p><strong>高性能</strong></p>
<p>前浪微博系统用户每天发送 1000 万条微博，那么微博子系统一天会产生 1000 万条消息，平均一条消息有 10 个子系统读取，那么其他子系统读取的消息大约是 1 亿次。将数据按照秒来计算，一天内平均每秒写入消息数为 115 条，每秒读取的消息数是 1150 条；再考虑系统的读写并不是完全平均的，设计的目标应该以峰值来计算。峰值一般取平均值的 3 倍，那么消息队列系统的 TPS 是 345，QPS 是 3450，考虑一定的性能余量。由于现在的基数较低，为了预留一定的系统容量应对后续业务的发展，我们将设计目标设定为峰值的 4 倍，因此最终的性能要求是：TPS 为 1380，QPS 为 13800。TPS 为 1380 并不高，但 QPS 为 13800 已经比较高了，因此高性能读取是复杂度之一。</p>
<p><strong>可扩展</strong></p>
<p>消息队列的功能很明确，基本无须扩展，因此可扩展性不是这个消息队列的关键复杂度。</p>
<ol start="4">
<li>备选方案</li>
</ol>
<p>[备选方案设计，至少 3 个备选方案，每个备选方案需要描述关键的实现，无须描述具体的实现细节。此处省略具体方案描述，详细请参考<a href="http://time.geekbang.org/column/article/7800">专栏第 11 期</a>]</p>
<p><strong>备选方案 1：直接引入开源 Kafka</strong></p>
<p>[此处省略方案描述]</p>
<p><strong>备选方案 2：集群 + MySQL 存储</strong></p>
<p>[此处省略方案描述]</p>
<p><strong>备选方案 3：集群 + 自研存储</strong></p>
<p>[此处省略方案描述]</p>
<ol start="5">
<li>备选方案评估</li>
</ol>
<p>[备选方案 360 度环评，详细请参考<a href="http://time.geekbang.org/column/article/7832">专栏第 12 期</a>。注意备选方案评估的内容会根据评估会议的结果进行修改，也就是说架构师首先给出自己的备选方案评估，然后举行备选方案评估会议，再根据会议结论修改备选方案文档]</p>
<h2 id="架构设计模板"><a href="#架构设计模板" class="headerlink" title="架构设计模板"></a>架构设计模板</h2><p>[备选方案评估后会选择一个方案落地实施，架构设计文档就是用来详细描述细化方案的]</p>
<ol>
<li>总体方案</li>
</ol>
<p>[总体方案需要从整体上描述方案的结构，其核心内容就是架构图，以及针对架构图的描述，包括模块或者子系统的职责描述、核心流程]</p>
<ol start="2">
<li>架构总览</li>
</ol>
<p>[架构总览给出架构图以及架构的描述]</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240122084019282.png" alt="image-20240122084019282"></p>
<p>架构关键设计点：</p>
<ul>
<li><p>采用数据分散集群的架构，集群中的服务器进行分组，每个分组存储一部分消息数据。</p>
</li>
<li><p>每个分组包含一台主 MySQL 和一台备 MySQL，分组内主备数据复制，分组间数据不同步。</p>
</li>
<li><p>正常情况下，分组内的主服务器对外提供消息写入和消息读取服务，备服务器不对外提供服务；主服务器宕机的情况下，备服务器对外提供消息读取的服务。</p>
</li>
<li><p>客户端采取轮询的策略写入和读取消息。</p>
</li>
<li><p>核心流程</p>
</li>
<li><p>消息发送流程</p>
</li>
</ul>
<p>[此处省略流程描述]</p>
<ul>
<li>消息读取流程</li>
</ul>
<p>[此处省略流程描述]</p>
<ol start="4">
<li>详细设计</li>
</ol>
<p>[详细设计需要描述具体的实现细节]</p>
<p><strong>高可用设计</strong></p>
<ul>
<li>消息发送可靠性</li>
</ul>
<p>业务服务器中嵌入消息队列系统提供的 SDK，SDK 支持轮询发送消息，当某个分组的主服务器无法发送消息时，SDK 挑选下一个分组主服务器重发消息，依次尝试所有主服务器直到发送成功；如果全部主服务器都无法发送，SDK 可以缓存消息，也可以直接丢弃消息，具体策略可以在启动 SDK 的时候通过配置指定。</p>
<p>如果 SDK 缓存了一些消息未发送，此时恰好业务服务器又重启，则所有缓存的消息将永久丢失，这种情况 SDK 不做处理，业务方需要针对某些非常关键的消息自己实现永久存储的功能。</p>
<ul>
<li>消息存储可靠性</li>
</ul>
<p>消息存储在 MySQL 中，每个分组有一主一备两台 MySQL 服务器，MySQL 服务器之间复制消息以保证消息存储高可用。如果主备间出现复制延迟，恰好此时 MySQL 主服务器宕机导致数据无法恢复，则部分消息会永久丢失，这种情况不做针对性设计，DBA 需要对主备间的复制延迟进行监控，当复制延迟超过 30 秒的时候需要及时告警并进行处理。</p>
<ul>
<li>消息读取可靠性</li>
</ul>
<p>每个分组有一主一备两台服务器，主服务器支持发送和读取消息，备服务器只支持读取消息，当主服务器正常的时候备服务器不对外提供服务，只有备服务器判断主服务器故障的时候才对外提供消息读取服务。</p>
<p>主备服务器的角色和分组信息通过配置指定，通过 ZooKeeper 进行状态判断和决策。主备服务器启动的时候分别连接到 ZooKeeper，在 /MQ/Server/[group] 目录下建立 EPHEMERAL 节点，假设分组名称为 group1，则主服务器节点为 /MQ/Server/group1/master，备服务器的节点为 /MQ/Server/group1/slave。节点的超时时间可以配置，默认为 10 秒。</p>
<p><strong>高性能设计</strong></p>
<p>[此处省略具体设计]</p>
<p><strong>可扩展设计</strong></p>
<p>[此处省略具体设计。如果方案不涉及，可以简单写上“无”，表示设计者有考虑但不需要设计；否则如果完全不写的话，方案评审的时候可能会被认为是遗漏了设计点]</p>
<p>无</p>
<p><strong>安全设计</strong></p>
<p>消息队列系统需要提供权限控制功能，权限控制包括两部分：身份识别和队列权限控制。</p>
<ul>
<li>身份识别</li>
</ul>
<p>消息队列系统给业务子系统分配身份标识和接入 key，SDK 首先需要建立连接并进行身份校验，消息队列服务器会中断校验不通过的连接。因此，任何业务子系统如果想接入消息队列系统，都必须首先申请身份标识和接入 key，通过这种方式来防止恶意系统任意接入。</p>
<ul>
<li>队列权限</li>
</ul>
<p>某些队列信息可能比较敏感，只允许部分子系统发送或者读取，消息队列系统将队列权限保存在配置文件中，当收到发送或者读取消息的请求时，首先需要根据业务子系统的身份标识以及配置的权限信息来判断业务子系统是否有权限，如果没有权限则拒绝服务。</p>
<p><strong>其他设计</strong></p>
<p>[其他设计包括上述以外的其他设计考虑点，例如指定开发语言、符合公司的某些标准等，如果篇幅较长，也可以独立进行描述]</p>
<ul>
<li>消息队列系统需要接入公司已有的运维平台，通过运维平台发布和部署。</li>
<li>消息队列系统需要输出日志给公司已有的监控平台，通过监控平台监控消息队列系统的健康状态，包括发送消息的数量、发送消息的大小、积压消息的数量等，详细监控指标在后续设计方案中列出。</li>
</ul>
<p><strong>部署方案</strong></p>
<p>[部署方案主要包括硬件要求、服务器部署方式、组网方式等]</p>
<p>消息队列系统的服务器和数据库服务器采取混布的方式部署，即：一台服务器上，部署同一分组的主服务器和主 MySQL，或者备服务器和备 MySQL。因为消息队列服务器主要是 CPU 密集型，而 MySQL 是磁盘密集型的，所以两者混布互相影响的几率不大。</p>
<p>硬件的基本要求：32 核 48G 内存 512G SSD 硬盘，考虑到消息队列系统动态扩容的需求不高，且对性能要求较高，因此需要使用物理服务器，不采用虚拟机。</p>
<ol start="5">
<li>架构演进规划</li>
</ol>
<p>[通常情况下，规划和设计的需求比较完善，但如果一次性全部做完，项目周期可能会很长，因此可以采取分阶段实施，即：第一期做什么、第二期做什么，以此类推]</p>
<p>整个消息队列系统分三期实现：</p>
<p>第一期：实现消息发送、权限控制功能，预计时间 3 个月。</p>
<p>第二期：实现消息读取功能，预计时间 1 个月。</p>
<p>第三期：实现主备基于 ZooKeeper 切换的功能，预计时间 2 周。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>高架构</tag>
      </tags>
  </entry>
  <entry>
    <title>BootStrap-Table-树</title>
    <url>/2020/07/27/%E5%89%8D%E7%AB%AF/Bootstrap-table-%E6%A0%91/</url>
    <content><![CDATA[<p>BootStrap-Table树形显示，包含js请求后端的代码</p>
<span id="more"></span>

<h1 id="BootStrap-Table-树"><a href="#BootStrap-Table-树" class="headerlink" title="BootStrap-Table-树"></a>BootStrap-Table-树</h1><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WVJLnlT3ZRU4or5.png" alt="image-20200729155605576"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html lang=&quot;zh-cn&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;width=device-width,initial-scale=1.0&quot; name=&quot;viewport&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;</span><br><span class="line">    &lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;</span><br><span class="line">    &lt;title&gt;系统管理&lt;/title&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap-table/1.11.1/bootstrap-table.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/css/jquery.treegrid.min.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h1&gt;树形表格 ： Table Treegrid&lt;/h1&gt;</span><br><span class="line">    &lt;table id=&quot;table&quot;&gt;&lt;/table&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;button onclick=&quot;test()&quot;&gt;选择&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.1/bootstrap-table.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.0/extensions/treegrid/bootstrap-table-treegrid.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/js/jquery.treegrid.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var $table = $(&#x27;#table&#x27;);</span><br><span class="line">    var data = JSON.parse(</span><br><span class="line">        &#x27;[&#123;&quot;id&quot;:1,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;用户管理&quot;,&quot;permissionValue&quot;:&quot;open:user:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:2,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;系统管理&quot;,&quot;permissionValue&quot;:&quot;open:system:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:3,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;新增用户&quot;,&quot;permissionValue&quot;:&quot;open:user:add&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:4,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;修改用户&quot;,&quot;permissionValue&quot;:&quot;open:user:edit&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:5,&quot;pid&quot;:1,&quot;status&quot;:0,&quot;name&quot;:&quot;删除用户&quot;,&quot;permissionValue&quot;:&quot;open:user:del&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:6,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统配置管理&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:7,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;新增配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:add&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:8,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;修改配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:edit&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:9,&quot;pid&quot;:6,&quot;status&quot;:0,&quot;name&quot;:&quot;删除配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:del&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:10,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统日志管理&quot;,&quot;permissionValue&quot;:&quot;open:log:manage&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:11,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;新增日志&quot;,&quot;permissionValue&quot;:&quot;open:log:add&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:12,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;修改日志&quot;,&quot;permissionValue&quot;:&quot;open:log:edit&quot;&#125;,&#x27; +</span><br><span class="line">        &#x27;&#123;&quot;id&quot;:13,&quot;pid&quot;:10,&quot;status&quot;:0,&quot;name&quot;:&quot;删除日志&quot;,&quot;permissionValue&quot;:&quot;open:log:del&quot;&#125;]&#x27;);</span><br><span class="line"></span><br><span class="line">    $(function() &#123;</span><br><span class="line"></span><br><span class="line">        //控制台输出一下数据</span><br><span class="line">        console.log(data);</span><br><span class="line"></span><br><span class="line">        $table.bootstrapTable(&#123;</span><br><span class="line">            data:data,</span><br><span class="line">            idField: &#x27;id&#x27;,</span><br><span class="line">            dataType:&#x27;jsonp&#x27;,//json也可以</span><br><span class="line">			/*访问后台 访问后端时不需要data属性</span><br><span class="line">			responseHandler: function(res) &#123;</span><br><span class="line">				console.log(res);</span><br><span class="line">				if (res.meta.code == 200) &#123;</span><br><span class="line">					var mydata = res.data.menuTree;</span><br><span class="line">					return &#123;</span><br><span class="line">						&quot;data&quot;: mydata//注意这里</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;,</span><br><span class="line">			*/</span><br><span class="line">            columns: [</span><br><span class="line">                &#123; field: &#x27;check&#x27;,  checkbox: true, formatter: function (value, row, index) &#123;</span><br><span class="line">                        if (row.check == true) &#123;</span><br><span class="line">                           // console.log(row.serverName);</span><br><span class="line">                            //设置选中</span><br><span class="line">                            return &#123;  checked: true &#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123; field: &#x27;name&#x27;,  title: &#x27;名称&#x27; &#125;,</span><br><span class="line">               // &#123;field: &#x27;id&#x27;, title: &#x27;编号&#x27;, sortable: true, align: &#x27;center&#x27;&#125;,</span><br><span class="line">               // &#123;field: &#x27;pid&#x27;, title: &#x27;所属上级&#x27;&#125;,</span><br><span class="line">                &#123; field: &#x27;status&#x27;,  title: &#x27;状态&#x27;, sortable: true,  align: &#x27;center&#x27;, formatter: &#x27;statusFormatter&#x27;  &#125;,</span><br><span class="line">                &#123; field: &#x27;permissionValue&#x27;, title: &#x27;权限值&#x27;  &#125;,</span><br><span class="line">                &#123; field: &#x27;operate&#x27;, title: &#x27;操作&#x27;, align: &#x27;center&#x27;, events : operateEvents, formatter: &#x27;operateFormatter&#x27; &#125;,</span><br><span class="line">            ],</span><br><span class="line"></span><br><span class="line">            // bootstrap-table-treegrid.js 插件配置 -- start</span><br><span class="line"></span><br><span class="line">            //在哪一列展开树形</span><br><span class="line">            treeShowField: &#x27;name&#x27;,</span><br><span class="line">            //指定父id列</span><br><span class="line">            parentIdField: &#x27;pid&#x27;,//pid&gt;=0 小于0时不显示</span><br><span class="line">            </span><br><span class="line">            onResetView: function(data) &#123;</span><br><span class="line">                //console.log(&#x27;load&#x27;);</span><br><span class="line">                $table.treegrid(&#123;</span><br><span class="line">                    initialState: &#x27;collapsed&#x27;,// 所有节点都折叠</span><br><span class="line">                    // initialState: &#x27;expanded&#x27;,// 所有节点都展开，默认展开</span><br><span class="line">                    treeColumn: 1,//第几列折叠</span><br><span class="line">                    // expanderExpandedClass: &#x27;glyphicon glyphicon-minus&#x27;,  //图标样式</span><br><span class="line">                    // expanderCollapsedClass: &#x27;glyphicon glyphicon-plus&#x27;,</span><br><span class="line">                    onChange: function() &#123;</span><br><span class="line">                        $table.bootstrapTable(&#x27;resetWidth&#x27;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                //只展开树形的第一级节点</span><br><span class="line">                $table.treegrid(&#x27;getRootNodes&#x27;).treegrid(&#x27;expand&#x27;);</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            onCheck:function(row)&#123;</span><br><span class="line">                var datas = $table.bootstrapTable(&#x27;getData&#x27;);</span><br><span class="line">                // 勾选子类</span><br><span class="line">                selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,true);</span><br><span class="line"></span><br><span class="line">                // 勾选父类</span><br><span class="line">                selectParentChecked(datas,row,&quot;id&quot;,&quot;pid&quot;)</span><br><span class="line"></span><br><span class="line">                // 刷新数据</span><br><span class="line">                $table.bootstrapTable(&#x27;load&#x27;, datas);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            //onUncheck:function(row)&#123;</span><br><span class="line">            //    var datas = $table.bootstrapTable(&#x27;getData&#x27;);</span><br><span class="line">            //    selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,false);</span><br><span class="line">            //    $table.bootstrapTable(&#x27;load&#x27;, datas);</span><br><span class="line">            //&#125;,</span><br><span class="line">            // bootstrap-table-treetreegrid.js 插件配置 -- end</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 格式化按钮</span><br><span class="line">    function operateFormatter(value, row, index) &#123;</span><br><span class="line">        return [</span><br><span class="line">            &#x27;&lt;button type=&quot;button&quot; class=&quot;RoleOfadd btn-small  btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; &gt;&lt;/i&gt;&amp;nbsp;新增&lt;/button&gt;&#x27;,</span><br><span class="line">            &#x27;&lt;button type=&quot;button&quot; class=&quot;RoleOfedit btn-small   btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-pencil-square-o&quot; &gt;&lt;/i&gt;&amp;nbsp;修改&lt;/button&gt;&#x27;,</span><br><span class="line">            &#x27;&lt;button type=&quot;button&quot; class=&quot;RoleOfdelete btn-small   btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot; &gt;&lt;/i&gt;&amp;nbsp;删除&lt;/button&gt;&#x27;</span><br><span class="line">        ].join(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 格式化类型</span><br><span class="line">    function typeFormatter(value, row, index) &#123;</span><br><span class="line">        if (value === &#x27;menu&#x27;) &#123;  return &#x27;菜单&#x27;;  &#125;</span><br><span class="line">        if (value === &#x27;button&#x27;) &#123;  return &#x27;按钮&#x27;; &#125;</span><br><span class="line">        if (value === &#x27;api&#x27;) &#123;  return &#x27;接口&#x27;; &#125;</span><br><span class="line">        return &#x27;-&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 格式化状态</span><br><span class="line">    function statusFormatter(value, row, index) &#123;</span><br><span class="line">        if (value === 1) &#123;</span><br><span class="line">            return &#x27;&lt;span class=&quot;label label-success&quot;&gt;正常&lt;/span&gt;&#x27;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#x27;&lt;span class=&quot;label label-default&quot;&gt;锁定&lt;/span&gt;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化操作按钮的方法</span><br><span class="line">    window.operateEvents = &#123;</span><br><span class="line">        &#x27;click .RoleOfadd&#x27;: function (e, value, row, index) &#123;</span><br><span class="line">            add(row.id);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;click .RoleOfdelete&#x27;: function (e, value, row, index) &#123;</span><br><span class="line">            del(row.id);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;click .RoleOfedit&#x27;: function (e, value, row, index) &#123;</span><br><span class="line">            update(row.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /**</span><br><span class="line">     * 选中父项时，同时选中子项</span><br><span class="line">     * @param datas 所有的数据</span><br><span class="line">     * @param row 当前数据</span><br><span class="line">     * @param id id 字段名</span><br><span class="line">     * @param pid 父id字段名</span><br><span class="line">     */</span><br><span class="line">    function selectChilds(datas,row,id,pid,checked) &#123;</span><br><span class="line">        for(var i in datas)&#123;</span><br><span class="line">            if(datas[i][pid] == row[id])&#123;</span><br><span class="line">                datas[i].check=checked;</span><br><span class="line">                selectChilds(datas,datas[i],id,pid,checked);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function selectParentChecked(datas,row,id,pid)&#123;</span><br><span class="line">        for(var i in datas)&#123;</span><br><span class="line">            if(datas[i][id] == row[pid])&#123;</span><br><span class="line">                datas[i].check=true;</span><br><span class="line">                selectParentChecked(datas,datas[i],id,pid);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test() &#123;</span><br><span class="line">        var selRows = $table.bootstrapTable(&quot;getSelections&quot;);</span><br><span class="line">        if(selRows.length == 0)&#123;</span><br><span class="line">            alert(&quot;请至少选择一行&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var postData = &quot;&quot;;</span><br><span class="line">        $.each(selRows,function(i) &#123;</span><br><span class="line">            postData +=  this.id;</span><br><span class="line">            if (i &lt; selRows.length - 1) &#123;</span><br><span class="line">                postData += &quot;， &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        alert(&quot;你选中行的 id 为：&quot;+postData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(id) &#123;</span><br><span class="line">        alert(&quot;add 方法 , id = &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">    function del(id) &#123;</span><br><span class="line">        alert(&quot;del 方法 , id = &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">    function update(id) &#123;</span><br><span class="line">        alert(&quot;update 方法 , id = &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>pid 大于等于0，pid为负数时无法显示。</p>
<p>返回数据格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;&quot;data&quot;: mydata//注意这里&#125;</span><br></pre></td></tr></table></figure>

<p>没找到分页的办法</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>BootStrap</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-获取url参数</title>
    <url>/2020/08/12/%E5%89%8D%E7%AB%AF/JS-%E8%8E%B7%E5%8F%96url%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>window.location.href携带参数到test.html页面。test.html页面获取携带的参数。</p>
<span id="more"></span>

<h1 id="JS-获取url参数"><a href="#JS-获取url参数" class="headerlink" title="JS-获取url参数"></a>JS-获取url参数</h1><p>window.location.href携带参数到test.html页面。test.html页面获取携带的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">		// 前一个页面跳转到test.html并传递参数 </span><br><span class="line">		// window.location.href = &quot;http://127.0.0.1:8848/a/test.html?pdfId=1&quot;;</span><br><span class="line">		</span><br><span class="line">		// test.html获取参数</span><br><span class="line">		var pdfId = getQueryString(&quot;pdfId&quot;);</span><br><span class="line">		console.log(pdfId);</span><br><span class="line"></span><br><span class="line">		function getQueryString(name) &#123;</span><br><span class="line">			var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">			var r = window.location.search.substr(1).match(reg);</span><br><span class="line">			if (r != null) return unescape(r[2]);</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Number1引入Vue</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF/Number1%20%E5%BC%95%E5%85%A5Vue/</url>
    <content><![CDATA[<p>引入Vue</p>
<span id="more"></span>
<ul>
<li>1.直接使用script标签引入Vue.js（简单）</li>
<li>2.使用脚手架（复杂）</li>
</ul>
<h1 id="1-直接使用script标签引入Vue-js（简单）"><a href="#1-直接使用script标签引入Vue-js（简单）" class="headerlink" title="1.直接使用script标签引入Vue.js（简单）"></a>1.直接使用script标签引入Vue.js（简单）</h1><p>   有两种方式</p>
<h2 id="1-1通过网络引入外部的vue-js"><a href="#1-1通过网络引入外部的vue-js" class="headerlink" title="1.1通过网络引入外部的vue.js"></a>1.1通过网络引入外部的vue.js</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;!--引入外部的vue.js--&gt;</span><br><span class="line">		 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123; message &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var app = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="1-2引入本地的vue-js"><a href="#1-2引入本地的vue-js" class="headerlink" title="1.2引入本地的vue.js"></a>1.2引入本地的vue.js</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;!--引入本地的vue.js--&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123; message &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var app = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number2创建Vue实例</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF/Number2%20%E5%88%9B%E5%BB%BAVue%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>引入vue.js的基础上，用vue实例改变html中绑定id的内容</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;!--引入本地的vue.js--&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123; message &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var app = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number3初始Vue的数据和方法</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF/Number3%20%E5%88%9D%E8%AF%86Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>介绍Vue实例的属性，和一个观测属性值变化的方法。</p>
<span id="more"></span>

<!DOCTYPE html>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123;a&#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		  //  定义a,赋值为1.定义data.</span><br><span class="line">			var data =&#123;a:1,b:2&#125;;</span><br><span class="line">			定义vm,创建vue实例。将上边定义的data赋值给vm的属性data</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el:&#x27;#app&#x27;,</span><br><span class="line">				data:data</span><br><span class="line">			&#125;)</span><br><span class="line">			// 三种改值写法</span><br><span class="line">			data.a=&quot;sdafas&quot;;</span><br><span class="line">			vm.a=&quot;333&quot;;</span><br><span class="line">			//观测a的新旧值,函数在新旧值中间</span><br><span class="line">			vm.$watch(&#x27;a&#x27;,function(newVal,oldVal)&#123;</span><br><span class="line">				console.log(newVal,oldVal);</span><br><span class="line">			&#125;)</span><br><span class="line">			vm.$data.a=&quot;222&quot;;</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number4 Vue的生命周期钩子</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF/Number4%20Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<p>vue的生命周期内&amp;改变数据期间可通过钩子函数执行一些操作</p>
<span id="more"></span>

<p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%">官网地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src= &quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&#123;&#123;msg&#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el:&quot;#app&quot;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					msg:&quot;hi lifecycle hooks&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				//在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</span><br><span class="line">				beforeCreate() &#123;</span><br><span class="line">					console.log(&#x27;beforeCreate&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				/* 在实例创建完成后被立即调用。</span><br><span class="line">				在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</span><br><span class="line">				然而，挂载阶段还没开始，$el 属性目前不可见。 */</span><br><span class="line">				created() &#123;</span><br><span class="line">					console.log(&#x27;created&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				//在挂载开始之前被调用：相关的渲染函数首次被调用</span><br><span class="line">				beforeMount() &#123;</span><br><span class="line">					console.log(&#x27;beforeMount&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				// el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</span><br><span class="line">				mounted() &#123;</span><br><span class="line">					console.log(&#x27;mounted&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				//数据更新时调用</span><br><span class="line">				beforeUpdate() &#123;</span><br><span class="line">					console.log(&#x27;beforeUpdate&#x27;);</span><br><span class="line">				&#125;,</span><br><span class="line">				//组件 DOM 已经更新, 组件更新完毕</span><br><span class="line">				updated() &#123;</span><br><span class="line">					console.log(&#x27;updated&#x27;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			setTimeout(function()&#123;</span><br><span class="line">				vm.msg =&quot;change&quot;;</span><br><span class="line">				&#125;,3000</span><br><span class="line">			);</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number5Vue的模板语法1</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF/Number5%20Vue%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%951/</url>
    <content><![CDATA[<p>Vue的模板语法1</p>
<span id="more"></span>
<h1 id="1-插值"><a href="#1-插值" class="headerlink" title="1.插值"></a>1.插值</h1><h2 id="1-1-文本"><a href="#1-1-文本" class="headerlink" title="1.1 文本"></a>1.1 文本</h2><pre><code>&#123;&#123;msg&#125;&#125;
一次性插值 v-once
</code></pre>
<h2 id="1-2-原始html-v-html"><a href="#1-2-原始html-v-html" class="headerlink" title="1.2 原始html v-html"></a>1.2 原始html v-html</h2><h2 id="1-3-特性-v-bind"><a href="#1-3-特性-v-bind" class="headerlink" title="1.3 特性 v-bind"></a>1.3 特性 v-bind</h2><h2 id="1-4-javascript表达式"><a href="#1-4-javascript表达式" class="headerlink" title="1.4 javascript表达式"></a>1.4 javascript表达式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">		    &lt;!--1.1 文本 --&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">			&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;!--1.2 原始html --&gt;</span><br><span class="line">			&lt;!-- 改变字符串内容为html标签 --&gt;</span><br><span class="line">			&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">			&lt;!--1.3 特性 --&gt;</span><br><span class="line">			&lt;!-- 声明.css属性class,赋值为变量color --&gt;</span><br><span class="line">			&lt;div v-bind:class=&quot;color&quot;&gt;test...&lt;/div&gt;</span><br><span class="line">			&lt;!--1.4 javascript表达式 --&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123;number+1&#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;!-- 字符串的分割&amp;翻转&amp;拼接 --&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123;message2.split(&#x27;&#x27;).reverse()&#125;&#125;&lt;/p&gt;</span><br><span class="line">			&lt;p&gt;&#123;&#123;message2.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					message: &#x27;hello Vue&#x27;,</span><br><span class="line">					msg:&#x27;hi vue&#x27;,</span><br><span class="line">					rawHtml:&#x27;&lt;span style=&quot;color:red&quot;&gt;this is red&lt;/span&gt;&#x27;,</span><br><span class="line">					//yellow 为变量color的值,标识不同class</span><br><span class="line">					color:&#x27;yellow&#x27;,</span><br><span class="line">					number:11,</span><br><span class="line">					message2:&#x27;hello world&#x27;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">			vm.msg=&#x27;no change&#x27;;</span><br><span class="line">			</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">		&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			.red&#123;color:red&#125;</span><br><span class="line">			.yellow&#123;color:yellow;font-size: 100px;&#125;;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Number6Vue的模板语法2</title>
    <url>/2019/10/10/%E5%89%8D%E7%AB%AF/Number6%20Vue%E7%9A%84%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%952/</url>
    <content><![CDATA[<p>Vue的模板语法2</p>
<span id="more"></span>
<p>指令<br>    1参数<br>    2修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; &lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br><span class="line">			&lt;p v-if=&quot;seen2&quot;&gt;现在你看不到我了&lt;/p&gt;</span><br><span class="line">			&lt;!-- v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 --&gt;</span><br><span class="line">			&lt;a v-bind:href=&quot;url&quot;&gt;baidu&lt;/a&gt;</span><br><span class="line">			&lt;a v-on:click=&quot;doSomething&quot;&gt;点击事件&lt;/a&gt;</span><br><span class="line">			&lt;!-- v-on的缩写@   .stop执行click2后停止，不执行click1--&gt;</span><br><span class="line">			&lt;div @click=&quot;click1&quot;&gt;</span><br><span class="line">				&lt;div @click.stop=&quot;click2&quot;&gt;</span><br><span class="line">					click me</span><br><span class="line">				&lt;/div&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			var vm = new Vue(&#123;</span><br><span class="line">				el: &#x27;#app&#x27;,</span><br><span class="line">				data:&#123;</span><br><span class="line">					seen: true,</span><br><span class="line">					seen2: false,</span><br><span class="line">					url:&#x27;http://baidu.com&#x27;,</span><br><span class="line">				&#125;,</span><br><span class="line">				methods:&#123;</span><br><span class="line">					doSomething:function()&#123;</span><br><span class="line">						console.log(&#x27;点击事件出现&#x27;);</span><br><span class="line">					&#125;,</span><br><span class="line">					click1:function()&#123;</span><br><span class="line">						console.log(&#x27;click1&#x27;);</span><br><span class="line">					&#125;,</span><br><span class="line">					click2:function()&#123;</span><br><span class="line">						console.log(&#x27;click2&#x27;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>localStorage-内容消失</title>
    <url>/2020/08/07/%E5%89%8D%E7%AB%AF/localStorage-%E5%86%85%E5%AE%B9%E6%B6%88%E5%A4%B1/</url>
    <content><![CDATA[<p>localStorage-内容消失</p>
<span id="more"></span>

<h1 id="localStorage-内容消失"><a href="#localStorage-内容消失" class="headerlink" title="localStorage-内容消失"></a>localStorage-内容消失</h1><p>使用HbuilderX开发前端项目</p>
<p>​    前端项目跳转路径写为<code>localhost</code>，存储localStorage后，下一个页面取不到localStorage.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var baseurl = &quot;http://localhost:8849/&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//login.js中</span><br><span class="line">localStorage.setItem(key, value);</span><br><span class="line"></span><br><span class="line">// user.js中</span><br><span class="line">localStorage.getItem(key);// 取不到</span><br></pre></td></tr></table></figure>





<p>​    前端项目跳转路径写为127.0.0.1,存储localStorage后，项目运行正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var baseurl = &quot;http://127.0.0.1:8849/&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//login.js中</span><br><span class="line">localStorage.setItem(key, value);</span><br><span class="line"></span><br><span class="line">// user.js中</span><br><span class="line">localStorage.getItem(key);// 可以取到</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>localStorage</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离-重定向url携带数据</title>
    <url>/2020/08/18/%E5%89%8D%E7%AB%AF/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E9%87%8D%E5%AE%9A%E5%90%91url%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>前后端分离-重定向url携带数据</p>
<span id="more"></span>

<h1 id="前后端分离-重定向url携带中文数据"><a href="#前后端分离-重定向url携带中文数据" class="headerlink" title="前后端分离-重定向url携带中文数据"></a>前后端分离-重定向url携带中文数据</h1><p>后端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String redirectUrl = &quot;http://127.0.0.1/test.html&quot; </span><br><span class="line">try &#123;</span><br><span class="line">	String msg = &quot;登录失败&quot;;</span><br><span class="line">	msg = java.net.URLEncoder.encode(msg, &quot;UTF-8&quot;);// 编码</span><br><span class="line">	response.sendRedirect(redirectUrl+&quot;?msg=&quot;+msg);</span><br><span class="line">&#125; catch (IOException e2) &#123;</span><br><span class="line">	e2.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var request = new Object();</span><br><span class="line">request = GetRequest();</span><br><span class="line">var msg = request[&#x27;msg&#x27;];</span><br><span class="line">console.log(msg);</span><br><span class="line"></span><br><span class="line">function GetRequest() &#123;</span><br><span class="line">	debugger;</span><br><span class="line">	var url = location.search; //获取url中&quot;?&quot;符后的字串</span><br><span class="line">	console.log(url);</span><br><span class="line">	var theRequest = new Object();</span><br><span class="line">	if (url.indexOf(&quot;?&quot;) != -1) &#123;</span><br><span class="line">		var str = url.substr(1);</span><br><span class="line">		strs = str.split(&quot;&amp;&quot;);</span><br><span class="line">		for (var i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">			theRequest[strs[i].split(&quot;=&quot;)[0]] = decodeURI(strs[i].split(&quot;=&quot;)[1]);// 解码</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return theRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title>前端-弹出框底层不可选</title>
    <url>/2020/08/07/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF-%E5%BC%B9%E5%87%BA%E6%A1%86%E5%BA%95%E5%B1%82%E4%B8%8D%E5%8F%AF%E9%80%89/</url>
    <content><![CDATA[<p>前端-弹出框底层不可选</p>
<span id="more"></span>

<h1 id="前端-弹出框底层不可选"><a href="#前端-弹出框底层不可选" class="headerlink" title="前端-弹出框底层不可选"></a>前端-弹出框底层不可选</h1><p>转载：<a href="https://blog.csdn.net/llllvvv/article/details/79926656?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-79926656.nonecase">https://blog.csdn.net/llllvvv/article/details/79926656?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-79926656.nonecase</a></p>
<p>修改了一点</p>
<p>效果：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/foxnmYKIAycqOt8.png" alt="image-20200807175921117"></p>
<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;弹出窗口后，后面的层不可操作&lt;/title&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">	function show()  //显示隐藏层和弹出层 </span><br><span class="line">	&#123; </span><br><span class="line">	   var hideobj=document.getElementById(&quot;hidebg&quot;); </span><br><span class="line">	   hidebg.style.display=&quot;block&quot;;  //显示隐藏层 </span><br><span class="line">	   //hidebg.style.height=document.body.clientHeight+&quot;px&quot;;  //设置隐藏层的高度为当前页面高度 </span><br><span class="line">	   document.getElementById(&quot;hidebox&quot;).style.display=&quot;block&quot;;  //显示弹出层 </span><br><span class="line">	&#125; </span><br><span class="line">	function hide()  //去除隐藏层和弹出层 </span><br><span class="line">	&#123; </span><br><span class="line">	   document.getElementById(&quot;hidebg&quot;).style.display=&quot;none&quot;; </span><br><span class="line">	   document.getElementById(&quot;hidebox&quot;).style.display=&quot;none&quot;; </span><br><span class="line">	&#125; </span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">   #hidebg &#123; position:absolute;left:0px;top:0px; </span><br><span class="line">      background-color:#000; </span><br><span class="line">      width:100%;  /*宽度设置为100%，这样才能使隐藏背景层覆盖原页面*/    </span><br><span class="line">      height: 100%;</span><br><span class="line">      filter:alpha(opacity=60);  /*设置透明度为60%*/ </span><br><span class="line">      opacity:0.6;  /*非IE浏览器下设置透明度为60%*/ </span><br><span class="line">      display:none;</span><br><span class="line">      z-Index:2;&#125; </span><br><span class="line">   #hidebox &#123; text-align: right;position:absolute;width:400px;height:300px;top:200px;left:30%;border-radius: 5px;background-color:#fff;display:none;z-Index:3;padding: 10px;&#125; </span><br><span class="line">   #content &#123; text-align: center;cursor:pointer;z-Index:1;&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=&quot;hidebg&quot;&gt;&lt;/div&gt;&lt;!--隐藏层--&gt;</span><br><span class="line">	&lt;div id=&quot;hidebox&quot;&gt;&lt;span onClick=&quot;hide();&quot; style=&quot;cursor:pointer;&quot;&gt;关闭&lt;/span&gt;&lt;/div&gt;&lt;!--弹出层--&gt;</span><br><span class="line">	&lt;div id=&quot;content&quot; onClick=&quot;show();&quot;&gt;点击打开&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>弹出框</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客进阶：图片、主题、域名、HTTPS</title>
    <url>/2018/04/12/%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>hexo搭建的个人博客上传图片,主题更换,域名固定</p>
<span id="more"></span>
<h1 id="hexo搭建的个人博客上传图片"><a href="#hexo搭建的个人博客上传图片" class="headerlink" title="hexo搭建的个人博客上传图片"></a>hexo搭建的个人博客上传图片</h1><p>本方法为直接上传图片到GitHub，省事但是占用GitHub空间，如果怕GitHub（免费使用300M）以后空间不够用，可以用七牛（免费10G）当图片空间。<br>1.将站点配置文件_config.yml (刚进入博客文件夹)里的post_asset_folder:选项设置为true<br><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/1-1.jpg"></p>
<p>2.下载安装一个可以上传本地图片的插件,在你的blog目录下点击鼠标右键，再点击git bash here，然后输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个xxxx文件夹。<br><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/1-2.png"></p>
<p>在xxxx.md中想插入图片时，先把图片放到到xxxx这个文件夹中，然后在xxxx.md中按照markdown的格式引入图片：<br><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<h1 id="主题更换，示例next主题"><a href="#主题更换，示例next主题" class="headerlink" title="主题更换，示例next主题"></a>主题更换，示例next主题</h1><h2 id="下载next主题"><a href="#下载next主题" class="headerlink" title="下载next主题"></a>下载next主题</h2><p>在blog文件夹中点击鼠标右键，再点击git bash here，然后输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/2-1.png"></p>
<p>克隆完成之后，打开你的本地博客文件夹下的theme文件夹就可以看到刚刚下载的next主题。</p>
<h2 id="修改博客的配置文件"><a href="#修改博客的配置文件" class="headerlink" title="修改博客的配置文件"></a>修改博客的配置文件</h2><p>打开博客目录下的站点配置文件_config.yml 把主题切换为next。<br><img src="Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E3%80%81%E4%B8%BB%E9%A2%98%E3%80%81%E5%9F%9F%E5%90%8D/2-2.png"><br>完成之后主题就可以用了。<br>输入命令<br><code>hexo s </code><br>本地测试，可以在 localhost:4000 查看效果</p>
<p>配置文件_config.yml在网站中中文显示乱码<br>可以使用notepad++将配置文件转为utf-8编码</p>
<h1 id="域名固定"><a href="#域名固定" class="headerlink" title="域名固定"></a>域名固定</h1><p>上一篇绑定域名后，每次部署本地文件到GitHub，都需要到GitHub的setting中重写保存自己绑定的域名。<br>只保存一次的解决方法：到blog本地目录 source 文件夹下面新建一个文件，取名为 CNAME (无后缀)，内容就是上面所说到的自己的域名如下：<br>blog.xiaoruiit.com<br>就可以了。</p>
<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>阿里云域名控制台配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/9e5f13972c62601aaf8ea92f611f79c.png" alt="9e5f13972c62601aaf8ea92f611f79c"></p>
<p>github配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/bf91ff50c2ac87d6c6c0e46efa87750.png" alt="bf91ff50c2ac87d6c6c0e46efa87750"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2018/04/12/%E5%8D%9A%E5%AE%A2/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo搭建博客并部署在GitHub上，以及绑定域名，以后如何发布文章。</p>
<span id="more"></span>
<h1 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h1><p>安装过程会自动配置系统环境变量。（安装之后尽量不要更改文件夹名称，修改文件夹名称系统环境变量不会自动跟随改变，使用软件会出错）</p>
<h1 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h1><p>很简单，安装对应自己机器位数的git即可</p>
<h1 id="3-安装hexo（需要先安装好node-js和git"><a href="#3-安装hexo（需要先安装好node-js和git" class="headerlink" title="3.安装hexo（需要先安装好node.js和git)"></a>3.安装hexo（需要先安装好node.js和git)</h1><p>需要在联网状态下进行,下图红色的Err!是未联网下安装的报错结果。<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/3-1.png"></p>
<h1 id="4-建立站点"><a href="#4-建立站点" class="headerlink" title="4.建立站点"></a>4.建立站点</h1><ul>
<li>(1)先在电脑中的某一位置建立好 <em>your_name.github.io</em> 文件夹，比如          E:\your_name.github.io；</li>
<li>(2)在终端中切换到用cd命令 <em>your_name.github.io</em> 文件夹所在的路径。</li>
<li>(3)根据hexo的官方文档 <a href="https://hexo.io/zh-cn/docs/setup.html">开始使用 — 建站</a>，依次执行以下两条命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-1.png"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-2.png"></p>
<p>安装完成后simpleai.github.io目录下的内容：<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-3.png"></p>
<p>  ● <em>_config.yml</em> 文件存放着网站的配置信息，可以在这里配置大部分的参数。<br>  ● <em>package.json</em> 文件存放着插件信息，从中可以查看那些插件已经安装。<br>  ● <em>scaffolds</em> 是模板文件夹，新建文章时，Hexo 会根据 <em>scaffold</em> 来建立文件，不过这个模板和后面的主题里指的模板不一样。<br>  ● <em>source</em> 是存放用户资源的地方的文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线) 的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（别急，等下会生成的），而其他文件会被拷贝过去。<br>  ● <em>themes</em> 主题文件夹，Hexo 会根据主题来生成静态页面，我们以后自己安装的主题也都会放在这个文件夹下面，默认的 landscape 主题已经在里面了。<br>（4） 根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/commands.html">开始使用 — 命令</a>，在终端中敲入 （确保路径仍在 your_name.github.io 下；防火墙可能会阻止，点击允许。），</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-4.png"></p>
<p>可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 中看到我们网站默认的样子了。<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/4-5.png"></p>
<h1 id="5-配置站点"><a href="#5-配置站点" class="headerlink" title="5.配置站点"></a>5.配置站点</h1><p>在 <em>_config.yml</em> 中，我们可以修改大部份的配置，里面每一个参数的含义可以查看 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/configuration.html">开始使用 — 配置</a> ，这里我暂且只修改了 title，subtitle 和 author，替换成自己网站的名字和作者名即可。per_page 决定首页显示多少篇文章，默认的 10 篇有点多，我改成了 5 篇。其余的设置，比如 theme，deploy 我们用到了再来更改。</p>
<h1 id="6-生成自己的内容"><a href="#6-生成自己的内容" class="headerlink" title="6.生成自己的内容"></a>6.生成自己的内容</h1><p>在 _posts 文件夹下，新建一个 Markdown 文件(.md文件)，或者把以前有的 Markdown 文件复制进来，根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/front-matter.html">基本操作 — Front-matter</a> ，写好你的第一篇文章，比如：<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/6-1.png"></p>
<p>这里，Front-matter 是文件最上方以 — 分隔的区域，用于指定文章的标题、建立日期、更新日期等，如果主题模板还支持分类和标签的话（比如默认的 landscape 主题），还可以指定分类和标签。根据 Hexo 的官方文档 基本操作 — 生成文件，在终端中敲入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>Hexo 会替我们刚加入到 _posts 文件夹下的 markdown 文件生成静态文件。接着输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p> 就可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 中看到我们新添加的网页内容了。至此，我们采用默认主题 landscape 的网站已经生成了，且相信你已经掌握了关于 Hexo 的大部分操作，如果自感还不熟悉，可以再看看 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/commands.html">开始使用 — 命令</a>，主要是下面几个命令：<br>  ● <code>hexo init</code> [folder]: 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站；<br>  ● <code>hexo generate</code>: 生成静态文件；<br>  ● <code>hexo server</code>: 启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%EF%BC%9B">http://localhost:4000/；</a><br>  ● <code>hexo deploy</code>: 部署本地文件到网站（后文会用得）；<br>  ● <code>hexo clean</code>: 清除缓存文件 (db.json) 和 public 文件夹下已生成的静态文件。</p>
<h1 id="7部署到GitHub"><a href="#7部署到GitHub" class="headerlink" title="7部署到GitHub"></a>7部署到GitHub</h1><h2 id="7-1注册账号"><a href="#7-1注册账号" class="headerlink" title="7.1注册账号"></a>7.1注册账号</h2><h2 id="7-2github中创建项目"><a href="#7-2github中创建项目" class="headerlink" title="7.2github中创建项目"></a>7.2github中创建项目</h2><p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-1.png"></p>
<p>Github 的官方文档 <a href="https://help.github.com/articles/create-a-repo/#create-a-new-repository-on-github">Create a new repository on GitHub</a> 已经图文并茂将如何建立一个 repository 交待得非常清楚明白了（英文），唯一要注意的是，第二步里的 Repository name 一定要是 your_name.github.io ，your_name 是 Github 用户名。</p>
<h2 id="7-3配置Git"><a href="#7-3配置Git" class="headerlink" title="7.3配置Git"></a>7.3配置Git</h2><p>根据 Github 的官方文档 <a href="https://help.github.com/articles/set-up-git/#setting-up-git">Setting up Git</a>，这一操作的目的是 告诉版本控制软件 Git 接下来这台电脑上提交的文件是 E-mail 地址是什么的某人提交的。在 Git Bash 中执行如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;YOUR NAME&quot;</span><br><span class="line">git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;</span><br></pre></td></tr></table></figure>
<p>其中，YOUR NAME 是自己取的名字，YOUR EMAIL ADDRESS 是自己的邮箱。由于自己的博客网站就自己一个人提交，所以就都设置成跟 Github 用户名和邮箱相同了。但其实是可以不同，因为对于很多项目，并不只有一个开发者，Github 允许多人向同一个 Repo 提交，这里提供用户名和邮箱，只是为了搞清楚哪些代码是谁提交的。</p>
<h2 id="7-4Git-与-Github-进行身份验证"><a href="#7-4Git-与-Github-进行身份验证" class="headerlink" title="7.4Git 与 Github 进行身份验证"></a>7.4Git 与 Github 进行身份验证</h2><p>这一整章，我们的最终目的是实现在终端中敲入 hexo deploy （部署本地文件到网站）后，Hexo 会将我们本地的 public 文件夹下的东西上传到 Github 服务器，这样我们就可以通过 <em>your_name.github.io</em> 这个域名（your_name 是你的 Github 用户名）看到我们已经上网的博客网站了。为了实现这个目的，首先我们先要让本地的电脑和 Github 服务器建立起某种联系，也就是让 Github 服务器信任由我这台电脑提交的东西，接受，并存放到 your_name.github.io 这个 Repo 下面，与 Github 服务器建立信任的这个环节就是身份认证（Authenticating ）。根据 Github 的官方文档 <a href="https://help.github.com/articles/set-up-git/#next-steps-authenticating-with-github-from-git">Authenticating with GitHub from Git</a> 这里，我们选择 <a href="https://help.github.com/articles/set-up-git/#connecting-over-ssh">Connecting over SSH</a> 这一种方式。在 Github 的官方文档 <a href="https://help.github.com/categories/ssh/">Categories / SSH</a> 下，我们能找到关于 Github 与 SSH 的资料。</p>
<h3 id="7-4-1-生成新的-SSH-key"><a href="#7-4-1-生成新的-SSH-key" class="headerlink" title="7.4.1 生成新的 SSH key"></a>7.4.1 生成新的 SSH key</h3><p>根据 Github 的官方文档 <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#generating-a-new-ssh-key">Generating a new SSH key</a> ， 我们在 Git Bash 下执行如下命令，生成 SSH key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>其中，<a href="mailto:&#121;&#111;&#x75;&#x72;&#x5f;&#x65;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#121;&#111;&#x75;&#x72;&#x5f;&#x65;&#109;&#97;&#105;&#x6c;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a> 是你的 Github 注册邮箱。然后，Git Bash 中会出现<em>Generating public/private rsa key pair.</em></p>
<p>表示新的 SSH 已经生成了。随后会出现<br><em>Enter file in which to save the key (/c/Users/han/.ssh/id_rsa):</em><br>*Created directory ‘/c/Users/han/.ssh’.*这里 <em>id_rsa</em>是生成的 key 文件的文件名，默认都是这个；如果不是，在后面用到 <em>id_rsa</em> 的地方请替换成出现的名字。这条信息是让你选择 SSH key 存放的地点，按回车选择默认的即可。回车后，还会出现<br><em>Enter passphrase (empty for no passphrase):</em><br><em>Enter same passphrase again:</em><br>让你设置使用 SSH 密钥时的密码，由于我们都是在自己个人的电脑上操作，所以仍然回车，不设置密码即可。<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-2.png"></p>
<h3 id="7-4-2-将-SSH-key-添加到-ssh-agent"><a href="#7-4-2-将-SSH-key-添加到-ssh-agent" class="headerlink" title="7.4.2 将 SSH key 添加到 ssh-agent"></a>7.4.2 将 SSH key 添加到 ssh-agent</h3><p>根据 Wikipedia，ssh-agent 是一个在本地登录会话持续时间内，将未加密的密钥存储在内存中，并使用 Unix 域套接字与 SSH 客户端进行通信的程序。根据 Github 的官方文档 <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent">Adding your SSH key to the ssh-agent</a> ， 我们在 Git Bash 下执行如下命令，开启 ssh-agent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-3.png"></p>
<p>然后我们要将这个 SSH key 添加到 ssh-agent 里去，运行如下命令，其中<em>id_rsa</em> 是你的 key 文件的文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-4.png"></p>
<h3 id="7-4-3-将-SSH-key-添加到-Github-账户"><a href="#7-4-3-将-SSH-key-添加到-Github-账户" class="headerlink" title="7.4.3 将 SSH key 添加到 Github 账户"></a>7.4.3 将 SSH key 添加到 Github 账户</h3><p>Github 的官方文档 <a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/">Adding a new SSH key to your GitHub account</a> 已经图文并茂将如何在 Github<br>帐号中添加 SSH 介绍的非常清楚了。先是在 Git Bash 中将 SSH Key 拷贝出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br><span class="line">$ #Copies the contents of the id_rsa.pub file to your clipboard</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-5.png"><br>id_rsa 是你刚才的 SSH Key 文件。此时，SSH Key 已经在我们的剪切板里了。然后登录 Github 帐号，依次点击自己的头像，Settings，SSH and GPG keys，New SSH key 或者 Add SSH key， 在 Title 这里输入 Key 的label，比如 your_name - PC，然后在 Key 里面把 SSH Key 粘贴进去，点击 Add SSH key 大功告成。<br>我们做了身份认证的凭证 SSH key，分别放在自己本地电脑和 Github 服务器上，以后向 Github 提交内容的时候，两者的 Key 匹配就可以了，不需要每次输密码。</p>
<h3 id="7-4-4-测试-SSH-连接"><a href="#7-4-4-测试-SSH-连接" class="headerlink" title="7.4.4 测试 SSH 连接"></a>7.4.4 测试 SSH 连接</h3><p>在大功告成之前，为了稳妥起见，我们来测试一下自己跟 Github 服务器 SSH 连接是否已经建立起来了。Github 的官方文档 <a href="https://help.github.com/articles/testing-your-ssh-connection/">Testing your SSH connection</a> 将这个环节介绍得非常详细。我们要做得就是在 Git Bash 中敲入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>你可能会看到类似于<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-6.png"><br>没关系，输入 yes 敲回车，就可以看到如下的成功信息了<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-7.png"><br>至此为止，我们已经建立起了跟 Github 服务器的连接。其实我们也可以用 git push 命令，提交 public 文件夹下面的内容，不过 Hexo 更我们提供了更方便的途径。</p>
<h2 id="7-5-Hexo-部署"><a href="#7-5-Hexo-部署" class="headerlink" title="7.5 Hexo 部署"></a>7.5 Hexo 部署</h2><p>Hexo 提供了 hexo deploy 命令，可以方便地将整个 public 文件夹部署到 Github 服务器上去。根据 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/deployment.html">基本操作 — 部署</a> 我们只需要做以下两步：</p>
<h3 id="7-5-1-在终端中运行如下命令，安装-hexo-deployer-git-插件："><a href="#7-5-1-在终端中运行如下命令，安装-hexo-deployer-git-插件：" class="headerlink" title="7.5.1: 在终端中运行如下命令，安装 hexo-deployer-git 插件："></a>7.5.1: 在终端中运行如下命令，安装 hexo-deployer-git 插件：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/7-8.png"></p>
<h3 id="7-5-2-在-config-yml-中修改参数，如下所示："><a href="#7-5-2-在-config-yml-中修改参数，如下所示：" class="headerlink" title="7.5.2: 在 _config.yml 中修改参数，如下所示："></a>7.5.2: 在 _config.yml 中修改参数，如下所示：</h3><p>deploy:<br>    type: git<br>    repo: <a href="https://github.com/simpleai/simpleai.github.io.git">https://github.com/simpleai/simpleai.github.io.git</a><br>    branch: master<br>其中，<em>your_name</em> 是你的 Github 帐号名。repo 对应的是你 <em>your_name.github.io</em> 这个项目的库（Repository）地址，进入这个项目的主页，点击 Clone or download 下拉菜单也能看到。branch 是分支名称，如果使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测，通常都是 master。 注意，repo冒号后的空格非常重要，一定要有！<br>至此，在终端执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<p>就可以把我们的本地文件部署到 Github 服务器上。在第一次部署的时候，Github 还会跳出来一个小窗口，让输入 Github 帐号和密码，输入即可。等待 20分钟的样子，就可以通过 <em>your_name.github.io</em> （your_name 是你的 Github 用户名）来访问自己的网站了。</p>
<h1 id="8-独立域名与GitHub域名绑定"><a href="#8-独立域名与GitHub域名绑定" class="headerlink" title="8.独立域名与GitHub域名绑定"></a>8.独立域名与GitHub域名绑定</h1><h2 id="8-1阿里云购买域名"><a href="#8-1阿里云购买域名" class="headerlink" title="8.1阿里云购买域名"></a>8.1阿里云购买域名</h2><h2 id="8-2解析域名"><a href="#8-2解析域名" class="headerlink" title="8.2解析域名"></a>8.2解析域名</h2><p>在cmd命令框中ping自己的博客网址(联网状态下)，ping yourname.github.io如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping simpleai.github.io</span><br></pre></td></tr></table></figure>
<p>得到数字地址如：151.101.73.147<br>在域名解析中添加两条记录：我这里设置了一个三级域名blog，<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8-1.png"><br>www 指定的记录是你在 github 创建的仓库。<br>如博客不能登录，有可能是 github 更改了空间服务的 ip 地址，记得及时查看最新的ip即可</p>
<h2 id="8-3更改博客对应的域名"><a href="#8-3更改博客对应的域名" class="headerlink" title="8.3更改博客对应的域名"></a>8.3更改博客对应的域名</h2><p>点击右上角Settings<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8-2.png"><br>更改并保存自己的域名<br><img src="Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/8-3.png"></p>
<h1 id="以后如何写博客，提供两种方法"><a href="#以后如何写博客，提供两种方法" class="headerlink" title="以后如何写博客，提供两种方法"></a>以后如何写博客，提供两种方法</h1><h2 id="1-在当初建的博客站点文件夹下的source-posts目录下，建立-md文件，一个md文件对应一篇博客文章。"><a href="#1-在当初建的博客站点文件夹下的source-posts目录下，建立-md文件，一个md文件对应一篇博客文章。" class="headerlink" title="1.在当初建的博客站点文件夹下的source\ _posts目录下，建立.md文件，一个md文件对应一篇博客文章。"></a>1.在当初建的博客站点文件夹下的source\ _posts目录下，建立.md文件，一个md文件对应一篇博客文章。</h2><p>写好之后在你博客站点文件夹下右键空白处，选择Git Bash Here，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态页面，再输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>然后到localhost:4000预览博客效果，<br>最后输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>同步到github上去就行了。</p>
<h2 id="2-使用在线使用CSDN的markdown编辑器"><a href="#2-使用在线使用CSDN的markdown编辑器" class="headerlink" title="2.使用在线使用CSDN的markdown编辑器"></a>2.使用在线使用CSDN的markdown编辑器</h2><p>注册登录CSDN，更改设置，使用Markdown编辑器。<br>编辑好文章后导出文件，复制到source\ _posts目录下，之后操作同1。</p>
<h1 id="文章乱码问题"><a href="#文章乱码问题" class="headerlink" title="文章乱码问题"></a>文章乱码问题</h1><p>以txt方式打开文件，然后另存为的时候，以utf-8的编码格式保存。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客百度收录</title>
    <url>/2018/04/16/%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<p>注意：提交博客域名到百度，等待的时间比较长。错误{“error”:401,”message”:”site error”}解决方法。</p>
<span id="more"></span>
<h1 id="向百度提交信息"><a href="#向百度提交信息" class="headerlink" title="向百度提交信息"></a>向百度提交信息</h1><p>1登录<a href="https://ziyuan.baidu.com/linksubmit">百度站长管理</a>，移动鼠标到网站支持，点击下边的链接提交。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1-1.png"><br>2按步骤提交网址<br>3验证。三种验证方式CNAME验证最简单。去域名管理处在网址解析添加一条记录。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1-2.png"><br>3拿到token。<br><img src="hexo%E5%8D%9A%E5%AE%A2%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/1-3.png"><br>4进入根目录的配置文件，新增以下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 ## 提交最新的一个链接</span><br><span class="line">  host: www.blog.xiaoruiit.com ## 在百度站长平台中注册的域名</span><br><span class="line">  token: H4KSennR803cks3C ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>
<p>记得查看URL,如果是<a href="http://yoursite.com/child%EF%BC%8C%E4%BF%AE%E6%94%B9%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E5%9D%80%E3%80%82">http://yoursite.com/child，修改为自己的网址。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: http://www.blog.xiaoruiit.com</span><br></pre></td></tr></table></figure>

<p>新加deploy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  #type: git 之前的</span><br><span class="line">  bucket: blog.xiaoruiit.com</span><br><span class="line">  type: baidu_url_submitter 现在的</span><br></pre></td></tr></table></figure>
<p>需要等待很长时间，可能十几天。</p>
<p>输入命令<code>hexo g,hexo d</code>成功提示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;remain&quot;:4999993,&quot;success&quot;:1,&quot;not_same_site&quot;:[&quot;http://www.blog.xiaoruiit.com/hexo博客百度收录.html/&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>remain:剩余可提交链接数量。success：成功提交链接数量</p>
<h1 id="出现错误-“error”-401-”message”-”site-error”-："><a href="#出现错误-“error”-401-”message”-”site-error”-：" class="headerlink" title="出现错误{“error”:401,”message”:”site error”}："></a>出现错误{“error”:401,”message”:”site error”}：</h1><p>输入命令<code>hexo d</code>出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;error&quot;:401,&quot;message&quot;:&quot;site error&quot;&#125;</span><br><span class="line">INFO  Deploy done: baidu_url_submitter</span><br></pre></td></tr></table></figure>
<p>请检查配置中的域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 </span><br><span class="line">  host: blog.xiaoruiit.com #没有www的域名请不要添加www</span><br><span class="line">  token: H4KSen*****cks3C </span><br><span class="line">  path: baidu_urls.txt</span><br></pre></td></tr></table></figure>
<h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git #提交给GitHub</span><br><span class="line">  bucket: blog.xiaoruiit.com</span><br><span class="line">  #type: baidu_url_submitter #提交给baidu</span><br></pre></td></tr></table></figure>
<p> 提交到GitHub和baidu需要来回切换</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>百度收录</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo来必力评论+learncloud统计访客</title>
    <url>/2018/04/15/%E5%8D%9A%E5%AE%A2/hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/</url>
    <content><![CDATA[<p>韩国来必力评论+learncloud统计阅读次数</p>
<span id="more"></span>
<h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><h2 id="1注册来必力"><a href="#1注册来必力" class="headerlink" title="1注册来必力"></a>1注册来必力</h2><p><a href="https://livere.com/">来必力官网</a></p>
<h2 id="2去管理页面"><a href="#2去管理页面" class="headerlink" title="2去管理页面"></a>2去管理页面</h2><p>点击右上边的小头像，点击管理页面</p>
<h2 id="3安装免费版"><a href="#3安装免费版" class="headerlink" title="3安装免费版"></a>3安装免费版</h2><p>很快，只需要点免费即可，并不会在电脑上安装东西。</p>
<h2 id="4设置网页链接"><a href="#4设置网页链接" class="headerlink" title="4设置网页链接"></a>4设置网页链接</h2><p>url:为自己的域名。名称不重要。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-1.png"></p>
<h2 id="5获取id"><a href="#5获取id" class="headerlink" title="5获取id"></a>5获取id</h2><p>一般网站中在代码中找data-uid后””中的内容<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-2.png"></p>
<h2 id="6修改主题配置文件"><a href="#6修改主题配置文件" class="headerlink" title="6修改主题配置文件"></a>6修改主题配置文件</h2><p>找到livere_uid:(可能被注释，去掉前边的#)将获取到的id粘贴到这。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-3.png"><br>成功效果图：<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/1-4.png"></p>
<h1 id="统计文章阅读次数"><a href="#统计文章阅读次数" class="headerlink" title="统计文章阅读次数"></a>统计文章阅读次数</h1><h2 id="1注册leancloud"><a href="#1注册leancloud" class="headerlink" title="1注册leancloud"></a>1注册leancloud</h2><p>点击<a href="https://leancloud.cn/">leancloud</a>。注册好账号。</p>
<h2 id="2创建应用"><a href="#2创建应用" class="headerlink" title="2创建应用"></a>2创建应用</h2><p><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/2-1.png"></p>
<h2 id="3创建class"><a href="#3创建class" class="headerlink" title="3创建class"></a>3创建class</h2><p>class名称为Counter，选择限制写入，点击创建。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/2-2.png"></p>
<h2 id="4获取key"><a href="#4获取key" class="headerlink" title="4获取key"></a>4获取key</h2><p>依次点击设置→应用key。找到App ID和App Key。<br><img src="hexo%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA+learncloud%E7%BB%9F%E8%AE%A1%E8%AE%BF%E5%AE%A2/2-3.png"></p>
<h2 id="5修改next主题设置"><a href="#5修改next主题设置" class="headerlink" title="5修改next主题设置"></a>5修改next主题设置</h2><p>找到next目录下的_config文件，修改enable，将刚才获取的app_id和app_key粘贴到此处对应位置。注意留下空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: S5VAuYJ1Iw******k8a4FHBc-gzGzoHsz</span><br><span class="line">  app_key: 4uuoVMQeq******7xwgWjGat</span><br></pre></td></tr></table></figure>
<p>可以了。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>评论</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客！</title>
    <url>/2018/04/11/%E5%8D%9A%E5%AE%A2/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<pre><code>欢迎来到我的博客！
    一直想要开通一个属于自己的博客，以前只是模糊的觉得这个东西好，并且在建立的过程遇到些困难就放弃了。
现在我想要用它整理分享自己学到的东西，表达生活中的所想所悟。随后会发自己建立博客的过程。欢迎大家常来交
流评论。
</code></pre>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>重新搭建博客</title>
    <url>/2020/06/12/%E5%8D%9A%E5%AE%A2/%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>重新搭建博客，hexo版本太低无法使用。升级过程中重新搭建。</p>
<span id="more"></span>

<h1 id="重新搭建博客"><a href="#重新搭建博客" class="headerlink" title="重新搭建博客"></a>重新搭建博客</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>hexo: 5.4.0</p>
<p>node: 12.22.1</p>
<p>npm: 7.16.0</p>
<h2 id="重搭步骤"><a href="#重搭步骤" class="headerlink" title="重搭步骤"></a>重搭步骤</h2><p>备份simpleai.github.io文件夹</p>
<p>删除simpleai.github.io文件夹内的文件</p>
<p>卸载node.js</p>
<p>安装12.22.1node.js</p>
<p>simpleai.github.io文件夹进入git的bash命令</p>
<p>安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>测试博客效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>下载next主题，解压到themes文件夹中，重命名为next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># next换了地址</span><br><span class="line">https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>

<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo 的 _config.yml</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># next 的_config.yml</span><br><span class="line"># scheme: Muse</span><br><span class="line">scheme: Gemini # 修改主题样式</span><br></pre></td></tr></table></figure>

<h3 id="修改hexo首页信息"><a href="#修改hexo首页信息" class="headerlink" title="修改hexo首页信息"></a>修改hexo首页信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Go after </span><br><span class="line">subtitle: </span><br><span class="line">description: 技术融于生活</span><br><span class="line">keywords:</span><br><span class="line">author: 追逐</span><br><span class="line">language: zh-CN # 解决菜单栏乱码 next的_config.yml配置tags后</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: http://blog.xiaoruiit.com</span><br><span class="line"></span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 5 # 每一页显示几条</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure>

<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>分类、标签、关于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page about</span><br><span class="line"># 修改 source下的各个文件下的index.md文件内容</span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2021-06-11 06:53:07</span><br><span class="line">type: &quot;categories&quot; categories文件夹添加本行。其他两个类似</span><br><span class="line">---</span><br><span class="line"># 修改next 下_config.yml</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>hexo配置文件<code>&lt;blog_root&gt;/_config.yml</code>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Configration for Theme-Next</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure>

<p>修改hexo-next配置文件 <code>&lt;next_root&gt;/_config.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h3 id="底部协议，评论，文字统计和阅读时长-阅读次数统计"><a href="#底部协议，评论，文字统计和阅读时长-阅读次数统计" class="headerlink" title="底部协议，评论，文字统计和阅读时长,阅读次数统计"></a>底部协议，评论，文字统计和阅读时长,阅读次数统计</h3><p>协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># next config.yml</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa 4.0</span><br><span class="line">  sidebar: true # 开启</span><br><span class="line">  post: true # 开启</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<p>来必力评论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># next的config.yml</span><br><span class="line">livere_uid: MTAyMC8******8xMjI0MA==</span><br></pre></td></tr></table></figure>

<p>文字统计和阅读时长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>阅读次数统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># leancloud</span><br><span class="line"># leancloud原应用停用，实名认证+手机号验证+发帖请求解封1天后可用</span><br><span class="line"># next的 config.yml</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: S5VAuYJ1Iwl*************-gzGzoHsz</span><br><span class="line">  app_key: 4uuo************gWjGat</span><br></pre></td></tr></table></figure>

<p>去除站点统计次数、时间</p>
<p>\themes\next\layout_partials\footer.swig</p>
<p>删除错误统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if config.symbols_count_time.total_symbols %&#125;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-chart-area&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title=&quot;&#123;&#123; __(&#x27;symbols_count_time.count_total&#x27;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsCountTotal(site) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;%- if config.symbols_count_time.total_time %&#125;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-coffee&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;%- if theme.symbols_count_time.item_text_total %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125; &amp;asymp;&lt;/span&gt;</span><br><span class="line">    &#123;%- endif %&#125;</span><br><span class="line">    &lt;span title=&quot;&#123;&#123; __(&#x27;symbols_count_time.time_total&#x27;) &#125;&#125;&quot;&gt;&#123;&#123; symbolsTimeTotal(site, config.symbols_count_time.awl, config.symbols_count_time.wpm, __(&#x27;symbols_count_time.time_minutes&#x27;)) &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p>文章访问次数统计leancloud</p>
<ol>
<li><p>申请账号</p>
</li>
<li><p>创建应用</p>
</li>
<li><p>域名绑定（2021.10.1之后不绑定可能不再提供服务）</p>
<ol>
<li><p>leancloud配置，配置域名后会检查备案信息，需等待</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IGLCnxia2Z68fyT.png" alt="image-20210829181327021"></p>
</li>
<li><p>域名解析</p>
<p>阿里云：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SR4WrZ1UBpdslAa.png" alt="image-20210829183606728"></p>
<p>leancloud显示</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ox9Ewr8uSaPObZW.png" alt="image-20210829183709552"></p>
</li>
</ol>
</li>
<li><p>next的_config.yml 设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: S5VA*****************zGzoHsz</span><br><span class="line">  app_key: 4u*********************WjGat</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>next _config.yml 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  #comment: Donate comment here.</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png</span><br><span class="line">  alipay: /images/alipay.png</span><br></pre></td></tr></table></figure>

<p>图片放到 /themes/next/source/images 下</p>
<h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><p>建立ssh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;simpleintelligence@qq.com&quot; #生成key</span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">ssh-add ~/.ssh/id_rsa # 将key放到本地电脑</span><br><span class="line">clip &lt; ~/.ssh/id_rsa.pub # 复制ssh key </span><br><span class="line"></span><br><span class="line"># 登录 Github 帐号，依次点击自己的头像，Settings，SSH and GPG keys，New SSH key 或者 Add SSH key， 在 Title 这里输入 Key 的label，比如 your_name - PC，然后在 Key 里面把 SSH Key 粘贴进去，点击 Add SSH key 大功告成。</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">ssh -T git@github.com # 输入enter+yes，看到 Hi simpleai! You&#x27;ve successfully authenticated...</span><br></pre></td></tr></table></figure>



<p>source文件夹下添加一个文件<code>CNAME</code></p>
<p>内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog.xiaoruiit.com</span><br></pre></td></tr></table></figure>

<p>安装hexo-deployer-git插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>修改_config.yml参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/simpleai/simpleai.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>部署报错<code>spawn failed</code></p>
<p>解决1：刪除博客文件夹下的.deploy_git，重启电脑。重新执行<code>hexo d</code>。</p>
<p>解決2：可能是分支代码冲突，参考：<a href="https://www.jianshu.com/p/504fdfb31081%EF%BC%8C%E6%9C%AA%E6%B5%8B%E8%AF%95%E3%80%82">https://www.jianshu.com/p/504fdfb31081，未测试。</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），站点的更改无论如何也不生效</span><br><span class="line">$ hexo generate # 生成静态文件，该命令可以简写为 $ hexo g</span><br><span class="line">$ hexo server # 启动服务器，http://localhost:4000/</span><br><span class="line">$ hexo deploy # 部署网站，推送到github。该命令可以简写为 $ hexo d您可能需要运行该命令</span><br><span class="line"></span><br><span class="line">$ hexo init [folder] # 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站</span><br><span class="line">$ hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout ，默认使用 _config.yml 中的 default_layout 参数代替</span><br><span class="line">$ hexo render &lt;file1&gt; [file2] ... # 渲染文件</span><br><span class="line">$ hexo list &lt;type&gt; # 列出网站资料</span><br><span class="line">$ hexo publish [layout] # &lt;filename&gt; 发表草稿</span><br><span class="line">$ hexo version # 显示 Hexo 版本</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>重新部署博客</title>
    <url>/2023/03/29/%E5%8D%9A%E5%AE%A2/%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>修改图片地址，重新部署博客</p>
<span id="more"></span>

<h1 id="重新部署博客"><a href="#重新部署博客" class="headerlink" title="重新部署博客"></a>重新部署博客</h1><ol>
<li>博客内容路径<code>F:\simpleai.github.io\source\_posts</code>，修改博客中图片地址</li>
<li>在<code>F:\simpleai.github.io</code>进入git bash</li>
<li>执行<code>hexo clean</code></li>
<li>执行<code>hexo g</code></li>
<li>执行<code>hexo s</code>，浏览器打开<code>localhost:4000</code>查看效果</li>
<li>执行<code>hexo d</code></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>执行hexo d</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">SHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /c/Users/han/.ssh/known_hosts to get rid of this message</span><br><span class="line">Offending RSA key in /c/Users/han/.ssh/known_hosts:1</span><br><span class="line">Host key for github.com has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (F:\simpleai.github.io\node_modules\hexo-util\1:21)</span><br><span class="line">      at ChildProcess.emit (events.js:314:20)</span><br><span class="line">      at ChildProcess.cp.emit (F:\simpleai.github.io\node_modules\cross-spawn\li:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:276:12)</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/doting.html</span><br></pre></td></tr></table></figure>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li><p>生成 SSH 密钥对。在命令行中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>其中 “<a href="mailto:your_email@example.com">your_email@example.com</a>“ 是您的 GitHub 账号注册时所用的邮箱地址。接着按照提示输入文件保存路径和密码等信息，或者直接按 Enter 使用默认选项。该命令将生成一个公钥文件和一个私钥文件。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230329232952423.png" alt="image-20230329232952423"></p>
</li>
<li><p>将公钥添加到 GitHub 帐户。GitHub 网站依次单击 “Settings”，”SSH and GPG  keys” 和 “New SSH key” 按钮。在 “Title” 字段中输入一个有意义的标识，例如 “My Hexo Blog SSH  Key”，然后将公钥复制到 “Key” 字段中。最后单击 “Add SSH key” 按钮以将公钥添加到您的 GitHub 帐户中。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230329233151828.png" alt="image-20230329233151828"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20230329233247637.png" alt="image-20230329233247637"></p>
</li>
<li><p>在 Hexo 博客的配置文件中指定 SSH URL。打开 Hexo 博客的根目录，找到 <code>F:\simpleai.github.io\_config.yml</code> 文件并打开它。在文件中找到以下行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # repo: https://github.com/simpleai/simpleai.github.io.git # 代表https协议</span><br><span class="line">  repo: git@github.com:simpleai/simpleai.github.io.git # 代表ssh协议</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>将私钥添加到 SSH 代理。为了使 Git 能够使用您的 SSH 私钥进行认证，您需要将私钥添加到 SSH 代理中。在命令行中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p>如果提示<code>Could not open a connection to your authentication agent.</code>意味着 SSH 代理没有启动。</p>
<ol>
<li><p>先执行<code>eval &quot;$(ssh-agent -s)&quot;</code>,启动ssh代理</p>
</li>
<li><p>再执行<code>ssh-add ~/.ssh/id_ed25519</code></p>
</li>
<li><p>输入 <code>ssh-add -l</code> 命令可以检查您的 SSH 密钥是否已添加到代理中，显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4096 SHA256:abc123... my_key_name (RSA)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>执行 <code>hexo d</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA-EasyCode使用</title>
    <url>/2021/06/10/%E5%B7%A5%E5%85%B7/IDEA-EasyCode/</url>
    <content><![CDATA[<p>IDEA-EasyCode使用</p>
<span id="more"></span>
<h1 id="IDEA-EasyCode使用"><a href="#IDEA-EasyCode使用" class="headerlink" title="IDEA-EasyCode使用"></a>IDEA-EasyCode使用</h1><p>一键生成单表后端代码，包括entity,controller,service,serviceImpl,dao,mapper</p>
<h2 id="1-安装idea插件"><a href="#1-安装idea插件" class="headerlink" title="1.安装idea插件"></a>1.安装idea插件</h2><ol>
<li>打开设置中的<code>plugins</code></li>
<li>搜索安装<code>EasyCode</code><ul>
<li>版本： <code>v1.2.3-RELEASE</code></li>
</ul>
</li>
<li>搜索安装<code>lombok</code></li>
<li>重启<code>idea</code></li>
</ol>
<h2 id="2-使用Database连接数据库"><a href="#2-使用Database连接数据库" class="headerlink" title="2.使用Database连接数据库"></a>2.使用Database连接数据库</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tQeLBPh9gC8jb2U.png" alt="image-20201219135638858"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>连接中多个数据库的，在Database中指定数据库</li>
<li>修改数据库字段后，需同步表。右击表，点击<code>synchronize</code></li>
</ul>
<h2 id="3-EasyCode生成代码"><a href="#3-EasyCode生成代码" class="headerlink" title="3.EasyCode生成代码"></a>3.EasyCode生成代码</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WoSlC9bfeBxE4wp.png" alt="image-20201219135505403"></p>
<h3 id="自定义模板配置"><a href="#自定义模板配置" class="headerlink" title="自定义模板配置"></a>自定义模板配置</h3><h4 id="Type-Mapper"><a href="#Type-Mapper" class="headerlink" title="Type Mapper"></a>Type Mapper</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XzNDSKAaQtl7Hrf.png" alt="image-20201219141100298"></p>
<h4 id="Template-Setting"><a href="#Template-Setting" class="headerlink" title="Template Setting"></a>Template Setting</h4><h4 id="Table-Editor-Config"><a href="#Table-Editor-Config" class="headerlink" title="Table Editor Config"></a>Table Editor Config</h4><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/VvLzBsEH7rxlZOo.png" alt="image-20201219143546075"></p>
<h5 id="entity-java"><a href="#entity-java" class="headerlink" title="entity.java"></a>entity.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##使用宏定义设置回调（保存位置与文件后缀）</span><br><span class="line">#save(&quot;/entity&quot;, &quot;.java&quot;)</span><br><span class="line"></span><br><span class="line">##使用宏定义设置包后缀</span><br><span class="line">#setPackageSuffix(&quot;entity&quot;)</span><br><span class="line"></span><br><span class="line">##使用全局变量实现默认包导入</span><br><span class="line">$!autoImport</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;实体类&quot;)</span><br><span class="line">@Data</span><br><span class="line">@ApiModel</span><br><span class="line">public class $!&#123;tableInfo.name&#125; implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = $!tool.serial();</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line"></span><br><span class="line">    #if($&#123;column.comment&#125;)@ApiModelProperty(value = &quot;$&#123;column.comment&#125;&quot;)</span><br><span class="line">    #end</span><br><span class="line">private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#*#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">##使用宏定义实现get,set方法</span><br><span class="line">#getSetMethod($column)</span><br><span class="line">#end*#</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="dao-java"><a href="#dao-java" class="headerlink" title="dao.java"></a>dao.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Dao&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/dao&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;dao;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import org.apache.ibatis.annotations.Param;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表数据库访问层&quot;)</span><br><span class="line">public interface $!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过实体作为筛选条件查询</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 对象列表</span><br><span class="line">     */</span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryAll($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 影响行数</span><br><span class="line">     */</span><br><span class="line">    int deleteById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="service-java"><a href="#service-java" class="headerlink" title="service.java"></a>service.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Service&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/service&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表服务接口&quot;)</span><br><span class="line">public interface $!&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    $!&#123;tableInfo.name&#125; update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 是否成功</span><br><span class="line">     */</span><br><span class="line">    boolean deleteById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="serviceImpl-java"><a href="#serviceImpl-java" class="headerlink" title="serviceImpl.java"></a>serviceImpl.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;ServiceImpl&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/service/impl&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.dao.$!&#123;tableInfo.name&#125;Dao;</span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表服务实现类&quot;)</span><br><span class="line">@Service(&quot;$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Service&quot;)</span><br><span class="line">public class $!&#123;tableName&#125; implements $!&#123;tableInfo.name&#125;Service &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private $!&#123;tableInfo.name&#125;Dao $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Dao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过ID查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name) &#123;</span><br><span class="line">        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.queryById($!pk.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 新增数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public $!&#123;tableInfo.name&#125; insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;</span><br><span class="line">        this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.insert($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">        return $!tool.firstLowerCase($!&#123;tableInfo.name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line">     * @return 实例对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public $!&#123;tableInfo.name&#125; update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;</span><br><span class="line">        this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.update($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">        return this.queryById($!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;.get$!tool.firstUpperCase($pk.name)());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键删除数据</span><br><span class="line">     *</span><br><span class="line">     * @param $!pk.name 主键</span><br><span class="line">     * @return 是否成功</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean deleteById($!pk.shortType $!pk.name) &#123;</span><br><span class="line">        return this.$!&#123;tool.firstLowerCase($!&#123;tableInfo.name&#125;)&#125;Dao.deleteById($!pk.name) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="controller-java"><a href="#controller-java" class="headerlink" title="controller.java"></a>controller.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">#set($tableName = $tool.append($tableInfo.name, &quot;Controller&quot;))</span><br><span class="line">##设置回调</span><br><span class="line">$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/controller&quot;))</span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;controller;</span><br><span class="line"></span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">import $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;表控制层&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;$!tool.firstLowerCase($tableInfo.name)&quot;)</span><br><span class="line">public class $!&#123;tableName&#125; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 服务对象</span><br><span class="line">     */</span><br><span class="line">    @Resource</span><br><span class="line">    private $!&#123;tableInfo.name&#125;Service $!tool.firstLowerCase($tableInfo.name)Service;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过主键查询单条数据</span><br><span class="line">     *</span><br><span class="line">     * @param id 主键</span><br><span class="line">     * @return 单条数据</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;selectOne&quot;)</span><br><span class="line">    public $!&#123;tableInfo.name&#125; selectOne($!pk.shortType id) &#123;</span><br><span class="line">        return this.$!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入mybatis支持</span><br><span class="line">$!mybatisSupport</span><br><span class="line"></span><br><span class="line">##设置保存名称与保存位置</span><br><span class="line">$!callback.setFileName($tool.append($!&#123;tableInfo.name&#125;, &quot;Dao.xml&quot;))</span><br><span class="line">$!callback.setSavePath($tool.append($modulePath, &quot;/src/main/resources/mapper&quot;))</span><br><span class="line"></span><br><span class="line">##拿到主键</span><br><span class="line">#if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;$!&#123;tableInfo.savePackageName&#125;.dao.$!&#123;tableInfo.name&#125;Dao&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;$!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;&quot;&gt;</span><br><span class="line">        &lt;!--@Table $!&#123;tableInfo.originTableName&#125;--&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">        &lt;result property=&quot;$!column.name&quot; column=&quot;$!column.obj.name&quot; jdbcType=&quot;$!column.ext.jdbcType&quot;/&gt;</span><br><span class="line">#end</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--查询单个--&gt;</span><br><span class="line">    &lt;select id=&quot;queryById&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">          #allSqlColumn()</span><br><span class="line"></span><br><span class="line">        from $!&#123;tableInfo.obj.parent.name&#125;.$!tableInfo.obj.name</span><br><span class="line">        where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过实体作为筛选条件查询--&gt;</span><br><span class="line">    &lt;select id=&quot;queryAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">          #allSqlColumn()</span><br><span class="line"></span><br><span class="line">        from $!&#123;tableInfo.obj.parent.name&#125;.$!tableInfo.obj.name</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                and $!column.obj.name = #&#123;$!column.name&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--新增所有列--&gt;</span><br><span class="line">    &lt;insert id=&quot;insert&quot; keyProperty=&quot;$!pk.name&quot; useGeneratedKeys=&quot;true&quot;&gt;</span><br><span class="line">        insert into $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125;(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#if($velocityHasNext), #end#end)</span><br><span class="line">        values (#foreach($column in $tableInfo.otherColumn)#&#123;$!&#123;column.name&#125;&#125;#if($velocityHasNext), #end#end)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键修改数据--&gt;</span><br><span class="line">    &lt;update id=&quot;update&quot;&gt;</span><br><span class="line">        update $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">#foreach($column in $tableInfo.otherColumn)</span><br><span class="line">            &lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != &#x27;&#x27;#end&quot;&gt;</span><br><span class="line">                $!column.obj.name = #&#123;$!column.name&#125;,</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">#end</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">        where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通过主键删除--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteById&quot;&gt;</span><br><span class="line">        delete from $!&#123;tableInfo.obj.parent.name&#125;.$!&#123;tableInfo.obj.name&#125; where $!pk.obj.name = #&#123;$!pk.name&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="RespVO-java"><a href="#RespVO-java" class="headerlink" title="RespVO.java"></a>RespVO.java</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line">$!define</span><br><span class="line"></span><br><span class="line">##使用宏定义设置回调（保存位置与文件后缀）</span><br><span class="line">#save(&quot;/entity/vo&quot;, &quot;RespVO.java&quot;)</span><br><span class="line"></span><br><span class="line">##使用宏定义设置包后缀</span><br><span class="line">#setPackageSuffix(&quot;entity.vo&quot;)</span><br><span class="line"></span><br><span class="line">##使用全局变量实现默认包导入</span><br><span class="line">$!autoImport</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment(&quot;返回传输类&quot;)</span><br><span class="line">@Data</span><br><span class="line">@ApiModel</span><br><span class="line">public class $!&#123;tableInfo.name&#125;RespVO implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = $!tool.serial();</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line"></span><br><span class="line">    #if($&#123;column.name&#125; != &quot;isDel&quot; &amp;&amp; $&#123;column.name&#125; != &quot;creator&quot; &amp;&amp; $&#123;column.name&#125; != &quot;createTime&quot; &amp;&amp; $&#123;column.name&#125; != &quot;modifier&quot; &amp;&amp; $&#123;column.name&#125; != &quot;modifiTime&quot;)</span><br><span class="line">    #if($&#123;column.comment&#125;)@ApiModelProperty(value = &quot;$&#123;column.comment&#125;&quot;)</span><br><span class="line">    #end</span><br><span class="line">    private $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">    #end</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Global-Config"><a href="#Global-Config" class="headerlink" title="Global Config"></a>Global Config</h4><h5 id="mybatisSupport"><a href="#mybatisSupport" class="headerlink" title="mybatisSupport"></a>mybatisSupport</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##针对Mybatis 进行支持，主要用于生成xml文件</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">    ##储存列类型</span><br><span class="line">    $tool.call($column.ext.put(&quot;sqlType&quot;, $tool.getField($column.obj.dataType, &quot;typeName&quot;)))</span><br><span class="line">    #if($tool.newHashSet(&quot;java.lang.String&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;VARCHAR&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Boolean&quot;, &quot;boolean&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;BOOLEAN&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Byte&quot;, &quot;byte&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;TINYINT&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Integer&quot;, &quot;int&quot;, &quot;java.lang.Short&quot;, &quot;short&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;INTEGER&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Long&quot;, &quot;long&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;BIGINT&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.lang.Float&quot;, &quot;float&quot;, &quot;java.lang.Double&quot;, &quot;double&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;NUMERIC&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.sql.Date&quot;, &quot;java.time.LocalDateTime&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;TIMESTAMP&quot;)</span><br><span class="line">    #elseif($tool.newHashSet(&quot;java.math.BigDecimal&quot;).contains($column.type))</span><br><span class="line">        #set($jdbcType=&quot;DECIMAL&quot;)</span><br><span class="line">    #else</span><br><span class="line">        ##其他类型</span><br><span class="line">        #set($jdbcType=&quot;OTHER&quot;)</span><br><span class="line">    #end</span><br><span class="line">    $tool.call($column.ext.put(&quot;jdbcType&quot;, $jdbcType))</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">##定义宏，查询所有列</span><br><span class="line">#macro(allSqlColumn)#foreach($column in $tableInfo.fullColumn)$column.obj.name#if($velocityHasNext), #end#end#end</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>EasyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA导入Eclipse项目</title>
    <url>/2019/05/31/%E5%B7%A5%E5%85%B7/IDEA%E5%AF%BC%E5%85%A5Eclipse%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>IDEA导入Eclipse项目</p>
<span id="more"></span>
<p>背景：网上有很多教程，看了很多博客自己导入时有其他问题，在一个博客基础上做了完善。<a href="https://blog.csdn.net/zeal9s/article/details/90690524">https://blog.csdn.net/zeal9s/article/details/90690524</a><br>版本：2018.3.3</p>
<h2 id="1-新建一个文件夹-idea打开这个空文件夹"><a href="#1-新建一个文件夹-idea打开这个空文件夹" class="headerlink" title="1.新建一个文件夹,idea打开这个空文件夹"></a>1.新建一个文件夹,idea打开这个空文件夹</h2><h2 id="2-将项目导入"><a href="#2-将项目导入" class="headerlink" title="2.将项目导入"></a>2.将项目导入</h2><p><img src="https://img-blog.csdnimg.cn/2020033115122176.png" alt="如图"><img src="https://img-blog.csdnimg.cn/20200331151331941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="点击OK"><img src="https://img-blog.csdnimg.cn/20200331151359494.png" alt="点击next"><br><img src="https://img-blog.csdnimg.cn/20200331151711595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="点击next"><img src="https://img-blog.csdnimg.cn/20200331151737354.png" alt="点击next"><img src="https://img-blog.csdnimg.cn/20200331151758837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="点击next"><img src="https://img-blog.csdnimg.cn/20200331151844698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="选择jdk">  </p>
<h2 id="3-等待编译完成"><a href="#3-等待编译完成" class="headerlink" title="3.等待编译完成"></a>3.等待编译完成</h2><p><img src="https://img-blog.csdnimg.cn/20200331154433717.png" alt="在这里插入图片描述"></p>
<h2 id="4-配置项目环境"><a href="#4-配置项目环境" class="headerlink" title="4.配置项目环境"></a>4.配置项目环境</h2><p><img src="https://img-blog.csdnimg.cn/2020033115470628.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331154756856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331154958297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155059452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155313320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155401258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331155457908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包"><a href="#5-小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包" class="headerlink" title="5.小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包"></a>5.小问题：我导入项目时，idea自动导入了项目存在的jar包，但少导入了几个，我手动添加了少导入对的jar包</h2><p><img src="https://img-blog.csdnimg.cn/20200331155812848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200331155737577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-配置Tomcat"><a href="#6-配置Tomcat" class="headerlink" title="6.配置Tomcat"></a>6.配置Tomcat</h2><p><img src="https://img-blog.csdnimg.cn/20200331160106981.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160140962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160201840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160245239.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331160357364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="7-重新编译项目，编译完成后启动项目"><a href="#7-重新编译项目，编译完成后启动项目" class="headerlink" title="7.重新编译项目，编译完成后启动项目"></a>7.重新编译项目，编译完成后启动项目</h2><p><img src="https://img-blog.csdnimg.cn/20200331161455184.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200331161508831.png" alt="在这里插入图片描述"></p>
<h2 id="8-注意tomcat引入jar包的配置"><a href="#8-注意tomcat引入jar包的配置" class="headerlink" title="8.注意tomcat引入jar包的配置"></a>8.注意tomcat引入jar包的配置</h2><p>我自己在这出错了。之前tomcat中的包和项目包有冲突，我只引入了tomcat中的两个包，导入这个项目时，项目又缺少了tomcat中包含的包，就把tomcat中的包都导入了<br><img src="https://img-blog.csdnimg.cn/20200331160801302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-入门</title>
    <url>/2020/11/11/212Java%E8%AF%AD%E8%A8%80/JVM/JVM-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>JVM-入门</p>
<span id="more"></span>

<h1 id="JVM-入门"><a href="#JVM-入门" class="headerlink" title="JVM-入门"></a>JVM-入门</h1><p>类加载器，内存空间，垃圾收集器。</p>
<p>内存空间：方法区，堆，栈。</p>
<h2 id="堆、栈、方法区"><a href="#堆、栈、方法区" class="headerlink" title="堆、栈、方法区"></a>堆、栈、方法区</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>存放由new创建的对象和数组。堆中分配的内存，由java虚拟机自动垃圾回收器来管理。</p>
<p>根据垃圾回收机制的不同，Java堆有可能拥有不同的结构。最为常见的就是将整个Java堆分为<br> 新生代和老年代。</p>
<h4 id="参数调节"><a href="#参数调节" class="headerlink" title="参数调节"></a>参数调节</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC 每次触发GC的时候打印相关日志</span><br><span class="line">-XX:+UseSerialGC 串行回收</span><br><span class="line">-XX:+PrintGCDetails 更详细的GC日志</span><br><span class="line"></span><br><span class="line">-Xms 堆初始值</span><br><span class="line">-Xmx 堆最大可用值</span><br><span class="line">-Xmn 新生代堆最大可用值</span><br><span class="line">-XX:NewRatio 新生代与老年代的比例 例如： –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</span><br><span class="line">-XX:SurvivorRatio 用来设置新生代中 Eden 与 Survivor 的比值</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms 5m -Xmx 20m -XX:+PrintGCDetails -XX:+UseSerialGC -XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>Java栈是一块线程私有的空间，一个栈，一般由三部分组成:局部变量表、操作数据栈和帧数据区。</p>
<h3 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h3><p>Java方法区和堆一样，方法区是一块所有线程共享的内存区域，他保存系统的类信息。<br> 比如类的字段、方法、常量池等。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>FullGC:年老代的回收</p>
<h2 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h2><h3 id="调优目标"><a href="#调优目标" class="headerlink" title="调优目标"></a>调优目标</h3><ol>
<li>GC的时间足够的小</li>
<li>GC的次数足够的少</li>
<li>发生Full GC的周期足够的长</li>
</ol>
<h3 id="年轻代和年老代不同大小的影响"><a href="#年轻代和年老代不同大小的影响" class="headerlink" title="年轻代和年老代不同大小的影响"></a>年轻代和年老代不同大小的影响</h3><ul>
<li><p>大年轻代小年老代：大的年轻代会延长普通GC的周期，增加每次GC的时间；小的年老代会导致更频繁的Full GC</p>
</li>
<li><p>小年轻代大年老代：小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率</p>
</li>
</ul>
<h3 id="如何选择年轻代与年老代比例"><a href="#如何选择年轻代与年老代比例" class="headerlink" title="如何选择年轻代与年老代比例"></a>如何选择年轻代与年老代比例</h3><ul>
<li>如果应用存在大量的临时对象，应该选择更大的年轻代；</li>
<li>如果存在相对较多的持久对象，年老代应该适当增大。</li>
<li>Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理</li>
<li>观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间</li>
</ul>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework体系结构</title>
    <url>/2020/01/27/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-Spring%20Framework%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Spring Framework体系结构</p>
<span id="more"></span>

<h1 id="Spring-Framework体系结构"><a href="#Spring-Framework体系结构" class="headerlink" title="Spring Framework体系结构"></a>Spring Framework体系结构</h1><p>Spring组件被分别整合在核心容器（CoreContainer）、AOP（AspectOrientedProgramming）和设备支持（Instrmentation）、数据</p>
<p>访问及集成（DataAccess/Integeration）、Web、报文发送（Messaging）、Test，6个模块集合中。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Ql64MGWBKVjDcSf.png" alt="image-20200606101444656"></p>
<h2 id="1-核心容器"><a href="#1-核心容器" class="headerlink" title="1.核心容器"></a>1.核心容器</h2><p><strong>由spring-beans、spring-core、spring-context和spring-expression（Spring ExpressionLanguage,SpEL）4个模块组成。</strong></p>
<p>spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（InversionofControl,IOC）和依赖注入（DependencyInjection,DI）。BeanFactory接口是Spring框架中的核心接口。</p>
<p>spring-context模块构架于核心模块之上，他扩展了BeanFactory，为她添加了Bean生命周期控制、框架事件体系以及资源加载透明化等功能。ApplicationContext是该模块的核心接口，ApplicationContext容器实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</p>
<p>spring-expression模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。</p>
<h2 id="2-AOP相关"><a href="#2-AOP相关" class="headerlink" title="2.AOP相关"></a>2.AOP相关</h2><p><strong>由spring-aop、spring-aspects和spring-instrument3个模块组成。</strong></p>
<p>spring-aop是Spring的另一个核心模块，是AOP主要的实现模块。</p>
<p>spring-aspects模块集成自AspectJ框架，主要是为SpringAOP提供多种AOP实现方法。</p>
<p>spring-instrument模块是基于JAVASE中的”java.lang.instrument”进行设计的，算是AOP的一个支援模块，主要作用是在JVM启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现AOP的功能。</p>
<h2 id="3-数据处理"><a href="#3-数据处理" class="headerlink" title="3.数据处理"></a>3.数据处理</h2><p><strong>由spring-jdbc、spring-tx、spring-orm、spring-jms和spring-oxm5个模块组成。</strong></p>
<h2 id="4-web"><a href="#4-web" class="headerlink" title="4.web"></a>4.web</h2><p><strong>由spring-web、spring-webmvc、spring-websocket和spring-webflflux4个模块组成。</strong></p>
<h2 id="5-消息支持"><a href="#5-消息支持" class="headerlink" title="5.消息支持"></a>5.消息支持</h2><p><strong>spring-messaging模块</strong>，为Spring框架集成一些基础的报文传送应用</p>
<h2 id="6-Test测试"><a href="#6-Test测试" class="headerlink" title="6.Test测试"></a>6.Test测试</h2><p><strong>即spring-test模块。</strong></p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>idea导入spring源码</title>
    <url>/2020/01/30/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-idea%E5%AF%BC%E5%85%A5spring%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>idea导入spring源码，导入时出现一些问题的解决</p>
<span id="more"></span>

<h1 id="idea导入spring源码"><a href="#idea导入spring源码" class="headerlink" title="idea导入spring源码"></a>idea导入spring源码</h1><h2 id="此次导入的环境："><a href="#此次导入的环境：" class="headerlink" title="此次导入的环境："></a>此次导入的环境：</h2><p>​    Idea:2018.3.3 </p>
<p>​    jdk:1.8.0_131 </p>
<p>​    gradle:4.6</p>
<p>​    Spring-framework 5.0.7</p>
<h2 id="官方源码导入步骤："><a href="#官方源码导入步骤：" class="headerlink" title="官方源码导入步骤："></a>官方源码导入步骤：</h2><h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><ol>
<li><p>下载源码</p>
<p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
</li>
<li><p>下载gradle</p>
<p><a href="http://downloads.gradle.org/distributions/gradle-4.6-bin.zip">http://downloads.gradle.org/distributions/gradle-4.6-bin.zip</a></p>
<p>最好用4G网下载，稳定，不容易失败</p>
</li>
<li><p>配置gradle环境变量  按照第一篇博客配置gradle环境变量</p>
<ol>
<li><p>配置变量</p>
<p>添加<code>GRADLE_HOME</code>变量:<code>D:\development\gradle-4.6</code></p>
<p><code>GRADLE_HOME</code>到Path变量 : <code>%GRADLE_HOME%\bin</code></p>
<p>配置gradle工厂,添加<code>GRADLE_USER_HOME</code> 变量: <code>%GRADLE_HOME%\.gradle</code></p>
</li>
<li><p>检测</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/e7d1bzoIHjrPc8g.png" alt="image-20200613163121207"></p>
</li>
</ol>
</li>
</ol>
<h3 id="2-下载依赖并预编译一些源码"><a href="#2-下载依赖并预编译一些源码" class="headerlink" title="2.下载依赖并预编译一些源码"></a>2.下载依赖并预编译一些源码</h3><p>进入源码目录：cmd输入<code>.\gradlew :spring-oxm:compileTestJava</code>，中间可能出现连接断开，需要再次输入。等待一会，10分钟左右</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ypkztC5iT4xHOhA.png" alt="image-20200612170443764"></p>
<h3 id="3-open-project"><a href="#3-open-project" class="headerlink" title="3.open project"></a>3.open project</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TF7vb2KY6hMoNnW.png" alt="image-20200612143119648"></p>
<p>选项配置：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6QMOSaveHYg5qUi.png" alt="image-20200612143258195"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/GxtrRlPodqswIin.png" alt="image-20200612143359736"></p>
<p>gradle中过程中报错</p>
<p>1.遇到第一个问题</p>
<h3 id="4-build-project"><a href="#4-build-project" class="headerlink" title="4.build project"></a>4.build project</h3><p>gradle结束后，build项目时报错。</p>
<p>遇到AspectJ的问题，请查看issues</p>
<h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><h3 id="第一个问题："><a href="#第一个问题：" class="headerlink" title="第一个问题："></a>第一个问题：</h3><p><strong>报错：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No such property: values for class: org.gradle.api.internal.tasks.DefaultTas</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>点击<code>open file</code>，注释掉spring-beans.gradle倒数第二行和第三行。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/xjLDk8YH9rB2RPK.png" alt="image-20200613173049016"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ySxiL9zoZcJbmwk.png" alt="image-20200611183343723"></p>
<p><strong>解决后：</strong></p>
<p>开始下载依赖，下载很长时间，4G网半小时左右</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JBIl9iQfe4vudzL.png" alt="image-20200611183803599"></p>
<p>问题：<code>Error:java: Compilation failed: internal java compiler error</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/DibpSRdkXjvF4wP.png" alt="image-20200613184804031"></p>
<h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>缺少两个包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning:Kotlin: Classpath entry points to a non-existent location: D:\han\project\spring-framework-5.0.7.RELEASE\spring-core\build\libs\spring-cglib-repack-3.2.6.jar</span><br><span class="line"></span><br><span class="line">D:\han\project\spring-framework-5.0.7.RELEASE\spring-core\src\main\java\org\springframework\cglib\core\SpringNamingPolicy.java</span><br><span class="line">Error:(30, 41) java: 找不到符号</span><br><span class="line">  符号: 类 DefaultNamingPolicy</span><br><span class="line">Error:(34, 9) java: 方法不会覆盖或实现超类型的方法</span><br></pre></td></tr></table></figure>

<h4 id="第一种解决方法："><a href="#第一种解决方法：" class="headerlink" title="第一种解决方法："></a>第一种解决方法：</h4><p>Add Hooks for Before Gradle Import</p>
<p>官方文档<a href="https://youtrack.jetbrains.com/issue/IDEA-160605">https://youtrack.jetbrains.com/issue/IDEA-160605</a></p>
<h5 id="官方添加的内容："><a href="#官方添加的内容：" class="headerlink" title="官方添加的内容："></a>官方添加的内容：</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/abgtnuoWVcS41vC.png" alt="image-20200612115207945"></p>
<h5 id="我添加的内容："><a href="#我添加的内容：" class="headerlink" title="我添加的内容："></a>我添加的内容：</h5><p>少添加了一个spring下的genXmlbeans,因为找不到</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/EPVMQrZ582pzhaC.png" alt="image-20200612115416599"></p>
<h5 id="添加步骤："><a href="#添加步骤：" class="headerlink" title="添加步骤："></a>添加步骤：</h5><p>1.打开idea的gradle视图</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OExDjXW5H1wLKSd.png" alt="image-20200612115822785"></p>
<p>2.添加hooks</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tHwlyhsfTCKGaOc.png" alt="image-20200612115007891"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/kVcvGPSKOfx3y89.png" alt="image-20200612115048276"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/AhDyZFgVMmn91Rz.png" alt="image-20200612114758749"></p>
<h5 id="刷新gradle"><a href="#刷新gradle" class="headerlink" title="刷新gradle"></a>刷新gradle</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OV7WrqvsAPDgfyI.png" alt="image-20200612133911713"></p>
<h5 id="等待几分钟"><a href="#等待几分钟" class="headerlink" title="等待几分钟"></a>等待几分钟</h5><h3 id="AspectJ的问题"><a href="#AspectJ的问题" class="headerlink" title="AspectJ的问题"></a>AspectJ的问题</h3><ol>
<li><p>移走 unload</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Z3hfXRPDSFmiEU4.png" alt="image-20200612173712719"></p>
</li>
<li><p>重新编译</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XW2z3HwPy1OfFio.png" alt="image-20200612173748663"></p>
</li>
<li><p>编译成功</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RZtmYoqeG9kgcW7.png" alt="image-20200612173622416"></p>
</li>
</ol>
<h2 id="有注释的残缺源码导入"><a href="#有注释的残缺源码导入" class="headerlink" title="有注释的残缺源码导入"></a>有注释的残缺源码导入</h2><h3 id="1-搭建环境-1"><a href="#1-搭建环境-1" class="headerlink" title="1.搭建环境"></a>1.搭建环境</h3><p>同上</p>
<h3 id="2-预编译源码"><a href="#2-预编译源码" class="headerlink" title="2.预编译源码"></a>2.预编译源码</h3><p>源码目录下，双击gradlew.bat</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6P1MoUvjamXgDxN.png" alt="image-20200612143004534"></p>
<h3 id="3-open-project-1"><a href="#3-open-project-1" class="headerlink" title="3.open project"></a>3.open project</h3><p>同上</p>
<h3 id="4-build-project-1"><a href="#4-build-project-1" class="headerlink" title="4.build project"></a>4.build project</h3><p>2.第二个问题 请查看issues</p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/2020/01/26/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务</p>
<span id="more"></span>

<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h3><p>原子性：不可分割</p>
<p>一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态</p>
<p>隔离性：不被其他事物影响</p>
<p>持久性：对数据库的改变是持久的。</p>
<h3 id="事务并发时会出现的问题"><a href="#事务并发时会出现的问题" class="headerlink" title="事务并发时会出现的问题"></a>事务并发时会出现的问题</h3><p>脏读：一个事务读取到另一个事务未提交的数据。</p>
<p>不可重复读：是指一个事务范围内，多次查询某个数据，却得到不同的结果。第一个事务中的两次读取数据之间，第二个事务对数据进行了修改。</p>
<p>幻读：第一个事务对一个表中全部数据行中的某一项的数据进行了修改。同时，第二个事务向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>Read uncommitted（读未提交）：任何情况都无法保证。</p>
<p>Read committed（读已提交）：可避免脏读。oracle采用。</p>
<p>Repeatable read(可重复读)：可避免脏读、不可重复读。mysql采用</p>
<p>Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>给格数据源提供开启事务、释放资源、回滚数据等接口，各数据源负责具体实现。比如：jdbc，mybatis，hibernate。自己的框架需要自己实现。</p>
<p>底层使用SpringAop，而不是SpringAop+Aspectj</p>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="xml使用"><a href="#xml使用" class="headerlink" title="xml使用"></a>xml使用</h3><p>配置事务+数据源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">&lt;!-- 配置数据源 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">	class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;driverClassName&quot;</span><br><span class="line">		value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///kkb&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;	</span><br><span class="line"></span><br><span class="line">&lt;!-- 扫描AccountDao和AccountService --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.kkb.spring.tx&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>


<p>配置通配符方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务通知类（Spring实现的事务增强类） --&gt;</span><br><span class="line">&lt;!--   TransactionInterceptor  --&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot;</span><br><span class="line">	transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">	&lt;tx:attributes&gt;</span><br><span class="line">		&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;transfer*&quot; propagation=&quot;REQUIRED&quot; /&gt;</span><br><span class="line">		&lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>

<p>配置切面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置aop切面类或者通知器类 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;!-- 这使用的是Spring AOP的实现 --&gt;</span><br><span class="line">	&lt;!-- advice-ref：指定advice增强类 --&gt;</span><br><span class="line">	&lt;aop:advisor advice-ref=&quot;txAdvice&quot;</span><br><span class="line">		pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<h3 id="xml-注解混合使用"><a href="#xml-注解混合使用" class="headerlink" title="xml+注解混合使用"></a>xml+注解混合使用</h3><p>通配符方法+切面改为注解@Transactional</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务注解驱动 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="纯注解使用"><a href="#纯注解使用" class="headerlink" title="纯注解使用"></a>纯注解使用</h3><p>xml配置改为注解@EnableTransactionManagement</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableTransactionManagement</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring介绍</title>
    <url>/2020/01/23/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>IOC、DI、AOP、事务</p>
<span id="more"></span>

<p><strong>目标：</strong>掌握一些概念，包括IoC、DI、AOP、Spring容器</p>
<p>Spring的优点：</p>
<ul>
<li><p>方便解耦</p>
<p>Spring可以管理对象之间的依赖关系 @Autow @Resource 单例模式</p>
</li>
<li><p>AOP编程的支持</p>
<p>面向切面编程，不改变原有类的情况下增强Bean的功能。代理模式，jdk动态道理，Cligb动态代理。</p>
</li>
<li><p>声明式事务支持</p>
</li>
<li><p>方便程序测试</p>
<p>Spring 对Junit支持很好，可以通过注解方便的测试。</p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>Hessian、Quartz</p>
</li>
<li><p>Java源码的经典学习案例</p>
<p>Spring源码是java技术的最佳实践案例，可以学到设计模式的灵活应用，提高代码编写质量。</p>
</li>
</ul>
<p>Spring核心概念：</p>
<ul>
<li><p>IoC：Inverse of Control，控制反转。由Spring框架负责对象的创建，用到了单例模式（也可多例Struts2）。Spring创建对象时，需要将UserService类的依赖对象userDao注入到Bean组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>DI：Dependency Injection，依赖注入。依赖：Bean实例的属性。给依赖对象的属性赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AOP：不修改目标对象代码的情况下，增强IOC容器中Bean的功能。</p>
</li>
<li><p>Spring容器：指的是IoC容器，底层是BeanFactory</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>全家桶介绍</title>
    <url>/2020/01/27/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>全家桶介绍</p>
<span id="more"></span>

<p>springframework：spring，aop，mvc，test，jdbc，orm，oxm。message</p>
<p>springdata：spring对数据的支持。springdata，jpa，springRedis，springMongoDB。</p>
<p>springboot：简化配置</p>
<p>springcloud：关于分布式服务</p>
<p>熔断器，服务注册</p>
<p>springconfiguration：配置中心</p>
]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-手写框架流程</title>
    <url>/2020/02/05/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E6%89%8B%E5%86%99%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>手写框架流程,附上了获取bean和创建bean的代码，为附上加载配置文件，生成bean定义的代码</p>
<span id="more"></span>

<h2 id="一-准备环境"><a href="#一-准备环境" class="headerlink" title="一.准备环境"></a>一.准备环境</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><h3 id="2-写xml配置文件"><a href="#2-写xml配置文件" class="headerlink" title="2.写xml配置文件"></a>2.写xml配置文件</h3><h3 id="3-编写测试代码"><a href="#3-编写测试代码" class="headerlink" title="3.编写测试代码"></a>3.编写测试代码</h3><h2 id="二-写框架"><a href="#二-写框架" class="headerlink" title="二.写框架"></a>二.写框架</h2><h3 id="1-加载并解析配置文件"><a href="#1-加载并解析配置文件" class="headerlink" title="1.加载并解析配置文件"></a>1.加载并解析配置文件</h3><p>​    涉及到Bedifinition</p>
<h3 id="2-创建Bean实例"><a href="#2-创建Bean实例" class="headerlink" title="2.创建Bean实例"></a>2.创建Bean实例</h3><ol>
<li><p>判断单例缓存Map中是否存在需要的实例</p>
<ol>
<li><p>存在</p>
<p>返回单例实例</p>
</li>
<li><p>不存在</p>
<p>创建实例</p>
<ol>
<li><p>获取Bedifinition，判断是否为null</p>
<ol>
<li><p>null,return null</p>
</li>
<li><p>判断是单例还是多例</p>
<ol>
<li><p>单例</p>
<ol>
<li><p>创建实例</p>
</li>
<li><p>创建bean的实例</p>
<ol start="2">
<li><p>注入属性</p>
</li>
<li><p>是否有初始化方法</p>
</li>
<li><p>有</p>
<ol>
<li>执行方法 通过反射</li>
</ol>
</li>
<li><p>无</p>
</li>
<li><p>是否有后置处理方法</p>
</li>
<li><p>有</p>
<ol>
<li>通过aop处理</li>
</ol>
</li>
</ol>
</li>
<li><p>加入缓存Map</p>
</li>
<li><p>返回实例对象</p>
</li>
</ol>
</li>
<li><p>多例</p>
<ol>
<li><p>创建实例</p>
</li>
<li><p>返回实例对象</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>创建bean实例简化代码，只实现核心部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Map&lt;String, BeanDefinition&gt; beanDefinitions = new HashMap&lt;&gt;();</span><br><span class="line">// 单例缓存</span><br><span class="line">Map&lt;String, Object&gt; beans = new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition bd) &#123;</span><br><span class="line">	beanDefinitions.put(beanName, bd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public BeanDefinition getBeanDefinition(String beanName) &#123;</span><br><span class="line">	return beanDefinitions.get(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// @Override</span><br><span class="line">public Object getBean2(String name) &#123;</span><br><span class="line">	</span><br><span class="line">	// 从单例缓存获取实例对象</span><br><span class="line">	Object object = beans.get(name);</span><br><span class="line">	// 有实例对象时返回实现对象</span><br><span class="line">	if (object != null) &#123;</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br><span class="line">	// 没有实例对象，创建实例对象</span><br><span class="line">	// 获取Bedifinition,类的定义</span><br><span class="line">	BeanDefinition beanDefinition = getBeanDefinition(name);</span><br><span class="line">	// 没有类的定义时返回实例null</span><br><span class="line">	if (beanDefinition == null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取单例多例属性，判断多例还是单例</span><br><span class="line">	String scope = beanDefinition.getScope();</span><br><span class="line">	if (&quot;singleton&quot;.equals(scope)) &#123;</span><br><span class="line">		// 单例：</span><br><span class="line">		// 一、创建实例</span><br><span class="line">		Object bean = creaBean2(name, beanDefinition);</span><br><span class="line">		// 二、加入单例缓存</span><br><span class="line">		beans.put(name, bean);</span><br><span class="line">		// 三、返回单例实例</span><br><span class="line">		return bean;</span><br><span class="line">	&#125; else if (&quot;prototype&quot;.equals(scope)) &#123;</span><br><span class="line">		// 多例：</span><br><span class="line">		// 一、创建实例</span><br><span class="line">		// 二、返回实例</span><br><span class="line">		 return creaBean2(name, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object creaBean2(String name, BeanDefinition beanDefinition) &#123;</span><br><span class="line">	// 1.创建bean的实例</span><br><span class="line">	// 1.1获取类的类型</span><br><span class="line">	String clazzName = beanDefinition.getClazzName();</span><br><span class="line">	// 1.2创建</span><br><span class="line">	Class&lt;?&gt; type = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		type = Class.forName(clazzName);</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	Object bean = ReflectUtils.createObject(type);</span><br><span class="line">	// 2.注入属性</span><br><span class="line">	List&lt;PropertyValue&gt; propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line">	for (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">		// 类属性名称</span><br><span class="line">		String name2 = propertyValue.getName();</span><br><span class="line">		// 类属性值 分两种，普通类型value和引用类型ref  propertity中的value标签中的内容</span><br><span class="line">		Object value = propertyValue.getValue();</span><br><span class="line">		</span><br><span class="line">		Object valueToUse = null;</span><br><span class="line">		// 判断普通类型or引用类型</span><br><span class="line">		if (value instanceof TypedStringValue) &#123;// 判断是否为普通类型</span><br><span class="line">			TypedStringValue typedStringValue = (TypedStringValue) value;</span><br><span class="line">			String stringValue = typedStringValue.getValue();</span><br><span class="line">			Class&lt;?&gt; targetType = typedStringValue.getTargetType();</span><br><span class="line">			</span><br><span class="line">			// 只匹配了两种Integer和String</span><br><span class="line">			if (targetType == Integer.class) &#123;</span><br><span class="line">				// 确定了value的类型为Integer，注入属性 name2:属性名称:age;valueToUse:属性值:18</span><br><span class="line">				valueToUse = Integer.parseInt(stringValue);</span><br><span class="line">			&#125; else if (targetType == String.class) &#123;</span><br><span class="line">				valueToUse = stringValue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; else if (value instanceof RuntimeBeanReference) &#123;// 判断是否为引用类型</span><br><span class="line">			RuntimeBeanReference runtimeBeanReference = (RuntimeBeanReference) value;</span><br><span class="line">			String ref = runtimeBeanReference.getRef();</span><br><span class="line">			</span><br><span class="line">			// TODO 容易引起循环依赖问题</span><br><span class="line">			// 获取引用类型的属性，并注入。获取引用类型时，需要把引用类型Course中的属性name和age先注入到Course中</span><br><span class="line">			valueToUse = getBean2(ref);</span><br><span class="line">		&#125;</span><br><span class="line">		// 设置属性</span><br><span class="line">		ReflectUtils.setProperty(bean, name2, valueToUse);</span><br><span class="line">	&#125;</span><br><span class="line">	// 3.处理初始化方法</span><br><span class="line">	String initMethod = beanDefinition.getInitMethod();</span><br><span class="line">	if (&quot;init&quot;.equals(initMethod)) &#123;</span><br><span class="line">		ReflectUtils.invokeMethod(bean, initMethod);</span><br><span class="line">	&#125;</span><br><span class="line">	// 4.处理后置方法 aop</span><br><span class="line">	</span><br><span class="line">	return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>核心基础</title>
    <url>/2020/01/24/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>基于XML使用、基于注解+XML混合使用、基于纯注解使用</p>
<span id="more"></span>

<h1 id="1-基于XML使用"><a href="#1-基于XML使用" class="headerlink" title="1.基于XML使用"></a>1.基于XML使用</h1><h2 id="1-IoC配置"><a href="#1-IoC配置" class="headerlink" title="1.IoC配置"></a>1.IoC配置</h2><p>配置被Spring容器管理的bean信息，默认使用无参构造方法。</p>
<p>bean标签实例化三种方式：</p>
<ol>
<li><p>无参构造（常用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id = &quot;userService&quot; class = &quot;com.xiaoruiit.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>静态工厂</p>
</li>
<li><p>实例工厂</p>
</li>
</ol>
<h2 id="2-DI配置"><a href="#2-DI配置" class="headerlink" title="2.DI配置"></a>2.DI配置</h2><p>给bean的属性赋值</p>
<ol>
<li><p>构造函数注入，<code>constructor-arg</code>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.xiaoruiit.service.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>set方法注入,<code>property</code>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 需要配置bean标签的子标签property</span><br><span class="line">- 需要配置的bean中指定setter方法。</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2-基于注解-XML混合使用"><a href="#2-基于注解-XML混合使用" class="headerlink" title="2.基于注解+XML混合使用"></a>2.基于注解+XML混合使用</h1><p>使用xml的地方：1.xml配置文件，内容包括：扫描包，配置数据源；2.加载配置文件。</p>
<p>使用注解的地方：</p>
<h3 id="IoC注解的使用方法"><a href="#IoC注解的使用方法" class="headerlink" title="IoC注解的使用方法"></a>IoC注解的使用方法</h3><ol>
<li><p>xml配置 <code>context:component-scan</code>标签  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.xiaoruiit.service&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>类上添加注解@Component @Controller @Service @Repository</p>
<p>@Component:把类交给Spring容器管理。</p>
<p>@Controller @Service @Repository:@Component的延伸，为了方便标注表现层、业务层、持久层，乱写不影响使用，影响理解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="DI的注解"><a href="#DI的注解" class="headerlink" title="DI的注解"></a>DI的注解</h3><ul>
<li><p>@Autowired  </p>
<ul>
<li>默认按类型装配（byType）  </li>
<li>spring自带的注解  </li>
<li>找不到时会报错，如果需要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)  </li>
<li>如果我们想按名称装配（byName）可以结合 @Qualifier 注解进行使用  </li>
</ul>
</li>
<li><p>@Qualifier </p>
<ul>
<li>在给字段注入时不能独立使用，必须和@Autowire 一起使用；</li>
</ul>
</li>
<li><p>@Resource  </p>
<ul>
<li>默认按名称装配（byName）  </li>
<li>属于J2EE JSR250规范的实现  ，jdk的注解</li>
<li>推荐使用@Resource注解  </li>
</ul>
</li>
<li><p>@Inject  </p>
<ul>
<li>根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；  </li>
<li>是JSR330中的规范，需要导入javax.inject.Inject  </li>
<li>可以作用在变量、setter方法、构造函数上。  </li>
</ul>
</li>
<li><p>@Value</p>
<ul>
<li><p>给基本类型和String类型注入值  </p>
</li>
<li><p>可以使用占位符获取属性文件中的值  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(“$&#123;name&#125;”)//name是properties文件中的key</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@Scope  </p>
<ul>
<li>指定 bean 的作用范围  </li>
<li>属性：  value：指定范围的值。取值：singleton(默认，单例) prototype（原型，多例） request session globalsession  </li>
</ul>
</li>
</ul>
<h1 id="3-基于纯注解使用"><a href="#3-基于纯注解使用" class="headerlink" title="3.基于纯注解使用"></a>3.基于纯注解使用</h1><p>将“基于注解+XML混合使用”中的xml部分使用注解实现。</p>
<h2 id="xml实现的部分"><a href="#xml实现的部分" class="headerlink" title="xml实现的部分"></a>xml实现的部分</h2><p>1.扫描包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启注解并扫描指定包中带有注解的类 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.xiaoruiit.service&quot;/&gt;</span><br><span class="line">&lt;context:property-placeholder src=&quot;&quot;&gt;&lt;/context:property-placeholder&gt;</span><br></pre></td></tr></table></figure>

<p>2.非自定义Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; value=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>3.加载配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(“beans.xml”);</span><br></pre></td></tr></table></figure>

<h2 id="使用注解实现"><a href="#使用注解实现" class="headerlink" title="使用注解实现"></a>使用注解实现</h2><p>1.xml扫描包</p>
<p>@Configuration 相当于xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">    //spring容器初始化时，会调用配置类的无参构造函数</span><br><span class="line">    public SpringConfiguration()&#123;</span><br><span class="line">    	System.out.println(“容器启动初始化。。。”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ComponentScan  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于context:component-scan标签</span><br><span class="line">组件扫描器，扫描@Component、@Controller、@Service、@Repository注解的类。</span><br><span class="line">该注解是编写在类上面的，一般配合@Configuration注解一起使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages=&quot;com.xiaoruiit.service&quot;)</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">    public SpringConfiguration() &#123;</span><br><span class="line">    	System.out.println(&quot;容器初始化...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // @Bean</span><br><span class="line">    // @Scope(&quot;prototype&quot;)</span><br><span class="line">    // public UserService userService() &#123;</span><br><span class="line">    // return new UserServiceImpl(1,&quot;张三&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.非自定义Bean</p>
<p>@Bean （@value）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于&lt;bean&gt;标签</span><br><span class="line">作用为：注册bean对象，主要用来配置非自定义的bean，比如DruidDataSource、SqlSessionFactory</span><br><span class="line">@Bean标注在方法上(返回某个实例的方法)</span><br><span class="line">name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。如果不指定，默认与标注的方法名相</span><br><span class="line">同。</span><br><span class="line">@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">    //spring容器初始化时，会调用配置类的无参构造函数</span><br><span class="line">    public SpringConfiguration()&#123;</span><br><span class="line">    	System.out.println(“容器启动初始化。。。”);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(“prototype”)</span><br><span class="line">    public SqlSessionFactory userService()&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory();</span><br><span class="line">        sqlSessionFactory.setxxx();</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Scope(“prototype”)</span><br><span class="line">    public SqlSessionFactory userService()&#123;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory();</span><br><span class="line">        sqlSessionFactory.setxxx();</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@PropertySource  </p>
<p>解决properties文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:///spring</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    /**</span><br><span class="line">    * 创建一个数据源，并存入 spring 容器中</span><br><span class="line">    * *</span><br><span class="line">    @return</span><br><span class="line">    */</span><br><span class="line">    @Bean(name = &quot;dataSource&quot;)</span><br><span class="line">    public DataSource createDataSource() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ComboPooledDataSource ds = new ComboPooledDataSource();</span><br><span class="line">            ds.setDriverClass(driver);</span><br><span class="line">            ds.setJdbcUrl(url);</span><br><span class="line">            ds.setUser(username);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">            return ds;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.加载配置文件</p>
<p>@Import</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于spring配置文件中的&lt;import&gt;标签</span><br><span class="line">用来组合多个配置类,在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.kkb.spring&quot;)</span><br><span class="line">@Import(&#123; JdbcConfig.class &#125;)</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">	public class JdbcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建纯注解方式上下文容器  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = new</span><br><span class="line">	AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br><span class="line">	UserService service = context.getBean(UserService.class);</span><br><span class="line">service.saveUser();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>核心高级</title>
    <url>/2020/01/26/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E6%A0%B8%E5%BF%83%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<p>AOP介绍，AOP的一些术语，AspectJ概念，SpringAOP，动态代理</p>
<span id="more"></span>

<h1 id="核心高级"><a href="#核心高级" class="headerlink" title="核心高级"></a>核心高级</h1><h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><ul>
<li>AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构。</li>
<li>AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范</li>
</ul>
<p><strong>作用：</strong>AOP采取横向抽取机制，补充了传统纵向继承体系（OOP）无法解决的重复性代码优化（性能监视、事务管理、安全检查、缓存），将业务逻辑和系统处理的代码（关闭连接、事务管理、操作日志记录）解耦。  </p>
<h3 id="AOP的一些术语"><a href="#AOP的一些术语" class="headerlink" title="AOP的一些术语"></a>AOP的一些术语</h3><ul>
<li>Target 目标对象</li>
</ul>
<ul>
<li> Joinpoint 连接点 目标类的方法</li>
</ul>
<ul>
<li>Pointcut  切入点 具体要增强的Joinpoint 方法</li>
</ul>
<ul>
<li><p>Advice 通知 对应增强的内容类，分为前置通知,后置通知,异常通知,最终通知,环绕<br>通知(切面要完成的功能)  </p>
</li>
<li><p>Aspect  切面 切入点+通知，自己来编写和配置的  </p>
</li>
<li><p>Proxy（代理）  </p>
</li>
<li><p>Weaving(织入)  把增强应用到目标对象来创建新的代理对象的过程  </p>
</li>
</ul>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>AOP的一种早期实现，比较完善，实现的功能多。</p>
<p>有自己的编译器。</p>
<p>与JAVA无缝衔接。</p>
<p>静态织入</p>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p>动态代理实现，使用了JDK动态代理和CGlib动态代理实现</p>
<h4 id="两种动态实现原理"><a href="#两种动态实现原理" class="headerlink" title="两种动态实现原理"></a>两种动态实现原理</h4><p>类加载时动态生成一个类给目标类添加功能。</p>
<h5 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h5><p>目标类必须实现一个接口</p>
<p>通过反射实现</p>
<p>比CGlib用的资源少</p>
<p>Spring先用jdk动态代理，目标类没有实现接口时使用CGlib代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 使用JDK的方式生成代理对象</span><br><span class="line">*/</span><br><span class="line">public class MyProxyUtils &#123;</span><br><span class="line">    public static UserService getProxy(final UserService service) &#123;</span><br><span class="line">        // 使用Proxy类生成代理对象</span><br><span class="line">        UserService proxy = (UserService)Proxy.newProxyInstance(service.getClass().</span><br><span class="line">        	getClassLoader(),service.getClass().getInterfaces(),new InvocationHandler() &#123;</span><br><span class="line">            // 代理对象方法一执行，invoke方法就会执行一次</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) </span><br><span class="line">            	throws Throwable &#123;</span><br><span class="line">                if(&quot;save&quot;.equals(method.getName()))&#123;</span><br><span class="line">                	System.out.println(&quot;记录日志...&quot;);</span><br><span class="line">                &#125;             </span><br><span class="line">                // 让service类的save或者update方法正常的执行下去</span><br><span class="line">                return method.invoke(service, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 返回代理对象</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CGlib动态代理"><a href="#CGlib动态代理" class="headerlink" title="CGlib动态代理"></a>CGlib动态代理</h5><p>通过继承目标类实现</p>
<p>目标类不能被 final 或static 修饰</p>
<p>单例时使用较好，因为创建一次消耗的资源较多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static UserService getProxy()&#123;</span><br><span class="line">    // 创建CGLIB核心的类</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    // 设置父类 目标类</span><br><span class="line">    enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">    // 设置回调函数</span><br><span class="line">    enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object intercept(Object obj, Method method, Object[] args,</span><br><span class="line">        MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">            if(&quot;save&quot;.equals(method.getName()))&#123;</span><br><span class="line">                // 记录日志</span><br><span class="line">                System.out.println(&quot;记录日志了...&quot;);</span><br><span class="line">            &#125; </span><br><span class="line">        	return methodProxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 生成代理对象</span><br><span class="line">    UserService proxy = (UserService) enhancer.create();</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于AspectJ的aop使用"><a href="#基于AspectJ的aop使用" class="headerlink" title="基于AspectJ的aop使用"></a>基于AspectJ的aop使用</h2><p>Spring+AspectJ整合</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 基于AspectJ的aop依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;aopalliance&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="目标类和方法"><a href="#目标类和方法" class="headerlink" title="目标类和方法"></a>目标类和方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UserService接口</span><br><span class="line">UserServiceImpl实现类</span><br></pre></td></tr></table></figure>

<h3 id="xml实现"><a href="#xml实现" class="headerlink" title="xml实现"></a>xml实现</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li><p>编写通知类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyAdvice&#123;</span><br><span class="line">	public void log()&#123;</span><br><span class="line">		System.out.println(&quot;记录日志&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置通知,交给IoC容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean name = &quot;myAdvice&quot; class = &quot;com.xiaoruiit.advice.Myadvice&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置切面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;</span><br><span class="line">		&lt;!-- 对哪些切入点进行功能增强由pointcut属性指定 --&gt;</span><br><span class="line">		&lt;!-- 增强哪些功能由method属性指定，它指定的方法是advice类中的方法 --&gt;</span><br><span class="line">		&lt;!-- 什么时候织入？通过aop:before等标签来指定 --&gt;</span><br><span class="line">		&lt;aop:before method=&quot;before&quot;</span><br><span class="line">			pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;</span><br><span class="line">		&lt;aop:after method=&quot;after&quot;</span><br><span class="line">			pointcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot; /&gt;</span><br><span class="line">	&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure>

<h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><p><strong>通知类型（五种）：</strong>前置通知、后置通知、最终通知、环绕通知、异常抛出通知。  </p>
<h3 id="XML结合注解实现"><a href="#XML结合注解实现" class="headerlink" title="XML结合注解实现"></a>XML结合注解实现</h3><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1.编写切面类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component(&quot;myAspect&quot;)</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAspect &#123;</span><br><span class="line">	</span><br><span class="line">	private static final String pcut=&quot;execution(* *..*.*ServiceImpl.*(..))&quot;;</span><br><span class="line">	</span><br><span class="line">	@Before(value=&quot;MyAspect.fn()&quot;)</span><br><span class="line">	public void before() &#123;</span><br><span class="line">		System.out.println(&quot;这是注解方式的前置通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@AfterReturning(pcut)</span><br><span class="line">	public void after() &#123;</span><br><span class="line">		System.out.println(&quot;这是注解方式的后置通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Pointcut(&quot;execution(* *..*.*ServiceImpl.*(..))&quot;)</span><br><span class="line">	public void fn() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开启AOP自动代理"><a href="#开启AOP自动代理" class="headerlink" title="开启AOP自动代理"></a>开启AOP自动代理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启aspectj的自动代理，用于AOP的注解方式 --&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><p>取代开启Aspect自动代理xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">@ComponentScan(basePackages=&quot;com.xiaoruiit&quot;) </span><br><span class="line">@EnableAspectJAutoProxy </span><br><span class="line">public class SpringConfiguration &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>高级特性</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>spring总结</title>
    <url>/2020/10/25/213Java%E6%A1%86%E6%9E%B6/Spring/Spring%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>对spring总结</p>
<span id="more"></span>

<h1 id="spring总结"><a href="#spring总结" class="headerlink" title="spring总结"></a>spring总结</h1><p>不使用spring：编写登录功能。此功能由多个类的对象互相调用实现。一个对象调用另一个对象。Controller调用Service。不使用spring，Controller调用Service，需要先<code>UserService userService = new UserService()</code></p>
<p><strong>解决了什么</strong>：优化了new对象硬编码，类与类之间进行解耦。减小了jvm频繁new对象的开销。</p>
<p><strong>做了什么</strong>：类的实例化对象的管理。</p>
<p><strong>关键技术点</strong>：</p>
<ul>
<li><p>IoC（Inversion of Control,控制翻转）：生成对象这件事交给spring。</p>
</li>
<li><p>IoC容器：</p>
<ul>
<li>D</li>
<li>存放类的实例化对象</li>
</ul>
</li>
<li><p>DI</p>
</li>
</ul>
<p><strong>如何管理类的实例化对象</strong>：</p>
<ul>
<li>单例对象，系统启动进行初始化时，将对象new出来放在IOC容器中。</li>
</ul>
<p><strong>使用</strong>：</p>
<ul>
<li>xml方式</li>
<li>注解方式<ul>
<li><p>@Autowire</p>
<p>@Resource</p>
</li>
<li><p>@Service</p>
</li>
<li><p>@Controller</p>
</li>
<li><p>@Repository</p>
</li>
<li><p>@Transaction</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码中的设计模式</title>
    <url>/2020/10/25/213Java%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>spring源码中的设计模式</p>
<span id="more"></span>

<h1 id="spring源码中的设计模式"><a href="#spring源码中的设计模式" class="headerlink" title="spring源码中的设计模式"></a>spring源码中的设计模式</h1><p>策略模式，代理模式，单例模式，模板方法模式</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><strong>策略模式</strong>：</p>
<p><strong>Spring源码中如何使用</strong>：</p>
<ul>
<li>加载xml文件。AbstractApplicationContext的refresh方法的第二步。加载xml文件，bean定义读取器BeanDefinitionReader中，资源加载器ResourceLoader、bean名称生成器（BeanNameGenerator）,使用了策略模式。ClassPathXmlApplicationContext、FileSystemXmlApplicationContext（覆盖了方法Resource getResourceByPath(String path)）是DefaultResource的子孙类，表示两种加载xml文件的策略：类路径、系统路径。</li>
<li>AOP代理。代理类AopProxy，有JdkDynamicAopProxy和CglibAopProxy两个实现类。</li>
<li>template的实现。JDBCTemplate，HibernateTemplate。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>代理模式</strong>：AOP用代理模式实现。</p>
<p><strong>目的</strong>：对业务代码做前置处理，增加日志</p>
<p><strong>Spring源码如何使用</strong>：</p>
<ul>
<li>JDK动态代理，需实现接口</li>
<li>CGLib代理，直接给字节码加代码</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>单例模式</strong>：类只有单个对象会被创建（实例化），向其他类只提供一种访问方式。可以全局访问.</p>
<p><strong>spring源码如何使用</strong>：</p>
<p>用到了双重校验锁。支持多线程，有lazy loading效果。</p>
<p>第一个<code>if (singletonObject== null)</code>，singletonObject没有被实例化时，对实例化内容加锁。避免非必要加锁。</p>
<p>第二个<code>if (singletonObject== null)</code>，第一次实例化singletonObject时，防止多个线程在synchronized处等待并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">	Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">	if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">			if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">				if (singletonFactory != null) &#123;</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					this.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p><strong>模板方法</strong>：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<p><strong>spring源码如何使用</strong>：</p>
<p>AbstractApplicationContext的refresh方法定义了初始化容器的流程。只是写了一个个流程的方法。</p>
<p>1.刷新预处理，重置容器的一些信息</p>
<p>2.创建容器，加载xml信息到BeanDefinition</p>
<p>3.对IOC容器进行预处理</p>
<p>…</p>
<p>11.实例化开发者配置的非抽象非延迟加载的单例Bean。</p>
<p>12.发步相应的事件。</p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码总结</title>
    <url>/2020/10/25/213Java%E6%A1%86%E6%9E%B6/Spring/Spring%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>spring源码总结</p>
<span id="more"></span>

<h1 id="spring源码总结"><a href="#spring源码总结" class="headerlink" title="spring源码总结"></a>spring源码总结</h1><p><strong>spring使用场景</strong>：编写登录功能。此功能由多个类的对象互相调用实现。一个对象调用另一个对象，Controller调用Service。不使用spring，Controller调用Service，调用之前需要<code>UserService userService = new UserService()</code></p>
<p><strong>spring源码做了什么</strong>：管理类的实例化对象</p>
<p><strong>如何做的</strong>：</p>
<ul>
<li><p>对不同对象的处理。</p>
<p>首先初始化的时候，即项目启动，加载所有的xml文件存为Bedifinition对象</p>
<ul>
<li>非延迟加载的单例对象，初始化的时候new出来放在IOC容器中。</li>
<li>延迟加载的单例对象，第一次调用的时候new 出来放在IOC容器中。</li>
<li>多例对象，在使用时根据Bedifinition将对象new出来，返回给调用方。</li>
</ul>
</li>
<li><p>AbstractApplicationContext定义了管理对象的流程。referesh有12个步骤.关键是第2步和第11步。</p>
<ul>
<li>第2步加载xml配置文件为Bedifinition对象<ul>
<li>创建IOC容器<code>DefaultListableBeanFactory</code></li>
<li>加载解析XML文件，存到Document中</li>
<li>读取Document，处理为BeanDefinition</li>
</ul>
</li>
<li>第11步根据Bedifinition中对Bean的定义，将bean new出来放在IOC容器中。<ul>
<li>finishBeanFactoryInitialization()</li>
<li>preInstantiateSingletons(),判断抽象、单例、懒加载，FactoryBean。</li>
<li>getBean()</li>
<li>doGetBean<ul>
<li>creatBean</li>
<li>doCreatBean<ul>
<li>creatBeanInstance()，默认使用无参构造函数生成Bean</li>
<li>放入三级缓存，用于解决循环依赖</li>
<li>populateBean()，依赖注入（DI），填充属性</li>
<li>initislizeBean()，调用初始化方法。（AOP发生在此步骤)</li>
</ul>
</li>
<li>DI</li>
<li>AOP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>spring源码关键点</strong>：</p>
<ul>
<li><p>FactoryBean与BeanFactory</p>
<p>BeanFactory，spring中的顶级接口。FactoryBean是工厂Bean。</p>
</li>
<li><p>三级缓存的理解</p>
<p>三级缓存扩展性更好。二级缓存可以解决循环依赖。但这意味着Bean在实例化之后就要完成AOP代理。而spring设计之初是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器在创建Bean的最后一步完成AOP代理。</p>
<ul>
<li><p>一级缓存 singletonObjects</p>
<p>单例bean完成三部曲之后，会添加到一级缓存中。存储的是所有创建好了的单例Bean</p>
</li>
<li><p>二级缓存 earlySingletonObjects</p>
<p>二级缓存，完成实例化，但是还未进行属性注入及初始化的对象。</p>
</li>
<li><p>三级缓存 singletonFactories</p>
<p>提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象.</p>
</li>
</ul>
</li>
<li><p>循环依赖</p>
<p>如何产生：类A中有一个属性是B，类B中有一个属性是A。初始化A和B的时候，使用构造函数初始化，new A发现需要先new B，new B 发现要先new A。产生循环依赖。构造函数：A(B b){this.b = b}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class  A&#123;</span><br><span class="line">	private B b;</span><br><span class="line">	</span><br><span class="line">	public A(B b)&#123;this.b = b;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">	private A a;</span><br><span class="line">	</span><br><span class="line">	public B(A a)&#123;this.a = a;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如何解决：DI属性注入使用set，而不是构造函数。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class  A&#123;</span><br><span class="line">	private B b;</span><br><span class="line">	</span><br><span class="line">	public A()&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public void setB()&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public B getB()&#123;</span><br><span class="line">		this.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  B&#123;</span><br><span class="line">	private A a;</span><br><span class="line">	</span><br><span class="line">	public B()&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public void setA()&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public A getA()&#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成A和B对象的流程。</p>
<ol>
<li>new A，放入缓存</li>
<li>依赖注入，set B<ol>
<li>new B，放入缓存</li>
<li>依赖注入，setA，从缓存中取出A，完成setA</li>
</ol>
</li>
<li>从缓存拿出B，完成setB</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2018/04/23/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-ArrayList/</url>
    <content><![CDATA[<p>List的实现类：ArrayList List的包java.util.List</p>
<span id="more"></span>
<p>= 左边的引用相比于 =右边new的对象 不能处于继承关系的下层，如main函数最后一行会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * &lt;&gt; 泛型    集合的泛型不可以用基本数据类型去定义， 需要放包装类</span><br><span class="line"> * .size()方法  获取长度</span><br><span class="line"> * list集合和数组都拥有下标   默认从0开始</span><br><span class="line"> */</span><br><span class="line">/*</span><br><span class="line"> * 方法：</span><br><span class="line"> * 		构造方法：public ArrayList()构造一个初始容量为 10 的空列表。 </span><br><span class="line"> * 			   public ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span><br><span class="line"> * 			   public ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。</span><br><span class="line"> * 		普通方法：</span><br><span class="line"> * 				public void trimToSize()将此 ArrayList 实例的容量调整为列表的当前大小。</span><br><span class="line"> * 				public boolean add(E e)将指定的元素添加到此列表的尾部。</span><br><span class="line"> * 				public void add(int index,E element)将指定的元素插入此列表中的指定位置。</span><br><span class="line"> *  			public boolean addAll(Collection&lt;? extends E&gt; c)按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</span><br><span class="line"> *  			public void clear()移除此列表中的所有元素。</span><br><span class="line"> *  			public boolean contains(Object o)如果此列表中包含指定的元素，则返回 true。</span><br><span class="line"> *  			public E set(int index,E element)用指定的元素替代此列表中指定位置上的元素。 </span><br><span class="line"> *  			public int indexOf(Object o)返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。</span><br><span class="line"> *  </span><br><span class="line"> * */		</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayListLearn &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">		list.add(2);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(list.size());</span><br><span class="line">		System.out.println(list.get(0));</span><br><span class="line">		//构造</span><br><span class="line">		//public ArrayList(Collection&lt;? extends E&gt; c)</span><br><span class="line">		ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(list);</span><br><span class="line">		list2.add(7);</span><br><span class="line">		list2.add(8);</span><br><span class="line">		System.out.println(list2);</span><br><span class="line">		System.out.println(list2.size());	</span><br><span class="line">		//public ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。</span><br><span class="line">		ArrayList&lt;Integer&gt; list3 = new ArrayList&lt;Integer&gt;(3);</span><br><span class="line">		list3.add(9);</span><br><span class="line">		System.out.println(list3.size());</span><br><span class="line">		</span><br><span class="line">		//普通</span><br><span class="line">		//public boolean add(E e)将指定的元素添加到此列表的尾部。 </span><br><span class="line">		list.add(3);</span><br><span class="line">		System.out.println(list.add(4));</span><br><span class="line">		//public void add(int index,E element)</span><br><span class="line">		list.add(2, 5);</span><br><span class="line">		for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------add(int index,E element结束)&quot;);</span><br><span class="line">		//public boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">		list.addAll(2, list2);</span><br><span class="line">		for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------addALL结束&quot;);</span><br><span class="line">		//public void clear()移除此列表中的所有元素。</span><br><span class="line">		list3.clear();</span><br><span class="line">		System.out.println(list3.size());</span><br><span class="line">		//public boolean contains(Object o)如果此列表中包含指定的元素，则返回 true。</span><br><span class="line">		System.out.println(list.contains(3));</span><br><span class="line">		System.out.println(&quot;-------contains(Object o)结束&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2018/04/23/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-HashMap/</url>
    <content><![CDATA[<p>map  数据结构  键值对  通过K(key)值获取V(values)值    k  t  v </p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * </span><br><span class="line"> *               </span><br><span class="line"> *      方法：</span><br><span class="line"> *               put(key, value)  //存储数据，修改数据</span><br><span class="line"> *               public V get(Object key)		//得到数据</span><br><span class="line"> *               Object get(Object key)这个方法完成的功能是，通过键对象 key，来找到相应的值对象</span><br><span class="line"> *               put(Object key, Object value)这个方法是把一个键值对放入 Map 中。</span><br><span class="line"> *               remove(Object key)这个方法根据一个键，删除一个键值对。</span><br><span class="line"> *               Set keySet()这个方法返回所有键的集合。</span><br><span class="line"> *               Collection values()values 方法返回类型是一个 Collection，返回的是所有值对象的集合</span><br><span class="line"> *               containsKey / containsValue这两个方法用来判断在 Map 中键是否存在，或者值是否存在</span><br><span class="line"> *               size() 这个方法返回 Map 中键值对的个数</span><br><span class="line"> *               isEmpty()判断 Map 是否为空</span><br><span class="line"> *               clear()清空 Map</span><br><span class="line"> *               entrySet这个方法返回值类型是一个 Set 集合，集合中放的是 Map.Entry 类型。这个方法是用来做键值对遍历的.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HashMapLearn &#123;</span><br><span class="line">	public static void main(String[] args) &#123;		</span><br><span class="line">		//定义map</span><br><span class="line">		//引用类型Map  =   对象类型Map的实现类HashMap的实例化对象</span><br><span class="line">		Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">		//存储数据put</span><br><span class="line">		map.put(&quot;id&quot;, &quot;04&quot;);</span><br><span class="line">		map.put(&quot;username&quot;, &quot;543&quot;);</span><br><span class="line">		map.put(&quot;password&quot;, &quot;123123&quot;);</span><br><span class="line">		map.put(&quot;name&quot;,&quot;han&quot;);</span><br><span class="line">		//获取数据get  //获得id的映射 并输出</span><br><span class="line">		System.out.println(map.get(&quot;id&quot;));</span><br><span class="line">		//全部输出</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		//修改： 使用put方法 覆盖上次的数据</span><br><span class="line">		map.put(&quot;id&quot;, &quot;05&quot;);</span><br><span class="line">		System.out.println(map.get(&quot;id&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>foreach</title>
    <url>/2018/04/23/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-foreach/</url>
    <content><![CDATA[<p>为了简化遍历的代码，在 5.0 中引入了 foreach 循环。</p>
<span id="more"></span>

<p>基本语法如下：<br>for(变量 : 集合){<br>循环体;<br>}</p>
<p>foreach 循环遍历和迭代遍历是完全等价的,5.0 的编译器会把 foreach 循环自动的翻译成对应的迭代遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一个 Set 而言，采用迭代遍历的代码如下：</span><br><span class="line">Iterator iter = set.iterator();</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">	Object value = iter.next();</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line">改为foreach遍历</span><br><span class="line">for(Object value : set)&#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>static+this+super</title>
    <url>/2018/04/18/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-static+this+super/</url>
    <content><![CDATA[<p>面向对象中的关键字:static、this、super</p>
<span id="more"></span>      
<p>#this 指本类中的引用。<br>    可以利用this调取到本类中的属性及方法。<br>    不能在static方法中使用。</p>
<p>#super 指父类中的引用。<br>    可以利用super调取的父类中的属性及方法。<br>    不能在static方法中使用。</p>
<p>#static 静态的。<br>       在类被加载的时候自动加载。<br>       被static修饰的方法 可被类名直接调用， 不需要new对象使用。</p>
<pre><code>   静态方法访问方法外的成员时，此成员只能是静态成员 -全局变量
   静态方法中不可以写this，super关键字
   静态方法中不能直接调用非静态方法（可通过new对象，对象调用）                               
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestObject extends C &#123;</span><br><span class="line">	static int c = 10;</span><br><span class="line">	int d = 15;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TestObject testObject = new TestObject();</span><br><span class="line"></span><br><span class="line">		testObject.staticTest();</span><br><span class="line">		testObject.thisTest();</span><br><span class="line">		testObject.superTest();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void staticTest() &#123;</span><br><span class="line">		int b = c;</span><br><span class="line">		System.out.println(&quot;staticTest结果&quot; + b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 测试this</span><br><span class="line">	public void thisTest() &#123;</span><br><span class="line">		int d = 5;</span><br><span class="line">		int b = this.d;</span><br><span class="line">		System.out.println(&quot;b=this.d的值为&quot; + b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 测试super</span><br><span class="line">	public void superTest() &#123;</span><br><span class="line">		String eString = super.taiyuan;</span><br><span class="line">		System.out.println(&quot;super测试结果：&quot; + eString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C &#123;</span><br><span class="line">	public String taiyuan = &quot;taiyuan&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>双层循环</title>
    <url>/2018/04/17/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-%E5%8F%8C%E5%B1%82%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>双层循环的逻辑：内循环控制第一个变量，外循环控制第二个变量。</p>
<span id="more"></span>
<p>九九乘法表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1*1=1	</span><br><span class="line">1*2=2	2*2=4	</span><br><span class="line">1*3=3	2*3=6	3*3=9	</span><br><span class="line">1*4=4	2*4=8	3*4=12	4*4=16	</span><br><span class="line">1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	</span><br><span class="line">1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	</span><br><span class="line">1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	</span><br><span class="line">1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	</span><br><span class="line">1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81</span><br></pre></td></tr></table></figure>
<p>内循环的j控制乘数的第一个变量，外循环的i控制乘数的第二个变量。换行条件：第一个变量大于第二个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class For &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">			for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">				System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\t&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>九九乘法表</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类</title>
    <url>/2018/04/19/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>普通类提取出来共性</p>
<span id="more"></span>
<pre><code>抽象类：
    普通类的基础上在类名的返回值类型前加abstract 修饰
    包含抽象方法
    也可能有普通方法
    操作：
        抽象类的实例化对象只能调用抽象类中定义的抽象方法
        抽象类的实例化对象实际执行被子类覆盖的方法。
抽象方法：
    普通方法的基础上在方法的返回值类型前加abstract 修饰
    只能定义在抽象类中
    没有方法体。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Abstract &#123;</span><br><span class="line">	public abstract void show();</span><br><span class="line">	public abstract void eat();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cat extends Abstract&#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;猫吃鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(&quot;我是猫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dog extends Abstract&#123;</span><br><span class="line"></span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		System.out.println(&quot;狗吃骨头&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(&quot;我是狗&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AbstractTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Abstract cat = new Cat();</span><br><span class="line">		cat.show();</span><br><span class="line">		cat.eat();</span><br><span class="line">		</span><br><span class="line">		Abstract dog = new Dog();</span><br><span class="line">		dog.show();</span><br><span class="line">		dog.eat();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java方法</title>
    <url>/2018/04/16/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>对java中方法（函数）的一些个人总结</p>
<span id="more"></span>
<h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><h2 id="普通方法："><a href="#普通方法：" class="headerlink" title="普通方法："></a>普通方法：</h2><p>修饰符（ <em>public static</em> ） 返回值类型（ <em>int</em> ）方法名（ <em>show</em> ）()（参数）{}（方法体）</p>
<p>修饰符：修饰方法，描述调用方法的权限。<br>返回值类型：返回给调用者数据的类型。<br>方法名：标识此方法，命名规范下随意起名<br>参数：传递数据<br>方法体：放执行语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int show()&#123;</span><br><span class="line">	return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法重载：同名的方法（add相同）不同的参数列表（不同数量的参数或不同类型的参数）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public double add(double a, double b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><p>方法名与类名相同，无参数类型，构造对象时执行。主要用于初始化数据(下例中初始化a的值)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Construction &#123;</span><br><span class="line">	int a;</span><br><span class="line">	public Construction()&#123;</span><br><span class="line">		System.out.println(&quot;无参构造&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public Construction(int a)&#123;</span><br><span class="line">		System.out.println(&quot;有参构造&quot;);</span><br><span class="line">		this.a = a;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE-知识点</title>
    <url>/2020/11/12/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>JavaSE-知识点</p>
<span id="more"></span>

<h1 id="JavaSE-知识点"><a href="#JavaSE-知识点" class="headerlink" title="JavaSE-知识点"></a>JavaSE-知识点</h1><p>关键字，操作符，String类，重载与重写。面对对象，异常，集合类，线程，反射</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ol>
<li><p>static </p>
<p>static方法是否可以对非static方法的调用？</p>
<p>不能。当一个static方法被调用时，可能还没有创建任何实例对象。</p>
</li>
<li><p>final 类生成的实例化对象不可改变。</p>
</li>
<li><p>finally： try catch 最终执行的代码放在finally中，比如关闭资源。</p>
</li>
<li><p>finalize: Object的方法，垃圾收集器执行时调用此方法。</p>
</li>
<li><p>Integer与int的区别?</p>
<p>int是java的8大基本类型</p>
<p>Integer是int的包装类。</p>
</li>
</ol>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ol>
<li><p>&amp;和&amp;&amp;的区别</p>
<p>表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运bai算结果才为true，否则，只要有一方为false，则结果为false。</p>
<p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。</p>
<p>&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作</p>
</li>
<li><p>用最有效率的方法计算2乘以8</p>
<p> 2 &lt;&lt; 3</p>
</li>
</ol>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ol>
<li><p>String，StringBuffer，StringBuilder</p>
<p>String不可改变。</p>
<p>StringBuffer线程安全。</p>
<p>StringBuilder线程不安全，效率高。</p>
</li>
<li><p>equals</p>
</li>
<li><p>String s = new String(“xyz”);生成了几个对象</p>
<p>1个或两个。</p>
<p>常量池已经有”xyz”时，只生成了new String(“xyz”)一个对象。</p>
<p>String s 中 s是类String的引用。new String(“xyz”)是创建对象。</p>
</li>
<li><p>String s = “Hello”;s = s + “world!”;这两行代码执行后，原始的String对象中的内容到底变了没有？</p>
<p>没有改变。final修饰的类，其对象不会被改变。</p>
</li>
<li><p>下面这条语句一共创建了多少个对象：String s=”a”+”b”+”c”+”d”;</p>
<p>1个。class文件中自动将其拼接。</p>
</li>
</ol>
<h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重写：重写父类的方法</p>
<p>重载：本类中相同方法名不同形参。</p>
<h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><p>封装，继承，多态。</p>
<p>接口，抽象类</p>
<p>接口多继承，类单继承。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li><p>异常处理机制的简单原理和应用</p>
<p>TODO</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>重载与重写</title>
    <url>/2018/04/19/212Java%E8%AF%AD%E8%A8%80/JavaSE/JavaSE-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<p>重载与重写的不同</p>
<span id="more"></span>
<p>重写:将父类中的某个方法重新定义<br>      前提：继承关系<br>      在子类中定义一个和父类方法名相同的方法。 并在子类同名方法中编写自己的内容。</p>
<pre><code>       重载                          重写
  一个类中的同名方法，           子父类中的同名方法
  控制同名方法的参数类别         控制同名方法的载体
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OverrideTest extends Override&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		OverrideTest overrideTest = new OverrideTest();</span><br><span class="line">		overrideTest.method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void method() &#123;</span><br><span class="line">		//super继承父类方法中的内容</span><br><span class="line">		super.method();</span><br><span class="line">		System.out.println(&quot;重写method方法&quot;);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Override &#123;</span><br><span class="line">	public void method() &#123;</span><br><span class="line">		System.out.println(&quot;method方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-入门</title>
    <url>/2020/09/30/212Java%E8%AF%AD%E8%A8%80/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Multithreading-入门</p>
<span id="more"></span>

<h1 id="多线程-入门"><a href="#多线程-入门" class="headerlink" title="多线程-入门"></a>多线程-入门</h1><ul>
<li>1.线程的生命周期</li>
</ul>
<ul>
<li>2.创建线程</li>
<li>3.多线程编程的主要概念</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Multithreading &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);</span><br><span class="line">        R1.start();</span><br><span class="line"></span><br><span class="line">        RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);</span><br><span class="line">        R2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  1.线程的生命周期：新建、就绪、阻塞、运行、死亡</span><br><span class="line"> *  新建：new</span><br><span class="line"> *  就绪：新建状态调用start()方法，手动调用。</span><br><span class="line"> *  运行：就绪状态调用run()方法，自动调用。就绪状态的线程获取到满足运行的 CPU 资源，就执行 run()，</span><br><span class="line"> *  阻塞：线程执行sleep(睡眠)、suspend(挂起).</span><br><span class="line"> *       等待阻塞：运行状态执行wait()</span><br><span class="line"> *       同步阻塞：线程获取synchronized同步锁失败。</span><br><span class="line"> *       其他阻塞：调用线程的sleep()或join()发出来I/O请求。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</span><br><span class="line"> *  死亡：线程执行完或有终止条件</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 2.创建线程</span><br><span class="line"> *     1.实现Runnable接口</span><br><span class="line"> *     2.继承Thread类</span><br><span class="line"> *     3.通过 Callable 和 Future 创建线程</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//2.1.实现Runnable接口</span><br><span class="line">class RunnableDemo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private Thread t;</span><br><span class="line">    private String threadName;</span><br><span class="line"></span><br><span class="line">    RunnableDemo (String name)&#123;</span><br><span class="line">        this.threadName = name;</span><br><span class="line">        System.out.println(&quot;Thread &quot; +  threadName  + &quot;新建 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重写run方法</span><br><span class="line">    // 运行</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Thread &quot; +  threadName + &quot;运行&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;次执行Thread: &quot; + threadName);</span><br><span class="line">                // 阻塞</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Thread &quot; +  threadName + &quot;死亡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start()&#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            // 新建</span><br><span class="line">            t = new Thread (this, threadName);</span><br><span class="line">            // 就绪</span><br><span class="line">            t.start();</span><br><span class="line">            System.out.println(&quot;Thread &quot; +  threadName + &quot; 就绪&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.多线程编程的主要概念：</p>
<ul>
<li><pre><code>线程同步
</code></pre>
</li>
<li><pre><code>线程间通信
</code></pre>
</li>
<li><pre><code>线程死锁
</code></pre>
</li>
<li><pre><code>线程控制：挂起、停止和恢复
</code></pre>
</li>
<li>线程池</li>
</ul>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法</title>
    <url>/2021/07/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数据结构和算法</p>
<span id="more"></span>

<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="代码效率-时间复杂度与空间复杂度"><a href="#代码效率-时间复杂度与空间复杂度" class="headerlink" title="代码效率-时间复杂度与空间复杂度"></a>代码效率-时间复杂度与空间复杂度</h3><p>代码运行效率用复杂度衡量。</p>
<p>代码运行消耗时间和空间。</p>
<p>现实中的例子：</p>
<ul>
<li>汽车在有红绿灯的十字路口通行。红绿灯时汽车等待，消耗时间。</li>
<li>汽车在建有立交桥的十字路口通行，不用等待，立交桥消耗空间。 </li>
</ul>
<p>时间、空间消耗和输入量密切相关，无法直接定量衡量。为了更客观的评判时间消耗和空间消耗，我们关注输入量与时间、空间的关系。即时间复杂度、空间复杂度。</p>
<p>时间复杂度与代码结构密切相关，空间复杂度与数据结构密切相关。</p>
<p>不同时间复杂度的计算次数例子：100万条数据的处理</p>
<ul>
<li>O(n²)，10的十二次方</li>
<li>O(n)，10的六次方</li>
<li>O(log n)，20次</li>
</ul>
<p>时间无价，空间有价。</p>
<p>数据结构：连接时间和空间复杂度</p>
<p>代码优化：</p>
<ol>
<li>暴力解法</li>
<li>剔除无效计算、无效存储。（递归、回溯、分治（包括二分法）、排序算法、查找算法、贪婪、动态规划）</li>
<li>使用数据结构，将时间复杂度向空间复杂度转移</li>
</ol>
<p>代码的时间复杂度和常量系数无关，代码的执行时间与常量系数有关。</p>
<h3 id="复杂度估算"><a href="#复杂度估算" class="headerlink" title="复杂度估算"></a>复杂度估算</h3><p>复杂度是关于输入数据量n的函数。</p>
<ul>
<li><p>我们假定输入量为n，代码执行n次，复杂度为O(n)；</p>
</li>
<li><p>我们假定输入量为n，代码执行k常数次，与输入量无关，则复杂度为O(1)；</p>
</li>
<li><p>不同数量级的多项复杂度相加时，去数量级高的值。O(n²)+O(n) = O(n²)</p>
</li>
</ul>
<p>常见的复杂度：</p>
<ul>
<li>顺序执行，O(1);</li>
<li>一层for循环，O(n);</li>
<li>两个顺序执行for循环，O(n);</li>
<li>两层嵌套for循环，O(n²);</li>
<li>二分查找，即二分分而治之，O(log n);</li>
</ul>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul>
<li><p>遍历</p>
</li>
<li><p>增</p>
<ul>
<li>中间增加，元素位置顺序改变</li>
<li>末尾增加</li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>中间删除，元素位置顺序改变</li>
<li>末尾删除</li>
</ul>
</li>
<li><p>查</p>
<p>能否在数据结构中找到此元素。</p>
<ul>
<li>基于位置查询（索引、下标）</li>
<li>基于数值特征查询（数值相等）</li>
</ul>
</li>
</ul>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>算法：递归、分治（二分是重点）、回溯、贪婪、动态规划</p>
<h3 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h3><p>分析数据处理顺序、数据操作，选择不同的数据结构。</p>
<p>不同数据结构特点[参考，按住Control点我](# 各类数据结构对比)</p>
<h3 id="Java-数据结构API"><a href="#Java-数据结构API" class="headerlink" title="Java 数据结构API"></a>Java 数据结构API</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 复制数组</span><br><span class="line">int[] arr = new int[]&#123;1,2&#125;;</span><br><span class="line">int[] ints = Arrays.copyOf(arr, arr.length);</span><br><span class="line"></span><br><span class="line">// 字符串转字符数组</span><br><span class="line">String word = &quot;abc&quot;;</span><br><span class="line">char[] wordChars = word.toCharArray();</span><br><span class="line"></span><br><span class="line">// 输出数组内容</span><br><span class="line">Arrays.toString(arr);</span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = new HashMap();</span><br><span class="line">map.put(&quot;a&quot;,&quot;1&quot;);</span><br><span class="line">map.get(&quot;a&quot;);</span><br><span class="line">map.size();</span><br><span class="line">map.containsKey(&quot;a&quot;);</span><br><span class="line">map.remove(&quot;a&quot;);</span><br><span class="line">// 遍历</span><br><span class="line">for (Map.Entry&lt;String,String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey()+ map.get(entry.getKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双端队列-链表"><a href="#双端队列-链表" class="headerlink" title="双端队列-链表"></a>双端队列-链表</h4><p>LinkedList</p>
<table>
<thead>
<tr>
<th></th>
<th>第一个（头）</th>
<th>最后一个（尾）</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>offerFirst(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>pollFirst()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>获取元素</td>
<td>peekFirst()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>入队</th>
<th>出队（拿最大元素</th>
</tr>
</thead>
<tbody><tr>
<td>数组线性结构</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链式线性结构</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉堆</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody></table>
<h4 id="优先队列（二叉堆）PriorityQueue"><a href="#优先队列（二叉堆）PriorityQueue" class="headerlink" title="优先队列（二叉堆）PriorityQueue"></a>优先队列（二叉堆）PriorityQueue</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化大小为k的元素为int[]的小根堆（顶为堆中数组元素int[1]最小）</span><br><span class="line">PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue(k, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(int[] newValue, int[] pileTop) &#123;// 小值放到堆顶</span><br><span class="line">    	return newValue[1] - pileTop[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据的组织形式。对数据组织成一定的结构。</p>
<h3 id="1-线性表-链表"><a href="#1-线性表-链表" class="headerlink" title="1.线性表-链表"></a>1.线性表-链表</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>n 个相同特性数据元素的有限序列。</p>
<p>在链表中存储的数据元素也叫作结点，一个结点存储的就是一条数据记录。每个结点的结构包括两个部分：</p>
<ul>
<li>第一是具体的数据值；</li>
</ul>
<ul>
<li>第二是指向下一个结点的指针。</li>
</ul>
<p>在链表的最前面，通常会有个头指针用来指向第一个结点。对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。</p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h5><p>有一个链表，它存储了 10 个同学的考试成绩。现在将一个同学的成绩插入到第4个位置。</p>
<p>链表在执行数据新增的时候非常容易，只需要把待插入结点的指针指向原指针的目标，把原来的指针指向待插入的结点，就可以了。</p>
<p>p   s(带插入) t</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.next = p.next;</span><br><span class="line">p.next = s;</span><br></pre></td></tr></table></figure>

<p>复杂度：O(1)</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.next = p.next.next;</span><br></pre></td></tr></table></figure>

<p>复杂度：O(1)</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li><p>按照位置序号来查找</p>
<p>一个一个地遍历去查找。</p>
<p>复杂度：O(n)</p>
</li>
<li><p>按照具体的成绩来查找</p>
<p>一个一个地遍历去查找。</p>
<p>复杂度：O(n)</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果处理数据时有顺序，数据的元素个数不确定，且需要经常进行数据的新增和删除时，那么链表会比较合适。</p>
<ul>
<li>数据按照顺序存储，可以有序遍历数据。</li>
</ul>
<ul>
<li>按照数值的条件进行查找时，需要遍历，时间复杂度O(n)。</li>
<li>新增数据，复杂度是O(1)。伴随查找的动作，新增复杂度变为了O(n)</li>
<li>删除数据时，复杂度是O(1)。伴随查找的动作，新增复杂度变为了O(n)</li>
</ul>
<h4 id="链表算法题"><a href="#链表算法题" class="headerlink" title="链表算法题"></a>链表算法题</h4><ol>
<li><p>链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</p>
<p>分析：单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</p>
</li>
<li><p>求奇数结点链表的中间结点的数据</p>
<p>分析：未知长度的数据，获取总长度的一半。利用快慢指针，快指针是慢指针的前进速度的两倍，循环次数是数组长度的一半。</p>
</li>
<li><p>链表是否有环</p>
<p>快慢指针，有环时，慢指针循环一圈必定与快指针相遇一次。</p>
</li>
</ol>
<h3 id="2-线性表-栈"><a href="#2-线性表-栈" class="headerlink" title="2.线性表-栈"></a>2.线性表-栈</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>线性表的变种，元素先进后出。栈的数据新增操作只能在末端进行，不允许在栈的中间某个结点后新增数据。</p>
<p>数组或者链表的操作过于灵活，过多暴露了可操作的接口。这些没有意义的接口过多，当数据量很大的时候就会出现一些隐藏的风险。</p>
<h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p>同链表，有表头和表尾</p>
<h4 id="数据操作-2"><a href="#数据操作-2" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增-1"><a href="#新增-1" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>顺序栈</p>
<p>java中使用List实现栈。</p>
<p>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。一般以 top 是否为 -1 来判定是否为空栈。当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。</p>
<p>只在栈顶操作，时间复杂度O(1)</p>
</li>
<li><p>链栈</p>
<p>用链表的方式实现栈。</p>
<p>通常，可以把栈顶放在单链表的头部，如下图所示。由于链栈的后进先出，原来的头指针就毫无作用了。因此，对于链栈来说，是不需要头指针的。相反，它需要增加指向栈顶的 top 指针，这是压栈和出栈操作的重要支持。</p>
<p>只在栈顶操作，时间复杂度O(1)</p>
</li>
</ul>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>同新增</p>
<h5 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h5><p>同链表</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序</li>
<li>新增时间复杂度O(1)，但只能在栈顶操作</li>
<li>删除时间复杂度O(1)，但只能在栈顶操作</li>
<li>查询时间复杂度O(n)</li>
</ul>
<h4 id="栈算法题"><a href="#栈算法题" class="headerlink" title="栈算法题"></a>栈算法题</h4><ol>
<li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。</li>
<li>链表每k个元素翻转，如：链表：123456，k=3，则结果 321654</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>浏览器回退页面效果。</li>
</ol>
<h3 id="3-线性表-队列"><a href="#3-线性表-队列" class="headerlink" title="3.线性表-队列"></a>3.线性表-队列</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>线性表的变种，元素先进先出。</p>
<p>队列的数据新增操作只能在末端进行，不允许在队列的中间某个结点后新增数据;</p>
<p>队列的数据删除操作只能在始端进行，不允许在队列的中间某个结点后删除数据。</p>
<h4 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h4><h4 id="数据操作-3"><a href="#数据操作-3" class="headerlink" title="数据操作"></a>数据操作</h4><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序</li>
<li>新增时间复杂度O(1)，但只能在队尾操作</li>
<li>删除时间复杂度O(1)，但只能在队头操作</li>
<li>查询时间复杂度O(n)</li>
</ul>
<h4 id="队列算法题"><a href="#队列算法题" class="headerlink" title="队列算法题"></a>队列算法题</h4><ol>
<li>约瑟夫环问题。已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。</li>
</ol>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>面对数据处理顺序非常敏感的问题时，使用队列。</p>
<ul>
<li><p>可以确定队列长度最大值时，建议使用循环队列。</p>
</li>
<li><p>无法确定队列长度时，应考虑使用链式队列。</p>
</li>
</ul>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>LinkedList</p>
<table>
<thead>
<tr>
<th></th>
<th>第一个（头）</th>
<th>最后一个（尾）</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>offerFirst(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>pollFirst()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>获取元素</td>
<td>peekFirst()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>普通队列：先进先出；后进先出</p>
<p>优先队列：出队顺序和入队顺序无关；和优先级相关。优先级最高的在队首</p>
<p>底层可以使用不同的数据结构：</p>
<table>
<thead>
<tr>
<th></th>
<th>入队</th>
<th>出队（拿最大元素</th>
</tr>
</thead>
<tbody><tr>
<td>数组线性结构</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链式线性结构</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉堆</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody></table>
<p>PriorityQueue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化大小为k的元素为int[]的小根堆（顶为堆中数组元素int[1]最小）</span><br><span class="line">PriorityQueue&lt;int[]&gt; priorityQueue = new PriorityQueue(k, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(int[] newValue, int[] pileTop) &#123;// 小值放到堆顶</span><br><span class="line">    	return newValue[1] - pileTop[1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="4-线性表衍生-数组"><a href="#4-线性表衍生-数组" class="headerlink" title="4.线性表衍生-数组"></a>4.线性表衍生-数组</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>存储一个固定大小的相同类型元素的顺序集合。</p>
<h4 id="存储结构-3"><a href="#存储结构-3" class="headerlink" title="存储结构"></a>存储结构</h4><p>数组在内存中是连续存放的，数组内的数据，可以通过索引值直接取出得到。</p>
<h4 id="数据操作-4"><a href="#数据操作-4" class="headerlink" title="数据操作"></a>数据操作</h4><h5 id="新增-2"><a href="#新增-2" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>数组的最后增加一个新的元素</p>
<p>对原数据产生没有任何影响。时间复杂度是 O(1)。</p>
</li>
<li><p>数组中间的某个位置新增数据</p>
<p>原数据的位置需要依次向后挪动 1 个位置。时间复杂度是 O(n)。</p>
</li>
</ul>
<h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><p>同新增</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><ul>
<li>根据位置值查找，时间复杂度是 O(1)。</li>
<li>根据数值查找，时间复杂度是 O(n)。</li>
</ul>
<h4 id="数组算法题"><a href="#数组算法题" class="headerlink" title="数组算法题"></a>数组算法题</h4><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据有序存储，遍历有序。</li>
<li>根据索引查找快，时间复杂度O(1)</li>
<li>根据数值查找，时间复杂度O(n)</li>
<li>中间位置删除数据，时间复杂度O(n)；末尾删除，时间复杂度O(1)。</li>
<li>中间位置新增数据，时间复杂度O(n)；末尾新增，时间复杂度O(1)。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5.字符串"></a>5.字符串</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>字符串（string） 是由 n 个字符组成的一个有序整体（ n &gt;= 0 ）。</p>
<p>特殊字符串：</p>
<ul>
<li><p>空串，指含有零个字符的串。例如，s = “”</p>
</li>
<li><p>空格串，只包含空格的串。例如，s = “   “</p>
</li>
<li><p>子串，串中任意连续字符组成的字符串叫作该串的子串。</p>
</li>
<li><p>原串通常也称为主串。</p>
<p>例如：a = “BEI”，b = “BEIJING”，c = “BJINGEI” 。</p>
<ul>
<li>对于字符串 a 和 b 来说，由于 b 中含有字符串 a ，所以可以称 a 是 b 的子串，b 是 a 的主串；</li>
<li>对于 c 和 a 而言，虽然 c 中也含有 a 的全部字符，但不是连续的 “BEI” ，所以串 c 和 a 没有任何关系。</li>
</ul>
</li>
</ul>
<h4 id="存储结构-4"><a href="#存储结构-4" class="headerlink" title="存储结构"></a>存储结构</h4><p>有顺序存储和链式存储两种。</p>
<ul>
<li><p>顺序存储</p>
<p>用一组地址连续的存储单元来存储串中的字符序列，一般是用定长数组来实现。</p>
</li>
<li><p>链式存储</p>
<p>由于串结构的特殊性（结构中的每个元素数据都是一个字符），如果也简单地将每个链结点存储为一个字符，就会造成很大的空间浪费。因此，一个结点可以考虑存放多个字符，如果最后一个结点未被占满时，可以使用 “#” 或其他非串值字符补全。</p>
</li>
</ul>
<h4 id="数据操作-5"><a href="#数据操作-5" class="headerlink" title="数据操作"></a>数据操作</h4><p>字符串的数据操作与线性表有很大差别。线性表更关注的是单个元素的操作，比如增删查一个元素，而字符串中更多关注的是查找子串的位置、替换等操作。</p>
<h5 id="新增-3"><a href="#新增-3" class="headerlink" title="新增"></a>新增</h5><ul>
<li><p>顺序存储</p>
<p>字符串的新增操作和数组相似，都牵涉对插入字符串之后字符的挪移操作，时间复杂度是 O(n)。</p>
</li>
</ul>
<h5 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h5><p>和新增相似</p>
<h5 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h5><p>需要做的是子串查找或字符串匹配。</p>
<p>在主串n中找模式串m，时间复杂度是 n 和 m 的函数。O(nm)</p>
<p>假设要从主串 s = “goodgoogle” 中找到 t = “google” 子串。</p>
<h4 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h4><ol>
<li>两个字符串的最大公共字串。如：a = “13452439”， b = “123456”。输出字符串”345”</li>
</ol>
<h3 id="6-树（二叉树、红黑树、堆、前缀树、线段树）"><a href="#6-树（二叉树、红黑树、堆、前缀树、线段树）" class="headerlink" title="6.树（二叉树、红黑树、堆、前缀树、线段树）"></a>6.树（二叉树、红黑树、堆、前缀树、线段树）</h3><p>博客 TODO</p>
<h3 id="7-哈希表"><a href="#7-哈希表" class="headerlink" title="7.哈希表"></a>7.哈希表</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>实现 “地址 = f (关键字)” 的映射关系</p>
<h4 id="存储结构-5"><a href="#存储结构-5" class="headerlink" title="存储结构"></a>存储结构</h4><p>特点：</p>
<ul>
<li><p>数据没有顺序。</p>
</li>
<li><p>数据存储与数据数值（关键字）有关。</p>
</li>
</ul>
<h4 id="数据操作-6"><a href="#数据操作-6" class="headerlink" title="数据操作"></a>数据操作</h4><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li>数据没有顺序。</li>
<li>根据数值查找，时间复杂度O(1)</li>
<li>新增时间复杂度O(1)</li>
<li>删除时间复杂度O(1)</li>
</ul>
<h4 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h4><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>满足以下：</p>
<ul>
<li>不需要有序遍历数据</li>
<li>n次查询</li>
<li>可以提前预测数据量的大小。</li>
</ul>
<h3 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h3><h4 id="知识点-TODO"><a href="#知识点-TODO" class="headerlink" title="知识点 TODO"></a>知识点 TODO</h4><p>图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）</p>
<p>图的遍历：深度优先、广度优先</p>
<p>二部图的检测（Bipartite）（785）、树的检测、环的检测：有向图、无向图</p>
<p>拓扑排序</p>
<p>联合-查找算法（Union-Find）</p>
<p>最短路径：Dijkstra、Bellman-Ford</p>
<h3 id="各类数据结构对比"><a href="#各类数据结构对比" class="headerlink" title="各类数据结构对比"></a>各类数据结构对比</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th>链表</th>
<th>数组</th>
<th>字符串</th>
<th>栈</th>
<th>普通队列</th>
<th>优先队列（二叉堆）</th>
<th>二叉搜索树</th>
<th>前缀树</th>
<th>哈希表</th>
</tr>
</thead>
<tbody><tr>
<td>数据有序性</td>
<td></td>
<td>有</td>
<td>无</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查询时间复杂度</td>
<td>按位置</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>按数值</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(mn)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>？</td>
<td>O(logn)</td>
<td></td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>新增时间复杂度</td>
<td>中间</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td></td>
<td>O(1)</td>
</tr>
<tr>
<td>末尾</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>删除时间复杂度</td>
<td>中间</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>-</td>
<td>-</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td></td>
<td>O(1)</td>
</tr>
<tr>
<td>末尾</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><p>某个函数自己调用自己。</p>
<p>递归的使用条件需满足以下两个条件：</p>
<ul>
<li><p>可以拆解为除了数据规模以外，求解思路与原问题完全相同的子问题；</p>
</li>
<li><p>存在终止条件。</p>
</li>
</ul>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn(n) &#123;</span><br><span class="line">    // 第一步：判断输入合理性？</span><br><span class="line">    if (input is invalid) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第二步：递归结束条件?</span><br><span class="line">    if (match condition) &#123;</span><br><span class="line">        return some value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第三步：缩小问题规模</span><br><span class="line">    result1 = fn(n1)</span><br><span class="line">    result2 = fn(n2)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 第四步: 获取结果</span><br><span class="line">    return combine(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归算法题"><a href="#递归算法题" class="headerlink" title="递归算法题"></a>递归算法题</h4><ol>
<li>二叉树中序遍历</li>
<li>汉诺塔</li>
<li>斐波那契数列</li>
</ol>
<h3 id="2-分治"><a href="#2-分治" class="headerlink" title="2.分治"></a>2.分治</h3><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p>定义：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92">递归</a>地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>特征：</p>
<ol>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li>
</ol>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><h4 id="分治算法题"><a href="#分治算法题" class="headerlink" title="分治算法题"></a>分治算法题</h4><ol>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>快速排序</li>
<li>归并排序</li>
<li>汉诺塔</li>
</ol>
<h3 id="3-回溯"><a href="#3-回溯" class="headerlink" title="3.回溯"></a>3.回溯</h3><h3 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4.排序算法"></a>4.排序算法</h3><h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><h3 id="5-查找算法"><a href="#5-查找算法" class="headerlink" title="5.查找算法"></a>5.查找算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>满足以下两点：</p>
<ul>
<li>时间复杂度O(logn)</li>
<li>数据有序</li>
</ul>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h4 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h4><h5 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h5><p>从起点出发，从规定的方向中选择其中一个不断地向前走，直到无法继续为止，然后尝试另外一种方向，直到最后走到终点。</p>
<p>解决连通性问题，从起点能不能到终点。</p>
<p>依赖栈，后进先出。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>给定一个二维矩阵代表一个迷宫，迷宫里面有通道，也有墙壁，通道由数字 0 表示，而墙壁由 -1 表示，有墙壁的地方不能通过，那么，能不能从 A 点走到 B 点。<img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/X7tLmsSGlF1JBE8.png" alt="image-20210829203111589"></p>
<h4 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h4><h3 id="6-贪婪"><a href="#6-贪婪" class="headerlink" title="6.贪婪"></a>6.贪婪</h3><h3 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7.动态规划"></a>7.动态规划</h3>]]></content>
      <categories>
        <category>编程基础</category>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-高级特性</title>
    <url>/2020/08/27/213Java%E6%A1%86%E6%9E%B6/RabbitMQ-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>消息可靠投递，Consumer ACK，消费者限流（削峰填谷)，TTL，DLX死信队列，延迟队列，消息追踪</p>
<span id="more"></span>

<h1 id="RabbitMQ-高级特性"><a href="#RabbitMQ-高级特性" class="headerlink" title="RabbitMQ-高级特性"></a>RabbitMQ-高级特性</h1><h2 id="消息可靠投递"><a href="#消息可靠投递" class="headerlink" title="消息可靠投递"></a>消息可靠投递</h2><p>producer到RabbitMQ</p>
<ul>
<li><p>producer→exchange</p>
<p>通过confirmCallback回调函数确认消息的投递</p>
<p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq.host=192.168.3.3</span><br><span class="line">rabbitmq.port=5672</span><br><span class="line">rabbitmq.username=guest</span><br><span class="line">rabbitmq.password=guest</span><br><span class="line">rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure>

<p>xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                 http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                 http://www.springframework.org/schema/context</span><br><span class="line">                 https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">                 http://www.springframework.org/schema/rabbit</span><br><span class="line">                 http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;&gt;</span><br><span class="line">    &lt;!--加载配置文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:rabbitmq.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义rabbitmq connectionFactory  1. 设置  publisher-confirms=&quot;true&quot; --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;$&#123;rabbitmq.host&#125;&quot;</span><br><span class="line">                               port=&quot;$&#123;rabbitmq.port&#125;&quot;</span><br><span class="line">                               username=&quot;$&#123;rabbitmq.username&#125;&quot;</span><br><span class="line">                               password=&quot;$&#123;rabbitmq.password&#125;&quot;</span><br><span class="line">                               virtual-host=&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span><br><span class="line">                               </span><br><span class="line">                               publisher-confirms=&quot;true&quot;</span><br><span class="line">                               /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--rabbitTemplate对象操作可以在代码中方便发送消息--&gt;</span><br><span class="line">    &lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;connectionFactory&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--2. 消息可靠性投递（生产端）--&gt;</span><br><span class="line">    &lt;!--队列--&gt;</span><br><span class="line">   &lt;rabbit:queue id=&quot;test_queue_confirm&quot; name=&quot;test_queue_confirm&quot;&gt;&lt;/rabbit:queue&gt;</span><br><span class="line">   &lt;!--交换机--&gt;</span><br><span class="line">    &lt;rabbit:direct-exchange name=&quot;test_exchange_confirm&quot;&gt;</span><br><span class="line">    	&lt;!--交换机绑定队列--&gt;</span><br><span class="line">        &lt;rabbit:bindings&gt;</span><br><span class="line">            &lt;rabbit:binding queue=&quot;test_queue_confirm&quot; key=&quot;confirm&quot;&gt;			               &lt;/rabbit:binding&gt;</span><br><span class="line">        &lt;/rabbit:bindings&gt;</span><br><span class="line">    &lt;/rabbit:direct-exchange&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-producer.xml&quot;)</span><br><span class="line">public class ProducerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 确认模式：</span><br><span class="line">     * 步骤：</span><br><span class="line">     * 1. 确认模式开启：ConnectionFactory中开启publisher-confirms=&quot;true&quot;</span><br><span class="line">     * 2. 在rabbitTemplate定义ConfirmCallBack回调函数</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testConfirm() &#123;</span><br><span class="line"></span><br><span class="line">        //2. 定义回调 **</span><br><span class="line">        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">            /**</span><br><span class="line">             *</span><br><span class="line">             * @param correlationData 相关配置信息</span><br><span class="line">             * @param ack   exchange交换机 是否成功收到了消息。true 成功，false代表失败</span><br><span class="line">             * @param cause 失败原因</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</span><br><span class="line">                System.out.println(&quot;confirm方法被执行了....&quot;);</span><br><span class="line"></span><br><span class="line">                if (ack) &#123;</span><br><span class="line">                    //接收成功</span><br><span class="line">                    System.out.println(&quot;接收成功消息&quot; + cause);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //接收失败</span><br><span class="line">                    System.out.println(&quot;接收失败消息&quot; + cause);</span><br><span class="line">                    //做处理，如让消息再次发送。</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //3. 发送消息</span><br><span class="line">        //rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;test_exchange_confirm1&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>exchange→queue</p>
<p>returnCallback</p>
<ol>
<li><p>xml开启配置return-true。增加publisher-returns=”true”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义rabbitmq connectionFactory  1. 设置  publisher-confirms=&quot;true&quot; --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;$&#123;rabbitmq.host&#125;&quot;</span><br><span class="line">                             port=&quot;$&#123;rabbitmq.port&#125;&quot;</span><br><span class="line">                               username=&quot;$&#123;rabbitmq.username&#125;&quot;</span><br><span class="line">                             password=&quot;$&#123;rabbitmq.password&#125;&quot;</span><br><span class="line">                               virtual-host=&quot;$&#123;rabbitmq.virtual-host&#125;&quot;</span><br><span class="line">                               </span><br><span class="line">                               publisher-confirms=&quot;true&quot;</span><br><span class="line">                             &lt;!-- 开启配置return-true --&gt;</span><br><span class="line">                               publisher-returns=&quot;true&quot;</span><br><span class="line">                             /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>producer中编写测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 步骤：</span><br><span class="line"> * 1. 开启回退模式:publisher-returns=&quot;true&quot;</span><br><span class="line"> * 2. 设置ReturnCallBack</span><br><span class="line"> * 3. 设置Exchange处理消息的模式：</span><br><span class="line"> *  1. 如果消息没有路由到Queue，则丢弃消息（默认）</span><br><span class="line"> *  2. 如果消息没有路由到Queue，返回给消息发送方ReturnCallBack</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testReturn() &#123;</span><br><span class="line"></span><br><span class="line">    //设置交换机处理失败消息的模式</span><br><span class="line">    rabbitTemplate.setMandatory(true);</span><br><span class="line"></span><br><span class="line">    //2.设置ReturnCallBack</span><br><span class="line">    rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        /**</span><br><span class="line">         *</span><br><span class="line">         * @param message   消息对象</span><br><span class="line">         * @param replyCode 错误码</span><br><span class="line">         * @param replyText 错误信息</span><br><span class="line">         * @param exchange  交换机</span><br><span class="line">         * @param routingKey 路由键</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123;</span><br><span class="line">            System.out.println(&quot;return 执行了....&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(message);</span><br><span class="line">            System.out.println(replyCode);</span><br><span class="line">            System.out.println(replyText);</span><br><span class="line">            System.out.println(exchange);</span><br><span class="line">            System.out.println(routingKey);</span><br><span class="line"></span><br><span class="line">            //处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //3. 发送消息   </span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_confirm&quot;, &quot;confirm&quot;, &quot;message confirm....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="Consumer-ACK"><a href="#Consumer-ACK" class="headerlink" title="Consumer ACK"></a>Consumer ACK</h2><p>RabbitMQ到consumer</p>
<p>消费端收到消息后的确认方式有三种。</p>
<ul>
<li>自动确认：acknowledge=”<strong>none</strong>“，当消息被Consumer接收到，则自动确认收到，并将message 从 RabbitMQ 的消息缓存中移除。</li>
</ul>
<ul>
<li>手动确认：acknowledge=”<strong>manual</strong>“，在业务处理完成后，调用channel.basicAck()，手动签收；如果出现异常，则调用channel.basicNack()方法，让其重新发送消息。</li>
</ul>
<ul>
<li>根据异常情况确认：acknowledge=”<strong>auto</strong>“</li>
</ul>
<ol>
<li><p>xml中配置手动接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">             http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">             http://www.springframework.org/schema/context</span><br><span class="line">             https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">             http://www.springframework.org/schema/rabbit</span><br><span class="line">             http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;&gt;</span><br><span class="line">    &lt;!--加载配置文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;classpath:rabbitmq.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义rabbitmq connectionFactory --&gt;</span><br><span class="line">    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;$&#123;rabbitmq.host&#125;&quot;</span><br><span class="line">                               port=&quot;$&#123;rabbitmq.port&#125;&quot;</span><br><span class="line">                               username=&quot;$&#123;rabbitmq.username&#125;&quot;</span><br><span class="line">                               password=&quot;$&#123;rabbitmq.password&#125;&quot;</span><br><span class="line">                               virtual-host=&quot;$&#123;rabbitmq.virtual-host&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.xiaoruiit.listener&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义监听器容器  添加  acknowledge=&quot;manual&quot; 手动--&gt;</span><br><span class="line">    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;manual&quot; &gt;</span><br><span class="line">        &lt;rabbit:listener ref=&quot;ackListener&quot; queue-names=&quot;test_queue_confirm&quot;&gt;	</span><br><span class="line">        &lt;/rabbit:listener&gt;</span><br><span class="line">    &lt;/rabbit:listener-container&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>监听类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.listener;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import org.springframework.amqp.core.Message;</span><br><span class="line">import org.springframework.amqp.core.MessageListener;</span><br><span class="line">import org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Consumer ACK机制：</span><br><span class="line"> *  1. 设置手动签收。acknowledge=&quot;manual&quot;</span><br><span class="line"> *  2. 让监听器类实现ChannelAwareMessageListener接口</span><br><span class="line"> *  3. 如果消息成功处理，则调用channel的 basicAck()签收</span><br><span class="line"> *  4. 如果消息处理失败，则调用channel的basicNack()拒绝签收，broker重新发送给consumer</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class AckListener implements ChannelAwareMessageListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line">        long deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //1.接收转换消息</span><br><span class="line">            System.out.println(new String(message.getBody()));</span><br><span class="line"></span><br><span class="line">            //2. 处理业务逻辑</span><br><span class="line">            System.out.println(&quot;处理业务逻辑...&quot;);</span><br><span class="line">            int i = 3/0;//出现错误</span><br><span class="line">            //3. 手动签收</span><br><span class="line">            channel.basicAck(deliveryTag,true);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            //4.拒绝签收</span><br><span class="line">            /*</span><br><span class="line">            第三个参数：requeue：重回队列。如果设置为true，则消息重新回到queue，broker会重新发送该消息给消费端</span><br><span class="line">             */</span><br><span class="line">            channel.basicNack(deliveryTag,true,true);</span><br><span class="line">            // 了解</span><br><span class="line">            //channel.basicReject(deliveryTag,true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:spring-rabbitmq-consumer.xml&quot;)</span><br><span class="line">public class ConsumerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="消费者限流"><a href="#消费者限流" class="headerlink" title="消费者限流"></a>消费者限流</h2><p>削（xue)峰填谷,RabbitMQ将瞬时的高并发消息慢慢分发给对消息后续处理的系统。</p>
<p>作用：</p>
<ul>
<li><p>缓解瞬时压力。</p>
</li>
<li><p>保护处理RabbitMQ消息的系统，防止系统崩溃。高可用</p>
</li>
</ul>
<p>implementation：</p>
<ul>
<li><p>Consumer需要设置为手动签收</p>
<p>监听类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class QosListener implements ChannelAwareMessageListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(Message message, Channel channel) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        //1.获取消息</span><br><span class="line">        System.out.println(new String(message.getBody()));</span><br><span class="line">        //2. 处理业务逻辑</span><br><span class="line">        //3. 签收</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置手动签收 acknowledge=”manual”</p>
</li>
<li><p>设置每次处理多少条消息后再次获取消息。perfetch = 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;manual&quot; prefetch=&quot;1&quot; &gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p><strong>解释：</strong>当消息到达存活时间后，还没有被消费，会被自动清除。</p>
<p>可设置消息或队列的过期时间。</p>
<ul>
<li><p>队列的过期可在<code>xml</code>的<code>queue</code>标签配置,</p>
</li>
<li><p>消息过期在发送消息时增加过期时间的参数即可。</p>
</li>
</ul>
<p><strong>注意：</strong>单条消息和队列都设置了过期时间时，以短的为准。</p>
<p><strong>示例：</strong>订单系统发送到RabbitMQ的消息设置为30分钟过期。交易系统30分钟不取走订单消息，则订单关闭。</p>
<p><strong>implementation：</strong></p>
<ul>
<li><p>设置队列过期时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--ttl--&gt;</span><br><span class="line">&lt;rabbit:queue name=&quot;test_queue_ttl&quot; id=&quot;test_queue_ttl&quot;&gt;</span><br><span class="line">    &lt;!--设置queue的参数--&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;!--x-message-ttl指队列的过期时间,注意Integer类型--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;100000&quot; value-type=&quot;java.lang.Integer&quot;/&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line"></span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;test_exchange_ttl&quot; &gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;ttl.#&quot; queue=&quot;test_queue_ttl&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTtl() &#123;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;,</span><br><span class="line">                                      &quot;ttl.hehe&quot;, &quot;message ttl....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置单个消息的过期时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTtl() &#123;</span><br><span class="line">  // 消息后处理对象，设置一些消息的参数信息</span><br><span class="line">    MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">            //1.设置message的信息</span><br><span class="line">            message.getMessageProperties().setExpiration(&quot;5000&quot;);//消息的过期时间</span><br><span class="line">            //2.返回该消息</span><br><span class="line">            return message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //消息单独过期</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.hehe&quot;, &quot;message ttl....&quot;,messagePostProcessor);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        if(i == 5)&#123;</span><br><span class="line">            //消息过期</span><br><span class="line">            rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.hehe&quot;, &quot;message ttl....&quot;,messagePostProcessor);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //不过期的消息</span><br><span class="line">            rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.hehe&quot;, &quot;message ttl....&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DLX-死信队列"><a href="#DLX-死信队列" class="headerlink" title="DLX 死信队列"></a>DLX 死信队列</h2><p>死信：</p>
<ul>
<li>TTL过期的消息</li>
<li>未签收的消息,并且没把消息重新放入原队列，requeue=false</li>
<li>超过队列的长度</li>
</ul>
<p><strong>implementation</strong></p>
<ol>
<li><p>设置正常队列，正常交换机，正常交换机绑定正常队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;test_queue_dlx&quot; id=&quot;test_queue_dlx&quot;&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;test_exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;test.dlx.#&quot; queue=&quot;test_queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置死信队列，死信交换机，死信交换机绑定死信队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;queue_dlx&quot; id=&quot;queue_dlx&quot;&gt;&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;dlx.#&quot; queue=&quot;queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置正常队列的死信绑定死信交换机，设置正常队列到死信交换机的路由key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;rabbit:queue name=&quot;test_queue_dlx&quot; id=&quot;test_queue_dlx&quot;&gt;</span><br><span class="line">    &lt;!--3. 正常队列绑定死信交换机--&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;!--3.1 x-dead-letter-exchange：死信交换机名称--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;exchange_dlx&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--3.2 x-dead-letter-routing-key：发送给死信交换机的routingkey--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-routing-key&quot; value=&quot;dlx.hehe&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--4.1 设置队列的过期时间 ttl--&gt;</span><br><span class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Integer&quot; /&gt;</span><br><span class="line">        &lt;!--4.2 设置队列的长度限制 max-length --&gt;</span><br><span class="line">        &lt;entry key=&quot;x-max-length&quot; value=&quot;10&quot; value-type=&quot;java.lang.Integer&quot; /&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;test_exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;test.dlx.#&quot; queue=&quot;test_queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>producer 测试方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 发送测试死信消息：</span><br><span class="line"> *  1. 时间过期</span><br><span class="line"> *  2. 超过长度</span><br><span class="line"> *  3. 消息拒收</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testDlx()&#123;</span><br><span class="line">    //1. 测试时间过期，死信消息</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,</span><br><span class="line">                                  &quot;test.dlx.haha&quot;,&quot;我是一条时间过期的消息&quot;);</span><br><span class="line">   </span><br><span class="line">    //2. 测试超过长度后，消息死信</span><br><span class="line">   for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,</span><br><span class="line">                                      &quot;test.dlx.haha&quot;,&quot;我是一条超过长度的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //3. 测试消息拒收</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;test_exchange_dlx&quot;,</span><br><span class="line">                                  &quot;test.dlx.haha&quot;,&quot;我是一条消息拒收&quot;);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>TTL+死信队列</p>
<p>架构图：</p>
<p>需求：订单30分钟未支付，取消订单，并回滚库存。</p>
<p>实现思路：正常队列设置30分钟有效期，30分钟内不做处理。30分钟后转入另一个队列判断订单状态，并处理</p>
<p>implementation</p>
<p>xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 定义正常交换机（order_exchange）和队列(order_queue)--&gt;</span><br><span class="line">&lt;rabbit:queue id=&quot;order_queue&quot; name=&quot;order_queue&quot;&gt;</span><br><span class="line">    &lt;!-- 3. 绑定，设置正常队列过期时间30分钟--&gt;</span><br><span class="line">    &lt;rabbit:queue-arguments&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-exchange&quot; value=&quot;order_exchange_dlx&quot; /&gt;</span><br><span class="line">        &lt;entry key=&quot;x-dead-letter-routing-key&quot; value=&quot;dlx.order.cancel&quot; /&gt;</span><br><span class="line">        &lt;entry key=&quot;x-message-ttl&quot; value=&quot;10000&quot; value-type=&quot;java.lang.Integer&quot; /&gt;</span><br><span class="line">    &lt;/rabbit:queue-arguments&gt;</span><br><span class="line">&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;order_exchange&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;order.#&quot; queue=&quot;order_queue&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--  2. 定义死信交换机（order_exchange_dlx）和队列(order_queue_dlx)--&gt;</span><br><span class="line">&lt;rabbit:queue id=&quot;order_queue_dlx&quot; name=&quot;order_queue_dlx&quot;&gt;&lt;/rabbit:queue&gt;</span><br><span class="line">&lt;rabbit:topic-exchange name=&quot;order_exchange_dlx&quot;&gt;</span><br><span class="line">    &lt;rabbit:bindings&gt;</span><br><span class="line">        &lt;rabbit:binding pattern=&quot;dlx.order.#&quot; queue=&quot;order_queue_dlx&quot;&gt;&lt;/rabbit:binding&gt;</span><br><span class="line">    &lt;/rabbit:bindings&gt;</span><br><span class="line">&lt;/rabbit:topic-exchange&gt;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public  void testDelay() throws InterruptedException &#123;</span><br><span class="line">    //1.发送订单消息。 订单系统中，下单成功后，发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;order_exchange&quot;,&quot;order.msg&quot;,&quot;订单信息：id=1,time=2020&quot;);</span><br><span class="line"></span><br><span class="line">    //2.打印倒计时10秒</span><br><span class="line">    for (int i = 10; i &gt; 0 ; i--) &#123;</span><br><span class="line">        System.out.println(i+&quot;...&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h2><p><strong>问题：</strong>配置写错，producer宕机、consumer宕机，服务器宕机、连接断开可能导致消息不能成功发送。</p>
<p><strong>解决：</strong>通过追踪消息可以排查这些问题。</p>
<p>Firehose、rabbitmq_tracing插件都可以实现消息追踪。</p>
<p>Firehose是额外发送一条消息到系统内部的一个交换机（amq.rabbitmq.trace）。</p>
<p>rabbitmq_tracing是额外发送一条消息（更详细）到内部交换机，并将消息记录到mytrace.log文件中。系统内部发送的消息不容易失败。</p>
<p>开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_tracing</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制台发送一条消息</span><br></pre></td></tr></table></figure>

<p>log会显示详细信息</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>高级特性</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>源码加载并解析xml文件</title>
    <url>/2020/02/03/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E6%BA%90%E7%A0%81%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>模板</p>
<span id="more"></span>

<h1 id="加载并解析xml文件"><a href="#加载并解析xml文件" class="headerlink" title="加载并解析xml文件"></a>加载并解析xml文件</h1><p>相关的类和方法。</p>
<h2 id="使用spring"><a href="#使用spring" class="headerlink" title="使用spring"></a>使用spring</h2><p>1.新建spring项目</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vzHpQKhXfEJ8eYy.png" alt="image-20200707152842482"></p>
<p>2.编写book类和配置文件</p>
<p>Book类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line"></span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public String getBookName() &#123;</span><br><span class="line">        return bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookName(String bookName) &#123;</span><br><span class="line">        this.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printBookInfo() &#123;</span><br><span class="line">        System.out.println(&quot;Book Name：&quot; + this.bookName + &quot;,Author：&quot; + this.author);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;book&quot; class=&quot;Book&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookName&quot; value=&quot;平凡的世界&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;author&quot; value=&quot;路遥&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>3.Test方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext  applicationContext = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);</span><br><span class="line">Book book = applicationContext.getBean(&quot;book&quot;,Book.class);</span><br><span class="line">book.printBookInfo();</span><br></pre></td></tr></table></figure>

<h2 id="spring加载并解析xml文件的过程"><a href="#spring加载并解析xml文件的过程" class="headerlink" title="spring加载并解析xml文件的过程"></a>spring加载并解析xml文件的过程</h2><p>1-5准备工作</p>
<p>6-9要获取xml资源时的处理，资源定位，多配置循环处理，资源编码处理</p>
<p>10-11获取资源流，使用工具初步解析</p>
<p>12定义注册流程统计BeanDefinition数量</p>
<p>13获取初步解析的资源，跳转</p>
<p>14-20实际解析</p>
<ul>
<li>14处理命名空间</li>
<li>15默认标签，自定义标签分别处理</li>
<li>16默认标签中的不同标签处理，bean、import、alias、beans</li>
<li>17解析bean标签和注册BeanDefinition的流程</li>
<li>18跳转</li>
<li>19-20解析bean标签</li>
</ul>
<p>​    </p>
<ol>
<li><p>ClassPathXmlApplicationContext类的构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String configLocation) throws BeansException &#123;</span><br><span class="line">    this(new String[]&#123;configLocation&#125;, true, (ApplicationContext)null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造方法内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    this.setConfigLocations(configLocations);</span><br><span class="line">    if (refresh) &#123;</span><br><span class="line">    	//刷新，即执行spring流程</span><br><span class="line">        this.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractApplicationContext类规定了refresh()的流程内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		// Prepare this context for refreshing.</span><br><span class="line">		// STEP 1： 刷新预处理</span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">		// STEP 2：</span><br><span class="line">		// 		a） 创建IoC容器（DefaultListableBeanFactory）</span><br><span class="line">		//		b） 加载解析XML文件（最终存储到Document对象中）</span><br><span class="line">		//		c） 读取Document对象，并完成BeanDefinition的加载和注册工作</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		// Prepare the bean factory for use in this context.</span><br><span class="line">		// STEP 3： 对IoC容器进行一些预处理（设置一些公共属性）</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">			// STEP 4： </span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Invoke factory processors registered as beans in the context.</span><br><span class="line">			// STEP 5： 调用BeanFactoryPostProcessor后置处理器对BeanDefinition处理</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Register bean processors that intercept bean creation.</span><br><span class="line">			// STEP 6： 注册BeanPostProcessor后置处理器</span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Initialize message source for this context.</span><br><span class="line">			// STEP 7： 初始化一些消息源（比如处理国际化的i18n等消息源）</span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			// Initialize event multicaster for this context.</span><br><span class="line">			// STEP 8： 初始化应用事件广播器</span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			// Initialize other special beans in specific context subclasses.</span><br><span class="line">			// STEP 9： 初始化一些特殊的bean</span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			// Check for listener beans and register them.</span><br><span class="line">			// STEP 10： 注册一些监听器</span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			// STEP 11： 实例化剩余的单例bean（非懒加载方式）</span><br><span class="line">			// 注意事项：Bean的IoC、DI和AOP都是发生在此步骤</span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			// Last step: publish corresponding event.</span><br><span class="line">			// STEP 12： 完成刷新时，需要发布对应的事件</span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			// Reset &#x27;active&#x27; flag.</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			// Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		finally &#123;</span><br><span class="line">			// Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">			// might not ever need metadata for singleton beans anymore...</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>obtainFreshBeanFactory()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line">	// 主要是通过该方法完成IoC容器的刷新</span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	return beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractRefreshableApplicationContext类refreshBeanFactory()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	// 如果之前有IoC容器，则销毁</span><br><span class="line">   	if (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">      		// 创建IoC容器，也就是DefaultListableBeanFactory</span><br><span class="line">		DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		// 设置工厂的属性：是否允许BeanDefinition覆盖和是否允许循环依赖</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">           // 调用载入BeanDefinition的方法，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器</span><br><span class="line">		loadBeanDefinitions(beanFactory);//钩子方法</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory = beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractXmlApplicationContext类的loadBeanDefinitions()的方法</p>
<p>准备工作完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">	// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">	// 创建一个BeanDefinition阅读器，通过阅读XML文件，真正完成BeanDefinition的加载和注册</span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">   </span><br><span class="line">	// Configure the bean definition reader with this context&#x27;s</span><br><span class="line">	// resource loading environment.</span><br><span class="line">	beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">	beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line">   </span><br><span class="line">	// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">	// then proceed with actually loading the bean definitions.</span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"></span><br><span class="line">	// 委托给BeanDefinition阅读器去加载BeanDefinition</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>loadBeanDefinitions(XmlBeanDefinitionReader reader)方法</p>
<p>对资源的其他处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">	// 获取资源的定位</span><br><span class="line">	// 这里getConfigResources是一个空实现，真正实现是调用子类的获取资源定位的方法</span><br><span class="line">	// 比如：ClassPathXmlApplicationContext中进行了实现</span><br><span class="line">	// 		而FileSystemXmlApplicationContext没有使用该方法</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	if (configResources != null) &#123;</span><br><span class="line">		// XML Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的资源</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果子类中获取的资源定位为空，则获取FileSystemXmlApplicationContext构造方法中setConfigLocations方法设置的资源</span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	if (configLocations != null) &#123;</span><br><span class="line">		// XML Bean读取器调用其父类AbstractBeanDefinitionReader读取定位的资源</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractBeanDefinitionReader的loadBeanDefinitions(configResources)方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">	int counter = 0;</span><br><span class="line">	for (Resource resource : resources) &#123;</span><br><span class="line">		counter += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XmlBeanDefinitionReader的loadBeanDefinitions(resource);</p>
<p>资源编码处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException 	  &#123;</span><br><span class="line">	// 将读入的XML资源进行特殊编码处理</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>loadBeanDefinitions的具体实现</p>
<p>获取xml资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">	if (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	if (currentResources == null) &#123;</span><br><span class="line">		currentResources = new HashSet&lt;&gt;(4);</span><br><span class="line">		this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		// 将资源文件转为InputStream的IO流</span><br><span class="line">		InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">		try &#123;</span><br><span class="line">			// 从InputStream中得到XML的解析源</span><br><span class="line">			InputSource inputSource = new InputSource(inputStream);</span><br><span class="line">			if (encodedResource.getEncoding() != null) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			// 这里是具体的读取过程</span><br><span class="line">			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		if (currentResources.isEmpty()) &#123;</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>具体的读取xml过程 doLoadBeanDefinitions(inputSource, encodedResource.getResource());</p>
<p>用工具初步解析获取的xml资源流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// 通过DOM4J加载解析XML文件，最终形成Document对象</span><br><span class="line">		Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">		// 通过对Document对象的操作，完成BeanDefinition的加载和注册工作</span><br><span class="line">           return registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXParseException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ParserConfigurationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Parser configuration exception parsing XML from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Unexpected exception parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>registerBeanDefinitions(doc, resource);</p>
<p>注册bean流程，统计BeanDefinition数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	// 创建BeanDefinitionDocumentReader来解析Document对象，完成BeanDefinition解析</span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	// 获得容器中已经注册的BeanDefinition数量</span><br><span class="line">	int countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	//解析过程入口，BeanDefinitionDocumentReader只是个接口，具体的实现过程在DefaultBeanDefinitionDocumentReader完成</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	// 统计新的的BeanDefinition数量</span><br><span class="line">	return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>DefaultBeanDefinitionDocumentReader类registerBeanDefinitions(doc, createReaderContext(resource));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)    &#123;</span><br><span class="line">	this.readerContext = readerContext;</span><br><span class="line">	logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">	// 获得Document的根元素&lt;beans&gt;标签</span><br><span class="line">	Element root = doc.getDocumentElement();</span><br><span class="line">	// 真正实现BeanDefinition解析和注册工作</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>doRegisterBeanDefinitions(root);</p>
<p>处理命名空间，并将解析工作委托给了其他类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">	// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span><br><span class="line">	// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span><br><span class="line">	// keep track of the current (parent) delegate, which may be null. Create</span><br><span class="line">	// the new (child) delegate with a reference to the parent for fallback purposes,</span><br><span class="line">	// then ultimately reset this.delegate back to its original (parent) reference.</span><br><span class="line">	// this behavior emulates a stack of delegates without actually necessitating one.</span><br><span class="line">	</span><br><span class="line">	// 这里使用了委托模式，将具体的BeanDefinition解析工作交给了BeanDefinitionParserDelegate去完成</span><br><span class="line">	BeanDefinitionParserDelegate parent = this.delegate;</span><br><span class="line">	this.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    </span><br><span class="line">	// 判断该根标签是否包含http://www.springframework.org/schema/beans默认命名空间</span><br><span class="line">	if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">		if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">							&quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">				&#125;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 在解析Bean定义之前，进行自定义的解析，增强解析过程的可扩展性</span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	// 委托给BeanDefinitionParserDelegate,从Document的根元素开始进行BeanDefinition的解析</span><br><span class="line">	parseBeanDefinitions(root, this.delegate);</span><br><span class="line">	// 在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性</span><br><span class="line">	postProcessXml(root);</span><br><span class="line">    </span><br><span class="line">	this.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>parseBeanDefinitions(root, this.delegate);</p>
<p>默认标签和自定义标签有不同的流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 加载的Document对象是否使用了Spring默认的XML命名空间（beans命名空间）</span><br><span class="line">	if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		// 获取Document对象根元素的所有子节点（bean标签、import标签、alias标签和其他自定义标签context、aop等）</span><br><span class="line">		NodeList nl = root.getChildNodes();</span><br><span class="line">		for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node = nl.item(i);</span><br><span class="line">			if (node instanceof Element) &#123;</span><br><span class="line">				Element ele = (Element) node;</span><br><span class="line">				// bean标签、import标签、alias标签，则使用默认解析规则</span><br><span class="line">				if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;//像context标签、aop标签、tx标签，则使用用户自定义的解析规则解析元素节点</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// 如果不是默认的命名空间，则使用用户自定义的解析规则解析元素节点</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>parseDefaultElement(ele, delegate);</p>
<p>默认的标签中各个不同的标签解析不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 解析&lt;import&gt;标签</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析&lt;alias&gt;标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析&lt;bean&gt;标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析内置&lt;beans&gt;标签</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		// recurse</span><br><span class="line">		// 递归调用</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DefaultListableBeanFactory。processBeanDefinition(ele, delegate);</p>
<p>解析bean标签，注册BeanDefinition到IoC容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	// 解析&lt;bean&gt;标签，获取BeanDefinition</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder != null) &#123;</span><br><span class="line">		// 如果需要，则装饰BeanDefinition对象</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			// Register the final decorated instance.</span><br><span class="line">			// 注册最终的BeanDefinition到BeanDefinitionRegistry（DefaultListableBeanFactory）</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#x27;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#x27;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		// Send registration event.</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BeanDefinitionParserDelegate的parseBeanDefinitionElement(ele);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">	// 解析&lt;bean&gt;标签，获取BeanDefinition对象</span><br><span class="line">	return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>parseBeanDefinitionElement(ele, null);</p>
<p>做bean标签的解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">	// 获取bean的id</span><br><span class="line">	String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">	// 获取bean的name</span><br><span class="line">	String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    </span><br><span class="line">	List&lt;String&gt; aliases = new ArrayList&lt;&gt;();</span><br><span class="line">	if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	String beanName = id;</span><br><span class="line">	if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		beanName = aliases.remove(0);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot; + beanName +</span><br><span class="line">					&quot;&#x27; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	if (containingBean == null) &#123;</span><br><span class="line">		// 检查bean的id或者name是否唯一</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析&lt;bean&gt;标签，获取BeanDefinition对象</span><br><span class="line">	AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	if (beanDefinition != null) &#123;</span><br><span class="line">		if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (containingBean != null) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					beanName = this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					// Register an alias for the plain bean class name, if still possible,</span><br><span class="line">					// if the generator returned the class name plus a suffix.</span><br><span class="line">					// This is expected for Spring 1.2/2.0 backwards compatibility.</span><br><span class="line">					String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">					if (beanClassName != null &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot; +</span><br><span class="line">							&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		// 将BeanDefinition对象和BeanName封装到BeanDefinitionHolder对象中</span><br><span class="line">		return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>parseBeanDefinitionElement(ele, beanName, containingBean);</p>
<p>解析获取到的资源中的其他属性和bean的子标签，id,name已解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">		Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">    </span><br><span class="line">	this.parseState.push(new BeanEntry(beanName));</span><br><span class="line">    </span><br><span class="line">	String className = null;</span><br><span class="line">	// 获取bean标签的class属性</span><br><span class="line">	if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">	&#125;</span><br><span class="line">	String parent = null;</span><br><span class="line">	// 获取bean标签的parent属性</span><br><span class="line">	if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	try &#123;</span><br><span class="line">		// 创建BeanDefinition对象GenericBeanDefinition</span><br><span class="line">		AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">		</span><br><span class="line">		// 解析&lt;bean&gt;标签的属性</span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		/** 解析&lt;bean&gt;标签的子标签  --- begin**/</span><br><span class="line">		// 解析&lt;description&gt;标签</span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">		// 解析&lt;meta&gt;标签</span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		// 解析&lt;lookup-method&gt;标签</span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		// 解析&lt;replaced-method&gt;标签</span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		</span><br><span class="line">		// 解析&lt;constructor-arg&gt;标签</span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		// 解析&lt;property&gt;标签</span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		// 解析&lt;qualifier&gt;标签</span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line">		/** 解析&lt;bean&gt;标签的子标签  --- end**/</span><br><span class="line">    </span><br><span class="line">		bd.setResource(this.readerContext.getResource());</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line">    </span><br><span class="line">		return bd;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>源码实例化单例bean</title>
    <url>/2020/02/04/213Java%E6%A1%86%E6%9E%B6/Spring/Spring-%E6%BA%90%E7%A0%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8D%95%E4%BE%8Bbean/</url>
    <content><![CDATA[<p>记录源码一步步实例化单例bean的过程</p>
<span id="more"></span>

<p>版本5.0.7</p>
<ol>
<li><p>AbstractApplicationContext的refresh()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		// Prepare this context for refreshing.</span><br><span class="line">           // STEP 1： 刷新预处理</span><br><span class="line">		prepareRefresh();</span><br><span class="line">   </span><br><span class="line">		// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">           // STEP 2：</span><br><span class="line">           // 		a） 创建IoC容器（DefaultListableBeanFactory）</span><br><span class="line">           //		b） 加载解析XML文件（最终存储到Document对象中）</span><br><span class="line">           //		c） 读取Document对象，并完成BeanDefinition的加载和注册工作</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">   </span><br><span class="line">		// Prepare the bean factory for use in this context.</span><br><span class="line">           // STEP 3： 对IoC容器进行一些预处理（设置一些公共属性）</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">		try &#123;</span><br><span class="line">			// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">               // STEP 4： </span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Invoke factory processors registered as beans in the context.</span><br><span class="line">			// STEP 5： 调用BeanFactoryPostProcessor后置处理器对BeanDefinition处理</span><br><span class="line">               invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Register bean processors that intercept bean creation.</span><br><span class="line">			// STEP 6： 注册BeanPostProcessor后置处理器</span><br><span class="line">               registerBeanPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Initialize message source for this context.</span><br><span class="line">			// STEP 7： 初始化一些消息源（比如处理国际化的i18n等消息源）</span><br><span class="line">               initMessageSource();</span><br><span class="line">   </span><br><span class="line">			// Initialize event multicaster for this context.</span><br><span class="line">			// STEP 8： 初始化应用事件广播器</span><br><span class="line">               initApplicationEventMulticaster();</span><br><span class="line">   </span><br><span class="line">			// Initialize other special beans in specific context subclasses.</span><br><span class="line">			// STEP 9： 初始化一些特殊的bean</span><br><span class="line">               onRefresh();</span><br><span class="line">   </span><br><span class="line">			// Check for listener beans and register them.</span><br><span class="line">			// STEP 10： 注册一些监听器</span><br><span class="line">               registerListeners();</span><br><span class="line">   </span><br><span class="line">			// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			// STEP 11： 实例化剩余的单例bean（非懒加载方式）</span><br><span class="line">               // 注意事项：Bean的IoC、DI和AOP都是发生在此步骤</span><br><span class="line">               finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">   </span><br><span class="line">			// Last step: publish corresponding event.</span><br><span class="line">			// STEP 12： 完成刷新时，需要发布对应的事件</span><br><span class="line">               finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			destroyBeans();</span><br><span class="line">   </span><br><span class="line">			// Reset &#x27;active&#x27; flag.</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">   </span><br><span class="line">			// Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		finally &#123;</span><br><span class="line">			// Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">			// might not ever need met		adata for singleton beans anymore...</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>finishBeanFactoryInitialization(beanFactory);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	// Initialize conversion service for this context.</span><br><span class="line">	if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">			beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">		beanFactory.setConversionService(</span><br><span class="line">				beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Register a default embedded value resolver if no bean post-processor</span><br><span class="line">	// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">	// at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">	if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">		beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">	String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">	for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">		getBean(weaverAwareName);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Stop using the temporary ClassLoader for type matching.</span><br><span class="line">	beanFactory.setTempClassLoader(null);</span><br><span class="line">   </span><br><span class="line">	// Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line">   </span><br><span class="line">	// Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">	// 实例化单例Bean之前</span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DefaultListableBeanFactory的preInstantiateSingletons()方法</p>
<p>FactoryBean的处理</p>
<p>BeanFactory内包括FactoryBean.BeanFactory实例化Bean，FactoryBean用来实例化Bean代理对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">	if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">		this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">	// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">	List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line">   </span><br><span class="line">	// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">	// 触发所有非懒加载方式的单例bean的创建</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		// 如果bean不是抽象的，而且是单例的，同时还不是懒加载的，则进行下面的操作</span><br><span class="line">		if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			// 如果bean是一个FactoryBean，则走下面的方法</span><br><span class="line">			if (isFactoryBean(beanName)) &#123;</span><br><span class="line">				Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				if (bean instanceof FactoryBean) &#123;</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">										((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123; // 普通bean走下面的方法</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">	for (String beanName : beanNames) &#123;</span><br><span class="line">		Object singletonInstance = getSingleton(beanName);</span><br><span class="line">		if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">			final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					return null;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractBeanFactory的getBean(beanName);</p>
<p>跳转，多个getBean重载方法跳转到同一个doGetBean方法    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">	// 获取Bean的实例</span><br><span class="line">	return doGetBean(name, null, null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>doGetBean(name, null, null, false);</p>
<p>获取bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">		@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">   </span><br><span class="line">	// 获取bean名称</span><br><span class="line">	final String beanName = transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line">   </span><br><span class="line">	// Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">	// 从缓存中获取单例bean</span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	if (sharedInstance != null &amp;&amp; args == null) &#123; //如果获取到单例bean，则走下面代码</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.debug(&quot;Returning eagerly cached instance of singleton bean &#x27;&quot; + beanName +</span><br><span class="line">						&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				logger.debug(&quot;Returning cached instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果取出来的Bean实例是FactoryBean的Bean实例，则需要从FactoryBean实例中产生一个对象实例。</span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	else &#123;//如果没有获取到单例bean，则走下面代码</span><br><span class="line">		// Fail if we&#x27;re already creating this bean instance:</span><br><span class="line">		// We&#x27;re assumably within a circular reference.</span><br><span class="line">		</span><br><span class="line">		// 如果原型模式的Bean发生循环引用，则直接不处理，抛出异常</span><br><span class="line">		if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		// Check if bean definition exists in this factory.</span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			// Not found -&gt; check parent.</span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			if (parentBeanFactory instanceof AbstractBeanFactory) &#123;</span><br><span class="line">				return ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (args != null) &#123;</span><br><span class="line">				// Delegation to parent with explicit args.</span><br><span class="line">				return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// No args -&gt; delegate to standard getBean method.</span><br><span class="line">				return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		if (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		try &#123;</span><br><span class="line">			// 获取要实例化的bean的BeanDefinition对象</span><br><span class="line">			final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			// 检查该BeanDefinition对象对应的Bean是否是抽象的</span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">   </span><br><span class="line">			// Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			if (dependsOn != null) &#123;</span><br><span class="line">				for (String dep : dependsOn) &#123;</span><br><span class="line">					if (isDependent(beanName, dep)) &#123;</span><br><span class="line">						throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								&quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					try &#123;</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								&quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			// Create bean instance.</span><br><span class="line">			// 如果是单例的Bean，请下面的代码</span><br><span class="line">			if (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						// 创建单例Bean的主要方法</span><br><span class="line">						return createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (BeansException ex) &#123;</span><br><span class="line">						// Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">						// eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">						// Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						throw ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			else if (mbd.isPrototype()) &#123;</span><br><span class="line">				// It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">				Object prototypeInstance = null;</span><br><span class="line">				try &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				finally &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			else &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">				if (scope == null) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						try &#123;</span><br><span class="line">							return createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						finally &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (IllegalStateException ex) &#123;</span><br><span class="line">					throw new BeanCreationException(beanName,</span><br><span class="line">							&quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; +</span><br><span class="line">							&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Check if required type matches the type of the actual bean instance.</span><br><span class="line">	if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			if (convertedBean == null) &#123;</span><br><span class="line">				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			return convertedBean;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (TypeMismatchException ex) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type &#x27;&quot; +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + &quot;&#x27;&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return (T) bean;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>AbstractAutowireCapableBeanFactory的createBean(beanName, mbd, args);</p>
<p>创建bean的准备工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">		throws BeanCreationException &#123;</span><br><span class="line">   </span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line">   </span><br><span class="line">	// Make sure bean class is actually resolved at this point, and</span><br><span class="line">	// clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">	// which cannot be stored in the shared merged bean definition.</span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">		mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">		mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Prepare method overrides.</span><br><span class="line">	// 处理方法覆盖</span><br><span class="line">	try &#123;</span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">				beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	try &#123;</span><br><span class="line">		// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">		// 获取BeanPostProcessor代理对象</span><br><span class="line">		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		if (bean != null) &#123;</span><br><span class="line">			return bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">				&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	try &#123;</span><br><span class="line">		// 完成Bean实例的创建（实例化、填充属性、初始化）</span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">		// A previously detected exception with proper bean creation context already,</span><br><span class="line">		// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanCreationException(</span><br><span class="line">				mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>doCreateBean(beanName, mbdToUse, args);</p>
<p>创建bean</p>
<p>通过三级缓存解决set循环依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span><br><span class="line">		throws BeanCreationException &#123;</span><br><span class="line">   </span><br><span class="line">	// Instantiate the bean.</span><br><span class="line">	BeanWrapper instanceWrapper = null;</span><br><span class="line">	if (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	// bean初始化第一步：默认调用无参构造实例化Bean</span><br><span class="line">	// 构造参数依赖注入，就是发生在这一步</span><br><span class="line">	if (instanceWrapper == null) &#123;</span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	// 实例化后的Bean对象</span><br><span class="line">	final Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	if (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Allow post-processors to modify the merged bean definition.</span><br><span class="line">	synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">		if (!mbd.postProcessed) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;</span><br><span class="line">				throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">	// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">	// 解决循环依赖的关键步骤</span><br><span class="line">	boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	// 如果需要提前暴露单例Bean，则将该Bean放入三级缓存中</span><br><span class="line">	if (earlySingletonExposure) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">					&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// 将刚创建的bean放入三级缓存中singleFactories(key是beanName，value是FactoryBean)</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Initialize the bean instance.</span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	try &#123;</span><br><span class="line">		// bean初始化第二步：填充属性（DI依赖注入发生在此步骤）</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		// bean初始化第三步：调用初始化方法，完成bean的初始化操作（AOP发生在此步骤）</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			throw (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	if (earlySingletonExposure) &#123;</span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">		if (earlySingletonReference != null) &#123;</span><br><span class="line">			if (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							&quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">							&quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">							&quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">							&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	// Register bean as disposable.</span><br><span class="line">	try &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		throw new BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	return exposedObject;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>三步曲</p>
<p>bean初始化第一步：默认调用无参构造实例化Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 构造参数依赖注入，就是发生在这一步</span><br><span class="line">if (instanceWrapper == null) &#123;</span><br><span class="line">   instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean初始化第二步：填充属性（DI依赖注入发生在此步骤）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure>

<p>bean初始化第三步：调用初始化方法，完成bean的初始化操作（AOP发生在此步骤）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​    </p>
<p><strong>先BeanPostProcessor，后放入三级缓存。</strong></p>
<p>AbstractAutowireCapableBeanFactory.java doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Allow post-processors to modify the merged bean definition.</span><br><span class="line">// 执行BeanPostProcessor</span><br><span class="line">synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">	if (!mbd.postProcessed) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		mbd.postProcessed = true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">// 解决循环依赖的关键步骤</span><br><span class="line">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">		isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">// 如果需要提前暴露单例Bean，则将该Bean放入三级缓存中</span><br><span class="line">if (earlySingletonExposure) &#123;</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">				&quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// 将刚创建的bean放入三级缓存中singleFactories(key是beanName，value是FactoryBean)</span><br><span class="line">	addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-入门</title>
    <url>/2020/08/24/213Java%E6%A1%86%E6%9E%B6/Rabbit-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>MQ介绍，RabbitMQ介绍，安装，配置，架构，五种常用工作模式helloword。</p>
<span id="more"></span>

<h1 id="RabbitMQ-入门"><a href="#RabbitMQ-入门" class="headerlink" title="RabbitMQ-入门"></a>RabbitMQ-入门</h1><h2 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h2><p>MQ全称为Message Queue，消息队列是应用程序和应用程序之间的通信方法。</p>
<h2 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h2><p><a href="https://www.rabbitmq.com/">官网</a></p>
<p>RabbitMQ是一套开源（MPL）的消息队列服务软件，是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP) 的开源实现，由以高性能、健壮以及可伸缩性出名的 Erlang 写成。</p>
<p>6中工作模式</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/uGEDs3AxXwRczCB.png" alt="image-20200905104518472"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4v8qjyHDd5lQgsA.png" alt="image-20200905104618032"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jwVKAkSuPQTY9hc.png" alt="image-20200905104735664"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/b7jon5FsHySYuhI.png" alt="image-20200905104809593"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IbzThmZocNSKgPU.png" alt="image-20200905104828048"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SAtoBasDdUVOjpF.png" alt="image-20200905104849361"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/q8ApBEWbc53CLfG.png" alt="image-20200905105120279"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>地址：</p>
<p>端口号：</p>
<p>​    5672</p>
<p>​    15672</p>
<p>​    25672</p>
<h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mnxAhU15GSg3blD.png" alt="image-20200906110051057"></p>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.6.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h3 id="生产者producer"><a href="#生产者producer" class="headerlink" title="生产者producer"></a>生产者producer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Produer</span><br><span class="line"> * @Description 生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;simple_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 要发送的信息</span><br><span class="line">        String message = &quot;hello rabbit&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>idea控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_131\bin\java.exe&quot;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">已发送消息：hello rabbit</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jHmQYtyl2TLdBSF.png" alt="image-20200906104944810"></p>
<p>rabbitMQ控制台</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/HnB2eFjsKPr8oCp.png" alt="image-20200906105002463"></p>
<h3 id="消费者consumer"><a href="#消费者consumer" class="headerlink" title="消费者consumer"></a>消费者consumer</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class Consumer &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;simple_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        //不关闭资源，应该一直监听消息</span><br><span class="line">        //channel.close();</span><br><span class="line">        //connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>idea 控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_131\bin\java.exe&quot;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">路由key为：simple_queue</span><br><span class="line">交换机为：</span><br><span class="line">消息id为：1</span><br><span class="line">接收到的消息为：hello rabbit</span><br><span class="line">路由key为：simple_queue</span><br><span class="line">交换机为：</span><br><span class="line">消息id为：2</span><br><span class="line">接收到的消息为：hello rabbit</span><br></pre></td></tr></table></figure>

<p>rabbitMQ控制台</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/eytRlLufjD1VTsg.png" alt="image-20200906110949041"></p>
<h2 id="五种工作模式"><a href="#五种工作模式" class="headerlink" title="五种工作模式"></a>五种工作模式</h2><p>简单模式</p>
<p>工作模式</p>
<p>订阅模式pubsub</p>
<h3 id="helloword（简单模式）"><a href="#helloword（简单模式）" class="headerlink" title="helloword（简单模式）"></a>helloword（简单模式）</h3><p>即入门程序</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>架构图：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/z4wKmrSn5AsfLiR.png" alt="image-20200905110727987"></p>
<p>一个生产者，一个队列，多个消费者</p>
<p>producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Produer</span><br><span class="line"> * @Description 生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer_Work &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;Work_queues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        // 要发送的信息</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            String message = i + &quot;hello rabbit&quot;;</span><br><span class="line">            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>consumer1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class Consumer_Work1 &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;Work_queues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //一次只能接收并处理一个消息</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        //不关闭资源，应该一直监听消息</span><br><span class="line">        //channel.close();</span><br><span class="line">        //connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>consumer2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname Consumer</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class Consumer_Work2 &#123;</span><br><span class="line">    static final String QUEUE_NAME = &quot;Work_queues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //创建连接工厂</span><br><span class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">        //主机地址;默认为 localhost</span><br><span class="line">        connectionFactory.setHost(&quot;192.168.3.3&quot;);</span><br><span class="line">        //连接端口;默认为 5672</span><br><span class="line">        connectionFactory.setPort(5672);</span><br><span class="line">        //虚拟主机名称;默认为 /</span><br><span class="line">        connectionFactory.setVirtualHost(&quot;learn&quot;);</span><br><span class="line">        //连接用户名；默认为guest</span><br><span class="line">        connectionFactory.setUsername(&quot;xiaorui&quot;);</span><br><span class="line">        //连接密码；默认为guest</span><br><span class="line">        connectionFactory.setPassword(&quot;xiaorui&quot;);</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        // queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //一次只能接收并处理一个消息</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line"></span><br><span class="line">        //不关闭资源，应该一直监听消息</span><br><span class="line">        //channel.close();</span><br><span class="line">        //connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>先运行消费者1，再运行消费者2，最后运行生产者。</p>
<p>生产者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_131\bin\java.exe&quot;</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span><br><span class="line">已发送消息：0hello rabbit</span><br><span class="line">已发送消息：1hello rabbit</span><br><span class="line">已发送消息：2hello rabbit</span><br><span class="line">已发送消息：3hello rabbit</span><br><span class="line">已发送消息：4hello rabbit</span><br><span class="line">已发送消息：5hello rabbit</span><br><span class="line">已发送消息：6hello rabbit</span><br><span class="line">已发送消息：7hello rabbit</span><br><span class="line">已发送消息：8hello rabbit</span><br><span class="line">已发送消息：9hello rabbit</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收到的消息为：1hello rabbit</span><br><span class="line">接收到的消息为：3hello rabbit</span><br><span class="line">接收到的消息为：5hello rabbit</span><br><span class="line">接收到的消息为：7hello rabbit</span><br><span class="line">接收到的消息为：9hello rabbit</span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接收到的消息为：0hello rabbit</span><br><span class="line">接收到的消息为：2hello rabbit</span><br><span class="line">接收到的消息为：4hello rabbit</span><br><span class="line">接收到的消息为：6hello rabbit</span><br><span class="line">接收到的消息为：8hello rabbit</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oBApt1rbivZH3Xj.png" alt="image-20200906114842946"></p>
<h3 id="订阅模式（广播）"><a href="#订阅模式（广播）" class="headerlink" title="订阅模式（广播）"></a>订阅模式（广播）</h3><p>交换机类型：fanout</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jwVKAkSuPQTY9hc.png" alt="image-20200905104735664"></p>
<p><strong>Exchange（交换机）只转发消息，不存储消息</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<p>生产者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 发布与订阅使用的交换机类型为：fanout</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    //交换机名称</span><br><span class="line">    static final String FANOUT_EXCHAGE = &quot;fanout_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String FANOUT_QUEUE_1 = &quot;fanout_queue_1&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String FANOUT_QUEUE_2 = &quot;fanout_queue_2&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 声明交换机</span><br><span class="line">         * 参数1：交换机名称</span><br><span class="line">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE_1, true, false, false, null);</span><br><span class="line">        channel.queueDeclare(FANOUT_QUEUE_2, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(FANOUT_QUEUE_1, FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line">        channel.queueBind(FANOUT_QUEUE_2, FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            // 发送信息</span><br><span class="line">            String message = &quot;发布订阅模式--&quot; + i;</span><br><span class="line">            /**</span><br><span class="line">             * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">             * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">             * 参数3：消息其它属性</span><br><span class="line">             * 参数4：消息内容</span><br><span class="line">             */</span><br><span class="line">            channel.basicPublish(FANOUT_EXCHAGE, &quot;&quot;, null, message.getBytes());</span><br><span class="line">            System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.FANOUT_QUEUE_1, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.FANOUT_QUEUE_1, Producer.FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;消费者1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        channel.basicConsume(Producer.FANOUT_QUEUE_1, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.FANOUT_EXCHAGE, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.FANOUT_QUEUE_2, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.FANOUT_QUEUE_2, Producer.FANOUT_EXCHAGE, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;消费者2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">        channel.basicConsume(Producer.FANOUT_QUEUE_2, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>队列与交换机绑定时，指定RoutingKey</p>
<p>消息发送时，指定消息的RoutingKey</p>
<p>队列根据RoutingKey接收消息。</p>
<p>交换机类型：direct</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/b7jon5FsHySYuhI.png" alt="image-20200905104809593"></p>
<p>producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 路由模式的交换机类型为：direct</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    //交换机名称</span><br><span class="line">    static final String DIRECT_EXCHAGE = &quot;direct_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String DIRECT_QUEUE_INSERT = &quot;direct_queue_insert&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String DIRECT_QUEUE_UPDATE = &quot;direct_queue_update&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 声明交换机</span><br><span class="line">         * 参数1：交换机名称</span><br><span class="line">         * 参数2：交换机类型，fanout、topic、direct、headers</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(DIRECT_QUEUE_INSERT, true, false, false, null);</span><br><span class="line">        channel.queueDeclare(DIRECT_QUEUE_UPDATE, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(DIRECT_QUEUE_INSERT, DIRECT_EXCHAGE, &quot;insert&quot;);</span><br><span class="line">        channel.queueBind(DIRECT_QUEUE_UPDATE, DIRECT_EXCHAGE, &quot;update&quot;);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        String message = &quot;新增了商品。路由模式；routing key 为 insert &quot; ;</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(DIRECT_EXCHAGE, &quot;insert&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        message = &quot;修改了商品。路由模式；routing key 为 update&quot; ;</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span><br><span class="line">         * 参数2：路由key,简单模式可以传递队列名称</span><br><span class="line">         * 参数3：消息其它属性</span><br><span class="line">         * 参数4：消息内容</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(DIRECT_EXCHAGE, &quot;update&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.DIRECT_QUEUE_INSERT, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.DIRECT_QUEUE_INSERT, Producer.DIRECT_EXCHAGE, &quot;insert&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.DIRECT_QUEUE_INSERT, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>consumer2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.DIRECT_EXCHAGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.DIRECT_QUEUE_UPDATE, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.DIRECT_QUEUE_UPDATE, Producer.DIRECT_EXCHAGE, &quot;update&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.DIRECT_QUEUE_UPDATE, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h3><p>交换机类型topic</p>
<p><code>#</code>：匹配0个或多个词</p>
<p><code>*</code>：匹配恰好1个词</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IbzThmZocNSKgPU.png" alt="image-20200905104828048"></p>
<p>producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通配符Topic的交换机类型为：topic</span><br><span class="line"> */</span><br><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    //交换机名称</span><br><span class="line">    static final String TOPIC_EXCHAGE = &quot;topic_exchange&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String TOPIC_QUEUE_1 = &quot;topic_queue_1&quot;;</span><br><span class="line">    //队列名称</span><br><span class="line">    static final String TOPIC_QUEUE_2 = &quot;topic_queue_2&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //创建连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 声明交换机</span><br><span class="line">         * 参数1：交换机名称</span><br><span class="line">         * 参数2：交换机类型，fanout、topic、topic、headers</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        String message = &quot;新增了商品。Topic模式；routing key 为 xiaorui.insert &quot; ;</span><br><span class="line">        channel.basicPublish(TOPIC_EXCHAGE, &quot;xiaorui.insert&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        message = &quot;修改了商品。Topic模式；routing key 为 xiaorui.update&quot; ;</span><br><span class="line">        channel.basicPublish(TOPIC_EXCHAGE, &quot;xiaorui.update&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 发送信息</span><br><span class="line">        message = &quot;删除了商品。Topic模式；routing key 为 xiaorui.delete&quot; ;</span><br><span class="line">        channel.basicPublish(TOPIC_EXCHAGE, &quot;xiaorui.delete&quot;, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;已发送消息：&quot; + message);</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.TOPIC_QUEUE_1, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, &quot;xiaorui.update&quot;);</span><br><span class="line">        channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHAGE, &quot;xiaorui.delete&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer1-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.TOPIC_QUEUE_1, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumer2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaorui.rabbitmq.util.ConnectionUtil;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Consumer2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        // 创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        //声明交换机</span><br><span class="line">        channel.exchangeDeclare(Producer.TOPIC_EXCHAGE, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        // 声明（创建）队列</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否定义持久化队列</span><br><span class="line">         * 参数3：是否独占本次连接</span><br><span class="line">         * 参数4：是否在不使用的时候自动删除队列</span><br><span class="line">         * 参数5：队列其它参数</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(Producer.TOPIC_QUEUE_2, true, false, false, null);</span><br><span class="line"></span><br><span class="line">        //队列绑定交换机</span><br><span class="line">        channel.queueBind(Producer.TOPIC_QUEUE_2, Producer.TOPIC_EXCHAGE, &quot;item.*&quot;);</span><br><span class="line"></span><br><span class="line">        //创建消费者；并设置消息处理</span><br><span class="line">        DefaultConsumer consumer = new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            /**</span><br><span class="line">             * consumerTag 消息者标签，在channel.basicConsume时候可以指定</span><br><span class="line">             * envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送)</span><br><span class="line">             * properties 属性信息</span><br><span class="line">             * body 消息</span><br><span class="line">             */</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                //路由key</span><br><span class="line">                System.out.println(&quot;路由key为：&quot; + envelope.getRoutingKey());</span><br><span class="line">                //交换机</span><br><span class="line">                System.out.println(&quot;交换机为：&quot; + envelope.getExchange());</span><br><span class="line">                //消息id</span><br><span class="line">                System.out.println(&quot;消息id为：&quot; + envelope.getDeliveryTag());</span><br><span class="line">                //收到的消息</span><br><span class="line">                System.out.println(&quot;consumer2-接收到的消息为：&quot; + new String(body, &quot;utf-8&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //监听消息</span><br><span class="line">        /**</span><br><span class="line">         * 参数1：队列名称</span><br><span class="line">         * 参数2：是否自动确认，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动确认</span><br><span class="line">         * 参数3：消息接收到后回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(Producer.TOPIC_QUEUE_2, true, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>架构</title>
    <url>/2024/02/10/215%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>架构</p>
<span id="more"></span>

<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="对架构的一些看法"><a href="#对架构的一些看法" class="headerlink" title="对架构的一些看法"></a>对架构的一些看法</h2><ol>
<li>架构设计关注的是取舍。业务开发关注的是逻辑和实现。</li>
<li>架构设计没有体系化的培训和训练机制。</li>
<li>架构没有那么高大上。不是一定要技术天分，创造力；架构设计可以不高大上，可以没有高可用、高性能。</li>
</ol>
<p>架构内容：</p>
<ol>
<li><p>架构基础</p>
<p>背景，目的，复杂度来源，设计原则、流程</p>
</li>
<li><p>高可用架构</p>
</li>
<li><p>高性能架构</p>
</li>
<li><p>可扩展架构</p>
</li>
<li><p>架构实战</p>
</li>
</ol>
<p>任何能力的提升都离不开知行合一，架构设计也不例外。架构设计可以有多种方式：</p>
<ol>
<li><p>亲自负责一个系统的架构设计</p>
<p>这种机会最锻炼人，但不可能一个工程师从来没做过架构设计然后某天突然被委以重任，必须要先有一定的积累才会有这样的机会；</p>
</li>
<li><p>参与某个系统的架构设计，在总架构师的指导下，负责其中一部分的设计；</p>
</li>
<li><p>在设计好的架构下进行开发</p>
<p>虽然没有亲自参与架构设计，但如果能理解和看懂架构设计，对开发本身也很有帮助，如果能看出和分析出架构存在的问题，那就是一个展现自己的机会。</p>
</li>
</ol>
<p>因此，在没有进行架构设计的时候要做好“知”的储备，并尝试运用这些知识技能去分析和研究已有系统的架构，通过这种方式逐步积累和提升，等到真正有机会的时候，能够做到快速开始，快速把握机会，然后在实践中逐步提升自己的能力。</p>
<h2 id="语言演进-amp-软件多次危机"><a href="#语言演进-amp-软件多次危机" class="headerlink" title="语言演进&amp;软件多次危机"></a>语言演进&amp;软件多次危机</h2><p>机器语言：直接由01组成。难以排查。出现过火箭发射问题。</p>
<p>汇编语言：指令转化为英文。编写同一用途的程序，需要针对不对的CPU指令写不同的实现。</p>
<p>高级语言：由编译器统一处理多套CPU指令之间的不同。</p>
<p>20世纪60年代出现的第一次危机，出现了结构化编程。</p>
<p>解决：代码开发复杂性</p>
<p>特性：自顶向下（执行顺序），逐步细化，模块化（函数）</p>
<p>80年代第二次危机，面对对象开始流行。</p>
<p>解决：软件的扩展性</p>
<p>特性：万物皆对象，封装、继承、多态</p>
<p>90年代第三次危机，软件架构开始流行</p>
<p>解决：大型公司当时多部分软件组成的系统带来的问题。</p>
<p>内部耦合严重，开发和排查效率低</p>
<ol>
<li>理解代码慢</li>
<li>难以修改、扩展</li>
<li>新增修改出现问题多</li>
<li>难以排查出现的问题</li>
</ol>
<p>模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。</p>
<p>软件开发需要用有限的资源应对随时间变化而增加的复杂性。</p>
<p>“银弹”产生于一定的历史背景和大环境，而历史和环境总是会变化的</p>
<h2 id="2架构设计的目的"><a href="#2架构设计的目的" class="headerlink" title="2架构设计的目的"></a>2架构设计的目的</h2><p>架构设计不是为了什么？</p>
<ol>
<li>炫技</li>
<li>有事干</li>
<li>不是要按着大公司的架构来</li>
<li>不是每个系统都需要架构设计。架构设计需要时间，不做设计开发更快</li>
<li>不是为了使用流行技术</li>
<li>不是最新的就是最好的</li>
</ol>
<p>架构设计可能导致的问题：</p>
<ol>
<li>推迟项目进度，项目上线遥遥无期</li>
<li>成员每天争吵</li>
</ol>
<p>主要目的：识别软件系统的主要复杂度，综合考量软件系统的复杂度，提供解决软件系统复杂度问题的架构方案。</p>
<h2 id="3架构知识"><a href="#3架构知识" class="headerlink" title="3架构知识"></a>3架构知识</h2><h3 id="软件复杂度"><a href="#软件复杂度" class="headerlink" title="软件复杂度"></a>软件复杂度</h3><h4 id="复杂度种类"><a href="#复杂度种类" class="headerlink" title="复杂度种类"></a>复杂度种类</h4><ol>
<li>性能<ol>
<li>延迟</li>
<li>并发量</li>
<li>数据量</li>
<li>实时性</li>
</ol>
</li>
<li>服务可用性</li>
<li>功能扩展性</li>
<li>数据安全性。<ol>
<li>不丢失数据</li>
<li>隐私数据。手机号、身份证、地址隐私数据保密，但达不到隐私照片、金融数据的保密性</li>
<li>数据权限</li>
</ol>
</li>
<li>成本</li>
<li>业务复杂度<ol>
<li>核心业务流、扩展点位置</li>
</ol>
</li>
</ol>
<h4 id="复杂度分析案例"><a href="#复杂度分析案例" class="headerlink" title="复杂度分析案例"></a>复杂度分析案例</h4><p>学生管理系统复杂度分析案例：</p>
<ol>
<li>性能：使用人1万左右，平均每天访问一次，无需特殊考虑。mysql足够，缓存可以不用，nginx也足够</li>
<li>服务可用性：宕机2小时也影响不大，无需考虑</li>
<li>功能扩展性：功能比较固定，无需考虑</li>
<li>数据安全性：<ol>
<li>需要不丢失大量数据，主备+备用机房</li>
<li>访问数据要做控制，账号密码，数据库权限</li>
</ol>
</li>
<li>成本：仅需几台服务器，对于大学来说不是问题。</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231124094922081.png" alt="image-20231124094922081"></p>
<p>一个架构师一般可以支撑20人以上的团队。（2018 黄洲君 UC架构师）</p>
<p>一个项目已经在持续推进，而当前的每个迭代只是不停地增加新的业务功能，一般不涉及任何底层设施的变动，此时开发人员设计代码架构图，如业务的活动图和类图。架构师无需考虑因开发新业务而引入的复杂度。</p>
<h4 id="复杂度-高性能"><a href="#复杂度-高性能" class="headerlink" title="复杂度-高性能"></a>复杂度-高性能</h4><h5 id="单机内高性能"><a href="#单机内高性能" class="headerlink" title="单机内高性能"></a>单机内高性能</h5><p>单机发展：</p>
<ul>
<li><p>速度：每秒几次逐渐到每秒几亿次</p>
</li>
<li><p>业务种类：简单的科学计算到每秒几万次的搜索</p>
</li>
<li><p>软件系统规模：单机到上万台计算机</p>
</li>
<li><p>操作系统：用户单工字符界面到windows11多用户图形操作系统</p>
</li>
<li><p>组件</p>
<ol>
<li>等待手工输入、计算、输出</li>
<li>从存储读取输入、计算、输出。CPU无需等待人直接输入</li>
<li>从存储读取输入、多进程计算。A任务计算依赖并等待别的读取时，B任务开始计算。进程间通信被设计出来，包括管道、消息队列、信号量、共享存储等。</li>
<li>从存储读取输入、多进程多线程计算。共享进程数据。为了保证数据的正确性，发明了互斥锁机制</li>
<li>从存储读取输入、多CPU多进程多线程计算</li>
</ol>
</li>
</ul>
<p>单机性能：</p>
<p>多进程、多线程、进程间通信、多线程并发。Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大。</p>
<h5 id="集群高性能"><a href="#集群高性能" class="headerlink" title="集群高性能"></a>集群高性能</h5><p>计算机硬件的性能快速发展，但和业务的发展速度相比，还是小巫见大巫了，尤其是进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。</p>
<ol>
<li><p>任务分配</p>
<ol>
<li>任务分配器<ul>
<li>硬件网络设备，如F5，交换机</li>
<li>软件网络设备，如LVS</li>
<li>负载均衡软件，如Nginx,Gateway</li>
</ul>
</li>
<li>任务分配器和业务服务器连接交互</li>
<li>分配算法<ol>
<li>轮询</li>
<li>权重分配</li>
<li>负载分配。需要业务服务器上报状态</li>
</ol>
</li>
<li>1台任务分配不够，多台任务分配器</li>
</ol>
</li>
<li><p>任务分解。微服务</p>
<p>优点：改动影响小，也降低了风险</p>
<p>缺点：增加代码量，增加调用链路，增加排查难度</p>
<p>任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度非常关键。</p>
</li>
</ol>
<h4 id="复杂度-高可用"><a href="#复杂度-高可用" class="headerlink" title="复杂度-高可用"></a>复杂度-高可用</h4><p>无中断。</p>
<p>导致中断的因素：</p>
<ol>
<li>硬件。硬件老化，服务器、路由器、线路</li>
<li>软件。bug</li>
<li>基础设施。光缆</li>
<li>天灾。断电、地震、火灾、洪水</li>
</ol>
<p>硬件：冗余处理单元</p>
<p>软件：提升质量</p>
<p>计算高可用：</p>
<p>​    双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。</p>
<p>​    分配算法需要结合实际业务需求来分析和判断。例如，ZooKeeper 采用的就是 1 主多备，而 Memcached 采用的就是全主 0 备。</p>
<p>存储高可用：</p>
<p>将数据从一台机器搬到到另一台机器，需要经过线路进行传输，也就需要一定的时间。</p>
<p>这意味着整个系统在某个时间点上，数据肯定是不一致的。按照“<strong>数据 + 逻辑 = 业务</strong>”这个公式来套的话，数据不一致，即使逻辑一致，最后的业务表现就不一样了。</p>
<p>线路传输的速度：</p>
<ol>
<li>同一机房内部能够做到几毫秒；</li>
<li>分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。例如，从广州机房到北京机房，稳定情况下 ping 延时大约是 50ms，不稳定情况下可能达到 1s 甚至更多。</li>
</ol>
<p>传输线路故障：短的十几分钟，长的几个小时的。例如，2015 年支付宝因为光缆被挖断，业务影响超过 4 个小时；2016 年中美海底光缆中断 3 小时等。</p>
<p>软件故障：如：2023双十一后，因底层组件问题，阿里云故障1小时。</p>
<p>正常情况下的传输延迟，会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；但如果完全不做冗余，系统的整体高可用又无法保证，所以<strong>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响</strong>。</p>
<p>高可用状态决策：</p>
<ol>
<li>独裁</li>
<li>协商</li>
<li>民主选举，多数取胜。如：zoopkeeper</li>
</ol>
<h4 id="复杂度-可扩展性"><a href="#复杂度-可扩展性" class="headerlink" title="复杂度-可扩展性"></a>复杂度-可扩展性</h4><p>结合未来的需求做设计，达到未来做需求时仅需小的改动，或者仅需配置即可实现需求。</p>
<ol>
<li>不能所有的变化都考虑</li>
<li>不能一点变化也不考虑</li>
<li>预测有可能错误</li>
</ol>
<p>做法：</p>
<ol>
<li><p>预测变化</p>
</li>
<li><p>实现变化</p>
<p>隔离变化，将变化和稳定层分开，即封装变化。</p>
<ol>
<li><p>将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。</p>
<ol>
<li>系统需要拆分出变化层和稳定层</li>
<li>设计变化层和稳定层之间的接口</li>
</ol>
</li>
<li><p>提炼出一个“抽象层”和一个“实现层”</p>
<p>抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。典型的实践就是设计模式和规则引擎。</p>
</li>
</ol>
</li>
</ol>
<p>如何把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，没有通用的标准可以简单套上去，更多是靠自己的经验、直觉</p>
<p>示例：装饰者模式</p>
<h4 id="复杂度-其他：成本、安全、规模"><a href="#复杂度-其他：成本、安全、规模" class="headerlink" title="复杂度-其他：成本、安全、规模"></a>复杂度-其他：成本、安全、规模</h4><h5 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h5><p>几台十几台服务器一般不考虑服务器成本。</p>
<p>从10000台降低到8000台差20%的2000台，成本会是4000万左右。</p>
<p>低成本是高性能的约束。</p>
<p>一般先定一个成本。架构设计好后，超出成本时，重新设计，多次设计都不行，找老板提高成本预算。</p>
<p>技术和成本：</p>
<ul>
<li><p>新技术可以降低成本，需要成员学习新技术，与已有技术结合</p>
<p>如：</p>
<ol>
<li>NoSQL（Memcache、Redis 等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力。</li>
<li>解决mysql的like查询效率的全文搜索引擎ES，solor</li>
</ol>
</li>
<li><p>创造技术，需要研发出质变的技术。需要投入大量人力、技术、时间。</p>
<p>如：</p>
<ol>
<li>facebook解决php低效研发的php转c++，php转字节码后在虚拟机中运行</li>
<li>linkedin解决每天5000万消息处理研发的Kafaka</li>
</ol>
</li>
</ul>
<p>不同公司降低成本的方式：</p>
<ul>
<li>中小公司：引入新技术</li>
<li>大公司：可能去创造技术。</li>
</ul>
<h5 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h5><p>软件安全：</p>
<ul>
<li><p>用途：防止漏洞攻击</p>
</li>
<li><p>漏洞：xss，crsf，sql注入，windows漏洞，密码破解，框架漏洞：Struts2多次远程代码执行漏洞，fastjson远程代码执行漏洞</p>
</li>
</ul>
<p>攻防对抗中不断补漏洞。</p>
<p>架构安全：</p>
<ul>
<li>攻击案例：<ol>
<li>2016安全博客网站被攻击的流量，每秒665Gbps</li>
<li>2018年，美国东部时间 2 月 28 日，GitHub 在一瞬间遭到高达 1.35Tbps</li>
</ol>
</li>
<li>用途：防止强盗，DDos攻击</li>
<li>实现<ul>
<li>传统公司：使用云厂商提供的服务</li>
<li>银行：分层多级防火墙</li>
</ul>
</li>
</ul>
<h5 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h5><p>功能：</p>
<p>功能越多，功能之间联系越多，功能迭代时间越长越复杂。</p>
<p>逻辑分支多，功能应用场景不清楚，细节无法掌握。黑盒系统</p>
<p>数据：</p>
<p>mysql在数据量大（2018年写的，单表大于10亿）之后，会出现</p>
<ul>
<li>插入索引需要几个小时</li>
<li>条件查询很慢的情况</li>
<li>表备份慢</li>
<li>修改表结构慢</li>
</ul>
<p>google解决大量数据研发的：大数据计算mapreduce理论，大数据存储，大数据文档存储</p>
<h3 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h3><p>选择难点示例：</p>
<ol>
<li>要选择业界最先进的技术，还是选择团队目前最熟悉的技术？如果选了最先进的技术后出了问题怎么办？如果选了目前最熟悉的技术，后续技术演进怎么办？</li>
<li>选择 Google 的 Angular 的方案来做，还是选择 Facebook 的 React 来做？Angular 看起来更强大，但 React 看起来更灵活？</li>
<li>选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>
<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>
</ol>
<h4 id="满足当下不过度"><a href="#满足当下不过度" class="headerlink" title="满足当下不过度"></a>满足当下不过度</h4><p>不因追求先进而设计远超当前需要的设计。</p>
<p>追求架构大而精美的问题：</p>
<ol>
<li>人员不足</li>
<li>没有时间实战<ol>
<li>需要时间埋坑</li>
<li>真实业务场景</li>
</ol>
</li>
</ol>
<h4 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h4><p>随着业务的变化，而逐渐调整架构</p>
<h3 id="软件架构分析"><a href="#软件架构分析" class="headerlink" title="软件架构分析"></a>软件架构分析</h3><h4 id="识别复杂度"><a href="#识别复杂度" class="headerlink" title="识别复杂度"></a>识别复杂度</h4><p><strong>将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题</strong>。</p>
<ol>
<li>系统稳定性不高，经常出各种莫名的小问题；</li>
<li>系统子系统数量太多，系统关系复杂，开发效率低；</li>
<li>不支持异地多活，机房级别的故障会导致业务整体不可用。</li>
</ol>
<p>一次最好只解决1-2个问题</p>
<p>背景信息罗列：</p>
<ul>
<li>中间件团队规模不大，大约 6 人左右。</li>
<li>中间件团队熟悉 Java 语言，但有一个新同事 C/C++ 很牛。</li>
<li>开发平台是 Linux，数据库是 MySQL。</li>
<li>目前整个业务系统是单机房部署，没有双机房。</li>
</ul>
<p>QPS：峰值一般考虑是日均的3倍</p>
<p>性能扩展性：微博这种的消息中间件可以考虑设计为峰值的4倍。一般不设定在10倍以上</p>
<p>TPS：1000不算高性能</p>
<p>QPS：10000算高性能</p>
<h4 id="设计备选方案"><a href="#设计备选方案" class="headerlink" title="设计备选方案"></a>设计备选方案</h4><p>三种错误设计：</p>
<ol>
<li><p>要设计最强大的架构，架构本身最优</p>
</li>
<li><p>没有备选方案</p>
<p>解决：防止思维狭隘，目光短浅，思维盲区等决策陷阱</p>
<p>缺点：</p>
<ol>
<li><p>可能因为一个缺点就把某个方案否决。实际上没有完美的方案。</p>
</li>
<li><p>自身的评估和经验可能不准确</p>
</li>
<li><p>单一方案无法避免过度辩护</p>
</li>
</ol>
<p>备选方案3-5个；备选方案需要有差异；备选方案可以考虑新技术，不是手里的锤子，遇到的问题都是钉子；</p>
</li>
<li><p>备选方案过于详细</p>
<p>缺点：耗费时间长，评审容易陷在细节里边。</p>
</li>
</ol>
<p>架构师的技术储备越丰富、经验越多，备选方案也会更多，从而才能更好地设计备选方案。</p>
<p>前浪微博2013消息系统设计方案：</p>
<ol>
<li>引入Kafaka</li>
<li>集群+Mysql存储</li>
<li>集群+自研存储系统</li>
</ol>
<h4 id="评估和选择备选方案"><a href="#评估和选择备选方案" class="headerlink" title="评估和选择备选方案"></a>评估和选择备选方案</h4><p>如：简单，最牛，最熟悉，领导</p>
<p>评分：评判维度给出权重分，计算总分</p>
<p>优先级：评判维度按优先级排列，不满足的依次排除</p>
<p>消息系统评判示例：</p>
<p>评判人员：架构设计师、中间件研发人员、测试、运维、业务主管</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231129150358189.png" alt="image-20231129150358189"></p>
<p>最终选择方案2.</p>
<ul>
<li>排除备选方案 1 的主要原因是可运维性，因为再成熟的系统，上线后都可能出问题，如果出问题无法快速解决，则无法满足业务的需求；并且 Kafka 的主要设计目标是高性能日志传输，而我们的消息队列设计的主要目标是业务消息的可靠传输。</li>
<li>排除备选方案 3 的主要原因是复杂度，目前团队技术实力和人员规模（总共 6 人，还有其他中间件系统需要开发和维护）无法支撑自研存储系统（参考架构设计原则 2：简单原则）。</li>
</ul>
<p>备选方案2缺点：</p>
<ul>
<li>备选方案 2 的第一个缺点是性能，业务目前需要的性能并不是非常高，方案 2 能够满足，即使后面性能需求增加，方案 2 的数据分组方案也能够平行扩展进行支撑（参考架构设计原则 3：演化原则）。</li>
<li>备选方案 2 的第二个缺点是成本，一个分组就需要 4 台机器，支撑目前的业务需求可能需要 12 台服务器，但实际上备机（包括服务器和数据库）主要用作备份，可以和其他系统并行部署在同一台机器上。</li>
<li>备选方案 2 的第三个缺点是技术上看起来并不很优越，但我们的设计目的不是为了证明自己（参考架构设计原则 1：合适原则），而是更快更好地满足业务需求。</li>
</ul>
<p>个人博客图床选择：</p>
<p>搭建博客</p>
<ol>
<li><p>hexo+github搭建博客</p>
<p>2018作为学生，为了博客版权归属自己，使用hexo+github搭建博客，图片存在github上</p>
</li>
<li><p>github图床切换为免费图床sm.ms</p>
<p>搭建后发现github空间只有300M，一张截图十几KB，一天截图十几张，怕不够用。考虑空间功能性、使用成本，找到了免费图床sm.ms</p>
</li>
<li><p>sm.ms迁移到阿里云oss</p>
<p>2022已工作，美国制裁，担心免费图床挂了，无法使用，数据丢失。使用过程也偶现过无法访问。考虑稳定性，存储安全性，切换到了国内付费阿里云oss.</p>
<p>图片从sm.ms迁移到阿里云oss没有成熟可用的代码，自己写了一套。查询指定文件夹md文件，记录其中的https://*.png，下载并上传到阿里云oss，将返回的url替换</p>
</li>
</ol>
<h4 id="详细方案设计"><a href="#详细方案设计" class="headerlink" title="详细方案设计"></a>详细方案设计</h4><p>中间件内的技术选型。</p>
<p>如：</p>
<ul>
<li>nginx选择负载均衡策略。默认轮询，权重适合机器性能不一致，IP hash适合购物车、电商架构后端有session，根据响应时间分配不容器将某个服务器打卦。</li>
</ul>
<ol>
<li><p>数据库表设计。</p>
<ul>
<li>使用日志表追加记录的方式存储消息</li>
<li>消息表异步拉取日志表，存储30天。日志表被拉取后，清楚记录。</li>
<li>消息表本身主备</li>
<li>字段设计</li>
</ul>
</li>
<li><p>主备如何切换。</p>
<p>采用 ZooKeeper 来做主备决策，主备服务器都连接到 ZooKeeper 建立自己的节点，主服务器的路径规则为“/MQ/server/ 分区编号 /master”，备机为“/MQ/server/ 分区编号 /slave”，节点类型为 EPHEMERAL。</p>
<p>备机监听主机的节点消息，当发现主服务器节点断连后，备服务器修改自己的状态，对外提供消息读取服务。</p>
</li>
<li><p>业务服务器如何写入消息</p>
<p>消息队列系统提供 SDK 供各业务系统调用，SDK 从配置中读取所有消息队列系统的服务器信息，SDK 采取轮询算法发起消息写入请求给主服务器。</p>
</li>
<li><p>业务服务器如何读取消息？</p>
<p>消息队列系统提供 SDK 供各业务系统调用，SDK 从配置中读取所有消息队列系统的服务器信息，轮流向所有服务器发起消息读取请求。</p>
</li>
<li><p>业务服务器和消息队列服务器之间的通信协议如何设计</p>
<p>消息队列系统后续可能会对接多种不同编程语言编写的系统，为了提升兼容性，传输协议用 TCP，数据格式为 ProtocolBuffer。</p>
</li>
</ol>
<p>架构设计对技术点掌握度要求：</p>
<ol>
<li>使用</li>
<li>基本原理，关键设计</li>
<li>优缺点</li>
</ol>
<p>确定选型后，要进行性能和可用性测试</p>
<h2 id="4架构高级知识"><a href="#4架构高级知识" class="headerlink" title="4架构高级知识"></a>4架构高级知识</h2><h3 id="成熟架构模式"><a href="#成熟架构模式" class="headerlink" title="成熟架构模式"></a>成熟架构模式</h3><h4 id="高性能架构-读写分离"><a href="#高性能架构-读写分离" class="headerlink" title="高性能架构-读写分离"></a>高性能架构-读写分离</h4><p>目的：分散读压力。一般在优化慢查询，调整不合理的业务逻辑，引入缓存之后</p>
<p>场景：单机并发无法支撑读请求。如：运营频繁查看大量统计数据。</p>
<p>基本实现：</p>
<ul>
<li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li>
<li>数据库主机负责读写操作，从机只负责读操作。</li>
<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li>
<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li>
</ul>
<p>缺点：主从复制延时，业务写入后，读取从库读不到。</p>
<p>解决：有一致性要求的指定主库。</p>
<ol>
<li>写操作后的读操作指定发给数据库主服务器。业务的侵入和影响较大</li>
<li>读从机失败后再读一次主机。二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。黑客暴力破解账号，会导致大量的二次读取操作</li>
<li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li>
</ol>
<p>分配主机查询机制</p>
<ol>
<li><p>代码封装。</p>
<p>优点：实现简单，而且可以根据业务做较多定制化的功能。</p>
<p>缺点：故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启。</p>
<p>案例：淘宝的 TDDL,sharding-jdbc</p>
</li>
<li><p>中间件封装</p>
<p>优点：数据库主从切换对业务服务器无感知</p>
<p>缺点：所有的数据库操作请求都要经过中间件，中间件的性能要求也很高。实现比较复杂，细节特别多，很容易出现 bug，需要较长的时间才能稳定。</p>
<p>案例：mysql官方MySQL Proxy，奇虎 360 公司数据库中间件 Atlas</p>
</li>
</ol>
<h4 id="高性能架构-分库分表"><a href="#高性能架构-分库分表" class="headerlink" title="高性能架构-分库分表"></a>高性能架构-分库分表</h4><p>TiDB与mysql对比 todo</p>
<p>目的：降低查询和写入压力。一般在提升硬件设备，优化慢查询，调整不合理的业务逻辑，引入缓存，读写分离，分库后再分表</p>
<p>场景：单机并发无法支撑读和写请求。如：订单表每月10亿数据。</p>
<p>小公司初创业务，一开始不适合拆分。业界成熟的大公司的预估规模大的业务，可以考虑一开始就拆分。</p>
<p>关系型数据库优势：sql查询、join、事务</p>
<h5 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h5><p>按业务拆分库到不同实例</p>
<p>分库案例：</p>
<p>因为电商业务数据库选择了主从分离。</p>
<p>因大节促销防止供应链不受电商业务影响选择了实例分离。</p>
<p>因运营查询数据量大的压力，运营数据，运营sql查询直接查询业务增加指定从库。</p>
<p>主从分离使用阿里云RDS，在mapper中增加特定注释查询主库。</p>
<h5 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h5><ul>
<li>垂直切分<ul>
<li>优点：关系性数据库不常用字段、大字段可以避免查询到内存中。</li>
<li>缺点：<ul>
<li>多一次查询</li>
<li>事务无法使用，只能自己模拟。A库写成功，B库失败，需要人工介入。</li>
<li>增加成本</li>
</ul>
</li>
</ul>
</li>
<li>水平切分<ul>
<li>切分维度<ul>
<li>范围</li>
<li>hash<ul>
<li>订单表可以按订单号分表，也可以按照买家id或者卖家id分表，还可以按照时间分表</li>
</ul>
</li>
<li>配置表</li>
</ul>
</li>
<li>实现：ShadingJdbc、mycat</li>
<li>缺点：增加查询次数。如select、count、group by、order by、join</li>
</ul>
</li>
</ul>
<h4 id="高性能NoSQL"><a href="#高性能NoSQL" class="headerlink" title="高性能NoSQL"></a>高性能NoSQL</h4><p>关系数据库缺点：</p>
<ol>
<li>行记录，无法直接存储数据结构。</li>
<li>schema 强约束导致扩展麻烦。操作不存在的列会报错，业务变化时扩充列也比较麻烦，需要执行 DDL</li>
<li>关系数据库在大数据场景下 I/O 较高</li>
<li>全文搜索功能比较弱。like查询效率低，多条件查询慢，消耗资源大。</li>
</ol>
<h5 id="K-V存储"><a href="#K-V存储" class="headerlink" title="K-V存储"></a>K-V存储</h5><h6 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h6><p>缺点：事务没有原子性和持久性。现在应该有?</p>
<p>大部分业务也不需要严格遵循 ACID 原则</p>
<h5 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h5><h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><p>特点：no-schema，可以存储和读取任意的数据。</p>
<p>用途：</p>
<p>场景：</p>
<ol>
<li><p>电商的商品数据</p>
<p>不同商品的属性差异很大。</p>
</li>
<li><p>游戏</p>
</li>
</ol>
<p>缺点：无事务，不能join。2023现在应该可以了？实现事务不是完全没有代价的，要么性能降低，要么灵活性降低</p>
<p>优点：</p>
<ol>
<li>新增字段简单，无需执行DDL</li>
<li>历史数据不会出错，无字段返回空</li>
<li>可以很容易存储复杂数据</li>
</ol>
<h5 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h5><h6 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h6><p>用途：离线海量数据分析统计。</p>
<p>实现：一列的数据在磁盘上是连续的，不同列在磁盘分开存储。</p>
<p>优点：</p>
<ul>
<li><p>列读取I/O低。不需要同关系型数据库需要读取其他列字段。</p>
</li>
<li><p>数据压缩率高，占用存储低。</p>
<p>普通的行式数据库一般压缩率在 3:1 到 5:1 左右，而列式数据库的压缩率一般在 8:1 到 30:1 左右</p>
</li>
</ul>
<p>缺点：修改多个列速度慢，多个列修改没有一致性</p>
<h5 id="全文搜索引擎"><a href="#全文搜索引擎" class="headerlink" title="全文搜索引擎"></a>全文搜索引擎</h5><h6 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h6><p>正排索引：</p>
<p>将某个字段作为1个索引，字段中的值对应n行</p>
<p>倒排索引：</p>
<p>一条数据是一个json；将全部json中的所有单词作为索引值，对应n条json</p>
<p>Elastcisearch 是分布式的文档存储方式。它能存储和检索复杂的数据结构——序列化成为 JSON 文档——以实时的方式。</p>
<p>在 Elasticsearch 中，每个字段的所有数据都是默认被索引的。即每个字段都有为了快速检索设置的专用倒排索引。</p>
<h4 id="高性能架构-缓存架构"><a href="#高性能架构-缓存架构" class="headerlink" title="高性能架构-缓存架构"></a>高性能架构-缓存架构</h4><p>目的：降低查询压力。</p>
<p>场景：能容忍短暂数据不一致的查多写少业务。微博、微信</p>
<p>引入复杂度：</p>
<ul>
<li><p>缓存击穿</p>
<ol>
<li><p>数据不存在。</p>
<p>解决：查询数据库也不存在时，缓存中添加空值</p>
</li>
<li><p>数据量大，分页缓存，爬虫访问所有信息，不常访问的数据把常访问的数据挤出去了</p>
<p>监控缓存命中率。容器化动态增加服务器、限流、业务降级</p>
<p>识别爬虫然后禁止访问，这可能会影响 SEO 和推广</p>
</li>
</ol>
</li>
<li><p>缓存雪崩</p>
<ol>
<li><p>单个缓存过期时，加载缓存期间大量请求发送到数据库，数据库扛不住，响应变慢或者直接宕机，影响到其他系统。</p>
<p>解决：加载缓存时机器少，增加sychronized；机器多，增加分布式锁；</p>
<p>缓存设置永久，后台定时任务更新缓存；业务线程发现缓存失效用定时消息通知后台线程更新缓存。</p>
<p>后台定时任务更新还可用于缓存预热</p>
</li>
<li><p>大批量缓存同时过期。</p>
<p>缓存设置固定时间+随机30-80毫秒</p>
</li>
</ol>
</li>
<li><p>缓存热点</p>
<p>缓存数据集中在一个分区上。如：1000万粉丝的微博发重要消息</p>
<p>解决：</p>
<ol>
<li>对缓存复制100份，设置不同过期时间，编号后分开存储到不同服务器上，随机读取。</li>
<li>多级缓存。前端：CDN加local storage。后端：二级缓存</li>
</ol>
</li>
</ul>
<p>其他：</p>
<ol>
<li><p>同步刷新缓存：当更新了某些信息后，立刻让缓存失效。<br>这种做法的优点是用户体验好，缺点是修改一个数据可能需要让很多缓存失效</p>
</li>
<li><p>适当容忍不一致：例如某东的商品就是这样，查询的时候显示有货，详情提示没货了</p>
</li>
<li><p>关键信息不缓存：库存，价格等不缓存。这类信息查询简单，效率高</p>
</li>
</ol>
<h4 id="单服务器高性能模式"><a href="#单服务器高性能模式" class="headerlink" title="单服务器高性能模式"></a>单服务器高性能模式</h4><h5 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h5><p>链接、请求</p>
<ol>
<li><p>海量连接（成千上万）海量请求：例如抢购，双十一等</p>
</li>
<li><p>常量连接（几十上百）海量请求：例如中间件,mysql，redis,mq</p>
</li>
<li><p>常量连接常量请求：例如内部运营系统，管理系统</p>
</li>
<li><p>PPC 多进程</p>
<p>read -&gt; 业务处理 -&gt; write 。当前连接没有数据可以读，则进程就阻塞在 read 操作上</p>
</li>
<li><p>TPC 多线程</p>
<p>示例：Mysql链接</p>
</li>
<li><p>Reactor同步非阻塞</p>
<p>非阻塞：操作系统read 操作（数据加载到内核缓存）改为非阻塞，当连接上有数据的时候进程才去处理。</p>
<p>同步：用户进程在执行 read（从内核加载到进程空间） 和 send 这类 I/O 操作的时候是同步。</p>
<p>数据加载到内核缓存时间远大于从内核加载到进程空间。</p>
<p>I/O 多路复用结合线程池。I/O 多路复用统一监听事件，收到事件后分配（Dispatch）给某个进程。</p>
<ol>
<li><p>单Reactor单进程/线程</p>
<p>示例：单进程redis。不适合处理大value，会阻塞其他请求，可以使用MemaCache</p>
</li>
<li><p>单Reactor多线程</p>
<p>示例：</p>
<p>单 Reator 多线程方案能够充分利用多核多 CPU 的处理能力。</p>
<p>缺点：</p>
<ul>
<li>多线程数据共享和访问比较复杂。</li>
<li>Reactor 承担所有事件的监听和响应，只在主线程中运行，瞬间高并发时会成为性能瓶颈。</li>
</ul>
</li>
<li><p>多Reactor多进程/线程</p>
<p>示例：</p>
<ul>
<li>多Reactor多进程：Nginx</li>
<li>多Reactor多线程：MemaCache、Netty</li>
</ul>
</li>
</ol>
</li>
<li><p>Proactor异步非阻塞</p>
</li>
</ol>
<p>bio：阻塞io，PPC和TPC属于这种<br>NIO：多路复用io，reactor就是基于这种技术<br>aio：异步io，Proactor就是基于这种技术</p>
<p>TPC计算可支持的并发数：可以根据系统的总资源和每个线程所需的资源来估算。例如，如果系统有8GB内存和4个CPU核心，每个线程需要0.5GB内存和0.5个CPU核心，那么可支持的并发数可能是16个</p>
<h4 id="高性能-负载均衡分类、架构、算法"><a href="#高性能-负载均衡分类、架构、算法" class="headerlink" title="高性能-负载均衡分类、架构、算法"></a>高性能-负载均衡分类、架构、算法</h4><p>负载均衡其实是任务分配，不是让不同服务器的负载达到均衡。</p>
<h5 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h5><p>优点：简单</p>
<p>缺点：</p>
<ol>
<li>扩展性差，掌控权在域名服务商手中</li>
<li>实时性差</li>
<li>功能简单，分配策略简单，不能根据服务器差异分配</li>
</ol>
<h5 id="硬件复杂均衡"><a href="#硬件复杂均衡" class="headerlink" title="硬件复杂均衡"></a>硬件复杂均衡</h5><p>设备：F5</p>
<p>量级：百万，200万-800万</p>
<p>优点：</p>
<ol>
<li>性能强，支持并发量大</li>
<li>功能强，负载均衡策略丰富。还支持安全功能，防火墙、防DDos攻击</li>
<li>稳定。商用，且经过严格测试和市场检验</li>
</ol>
<p>缺点：</p>
<ol>
<li>贵</li>
<li>扩展能力差，可以根据业务进行配置，但无法进行扩展和定制</li>
</ol>
<h5 id="软件复杂均衡"><a href="#软件复杂均衡" class="headerlink" title="软件复杂均衡"></a>软件复杂均衡</h5><h6 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h6><p>量级：万，5万左右</p>
<p>优点：</p>
<ol>
<li>便宜，买linux服务器部署即可</li>
<li>灵活，可以用插件实现业务的定制化功能</li>
<li>简单：部署和维护简单</li>
</ol>
<p>支持7层协议，Http</p>
<h6 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h6><p>量级：十万，20万左右。号称80万</p>
<p>支持4层协议</p>
<h5 id="多级负载均衡"><a href="#多级负载均衡" class="headerlink" title="多级负载均衡"></a>多级负载均衡</h5><p>DNS做南北地理负载均衡，F5做不同集群负载均衡，LVS、Nginx做不同机器负载均衡</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231201115627140.png" alt="image-20231201115627140"></p>
<h5 id="论坛日活1000万用户负载均衡分析"><a href="#论坛日活1000万用户负载均衡分析" class="headerlink" title="论坛日活1000万用户负载均衡分析"></a>论坛日活1000万用户负载均衡分析</h5><p>1000万日活 *100pv(请求/每人) / （86400/每秒） * （3/峰值） = 3.6万 峰值QPS</p>
<p>DNS + nginx足够</p>
<h5 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h5><p>轮询、加权轮询、负载最低优先、响应最低优先、</p>
<p>源地址hash：适合于存在事务、会话的业务。</p>
<p>ID哈希：将某个 ID 标识的业务分配到同一个服务器中进行处理。</p>
<h4 id="高可用-理论"><a href="#高可用-理论" class="headerlink" title="高可用-理论"></a>高可用-理论</h4><h5 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h5><p>互联和分享读写数据的分布式系统。如：mysql集群。不是memcache集群</p>
<p>C：分布式同一条数据的一致性</p>
<ul>
<li>具体细节</li>
</ul>
<ol>
<li><p>CAP针对的是分开存储的数据</p>
<p>部分数据选择CP，部分数据选择AP，不是整个系统要设计成CP或AP</p>
<p>如：库存需要CP。用户昵称、爱好需要AP</p>
</li>
<li><p>CAP没有考虑时延。</p>
<p>同机房时延几毫秒，广州、北京机房时延几十毫秒</p>
<p>分区一致性无法严格保证。但可以将不用一块访问的数据分区。比如：1-100的用户存在A实例，101-200存在B实例。</p>
<p>双写一致的时候，A集群挂了，如何去掉双写一致，只让B集群写入，并正常提供服务，前边增加一个服务器又陷入单点故障了。</p>
</li>
<li><p>C没有的时候可以做一些事来方便后续补偿</p>
<p>记录日志，挂调的节点起来后，用日志来同步数据</p>
</li>
</ol>
<h5 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h5><p>针对数据库事务</p>
<ul>
<li><p>原子性：一系列操作共同成功，共同失败</p>
</li>
<li><p>一致性：事务开始之前和事务结束以后，数据的完整性没有被破坏。</p>
</li>
<li><p>隔离性：多个并发事务同时对数据进行读写和修改的能力。隔离级别：RU，RC，RR，串行化</p>
</li>
<li><p>持久性：对数据库的修改将永久保存，不因软件故障丢失数据。</p>
</li>
</ul>
<p>原子性、隔离性、持久性是一致性的基础。</p>
<p>涉及到跨多个数据源或多个操作的业务场景时，原子性、隔离性和持久性不足以保证数据的一致性。</p>
<h5 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h5><ul>
<li><p>基本可用</p>
<p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p>
</li>
<li><p>软状态</p>
<p>允许数据不一致，但不能影响系统整理可用性</p>
</li>
<li><p>最终一致性</p>
<p>所有数据副本经过一定时间后，最终能够达到一致的状态。</p>
</li>
</ul>
<h5 id="高可用-FEMA分析系统可用性方法论"><a href="#高可用-FEMA分析系统可用性方法论" class="headerlink" title="高可用-FEMA分析系统可用性方法论"></a>高可用-FEMA分析系统可用性方法论</h5><p>通用分析方法</p>
<ol>
<li>功能点</li>
<li>故障点</li>
<li>故障影响</li>
<li>严重程度</li>
<li>故障原因</li>
<li>发生概率</li>
<li>风险程度</li>
<li>已有措施<ol>
<li>告警后人工干预、容错-备份、自恢复-主从自动切换</li>
<li>非法访问白名单控制</li>
<li>密码暴力破解的重试次数限制</li>
<li>防止磁盘坏道，2年更换</li>
</ol>
</li>
<li>后续规划<ol>
<li>敏感数据加密</li>
</ol>
</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231206110320875.png" alt="image-20231206110320875"></p>
<h4 id="高可用存储架构-双机架构"><a href="#高可用存储架构-双机架构" class="headerlink" title="高可用存储架构-双机架构"></a>高可用存储架构-双机架构</h4><ul>
<li><p>主备</p>
<p>备机只备份数据，主机出现问题时，可手动将服务端指向数据库的地址改为备用机。</p>
<ul>
<li><p>场景：内部后台管理系统。如：学生管理系统、员工管理系统</p>
</li>
<li><p>优点：简单</p>
</li>
<li><p>缺点：</p>
<ol>
<li>故障需人工干预</li>
<li>1年1-2次的操作不熟练可能出错。</li>
<li>备机没有读写浪费资源</li>
</ol>
</li>
</ul>
</li>
<li><p>主从</p>
<ul>
<li><p>场景：论坛，政府官网，门户</p>
</li>
<li><p>优点：</p>
<ol>
<li>主机挂了，读业务仍可用</li>
<li>丛机负担读，不浪费资源</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>故障需人工干预</li>
<li>客户端需感知主从关系，复杂度稍高</li>
<li>主从延时出现的数据不一致可能导致业务问题</li>
</ol>
</li>
</ul>
</li>
<li><p>主备/主从自动切换</p>
<ul>
<li><p>实现</p>
<ol>
<li><p>状态判断</p>
<ul>
<li><p>通知渠道</p>
<ol>
<li><p>互连式</p>
</li>
<li><p>中介式</p>
<p>优点：连接管理、状态决策简单</p>
<p>缺点：本身需要高可用。如zookeeper多数选举</p>
</li>
<li><p>模拟式</p>
<p>模拟成一个客户端。备/从写数据到主检查</p>
<p>优点：实现简单</p>
<p>缺点：检查状态少</p>
</li>
</ol>
</li>
</ul>
<p>检测内容：机器掉电、进程是否存在、响应是否缓慢</p>
</li>
<li><p>切换决策</p>
<ul>
<li>切换时机</li>
<li>切换策略</li>
<li>自动程度</li>
</ul>
</li>
<li><p>数据冲突解决</p>
<p>数据还没有复制到备机，此时发生切换。主备都有ID=100的数据</p>
</li>
</ol>
</li>
<li><p>优点：无需人工切换</p>
</li>
<li><p>缺点：</p>
<ol>
<li>复杂</li>
<li>可能有数据冲突</li>
</ol>
</li>
</ul>
</li>
<li><p>主主</p>
<p>适用场景少，需要数据能够双向复制。如：用户登录session数据，用户行为的日志数据，论坛草稿数据</p>
</li>
</ul>
<h4 id="高可用存储架构-集群"><a href="#高可用存储架构-集群" class="headerlink" title="高可用存储架构-集群"></a>高可用存储架构-集群</h4><h5 id="数据集中集群"><a href="#数据集中集群" class="headerlink" title="数据集中集群"></a>数据集中集群</h5><ul>
<li><p>介绍：一主多从，数据量单台服务器就可以承担</p>
</li>
<li><p>缺点：</p>
<ol>
<li>多从对主库复制压力大。</li>
<li>多个从库数据不一致</li>
<li>多个从对主状态判定可能不同</li>
</ol>
</li>
<li><p>示例：zookeeper集群</p>
</li>
</ul>
<h5 id="数据分散集群"><a href="#数据分散集群" class="headerlink" title="数据分散集群"></a>数据分散集群</h5><ul>
<li><p>介绍：</p>
<p>业务分实例，不同实例存储在不同地点，避免地理级别的灾害导致数据全部丢失。</p>
<p>同城仍需做备份，或同城双活。</p>
<ul>
<li>复杂点<ul>
<li>数据存储均衡性</li>
<li>容错性，故障服务器数据处理</li>
<li>可伸缩性，扩容服务器时数据处理</li>
</ul>
</li>
<li>备份机制<ul>
<li>互相备份<ul>
<li>优点：成本低</li>
<li>缺点：扩展性低，扩展需考虑备份迁移；设计复杂；各地区互相影响</li>
</ul>
</li>
<li>集中备份<ul>
<li>优点：设计简单；扩展容易；各地区互不影响</li>
<li>缺点：成本较高</li>
</ul>
</li>
<li>单独备份<ul>
<li>优点：</li>
<li>缺点：成本高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用途：成百上千台服务器</p>
</li>
<li><p>示例：</p>
<ol>
<li><p>大数据Hadoop集群</p>
<p>使用独立主机分配</p>
</li>
<li><p>ES集群</p>
<p>选举其中一台做数据分区分配</p>
</li>
<li><p>rocketMQ</p>
<p>使用客户端轮询发送分配给不同的master</p>
</li>
</ol>
</li>
</ul>
<h4 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h4><h5 id="主备"><a href="#主备" class="headerlink" title="主备"></a>主备</h5><ul>
<li>冷备</li>
<li>温备</li>
</ul>
<h5 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h5><h5 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h5><p>2个和2个以上</p>
<p>状态检测，任务分配</p>
<ul>
<li><p>对称集群</p>
<p>集群中每个节点可以处理所有类型的请求</p>
</li>
<li><p>非对称集群</p>
<p>节点类型不同处理请求不同。</p>
<p>如：zookeeper</p>
</li>
</ul>
<h4 id="高可用-异地多活架构"><a href="#高可用-异地多活架构" class="headerlink" title="高可用-异地多活架构"></a>高可用-异地多活架构</h4><p>仍有分钟级的影响</p>
<p>金融系统大部分使用主备架构，不算业余但也算不上先进。（2018 CIPS（人民币跨境支付系统）)</p>
<p>oceanbase保证异地多个节点中大部分节点写成功。未写成功的节点异步恢复。未恢复前不可发生新的交易。???</p>
<p>oceanbase采用了两阶段提交来实现跨区多机分布式事务。当协调器出现故障时，其通过查询所有参与者的状态来恢复分布式事务。当某个分区故障或网络中断时，事务会长时间挂起，直到故障修复，这段时间内部分其实是不可用的。虽然其声称强一致性和高可用，当发生故障和网络中断，依然会导致服务不可用。？？？</p>
<p>缺点：</p>
<ol>
<li>增加系统复杂度</li>
<li>成本高</li>
</ol>
<h5 id="同城异区"><a href="#同城异区" class="headerlink" title="同城异区"></a>同城异区</h5><ul>
<li><p>用途：防止机房级别的故障。如：机房火灾、机房断电、空调故障</p>
</li>
<li><p>实现：搭建专用高速网络，两个机房科实现和同一个机房几乎一样的网络传输速度。逻辑上可以看成是一个机房</p>
</li>
<li><p>复杂度：</p>
<p>切换前需要做流量限制，缓慢放量</p>
</li>
</ul>
<h5 id="跨城异地"><a href="#跨城异地" class="headerlink" title="跨城异地"></a>跨城异地</h5><ul>
<li><p>用途：部分业务应对极端灾难事件</p>
</li>
<li><p>时延：光纤中传输的速度大约是每秒 20 万千米，再加上传输中的各种网络设备的处理，实际还远远达不到理论上的速度。2000千米，不算网络设备需10毫秒。广州机房到北京机房，正常情况下 RTT 大约是 50 毫秒左右，遇到网络波动，回到500毫秒甚至1秒。</p>
</li>
<li><p>业务限制：可接受数据短时间不一致的情况。</p>
<p>可跨城异地多活：用户登录、新闻类网站、微博</p>
<p>不可跨城异地多活：银行存款余额、支付宝余额无法做异地多活。</p>
</li>
</ul>
<h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><p>保证绝大多数用户核心业务异地多活。</p>
<ol>
<li><p>保证核心业务</p>
<p>注册、修改用户信息、登录中只保证登录</p>
</li>
<li><p>核心数据最终一致性</p>
<ol>
<li>减小异地多活机房距离，搭建高速网络</li>
<li>减少数据同步量。只同步核心业务相关数据</li>
<li>保证最终一致性，不保证实时一致性<ol>
<li>正常情况下5分钟同步至所有机房即可，异常可允许1小时或者1天</li>
<li>根据不同的数据特征，进行差异化处理</li>
</ol>
</li>
</ol>
</li>
<li><p>数据多种方式同步</p>
<ol>
<li>数据库自带的同步</li>
<li>消息队列</li>
<li>查两次，A登录后，B再登录时，多去A查一次</li>
<li>回源读取</li>
<li>重新生成数据。如A挂了，在B需重新登录</li>
</ol>
</li>
<li><p>只保证绝大部分用户</p>
</li>
<li><p>业务降级</p>
<ol>
<li>实时转账替换为转账申请，申请结果发短信通知用户</li>
</ol>
</li>
</ol>
<h5 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h5><ol>
<li><p>业务分级</p>
<p>维度：</p>
<ol>
<li>访问量大的业务</li>
<li>核心业务</li>
<li>产生大量收入</li>
</ol>
<p>如：QQ聊天对用户更重要，影响用户数量大；QQ空间对用户重要性低，但影响收入（插入了广告）；</p>
<p>核心商业模式、公司阶段性目标、和公司具体业务有关，没有绝对的答案。</p>
</li>
<li><p>数据分类</p>
<ol>
<li><p>数据量</p>
</li>
<li><p>唯一性</p>
<p>如果数据不需要唯一，那就说明两个地方都产生同类数据是可能的；如果数据要求必须唯一，要么只能一个中心点产生数据，要么需要设计一个数据唯一生成的算法</p>
</li>
<li><p>实时性</p>
</li>
<li><p>可丢失性</p>
</li>
<li><p>可恢复性</p>
<p>微博可以重发。密码丢失可以重置。账号丢失，系统也无法恢复数据就真的丢失了</p>
</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231207150949115.png" alt="image-20231207150949115"></p>
</li>
<li><p>数据同步方式</p>
<ol>
<li><p>消息队列</p>
<p>适合不需要事务一致性、时间顺序一致的数据。如：适合注册用户，不适合修改密码</p>
</li>
<li><p>存储自带同步</p>
<p>如：适合修改密码</p>
</li>
<li><p>查询</p>
</li>
</ol>
<p>示例：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231207151029154.png" alt="image-20231207151029154"></p>
</li>
<li><p>异常处理</p>
<ol>
<li><p>双同步</p>
<p>适合可覆盖的数据。如：适合注册用户，不适合修改密码。</p>
<p>不走同一网络。如：消息队列走公网。存储自同步走内网</p>
</li>
<li><p>同步+访问结合</p>
<p>优先读取本地数据，读取不到时读取远程数据</p>
</li>
<li><p>日志记录</p>
<p>每个关键操作前后都记录日志，故障恢复后，数据库数据和日志数据对比修复数据。</p>
<p>存储位置：</p>
<ol>
<li>服务器。应对单台数据库服务器故障</li>
<li>本地独立系统。应对业务服务器、数据库同时宕机。如：服务器和数据库在同一机架、同一电源线路。</li>
<li>日志异地保存</li>
</ol>
</li>
<li><p>用户补偿</p>
</li>
</ol>
</li>
</ol>
<h4 id="高可用-接口级故障"><a href="#高可用-接口级故障" class="headerlink" title="高可用-接口级故障"></a>高可用-接口级故障</h4><p>系统并没有宕机，网络也没有中断，但业务却出现问题了。例如，业务响应缓慢、大量访问超时、大量访问出现异常（给用户弹出提示“无法连接数据库”），这类问题的主要原因在于系统压力太大、负载太高，导致无法快速处理业务请求，由此引发更多的后续问题。</p>
<p>例如：数据库慢查询将数据库的服务器资源耗尽，导致读写超时。</p>
<p>故障原因：</p>
<ol>
<li>程序bug</li>
<li>黑客攻击</li>
<li>促销、抢购人数超出预估10倍</li>
<li>第三方系统大量请求，第三方系统响应缓慢</li>
</ol>
<h5 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h5><p>实现：通过关闭非核心业务，优先保证核心业务。如：注册，修改用户信息</p>
<p>关闭方式：</p>
<ol>
<li><p>后门接口</p>
<p>缺点：多个服务器需要多次调用；需要做安全性校验</p>
</li>
<li><p>同一系统如nacos</p>
</li>
</ol>
<h5 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h5><p>问题：A服务调用B服务超时，导致A服务大量请求阻塞占用资源越来越多后，A服务也宕机</p>
<p>实现：在统一的如网关处，统计到B服务1分钟30%的请求超过1秒后，所有调用B服务的请求立马返回失败。提示10分钟后再尝试</p>
<p>用途：外部服务、第三方服务</p>
<p>先根据分析确定阈值，然后上线观察效果，再进行调优。</p>
<h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><ul>
<li><p>用途：更适合简单系统，如：网关系统、负载均衡系统、抢购系统</p>
</li>
<li><p>方式</p>
<ul>
<li><p>请求限流</p>
<ul>
<li>总量。如：直播间只允许100万人</li>
<li>时间量。如：每秒请求10万。</li>
</ul>
<p>分析后设定一个阈值，测试上线后，再观察调优。</p>
<p>缺点：</p>
<ol>
<li>未测试到的接口调用情况。</li>
<li>限流值不合理。限流6000，实际5000系统就扛不住了；或者限流6000，实际可以到1万</li>
</ol>
</li>
<li><p>资源限流</p>
<p>分析资源瓶颈，如连接数、文件句柄、线程数、请求队列、CPU、内存。如达到CPU70%时，后续请求都抛弃</p>
<p>分析后设定一个阈值，测试上线后，再观察调优</p>
</li>
</ul>
</li>
</ul>
<h5 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h5><p>排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间。</p>
<p>排队后如何返回客户端：</p>
<ol>
<li>轮询，2. Long polling，3. HTTP/2推送</li>
</ol>
<h4 id="可扩展架构模式基本思想和模式"><a href="#可扩展架构模式基本思想和模式" class="headerlink" title="可扩展架构模式基本思想和模式"></a>可扩展架构模式基本思想和模式</h4><p>思想：拆，将变化的部分单独放在一个地方。做到修改时不影响其他部分</p>
<p>模式：</p>
<ol>
<li>按流程拆。横拆。如：分层架构、TCP/IP四层模型</li>
<li>按功能拆。竖拆。如：登录微服务和注册微服务，规则引擎</li>
</ol>
<p>拆出来的部分，可以用设计模式、单独的服务</p>
<h4 id="可扩展架构模式-分层架构-amp-SOA架构"><a href="#可扩展架构模式-分层架构-amp-SOA架构" class="headerlink" title="可扩展架构模式-分层架构&amp;SOA架构"></a>可扩展架构模式-分层架构&amp;SOA架构</h4><h5 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h5><p>介绍：两两调用，隔离解耦。</p>
<p>分层方法：完全穷尽，互不相同</p>
<p>示例：</p>
<ol>
<li>C/S架构。B/S架构将客户端和服务端隔离。</li>
<li>操作系统文件接口单独一层隔离，屏蔽不同文件的差异。上层功能调用统一的VFS文件接口。VFS适配下层不同的文件接口。效果：新接入文件系统时，上层功能不需要修改</li>
</ol>
<p>优点：强制将分层依赖限定为两两依赖，降低了整体系统复杂度</p>
<p>缺点：</p>
<ol>
<li>冗余。简单的查询功能也需要层层实现一次。</li>
<li>性能。20世纪80年代是问题，现在不是了</li>
</ol>
<h5 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h5><p>介绍：为了解决多个相同功能不同协议已有系统与其他系统交互时的重复开发，是特定场景产生的架构。</p>
<p>实现：所有系统都通过总线系统ESB转换为统一协议后，再和其他系统交互</p>
<p>优点：已有大量不同协议系统要交互时，无法重新开发原有系统。</p>
<p>缺点：ESB容易成为系统卡点。</p>
<h4 id="可扩展架构-微服务"><a href="#可扩展架构-微服务" class="headerlink" title="可扩展架构-微服务"></a>可扩展架构-微服务</h4><p>SOA和微服务区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>微服务</th>
<th>SOA</th>
</tr>
</thead>
<tbody><tr>
<td>服务粒度</td>
<td>细</td>
<td>粗</td>
</tr>
<tr>
<td>服务通信</td>
<td>轻量级。http rest、RPC</td>
<td>重量级。由ESB统一路由、消息转换、消息传递</td>
</tr>
<tr>
<td>服务交付</td>
<td>理念是快速交付，相应的要求持续集成、持续部署、自动化测试等敏捷开发相关最佳实践。</td>
<td>无特殊要求，主要考虑兼容已有系统</td>
</tr>
<tr>
<td>应用场景</td>
<td>更适合快速、轻量级、基于Web的互联网系统，没有历史包袱的企业数据化</td>
<td>庞大、复杂、异构的企业级系统。系统已开发多年，无法完全推到重来或进行大规模的优化和重构。成本、相关影响太大</td>
</tr>
</tbody></table>
<p>微服务陷阱：</p>
<ol>
<li><p>部署成本</p>
<p>没有敏捷开发基础能力相关支撑，微服务数量一但变大（如：20个），部署成本呈指数上升。</p>
</li>
<li><p>系统复杂度</p>
<p>服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。</p>
</li>
<li><p>团队效率</p>
<p>如：团队人员规模是 5 ~ 6 个人，拆分出 30 多个微服务，每个人平均维护 5 个以上的微服务。一个简单的需求开发就需要涉及多个微服务，光是微服务之间的接口就有 6 ~ 7 个，无论是设计、开发、测试、部署，都需要工程师不停地在不同的服务间切换。</p>
</li>
<li><p>性能</p>
<p>调用链太长，性能下降。微服务之间都是通过 HTTP 或者 RPC 调用的，每次调用必须经过网络。一般线上的业务接口之间的调用，平均响应时间大约为 50 毫秒</p>
</li>
<li><p>问题定位困难</p>
<p>一次用户请求需要多个微服务协同处理，任意微服务的故障都将导致整个业务失败。然而由于微服务数量较多，且故障存在扩散现象，快速定位到底是哪个微服务故障是一件复杂的事情。</p>
</li>
<li><p>无法快速交付</p>
<p>如果没有相应的自动化系统进行支撑，都是靠人工去操作，那么微服务不但达不到快速交付的目的，甚至还不如一个大而全的系统效率高。自动化测试、自动化部署、自动化监控()、服务治理(nacos、gateway、sentinel)</p>
</li>
</ol>
<h4 id="可扩展架构-微服务-实践方法"><a href="#可扩展架构-微服务-实践方法" class="headerlink" title="可扩展架构-微服务-实践方法"></a>可扩展架构-微服务-实践方法</h4><p>微服务：小、轻，需要自动化基础设施。</p>
<h5 id="拆分方法"><a href="#拆分方法" class="headerlink" title="拆分方法"></a>拆分方法</h5><ol>
<li>按业务拆分</li>
<li>按人员拆分。每3个人可以拆一个微服务。6个人的团队，2个微服务。<ul>
<li>系统规模：3个人开一个系统，系统复杂度刚好达到每个人全面理解整个系统。</li>
<li>团队管理：3个人可以形成一个稳定的备份；1个人是单点，某些情况下很危险。</li>
<li>技术提升：3个人能够形成有效的讨论。少了想法不够，容易陷入思维盲区；多了人员没有认真参与。</li>
</ul>
</li>
<li>按可扩展拆分。稳定和变动</li>
<li>按可靠性拆分。可靠性要求高和低</li>
<li>按性能拆分</li>
</ol>
<h5 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h5><ol>
<li><p>服务发现、服务路由、服务容错：这是最基本的微服务基础设施。</p>
</li>
<li><p>接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。</p>
<p>接口框架：如约定http/rest 并且数据格式是json，数据封装是<code>Result&lt;T&gt;</code>，统一使用提供Jar包</p>
</li>
<li><p>自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。</p>
<p>自动化测试：如果每次更新都靠人工回归整个系统，则工作量大，效率低下，达不到“快速交付”的目的，因此必须通过自动化测试系统来完成绝大部分测试回归的工作。自动化测试涵盖的范围包括代码级的单元测试、单个系统级的集成测试、系统间的接口测试，理想情况是每类测试都自动化。如果因为团队规模和人力的原因无法全面覆盖，至少要做到接口测试自动化。</p>
</li>
<li><p>服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。</p>
</li>
</ol>
<p>3 和 4 两类基础设施，重要性会随着微服务节点数量增加而越来越重要，但在微服务节点数量较少的时候，可以通过人工的方式支撑。</p>
<h4 id="可扩展架构-微内核架构"><a href="#可扩展架构-微内核架构" class="headerlink" title="可扩展架构-微内核架构"></a>可扩展架构-微内核架构</h4><p>微内核架构（<code>Microkernel Architecture</code>），也被称为插件化架构（<code>Plug-in Architecture</code>），是一种面向功能进行拆分的可扩展性架构。如：Eclipse、Idea、Unix操作系统，保险公司的保险核算逻辑系统，不同保险品种可以将逻辑封装成插件。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231221103117067.png" alt="image-20231221103117067"></p>
<h5 id="设计关键点"><a href="#设计关键点" class="headerlink" title="设计关键点"></a>设计关键点</h5><ol>
<li>插件管理</li>
<li>插件连接</li>
<li>插件通信</li>
</ol>
<h5 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h5><p>如：drools，需要将规则封装成下面的页面供用户使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.xiaoruiit.knowledge.point.rule.drools.Person</span><br><span class="line">dialect  &quot;mvel&quot;</span><br><span class="line"></span><br><span class="line">rule &quot;age&quot;</span><br><span class="line">    when</span><br><span class="line">        $person : Person(age &gt; 18)</span><br><span class="line">    then</span><br><span class="line">        System.out.println(&quot;年龄大于18岁的人是：&quot; + $person.getName());</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231221103836731.png" alt="image-20231221103836731"></p>
<h3 id="架构重构"><a href="#架构重构" class="headerlink" title="架构重构"></a>架构重构</h3><h4 id="什么时候重构（重构背景）"><a href="#什么时候重构（重构背景）" class="headerlink" title="什么时候重构（重构背景）"></a>什么时候重构（重构背景）</h4><p>因为各种历史原因和历史问题没有及时处理，遗留下来逐渐积累，然后到了一个临界点，各种问题开始互相作用，集中爆发。</p>
<p>系统不断出现各种问题，轻微一点的如系统响应慢、数据错误、某些用户访问失败等，严重的可能是宕机、数据库瘫痪、数据丢失等，或者系统的开发效率很低。</p>
<h4 id="是否需要重构"><a href="#是否需要重构" class="headerlink" title="是否需要重构"></a>是否需要重构</h4><p>假设我们现在需要从 0 开始设计当前系统，新架构和老架构是否类似？如果差异不大，说明采取系统优化即可；如果差异很大，那可能就要进行系统重构了。</p>
<p>架构重构不能解决所有问题，架构师的首要任务是从一大堆纷繁复杂的问题中识别出真正要通过架构重构来解决的问题，集中力量快速解决。</p>
<h4 id="系统架构问题分析-重构架构的案例"><a href="#系统架构问题分析-重构架构的案例" class="headerlink" title="系统架构问题分析+重构架构的案例"></a>系统架构问题分析+重构架构的案例</h4><h5 id="不合理耦合"><a href="#不合理耦合" class="headerlink" title="不合理耦合"></a>不合理耦合</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231226164615535.png" alt="image-20231226164615535"></p>
<p>重构方案：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231226164656202.png" alt="image-20231226164656202"></p>
<h5 id="全局单点的可用性问题"><a href="#全局单点的可用性问题" class="headerlink" title="全局单点的可用性问题"></a>全局单点的可用性问题</h5><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231226164814515.png" alt="image-20231226164814515"></p>
<p>重构方案</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231226164837141.png" alt="image-20231226164837141"></p>
<p>重构后系统的可用性从 3 个 9 提升到 4 个 9，重构前最夸张的一个月有 4 次较大的线上故障，重构后虽然也经历了机房交换机宕机、运营商线路故障、机柜断电等问题，但对业务都没有什么大的影响。</p>
<h5 id="大系统问题"><a href="#大系统问题" class="headerlink" title="大系统问题"></a>大系统问题</h5><p>开发效率</p>
<p>系统可扩展性不足。</p>
<p>所有功能都在一个系统中，也可能导致一个功能出问题，整站不可用。</p>
<p>比如说某个功能把数据库拖慢了，整站所有业务跟着都慢了。</p>
<h5 id="多年复杂系统去O"><a href="#多年复杂系统去O" class="headerlink" title="多年复杂系统去O"></a>多年复杂系统去O</h5><p>一个运行18年的.net业务系统，业务一刻不能停止，大约2000张oracle表，大量的存储过程函数等实现的业务逻辑，现在要用java来重构，面临的问题就是好多大表都在Oracle中，想去o就涉及到很多表关联，做不到垂直拆分，业务耦合太紧。</p>
<ol>
<li><p>数据先不动，先拆分代码到多个子系统，然后再拆分数据。</p>
<p>优点：风险小</p>
<p>缺点：周期长</p>
</li>
<li><p>重写一套新的，然后做数据割接</p>
<p>优点：周期短</p>
<p>缺点：风险大</p>
</li>
</ol>
<h4 id="重构步骤"><a href="#重构步骤" class="headerlink" title="重构步骤"></a>重构步骤</h4><ol>
<li><p>收集问题</p>
</li>
<li><p>重构需要处理的问题</p>
<ol>
<li>分析架构重构可以解决的核心问题</li>
<li>处理核心问题需要的前置条件</li>
</ol>
</li>
<li><p>区分优先级，问题分类，划分难易程度，最多半年一个周期</p>
</li>
<li><p>相关方游说（shui4)(沟通协调)</p>
</li>
</ol>
<h4 id="重构步骤案例"><a href="#重构步骤案例" class="headerlink" title="重构步骤案例"></a>重构步骤案例</h4><h5 id="大系统"><a href="#大系统" class="headerlink" title="大系统"></a>大系统</h5><ol>
<li><p>收集系统目前存在的问题</p>
<p>可用性、性能、安全、用户体验。每个细分十几二十个子项。</p>
</li>
<li><p>重构需要处理的问题</p>
<ol>
<li>庞大的系统继承了太多功能，可扩展性不足</li>
<li>系统可用性不高，经常出线上问题，需要耗费大量人力处理</li>
<li>重构需要系统处于一个比较稳定的状态，线上问题不频繁。<ol>
<li>部分服务硬件资源不够用</li>
<li>系统组件使用不合理</li>
<li>架构上的问题</li>
</ol>
</li>
</ol>
</li>
<li><p>优先级、问题分类、难易划分、时间周期、效果衡量后的总策略</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240115115114726.png" alt="image-20240115115114726"></p>
</li>
</ol>
<h4 id="重构难点"><a href="#重构难点" class="headerlink" title="重构难点"></a>重构难点</h4><ol>
<li>业务不能停，一边在开发新需求，一边完成架构调整</li>
<li>关联方多，难以统一行动</li>
<li>旧架构的约束</li>
<li>大重构需要老板拍板</li>
</ol>
<p>架构重构对架构师的综合能力要求非常高，业务上要求架构师能够说服产品经理暂缓甚至暂停业务来进行架构重构；团队上需要架构师能够与其他团队达成一致的架构重构计划和步骤；技术上需要架构师给出让技术团队认可的架构重构方案。架构重构需要架构师既要说得动老板，也要镇得住同事；既要技术攻关，又要协调资源；既要保证业务正常发展，又要在指定时间内完成目标。</p>
<h4 id="沟通协调"><a href="#沟通协调" class="headerlink" title="沟通协调"></a>沟通协调</h4><p>人员：产品经理、项目经理、运营人员、开发人员。</p>
<p>跨领域沟通需要用通用语言；沟通需要用数据。</p>
<p>沟通如：</p>
<ol>
<li>可扩展性”转换为“版本开发速度很慢，每次设计都要考虑是否对门户有影响，是否要考虑对其他业务有影响”，然后我们还收集了 1 个月里的版本情况，发现有几个版本设计阶段讨论 1 周甚至 2 周时间，但开发只有 2 天时间；而且一个月才做了 4 个版本，最极端的一个版本讨论 2 周，开发 2 天，然后等了 1 个月才和门户系统一起上线。</li>
<li>可用性是几个 9转换为整理线上故障的次数、每次影响的时长，影响的用户，客服的反馈意见等，然后再拿其他系统的数据进行对比</li>
</ol>
<p>协调阻力：这对我有什么好处，这部分我这边不着急</p>
<ol>
<li>分析出对其他团队的好处</li>
<li>公司或者部门有利，对某个小组不利的情况。协调更高层级的管理者推动</li>
<li>有其他更重要的业务。<ol>
<li>等待策略，但要明确正式启动的时间。</li>
<li>先不做这个系统相关的重构。</li>
</ol>
</li>
</ol>
<h4 id="错误重构"><a href="#错误重构" class="headerlink" title="错误重构"></a>错误重构</h4><ol>
<li><p>多模块聚合</p>
<p>问题：版本开发和测试部署一样比较麻烦</p>
<p>正确做法：应该将公共功能独立为服务。</p>
</li>
<li><p>没有区分问题的优先级，所有问题一视同仁，没有集中有限资源去解决最重要或者关键的问题。</p>
<p>问题：做了大半年，好像做了很多事情，但没取得什么阶段性的成果。如同一直做业务完善的小需求和支撑新业务的大需求的区别</p>
</li>
<li><p>没有将问题分类</p>
<p>问题：方案重复，浪费人力，效率低</p>
</li>
<li><p>迫于业务版本压力，挑容易做的实施</p>
<p>问题：达不到重构目的。重构分析差不多白做了</p>
</li>
</ol>
<h3 id="业务发展中的技术演进"><a href="#业务发展中的技术演进" class="headerlink" title="业务发展中的技术演进"></a>业务发展中的技术演进</h3><h4 id="架构实战-架构演进方向"><a href="#架构实战-架构演进方向" class="headerlink" title="架构实战-架构演进方向"></a>架构实战-架构演进方向</h4><h5 id="技术和业务"><a href="#技术和业务" class="headerlink" title="技术和业务"></a>技术和业务</h5><p>产品类业务，服务类业务</p>
<p>创新技术能带来新的业务时，这一刻是技术驱动业务的。如：iPhone智能机、淘宝线上购物</p>
<p>技术是由业务驱动的。</p>
<h5 id="架构演进方向"><a href="#架构演进方向" class="headerlink" title="架构演进方向"></a>架构演进方向</h5><p>企业业务发展面对的复杂度就是架构演进的方向。</p>
<p>淘宝是100分。小公司从20分开始演进，大公司可以从60分开始演进。</p>
<p>按照企业当前的业务发展阶段衡量当前复杂度，逐步推演，设计合适的架构。<br>如果有对手系统可以参考，企业自身业务能够达到一个高度，老板给时间，就预见性的设计，为后续升级留出通路。</p>
<p>业务的不断创新和改进，对技术会提出越来越高的要求，因此是业务驱动了技术发展。</p>
<h4 id="架构实战-互联网业务发展过程中的技术演进"><a href="#架构实战-互联网业务发展过程中的技术演进" class="headerlink" title="架构实战-互联网业务发展过程中的技术演进"></a>架构实战-互联网业务发展过程中的技术演进</h4><h5 id="业务复杂性"><a href="#业务复杂性" class="headerlink" title="业务复杂性"></a>业务复杂性</h5><table>
<thead>
<tr>
<th></th>
<th>业务标志</th>
<th></th>
<th></th>
<th>技术要求</th>
</tr>
</thead>
<tbody><tr>
<td>初创期</td>
<td>创新的业务点</td>
<td>能买则买，能用开源就用开源</td>
<td></td>
<td>对技术就一个要求：“快”</td>
</tr>
<tr>
<td>发展期</td>
<td>业务推出后经过市场验证可行，业务就进入快速发展的时期。</td>
<td>1. 堆功能期；</td>
<td></td>
<td>团队规模不大，业务需求很紧</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2.优化期（换磁盘，增加机器，代码优化，增加缓存）；</td>
<td>优点：对系统改动较小，优化可以比较快速地实施；缺点：过不了多久，系统又撑不住了。</td>
<td>保证当下的竞争力是最主要的问题</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.架构期（开发速度慢，无法忍受了）。拆功能、拆数据库、拆服务器</td>
<td>优点：一次调整可以支撑比较长期的业务发展；缺点：动作较大、耗时较长，对业务的发展影响比较大。</td>
<td></td>
</tr>
<tr>
<td>竞争期</td>
<td>竞争对手开始加入行业来竞争. 内部问题：1.重复造轮子 2.系统交互一团乱麻</td>
<td>解决：1.平台化（存储平台化，淘宝的TFS；数据库平台化，百度的DBProxy)。2.服务化（消息队列，RocketMQ，开源Kafka;服务框架，Facebook的thrift）</td>
<td></td>
<td>由于竞争的压力，对技术的要求更上一层楼</td>
</tr>
<tr>
<td>成熟期</td>
<td>行业的领头羊。业务创新的机会已经不大，竞争压力也没有那么激烈，此时求快求新已经没有很大空间，业务上开始转向为“求精”。响应时间是否比竞争对手快？我们的用户体验是否比竞争对手好？我们的成本是否比竞争对手低</td>
<td>技术上能做的大动作其实也不多了，更多的是进行优化。这个时候的技术优化没有固定的套路，只能按照竞争的要求，找出自己的弱项，然后逐项优化。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="用户规模"><a href="#用户规模" class="headerlink" title="用户规模"></a>用户规模</h5><p>性能、可用性</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231221145041172.png" alt="image-20231221145041172"></p>
<h4 id="架构实战-互联网架构图模板"><a href="#架构实战-互联网架构图模板" class="headerlink" title="架构实战-互联网架构图模板"></a>架构实战-互联网架构图模板</h4><p>存储层，开发层，服务层，网络层，用户层，业务层；平台层</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231221174906031.png" alt="image-20231221174906031"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>存储层</td>
<td>数据库，集群，封装集群后提供服务</td>
<td></td>
</tr>
<tr>
<td>开发层</td>
<td>成熟框架，Web服务器（如：tomcat)，容器（K8s，Docker)</td>
<td></td>
</tr>
<tr>
<td>服务层</td>
<td>服务治理(配置中心、服务注册、消息队列等)</td>
<td></td>
</tr>
<tr>
<td>网络层</td>
<td>负载均衡、CDN、多机房</td>
<td></td>
</tr>
<tr>
<td>用户层</td>
<td>单点登录CAS，授权登录Oauth2，存储云，图片云</td>
<td></td>
</tr>
<tr>
<td>业务层</td>
<td>拆；合（服务太多，多个服务合并为一个域，通过网关对外提供服务）；DDD</td>
<td></td>
</tr>
<tr>
<td>平台层</td>
<td>运维平台、测试平台、数据平台、管理平台</td>
<td></td>
</tr>
</tbody></table>
<h4 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h4><ul>
<li><p>运维平台</p>
<ul>
<li><p>职责：</p>
<ul>
<li><p>配置</p>
<p>主要负责资源的管理。例如，机器管理、IP 地址管理、虚拟机管理等。</p>
</li>
<li><p>部署</p>
<p>要负责将系统发布到线上。例如，包管理、灰度发布管理、回滚等。</p>
</li>
<li><p>监控</p>
<p>主要负责收集系统上线运行后的相关数据并进行监控，以便及时发现问题。</p>
</li>
<li><p>应急</p>
<p>主要负责系统出故障后的处理。例如，停止程序、下线故障机器、切换 IP 等。</p>
</li>
</ul>
</li>
<li><p>要求：</p>
<ul>
<li><p>标准化</p>
<p>规范配置管理、部署流程、监控指标、应急能力等</p>
</li>
<li><p>平台化</p>
</li>
<li><p>自动化</p>
</li>
<li><p>可视化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>测试平台</p>
<ul>
<li><p>用例管理</p>
<p>单元测试：代码</p>
<p>接口测试：python</p>
<p>可靠性测试：shell</p>
<p>测试平台需要将用例管理起来，管理的维度包括业务、系统、测试类型、用例代码。例如，网购业务的订单系统的接口测试用例。</p>
</li>
<li><p>资源管理</p>
</li>
<li><p>任务管理。任务管理是测试平台设计的核心，它将测试平台的各个部分串联起来从而完成自动化测试。</p>
</li>
<li><p>数据管理</p>
<p>测试任务执行完成后，需要记录各种相关的数据（例如，执行时间、执行结果、用例执行期间的 CPU、内存占用情况等）</p>
</li>
</ul>
</li>
<li><p>数据平台</p>
<ul>
<li><p>数据管理</p>
<ul>
<li><p>数据采集</p>
<p>从业务系统搜集各类数据。例如，日志、用户行为、业务数据等</p>
</li>
<li><p>数据存储</p>
</li>
<li><p>数据访问</p>
</li>
<li><p>数据安全</p>
<p>数据平台都是多个业务共享的，部分业务敏感数据需要加以保护</p>
</li>
</ul>
</li>
<li><p>数据分析</p>
<ul>
<li><p>数据统计</p>
<p>根据原始数据统计出相关的总览数据。例如，PV、UV、交易额等</p>
</li>
<li><p>数据挖掘</p>
<p>经典的数据挖掘案例就是沃尔玛的啤酒与尿布的关联关系的发现。</p>
</li>
<li><p>机器学习、深度学习</p>
</li>
</ul>
</li>
<li><p>数据应用</p>
<p>例如，推荐、广告等属于在线应用，报表、欺诈检测、异常检测等属于离线应用。</p>
</li>
</ul>
</li>
<li><p>管理平台</p>
<p>身份认证、权限控制</p>
</li>
</ul>
<h3 id="如何选择开源项目做二次开发"><a href="#如何选择开源项目做二次开发" class="headerlink" title="如何选择开源项目做二次开发"></a>如何选择开源项目做二次开发</h3><h4 id="为什么选开源项目"><a href="#为什么选开源项目" class="headerlink" title="为什么选开源项目"></a>为什么选开源项目</h4><p>避免重复造轮子，提升效率</p>
<h4 id="开源项目的问题"><a href="#开源项目的问题" class="headerlink" title="开源项目的问题"></a>开源项目的问题</h4><ol>
<li><p>开源项目的质量是未知的。</p>
<p>任何程序员写的项目都有bug。bug轻则造成半小时宕机，严重可能丢失部分数据，甚至丢失全部数据</p>
</li>
</ol>
<h4 id="如何选择开源项目"><a href="#如何选择开源项目" class="headerlink" title="如何选择开源项目"></a>如何选择开源项目</h4><ol>
<li><p>是否满足业务需求</p>
<p>已有框架满足业务需求时，没必要引入新开源项目</p>
<ol>
<li>功能</li>
<li>性能</li>
</ol>
</li>
<li><p>成熟度</p>
<ol>
<li>使用的公司</li>
<li>社区活跃度<ol>
<li>发帖数</li>
<li>回复数</li>
<li>问题响应速度</li>
</ol>
</li>
<li>版本号，尽量不选0.X的，至少1.X版本</li>
</ol>
</li>
<li><p>是否有运维工具</p>
<ol>
<li>日志是否齐全。只有启动、停止几行的不好</li>
<li>运行时查看。如命令行、管理控制台查看系统运行时情况</li>
<li>故障检测和恢复能力。如：告警</li>
</ol>
</li>
</ol>
<h4 id="如何使用开源项目"><a href="#如何使用开源项目" class="headerlink" title="如何使用开源项目"></a>如何使用开源项目</h4><ol>
<li><p>深入研究</p>
<p>通过设计文档、白皮书了解设计原理；核对每个配置项的作用和影响，识别出关键配置项</p>
</li>
<li><p>仔细测试</p>
<p>多场景测试。</p>
<p>压力测试：连续跑几天，观察CPU、内存、磁盘I/O指标波动</p>
<p>故障测试：kill、断电、拔网线、重启100次以上</p>
</li>
<li><p>灰度发布</p>
<p>先在非核心业务上线</p>
</li>
<li><p>做好应急</p>
<p>做好数据备份</p>
</li>
</ol>
<h4 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h4><ol>
<li><p>扩展而不修改</p>
<p>增加一个 proxy 层来实现需要的新功能</p>
<p>开发辅助系统：监控、报警、负载均衡、管理等</p>
<p>不着急的时候给开源项目提需求或者bug</p>
</li>
<li><p>造轮子</p>
<p>对于细分需求没有已有轮子时，自己造轮子。</p>
</li>
</ol>
<h2 id="5架构设计案例"><a href="#5架构设计案例" class="headerlink" title="5架构设计案例"></a>5架构设计案例</h2><h3 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h3><ol>
<li>2003年4月7日，为了快。买php+mysql，1个月后5月10日上线。</li>
<li>2003年底，mysql扛不住，换成了Oracle</li>
<li>PHP开源数据库连接池导致Oracle经常死锁，无法解决。请Sun公司专家热切换为Java1.0，使用EJB，Oracle。Java当时是很多主流网站使用的语言</li>
<li>性能优化,节约成本。Java2.0，数据分库，切换为Spring，缓存、CDN，开源的JBoss。2005年，商品数量1600多万，PV8931万，会员1390万。已经不是靠“买”就能够解决问题了，此时必须从整个架构上去进行调整和优化。</li>
<li>Java3.0，去IOE化，技术从商用转向自研。去IBM服务器，去Oracle数据库软件，去EMC存储设备</li>
</ol>
<h3 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h3><ol>
<li><p>十万级用户</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231129095424645.png" alt="image-20231129095424645"></p>
</li>
<li><p>百万级用户</p>
<p>内存瓶颈，2GB只能支撑1百万用户的在线状态。</p>
<p>CPU/网卡包量/交换机流量瓶颈</p>
<p>单台服务支撑不下所有在线用户</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231129095433482.png" alt="image-20231129095433482"></p>
</li>
<li><p>千万级用户</p>
<ul>
<li><p>状态服务器同步状态遇到单机瓶颈</p>
</li>
<li><p>单台状态同步服务器支撑不下所有在线用户。</p>
</li>
</ul>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20231129095445189.png" alt="image-20231129095445189"></p>
</li>
<li><p>亿级用户</p>
<p>2010年3月重新设计。</p>
<ul>
<li>灵活性很差，比如“昵称”长度增加一半，需要两个月；增加“故乡”字段，需要两个月；最大好友数从 500 变成 1000，需要三个月。</li>
<li>无法支撑某些关键功能，比如好友数上万、隐私权限控制、PC QQ 与手机 QQ 不可互踢、微信与 QQ 互通、异地容灾。</li>
<li>1.0-3.5都是原来基础上做改造升级，补丁打不动了</li>
</ul>
</li>
</ol>
<h3 id="微信红包架构"><a href="#微信红包架构" class="headerlink" title="微信红包架构"></a>微信红包架构</h3><p><a href="https://www.infoq.cn/article/2017hongbao-weixin/">https://www.infoq.cn/article/2017hongbao-weixin/</a>  资金安全系统解决方案</p>
<p>2017 年 1 月 28 日，正月初一，用户在除夕当天收发微信红包的数量——142 亿个，收发峰值76 万每秒。</p>
<p>类似业务秒杀：</p>
<ol>
<li>发红包相当于秒杀活动的商品上架</li>
<li>抢红包相当于秒杀活动的查询库存</li>
<li>拆红包相当于下单</li>
</ol>
<p>业务特点：</p>
<ol>
<li><p>并发量比普通秒杀业务更高。</p>
<p>10万人同时发红包，10万个微信群同时抢红包</p>
</li>
<li><p>安全性要求更高</p>
<p>秒杀允许超卖和少卖。拆红包严格不允许超发金额，未发的24小时后金额准确退回</p>
</li>
</ol>
<p>技术难点：</p>
<ol>
<li>并发请求锁</li>
<li>事务操作量级大</li>
<li>事务性要求严格</li>
</ol>
<p>常用高并发方案：</p>
<ol>
<li><p>内存操作代替DB操作，异步持久化。</p>
<p>优点：磁盘操作转为内存操作</p>
<p>缺点：持久化不能保证</p>
</li>
<li><p>乐观锁代替悲观锁</p>
<p>优点：</p>
<p>缺点：</p>
<ol>
<li>增加资源消耗。并发量大时，产生大量无效请求</li>
<li>用户体验低，抢红包不可接受。并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错。</li>
<li>可能手慢后抢成功，用户体验不好。</li>
</ol>
</li>
</ol>
<p>主要技术点：</p>
<ol>
<li><p>根据红包ID做set分化，分而治之。全国抢一个红包会被分为10000个红包</p>
<p>相同红包ID hash后，发送同同一组服务器、数据库中。解决了海量事务级操作。</p>
</li>
<li><p>请求FIFO队列</p>
<p>服务器增加队列请求排队，写事务串行化访问DB；同一个红包ID路由到同一台机器</p>
<p>增加memacache控制并发，用cas自增统计抢同一红包人数，超过一定值后降级，返回抢红包失败。</p>
</li>
<li><p>数据库双维度分库分表</p>
<p>分库表规则像 db_xx.t_y_dd 设计，其中，xx/y 是红包 ID 的 hash 值后三位，dd 的取值范围在 01~31，代表一个月天数最多 31 天。</p>
</li>
</ol>
<p>结果：</p>
<ol>
<li>单库提升8倍性能。</li>
<li>2017每秒76万并发</li>
<li>2015、2016、2017无故障</li>
</ol>
<h3 id="移动端架构演进"><a href="#移动端架构演进" class="headerlink" title="移动端架构演进"></a>移动端架构演进</h3><ol>
<li><p>2010年前后，受限于设备、网络速度，PC互联网是主流。移动端一开始在Web业务上包装一个APP的壳，即WebApp。</p>
</li>
<li><p>2013年前后用户体验差据越来越大，原生APP（Android、IOS、windows Phone）成为主流。</p>
<p>用户体验差距：</p>
<ol>
<li>移动设备的发展速度远远超过 Web 技术的发展速度</li>
<li>App 承载的业务逻辑越来越复杂</li>
<li>移动设备在用户体验方面有很多优化和改进，而 Web App 无法利用这些技术优势</li>
</ol>
</li>
<li><p>在移动互联网更具竞争力又开始需要开发速度，出现Hybrid App</p>
</li>
<li><p>组件化、容器化</p>
</li>
<li><p>WebApp</p>
<p>原理：基于 web 技术（HTML、CSS、JavaScript）开发的应用。</p>
<p>优点：开发快，跨平台，成本低</p>
<p>缺点：体验差</p>
</li>
<li><p>原生App</p>
<p>原理：使用特定平台（如iOS、Android）的原生编程语言</p>
<p>优点：体验好</p>
<p>缺点：开发慢，不同平台需要重复开发</p>
</li>
<li><p>Hybrid App</p>
<p>原理：使用 web 技术（HTML、CSS、JavaScript）开发应用的一部分，并使用桥接技术将其集成到原生应用中。</p>
<p>优点：可以在体验和开发速度上均衡</p>
<p>缺点：开发速度WebApp慢，体验比原生APP差</p>
</li>
</ol>
<h2 id="开源项目的学习"><a href="#开源项目的学习" class="headerlink" title="开源项目的学习"></a>开源项目的学习</h2><p>1,2,3步骤，在研究开源项目的时候必不可少。</p>
<ol>
<li><p>安装</p>
<ul>
<li><p>获取依赖组件</p>
<p>依赖组件是系统设计和实现的基础。nginx依赖的库有pcre、pcre-devel、openssl、openssl-devel、zlib；openssl与https有关，zlib与压缩有关。</p>
</li>
<li><p>安装后的目录</p>
<p>conf会存放配置文件，logs会存放日志，sbin存放运行程序；</p>
<p>redis的redis-benchmark、redis-check-aof，这些工具在后面故障定位和处理、性能测试等场景可能非常方便。</p>
</li>
</ul>
</li>
<li><p>运行</p>
<p>通过命令行和配置文件了解系统具备的能力和如何运行。</p>
<p>了解配置项的原理、作用、影响，并且尝试去修改配置项然后看看系统会有什么变化。</p>
<p>每个命令行参数和配置项的作用和原理都全部掌握清楚时，对系统已经很熟悉了。</p>
</li>
<li><p>原理研究</p>
<p>研究命令行和配置项的时候已经涉及一部分原理。</p>
<p>接下来针对原理进行系统性的研究。</p>
<ul>
<li><p>关键特性实现原理</p>
<p>白皮书，设计文档；为了学习只需要看设计相关的；</p>
<p>网上已有的分析文档，可以站在前人的基础上，避免大量的重复投入；但需要多篇文章做对比；</p>
<p>Demo验证；</p>
</li>
<li><p>优缺点分析</p>
<p>掌握了技术方案的优缺点后才能在架构设计的时候做出合理的选择。</p>
<p>将两个类似的系统进行对比，实现差异，以及不同的实现优缺点都是什么；</p>
</li>
</ul>
</li>
<li><p>测试</p>
<p>需要在掌握参数配置，关键原理之后进行测试。</p>
<p>根据业务特点，掌握的原理，编写测试用例。</p>
<p>可以在准备在生产项目中使用时，再进行测试。</p>
</li>
<li><p>源码研究</p>
<p>带着明确目的去研究源码。学习关键特性的代码实现。</p>
<p>写demo，调试查看调用栈理解基础库的处理逻辑和过程，这比单纯看代码去理解逻辑要高效一些。</p>
<p>可以在有时间精力时再做。</p>
</li>
</ol>
<h2 id="架构师内功"><a href="#架构师内功" class="headerlink" title="架构师内功"></a>架构师内功</h2><p>内功内容：</p>
<ol>
<li><p>找出问题</p>
<p>项目架构上指的是找出复杂度在哪</p>
</li>
<li><p>解决问题</p>
<p>第一种：作出合适的方案解决已有复杂度问题</p>
<p>第二种：作出创新的方案解决复杂度</p>
</li>
</ol>
<p>内功来源：</p>
<ol>
<li><p>经历</p>
<p>设计过的系统越多、系统越复杂，架构师的内功也就越强，不管是成功的架构，还是失败的架构，不管是踩坑的经验，还是填坑的经验，都将成为架构师内功的一部分。</p>
</li>
<li><p>技能</p>
<p>掌握的技能越多，技能越深，内功越强。</p>
</li>
<li><p>思考</p>
<p>经历需要经过思考转化为经验。技能需要思考后为我所用。</p>
<p>将经历和技能中的模式、判断、选择、技巧等提炼出来为我所用。</p>
</li>
</ol>
<h2 id="架构师岗位成长"><a href="#架构师岗位成长" class="headerlink" title="架构师岗位成长"></a>架构师岗位成长</h2><p>不同阶段有不同的针对性方法</p>
<ol>
<li><p>工程师</p>
<ul>
<li><p>特征：基础技能积累</p>
</li>
<li><p>技能经验</p>
<ul>
<li><p>Java语法</p>
</li>
<li><p>开发工具</p>
</li>
<li><p>数据库CRUD、缓存使用</p>
</li>
<li><p>业务系统基本流程</p>
</li>
</ul>
</li>
<li><p>学习方法：书籍</p>
</li>
<li><p>学习内容：经典书籍，《Java编程思想》、《Java核心技术》、《TCP/IP协议》</p>
</li>
</ul>
</li>
<li><p>高级工程师</p>
<ul>
<li>时间：2-5年</li>
<li>特征：已有架构下独立完成开发</li>
<li>技能经验<ul>
<li>设计理论：数据库表设计3范式、面对对象设计模式、SOLID设计原则、缓存设计理论</li>
<li>技术原理：如：Java数据结构实现原理</li>
<li>需求分析，设计方案（表设计，2个表还是3个表），编码实现</li>
<li>积累表、缓存、业务流程、接口设计经验。根据设计理论、技术原理设计</li>
</ul>
</li>
<li>学习方法：书籍、源码</li>
<li>学习内容：《深入理解Java虚拟机》、《MySQL技术内幕：InnoDB存储引擎》、HashMap源码</li>
</ul>
</li>
<li><p>技术专家</p>
<ul>
<li>时间：4-8年</li>
<li>特征：某个领域的专家，根据需要修改、扩展、优化架构。如Java开发专家、前端开发专家；高级工程师关注优化MySQL性能，技术专家会考虑引入ES</li>
<li><h2 id="技能经验"><a href="#技能经验" class="headerlink" title="技能经验"></a>技能经验</h2></li>
<li>学习方法</li>
<li>学习内容</li>
</ul>
<p>领域内</p>
</li>
<li><p>初级架构师</p>
<p>分系统架构、简单系统架构</p>
</li>
<li><p>中级架构师</p>
<p>大型分布式系统架构，架构可以支撑100人团队干活</p>
</li>
<li><p>高级架构师</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="复杂度与解决整理"><a href="#复杂度与解决整理" class="headerlink" title="复杂度与解决整理"></a>复杂度与解决整理</h3><p>性能-写请求扛不住：</p>
<ol>
<li>分库分表，读扛不住读写分离+缓存就够了。</li>
<li>瞬时流量：分区顺序MQ，异步通知结果</li>
</ol>
<p>扩展性-解耦：</p>
<ol>
<li>微服务</li>
<li>消息队列</li>
<li>DDD</li>
</ol>
<p>可扩展：</p>
<ol>
<li>微服务</li>
<li>分层</li>
<li>消息队列</li>
<li>设计模式-策略模式、观察者模式等</li>
<li>规则引擎</li>
<li>工作流引擎</li>
</ol>
<p>日志占了百分之二十的cpu：</p>
<ol>
<li>日志压缩，采样，隔离</li>
</ol>
<h3 id="架构升级"><a href="#架构升级" class="headerlink" title="架构升级"></a>架构升级</h3><p>单机→集群:对单机进行性能测试，获得单机性能的极限数据，当业务实际性能达到极限的80%时，开始考虑扩容。</p>
<h3 id="常见性能"><a href="#常见性能" class="headerlink" title="常见性能"></a>常见性能</h3><ul>
<li>nginx：3万</li>
<li>kafaka:百万</li>
<li>redis：10万</li>
<li>http：2万</li>
<li>zookeeper：写入读取2万以上</li>
<li>业务系统：有的会是500</li>
</ul>
<p>画好架构图的方法：4+1视图</p>
<p>架构师需要五项全能：技术，沟通，推动，管理，撕逼</p>
<p>一分析二讨论三开会四汇报五审批</p>
<h3 id="数据聚合位置"><a href="#数据聚合位置" class="headerlink" title="数据聚合位置"></a>数据聚合位置</h3><p>首页有多个资源聚合，是应该app端去请求多个资源服务，然后聚合出来展示；还是有个后台服务去聚合后端的各个基础服务，然后只提供一个接口给app访问？</p>
<p>访问量大的，核心业务用服务器聚合，性能好；<br>访问量小的，非核心业务用app聚合，可扩展性好；</p>
<h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><p>《伟大的计算原理》《人月神话》《淘宝技术这十年》</p>
<p>《UNIX编程艺术》</p>
<p>《异类》：个人成长</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>高性能</tag>
        <tag>高可用</tag>
        <tag>可扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-基础</title>
    <url>/2020/09/09/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/HTTP-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>HTTP-基础</p>
<span id="more"></span>

<h1 id="HTTP-基础"><a href="#HTTP-基础" class="headerlink" title="HTTP-基础"></a>HTTP-基础</h1><p><strong>参考：</strong><a href="https://www.w3.org/Protocols/">https://www.w3.org/Protocols/</a></p>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>规定了一种客户端与服务器端传输数据的方式。</p>
<ul>
<li><p>超文本传输协议</p>
</li>
<li><p>无状态</p>
</li>
<li><p>基于TCP/IP</p>
</li>
</ul>
<p>1.0有三种请求方法。1.1增加了5种。</p>
<h2 id="HTTP1-1内容"><a href="#HTTP1-1内容" class="headerlink" title="HTTP1.1内容"></a>HTTP1.1内容</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/FqlurVyMwJ17DCt.png" alt="image-20200907183947988"></p>
<h2 id="http请求request"><a href="#http请求request" class="headerlink" title="http请求request"></a>http请求request</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client request:</span><br><span class="line"></span><br><span class="line">     GET /hello.txt HTTP/1.1</span><br><span class="line">     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</span><br><span class="line">     Host: www.example.com</span><br><span class="line">     Accept-Language: en, mi</span><br></pre></td></tr></table></figure>

<p>方法名称 /虚拟目录/文件名 协议名称/协议版本</p>
<p>用户代理：操作系统类型、版本，CPU类型，浏览器类型、版本，浏览器渲染引擎、浏览器语言</p>
<h2 id="http响应response"><a href="#http响应response" class="headerlink" title="http响应response"></a>http响应response</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server response:</span><br><span class="line"></span><br><span class="line">     HTTP/1.1 200 OK</span><br><span class="line">     Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">     Server: Apache</span><br><span class="line">     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">     ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">     Accept-Ranges: bytes</span><br><span class="line">     Content-Length: 51</span><br><span class="line">     Vary: Accept-Encoding</span><br><span class="line">     Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<p>协议名称/版本 状态码</p>
<p>时间</p>
<p>服务器类型</p>
<p>最后修改时间</p>
<p>可用来查看访问资源是否改变</p>
<p>支持部分请求的标志</p>
<p>响应的字节长度</p>
<p>…</p>
<p>响应体类型</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<p><a href="http://blog.xiaoruiit.com/categories/git.html?id=1&amp;page=1#name">http://blog.xiaoruiit.com:80/categories/git.html?id=1&amp;page=1#name</a></p>
<ul>
<li>协议 http://</li>
<li>域名或IP地址 blog.xiaoruiit.com</li>
<li>端口 80</li>
<li>虚拟目录 categories</li>
<li>文件名 git.html</li>
<li>参数 id=1&amp;page=1</li>
<li>锚 #name</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>2×× 成功</p>
<p>4×× 客户端找不到服务器</p>
<p>5×× 服务器端异常</p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>GET 查</p>
<p>POST 增</p>
<p>PUT 改</p>
<p>DELETE 删</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>客户端连接到Web服务器</li>
<li>发送http请求</li>
<li>服务器接收请求并响应</li>
<li>释放连接</li>
<li>客户端解析响应的html内容</li>
</ol>
]]></content>
      <categories>
        <category>编程基础</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续正数序列-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>和为s的连续正数序列</p>
<span id="more"></span>

<h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面试题57：和为s的连续正数序列</span><br><span class="line">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FindContinuousSequence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int target = 28;</span><br><span class="line">        for (int[] arrs:findContinuousSequence(target)) &#123;</span><br><span class="line">            for (int arr:arrs) &#123;</span><br><span class="line">                System.out.print(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[][] findContinuousSequence(int target)&#123;</span><br><span class="line">        ArrayList&lt;int[]&gt; list = new ArrayList();</span><br><span class="line">        for (int i = 1; i &lt; target/2+2; i++) &#123;</span><br><span class="line">            int target2 = target;</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            //连续序列的开始为i</span><br><span class="line">            int end = 0;//连续序列的结束</span><br><span class="line">            for (int j = i; j &lt; target/2+2; j++) &#123;</span><br><span class="line">                target2 -= j;</span><br><span class="line">                if (target2 &lt; 0 )&#123;//不是连续序列</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (target2 == 0 )&#123;//是连续序列</span><br><span class="line">                    end = j;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                int[] a = new int[end - i+1];</span><br><span class="line">                int b = 0;</span><br><span class="line">                for (int j = i; j &lt; end+1; j++) &#123;</span><br><span class="line">                    a[b] = b+i;</span><br><span class="line">                    b++;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(a);//不知道二维数组长度，先放在list中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //从list取出数据转移到要求的二维数组中</span><br><span class="line">        int[][] aa = new int[list.size()][];</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            aa[i] = list.get(i);</span><br><span class="line">            //System.out.println(Arrays.toString((int[])list.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        return aa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test()&#123;</span><br><span class="line">        int target = 15;</span><br><span class="line">        for (int i = 1; i &lt; target/2 + 1; i++) &#123;</span><br><span class="line">            //i为连续序列开头</span><br><span class="line">            int b = 0;//连续序列结尾</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            for (int j = i + 1; j &lt; target/2 + 2; j++) &#123;</span><br><span class="line">                if ((i+j)*(j-i+1)/2 == target)&#123;</span><br><span class="line">                    b = j;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                System.out.println(i+&quot;-&quot;+b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串压缩-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>字符串压缩</p>
<span id="more"></span>

<h1 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a>字符串压缩</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面试题01.06 字符串压缩：利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</span><br><span class="line">示例1:</span><br><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">输出：&quot;a2b1c5a3&quot;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例2:</span><br><span class="line">输入：&quot;abbccd&quot;</span><br><span class="line">输出：&quot;abbccd&quot;</span><br><span class="line">解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CompressString &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aabcccccaaa&quot;;</span><br><span class="line">        System.out.println(compressString(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String compressString(String s) &#123;</span><br><span class="line">        if (s.length() &lt;= 2 || s == null)</span><br><span class="line">            return s;</span><br><span class="line">        char[] ch = s.toCharArray();</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder().append(ch[0]);</span><br><span class="line">        char a = ch[0];//旧字符标记</span><br><span class="line">        int num = 1;//数量标记</span><br><span class="line">        for (int i = 1; i &lt; ch.length; i++) &#123;</span><br><span class="line">            if (a == ch[i]) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //1.新串添加数量 2.新串添加新字符</span><br><span class="line">                stringBuilder.append(num).append(ch[i]);</span><br><span class="line">                //3.重置数量标记num</span><br><span class="line">                num = 1;</span><br><span class="line">                //4.重置旧字符标记a</span><br><span class="line">                a = ch[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == ch.length - 1) &#123;</span><br><span class="line">                stringBuilder.append(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.length() &lt;= stringBuilder.length() ? s : stringBuilder.toString();</span><br><span class="line">        //System.out.println(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的最大面积-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>岛屿的最大面积</p>
<span id="more"></span>

<h1 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">695岛屿的最大面积:</span><br><span class="line">给定一个包含了一些 0 和 1 的非空二维数组 grid 。</span><br><span class="line">一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</span><br><span class="line">找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> 结果：6</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MaxAreaOfIsland &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] grid =  &#123;&#123;0,0,1,0,0,0,0,1,0,0,0,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,1,1,1,0,0,0&#125;,</span><br><span class="line">                         &#123;0,1,1,0,1,0,0,0,0,0,0,0,0&#125;,</span><br><span class="line">                         &#123;0,1,0,0,1,1,0,0,1,0,1,0,0&#125;,</span><br><span class="line">                         &#123;0,1,0,0,1,1,0,0,1,1,1,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,0,0,0,1,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,1,1,1,0,0,0&#125;,</span><br><span class="line">                         &#123;0,0,0,0,0,0,0,1,1,0,0,0,0&#125;&#125;;</span><br><span class="line">        System.out.println(maxAreaOfIsland(grid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 每次调用的时候假设num为1，进入后判断不是岛屿，则直接返回0，就可以避免错误的情况。</span><br><span class="line">    // 每次找到岛屿，把找到的岛屿改成0，这是传说中的沉岛思想，就是遇到岛屿就把沉默。</span><br><span class="line">    public static int maxAreaOfIsland(int[][] grid)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                if (grid[i][j] == 1) &#123;</span><br><span class="line">                    res = Math.max(res,dfs(i, j, grid));//math.max选取岛屿中的最大值，不控制时，获得的岛屿值为最后岛屿值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //深度算法，递归实现</span><br><span class="line">    private static int dfs(int i, int j, int[][] grid) &#123;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[i].length || grid[i][j] == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = 0;//沉岛思想</span><br><span class="line">        int num = 1;//没进入if判断，则是岛屿</span><br><span class="line">        num += dfs(i + 1, j, grid);</span><br><span class="line">        num += dfs(i, j + 1, grid);</span><br><span class="line">        num += dfs(i - 1, j, grid);</span><br><span class="line">        num += dfs(i, j - 1, grid);</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>拼写单词-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>拼写单词</p>
<span id="more"></span>

<h1 id="拼写单词"><a href="#拼写单词" class="headerlink" title="拼写单词"></a>拼写单词</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1160.拼写单词</span><br><span class="line">给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</span><br><span class="line">假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</span><br><span class="line">注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</span><br><span class="line">返回词汇表 words 中你掌握的所有单词的 长度之和。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br><span class="line"></span><br><span class="line">@see https://leetcode-cn.com/problems</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GetChar2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] words = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;&#125;;</span><br><span class="line">        String chars = &quot;welldonehoneyr&quot;;</span><br><span class="line">        System.out.println(countCharacters(words,chars));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //1.统计字母表chars中26个字母个数</span><br><span class="line">    //2.统计词汇表中单个词汇words[i]中26个字母个数</span><br><span class="line">    //3.单个词汇中字母个数与字母表中字母个数比较</span><br><span class="line">    public static int countCharacters(String[] words, String chars) &#123;</span><br><span class="line">        //字母表26个字母的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int[] chars1 = new int[26];</span><br><span class="line">        for (char c : chars.toCharArray()) &#123;</span><br><span class="line">            chars1[c - &#x27;a&#x27;]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String str : words) &#123;</span><br><span class="line">            int[] chars2 = new int[26];</span><br><span class="line">            //每个单词26个字母的个数</span><br><span class="line">            for (char strch : str.toCharArray()) &#123;</span><br><span class="line">                chars2[strch - &#x27;a&#x27;]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //System.out.println(Arrays.toString(chars2));</span><br><span class="line">            boolean flag = true;</span><br><span class="line">            //比较单词和字母表的26个字母数量的大小</span><br><span class="line">            for (int i = 0; i &lt; chars2.length; i++) &#123;</span><br><span class="line">                if (chars2[i] &gt; chars1[i])&#123;</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)&#123;</span><br><span class="line">                sum += str.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文串-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>最长回文串</p>
<span id="more"></span>

<h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">407.最长回文串:给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class="line">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class="line">注意:</span><br><span class="line">假设字符串的长度不会超过 1010。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @see https://leetcode-cn.com/problems/</span><br><span class="line">public class LongestPalindrome &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abccccdd&quot;;</span><br><span class="line">        System.out.println(longestPalindrome(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int longestPalindrome(String s) &#123;</span><br><span class="line">        int[] count = new int[128];</span><br><span class="line">        //统计每个字符的数量</span><br><span class="line">        for (char c: s.toCharArray())</span><br><span class="line">            count[c]++;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int v: count) &#123;</span><br><span class="line">            ans += v / 2 * 2;// 字符出现次数&gt;1的字符可构成v/2*2</span><br><span class="line">            //当有字符出现奇数次时，可放在回文正中间</span><br><span class="line">            if (v % 2 == 1 &amp;&amp; ans % 2 == 0)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>矩形重叠-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<p>矩形重叠</p>
<span id="more"></span>

<h1 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a>矩形重叠</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">836矩形重叠：矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">给出两个矩形，判断它们是否重叠并返回结果。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例 1：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">        输出：true</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例 2：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">        输出：false</span><br><span class="line">&lt;p&gt;</span><br><span class="line">说明：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</span><br><span class="line">        矩形中的所有坐标都处于 -10^9 和 10^9 之间。</span><br><span class="line">&lt;p&gt;</span><br><span class="line"></span><br><span class="line">@see https://leetcode-cn.com/problems/rectangle-overlap</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IsRectangleOverlap &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] rec1 = &#123;0, 0, 2, 2&#125;;</span><br><span class="line">        int[] rec2 = &#123;1, 3, 4, 4&#125;;</span><br><span class="line">        System.out.println(isRectangleOverlap(rec1, rec2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isRectangleOverlap(int[] rec1, int[] rec2) &#123;</span><br><span class="line">        //不重叠的情况：rec1在rec2左侧，rec1在rec2右侧，rec1在rec2上侧，rec1在rec2下侧</span><br><span class="line">        //左侧：rec1的最右边小于等于rec2的最左边。rec1[2] ≤rec2[0]</span><br><span class="line">        //右侧：rec1的最左边大于等于rec2的最右边。rec1[0] &gt;= rec2[2]</span><br><span class="line">        //上侧：rec1的最下边大于等于rec2的最上边。rec1[1] &gt;= rec2[3])</span><br><span class="line">        //下侧：rec1的最上边小于等于rec2的最下边。rec1[3] &lt;= rec2[1]</span><br><span class="line">        return !(rec1[2] &lt;= rec2[0] ||   // left</span><br><span class="line">                rec1[0] &gt;= rec2[2] ||   // right</span><br><span class="line">                rec1[1] &gt;= rec2[3]||   // top</span><br><span class="line">                rec1[3] &lt;= rec2[1]);  // bottom</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表的中间结点-LeetCode</title>
    <url>/2019/05/19/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/LeetCode-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<p>链表的中间结点</p>
<span id="more"></span>

<h1 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">876.链表的中间结点</span><br><span class="line">给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">如果有两个中间结点，则返回第二个中间结点。</span><br><span class="line">&lt;p&gt;</span><br><span class="line">示例 1：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure>

<p><strong>Implementation</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MiddleNode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListNode head = new ListNode(1);</span><br><span class="line">        head.next = new ListNode(2);</span><br><span class="line">        head.next.next = new ListNode(3);</span><br><span class="line">        head.next.next.next = new ListNode(4);</span><br><span class="line">        System.out.println(middleNode(head).val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ListNode middleNode(ListNode head) &#123;</span><br><span class="line">        //快慢指针</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Definition for singly-linked list.</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程基础</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-入门</title>
    <url>/2020/11/12/211%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/TCP-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>TCP-入门</p>
<span id="more"></span>

<h1 id="TCP-入门"><a href="#TCP-入门" class="headerlink" title="TCP-入门"></a>TCP-入门</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<h2 id="TCP解决了什么"><a href="#TCP解决了什么" class="headerlink" title="TCP解决了什么"></a>TCP解决了什么</h2><p>为连接到<strong>不同但互连</strong>的计算机通信网络的主计算机中的成对<strong>进程</strong>  提供<strong>可靠</strong>的<strong>通信服务</strong>。</p>
<h2 id="TCP如何解决"><a href="#TCP如何解决" class="headerlink" title="TCP如何解决"></a>TCP如何解决</h2><ol>
<li>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流</li>
<li>TCP把数据流分区成适当长度的报文段</li>
<li>TCP把结果包编序号并传给IP层</li>
<li>IP层通过网络将包传送给接收端实体的TCP层。</li>
<li>接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（<a href="https://baike.baidu.com/item/RTT">RTT</a>）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。</li>
<li>接收端实体将包按照编号顺序组装起来。</li>
</ol>
<h2 id="TCP结构"><a href="#TCP结构" class="headerlink" title="TCP结构"></a>TCP结构</h2><h2 id="TCP常见知识点"><a href="#TCP常见知识点" class="headerlink" title="TCP常见知识点"></a>TCP常见知识点</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>建立连接的过程：</p>
<ol>
<li>客户端发送SYN报文给服务器端</li>
<li>服务器端接收到SYN，回应一个SYN</li>
<li>客户端接收到服务的SYN，回应一个ACK</li>
</ol>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/STC4Lkmyvq9Zj5o.png" alt="image-20201112150119410"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>断开连接的过程：</p>
<ol>
<li>客户端发送FIN</li>
<li>接收端发送ACK</li>
<li>接收端发送FIN</li>
<li>客户端发送ACK</li>
</ol>
<h3 id="与UDP异同"><a href="#与UDP异同" class="headerlink" title="与UDP异同"></a>与UDP异同</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。</p>
<p><strong>优点：</strong>传输过程中延迟小、数据传输效率高。</p>
<p><strong>缺点：</strong>没有可靠性保证、顺序保证和流量控制字段</p>
<h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><p>强调传输性能而不是传输的完整性。是分发信息的一个理想协议。例如，在屏幕上报告股票市场、显示航空信息等等。如果有一个消息丢失，在几秒之后另一个新的消息就会替换它。</p>
<ol>
<li>音频</li>
<li>多媒体应用</li>
<li>网络视频会议</li>
<li>聊天：QQ</li>
</ol>
]]></content>
      <categories>
        <category>编程基础</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Jwt了解</title>
    <url>/2020/08/12/213Java%E6%A1%86%E6%9E%B6/Jwt%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>Jwt了解</p>
<span id="more"></span>

<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>官网：<a href="https://jwt.io/introduction/">https://jwt.io/introduction/</a></p>
<p>参考：<a href="https://www.liqingbo.cn/docs/jwt/content/summary.html">https://www.liqingbo.cn/docs/jwt/content/summary.html</a></p>
<p>客户端与服务端之间验证的一种技术，取代了之前使用的Session</p>
<p><strong>Session存在的问题</strong>：</p>
<ul>
<li><p>Session不利于搭建服务器的集群（也就是必须访问原本的那个服务器才能获取对应的SessionId）</p>
</li>
<li><p>CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
</li>
</ul>
<h3 id="鉴权机制"><a href="#鉴权机制" class="headerlink" title="鉴权机制"></a>鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，不需要去考虑用户在哪一台服务器登录</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>用户使用用户名密码来请求服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附送上这个token值</li>
<li>服务端验证token值，并返回数据</li>
</ul>
<p>token必须要在每次请求时传递给服务端，它应该保存在请求头里。</p>
<p>服务端要支持<code>CORS(跨来源资源共享)</code>策略，后端设置<code>Access-Control-Allow-Origin: *</code></p>
<h3 id="JWT-structure（构成）"><a href="#JWT-structure（构成）" class="headerlink" title="JWT structure（构成）"></a>JWT structure（构成）</h3><p>header.payload.signature</p>
<p>xxxxx.yyyyy.zzzzz</p>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>存储两个变量</p>
<ol>
<li><p>token type，token类型一般是JWT</p>
</li>
<li><p>signing algorithm，签名算法，例如：HMAC SHA256 or RSA</p>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对其进行Base64Url 编码，生成header.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上例Base64Url编码后的内容</span><br><span class="line">ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9</span><br></pre></td></tr></table></figure>



<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>three parts:<em>registered</em>, <em>public</em>, and <em>private</em> claims.</p>
<ul>
<li>registered claims 标准中注册的声明 (非强制)<ul>
<li>iss:jwt签发者</li>
<li>exp:jwt的过期时间</li>
<li>sub:jwt面向的用户</li>
<li>aud:接收jwt的一方</li>
<li>nbf:该时间之前，jwt不可用</li>
<li>iat:jwt的签发时间</li>
<li>jti:jwt的唯一标识</li>
</ul>
</li>
<li><em>public</em> claims 公共的声明</li>
<li><em>private</em>  claims 私有的声明，除了registered、public</li>
</ul>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,//registered claims </span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对其进行Base64Url 编码，生成payload.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上例Base64Url编码后的内容</span><br><span class="line">ewogICJzdWIiOiAiMTIzNDU2Nzg5MCIsLy9yZWdpc3RlcmVkIGNsYWltcyAKICAibmFtZSI6ICJKb2huIERvZSIsCiAgImFkbWluIjogdHJ1ZQp9</span><br></pre></td></tr></table></figure>

<h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>使用 secret 和报头指定的算法对header 和 payload进行签名，生成signature。</p>
<h2 id="为什么使用JWT"><a href="#为什么使用JWT" class="headerlink" title="为什么使用JWT"></a>为什么使用JWT</h2><h3 id="编码后的简洁性"><a href="#编码后的简洁性" class="headerlink" title="编码后的简洁性"></a>编码后的简洁性</h3><p>As JSON is less verbose than XML, when it is encoded its size is also  smaller, making JWT more compact than SAML. This makes JWT a good choice to be passed in HTML and HTTP environments.</p>
<h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h3><p>Security-wise, SWT can only be symmetrically signed by a shared secret  using the HMAC algorithm. However, JWT and SAML tokens can use a  public/private key pair in the form of a X.509 certificate for signing.  Signing XML with XML Digital Signature without introducing obscure  security holes is very difficult when compared to the simplicity of  signing JSON.</p>
<h3 id="解析的方便性"><a href="#解析的方便性" class="headerlink" title="解析的方便性"></a>解析的方便性</h3><p>JSON parsers are common in most programming languages because they map directly to objects. Conversely, XML doesn’t have a natural document-to-object mapping. This makes it easier to work with JWT than SAML assertions.</p>
<h3 id="服务器无关性"><a href="#服务器无关性" class="headerlink" title="服务器无关性"></a>服务器无关性</h3><p>Regarding usage, JWT is used at Internet scale. This highlights the ease of client-side processing of the JSON Web token on multiple platforms, especially mobile.</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>可以使用单个跨站点脚本窃取localStorage中的所有数据，因此建议不要在localStorage中存储敏感信息。</p>
<p>单个跨站点脚本也可用于将恶意数据加载到localStorage中，因此不要认为这些对象是可信的。</p>
<p>localStorage 和 sessionStorage 属性允许在浏览器中存储 key/value 对的数据。</p>
<p>localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。</p>
<p>localStorage 属性是只读的。</p>
<p>sessionStorage将数据保存在当前会话中</p>
<p>cookie可以使用httpOnly标志来降低这种风险。</p>
]]></content>
      <categories>
        <category>Java框架</category>
      </categories>
      <tags>
        <tag>Jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Java缓存</title>
    <url>/2020/05/22/213Java%E6%A1%86%E6%9E%B6/Redis-Java%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>了解Java中Redis作为缓存如何使用</p>
<span id="more"></span>

<p><strong>目的：</strong>了解Java中Redis作为缓存如何使用<br><strong>参考：</strong><a href="https://www.cnblogs.com/jinbuqi/p/11038731.html">https://www.cnblogs.com/jinbuqi/p/11038731.html</a></p>
<h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><h2 id="1-准备redis环境"><a href="#1-准备redis环境" class="headerlink" title="1.准备redis环境"></a>1.准备redis环境</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p>下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></p>
<p>版本3.0.503.zip</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vdMJrCyOEaZkYF4.png" alt="img"></p>
<h3 id="2-解压到指定位置"><a href="#2-解压到指定位置" class="headerlink" title="2.解压到指定位置"></a>2.解压到指定位置</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mREUpTxhbvJ53fd.png" alt="img"></p>
<h3 id="3-启动redis服务器："><a href="#3-启动redis服务器：" class="headerlink" title="3.启动redis服务器："></a>3.启动redis服务器：</h3><p>解压目录中新建文件<code>startup.cmd</code>，内容为：<code>redis-server redis.windows.conf</code></p>
<p>启动redis服务器：双击<code>startup.cmd</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/pMFru3qJyn7a9mO.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hu6OsdR3BfVUHDm.png" alt="img"></p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>打开同一个文件夹下的 redis-cli.exe<br>输入测试语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br><span class="line"></span><br><span class="line">get key</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“value”</span><br></pre></td></tr></table></figure>

<h2 id="2-java中使用"><a href="#2-java中使用" class="headerlink" title="2.java中使用"></a>2.java中使用</h2><h3 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h3><p>我的环境 idea:<code>2018.3.3</code> jdk:<code>1.8.0_131</code><br>idea新建springboot项目</p>
<p>maven添加jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--注释掉，开启junit--&gt;</span><br><span class="line">    &lt;!--&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">    &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--Web--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--json包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- log --&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h3 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h3><p><code>application.properties</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure>

<p>新建<code>log4j.properties</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=CONSOLE,FILE</span><br><span class="line">log4j.addivity.org.apache=true</span><br><span class="line"></span><br><span class="line"># 应用于控制台</span><br><span class="line">log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.CONSOLE.Threshold=INFO</span><br><span class="line">log4j.appender.CONSOLE.Target=System.out</span><br><span class="line">log4j.appender.CONSOLE.Encoding=UTF-8</span><br><span class="line">log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.CONSOLE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n</span><br><span class="line"></span><br><span class="line"># 每天新建日志</span><br><span class="line">log4j.appender.A1=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.A1.File=D:/log4j/log</span><br><span class="line">log4j.appender.A1.Encoding=UTF-8</span><br><span class="line">log4j.appender.A1.Threshold=DEBUG</span><br><span class="line">log4j.appender.A1.DatePattern=&#x27;.&#x27;yyyy-MM-dd</span><br><span class="line">log4j.appender.A1.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.A1.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L : %m%n</span><br><span class="line"></span><br><span class="line">#应用于文件</span><br><span class="line">log4j.appender.FILE=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.FILE.File=E:/log4j/file.log</span><br><span class="line">log4j.appender.FILE.Append=false</span><br><span class="line">log4j.appender.FILE.Encoding=UTF-8</span><br><span class="line">log4j.appender.FILE.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n</span><br></pre></td></tr></table></figure>

<h3 id="3-包结构"><a href="#3-包结构" class="headerlink" title="3.包结构"></a>3.包结构</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iumg1tOfKz8hwqC.png" alt="image-20200522161701680"></p>
<h3 id="4-配置Redis"><a href="#4-配置Redis" class="headerlink" title="4.配置Redis"></a>4.配置Redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description: redis配置  配置序列化方式以及缓存管理器</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">@EnableCaching//开启以注解方式使用缓存。</span><br><span class="line">@Configuration//这是一个配置类</span><br><span class="line">@AutoConfigureAfter(RedisAutoConfiguration.class)</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Description: json序列化</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer() &#123;</span><br><span class="line">        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(mapper);</span><br><span class="line">        return serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Description:配置自定义redisTemplate</span><br><span class="line">     *</span><br><span class="line">     * @param connectionFactory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer());</span><br><span class="line">        //使用StringRedisSerializer来序列化和反序列化redis的key值</span><br><span class="line">        template.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        return template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置缓存管理器</span><br><span class="line">     * @param redisConnectionFactory</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        // 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        // 设置缓存的默认过期时间，也是使用Duration设置</span><br><span class="line">        config = config.entryTtl(Duration.ofMinutes(1))</span><br><span class="line">                // 设置 key为string序列化</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))</span><br><span class="line">                // 设置value为json序列化</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer()))</span><br><span class="line">                // 不缓存空值</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line"></span><br><span class="line">        // 设置一个初始化的缓存空间set集合</span><br><span class="line">        Set&lt;String&gt; cacheNames = new HashSet&lt;&gt;();</span><br><span class="line">        cacheNames.add(&quot;timeGroup&quot;);</span><br><span class="line">        cacheNames.add(&quot;user&quot;);</span><br><span class="line"></span><br><span class="line">        // 对每个缓存空间应用不同的配置</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; configMap = new HashMap&lt;&gt;();</span><br><span class="line">        configMap.put(&quot;timeGroup&quot;, config);</span><br><span class="line">        configMap.put(&quot;user&quot;, config.entryTtl(Duration.ofSeconds(120)));</span><br><span class="line"></span><br><span class="line">        // 使用自定义的缓存配置初始化一个cacheManager</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory)</span><br><span class="line">                // 一定要先调用该方法设置初始化的缓存名，再初始化相关的配置</span><br><span class="line">                .initialCacheNames(cacheNames)</span><br><span class="line">                .withInitialCacheConfigurations(configMap)</span><br><span class="line">                .build();</span><br><span class="line">        return cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存的key是 包名+方法名+参数列表</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public KeyGenerator keyGenerator() &#123;</span><br><span class="line">        return (target, method, objects) -&gt; &#123;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            sb.append(target.getClass().getName());</span><br><span class="line">            sb.append(&quot;::&quot; + method.getName() + &quot;:&quot;);</span><br><span class="line">            for (Object obj : objects) &#123;</span><br><span class="line">                sb.append(obj.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-实体类pojo"><a href="#5-实体类pojo" class="headerlink" title="5.实体类pojo"></a>5.实体类pojo</h3><p>使用了lombok</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.redis_cache.pojo;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line">import lombok.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor                 //无参构造</span><br><span class="line">@AllArgsConstructor                //有参构造</span><br><span class="line">public class User &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String  nickname;</span><br><span class="line">    private String mobile;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)//在输出的Json数据中隐藏密码，只能输入不输出</span><br><span class="line">    private String password;</span><br><span class="line">    private String role;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Controller"><a href="#6-Controller" class="headerlink" title="6.Controller"></a>6.Controller</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedisTemplate&lt;String, Object&gt; redis;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&#123;id&#125;&quot;, method = RequestMethod.GET, produces = &quot;application/json&quot;)</span><br><span class="line">    public User getUserById(@PathVariable long id)&#123;</span><br><span class="line">        User user = userService.getUserById(id);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&#123;id&#125;/change-nick&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;)</span><br><span class="line">    public User updateNickname(@PathVariable long id) throws Exception&#123;</span><br><span class="line">        String nickname = &quot;ww-&quot; + Math.random();</span><br><span class="line">        User user = userService.updateUserNickname(id, nickname);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;&#123;id&#125;/change-nick&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;)</span><br><span class="line">    public User updateMobile(@PathVariable long id) throws Exception&#123;</span><br><span class="line">        String mobile = &quot;134&quot; + Math.random();</span><br><span class="line">        User user = userService.updateUserNickname(id, mobile);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用RedisTemplate访问redis服务器</span><br><span class="line">    @RequestMapping(value=&quot;/redis&quot;, method=RequestMethod.GET, produces=&quot;application/json&quot;)</span><br><span class="line">    public String redis() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        // 设置键&quot;key&quot;，值&quot;value&quot;</span><br><span class="line">        redis.opsForValue().set(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">        String value = (String) redis.opsForValue().get(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Service-ServiceImpl"><a href="#7-Service-ServiceImpl" class="headerlink" title="7.Service + ServiceImpl"></a>7.Service + ServiceImpl</h3><ul>
<li><p><code>@Cacheable</code> - 表明对应方法的返回结果可以被缓存，首次调用后，下次就从缓存中读取结果，方法不会再被执行了。</p>
</li>
<li><p><code>@CachePut</code> - 更新缓存，方法每次都会执行</p>
</li>
<li><p><code>@CacheEvict</code> - 清除缓存，方法每次都会执行</p>
<p>Service </p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public User getUserById(long userId);</span><br><span class="line">    public User updateUserNickname(long userId, String nickname);</span><br><span class="line">    public User updateUserMobile(long userId, String mobile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceImpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Description:</span><br><span class="line"> *</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    private User user = new User(11, &quot;zs&quot;, &quot;13400000000&quot;, &quot;123456&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">    @Cacheable(value = &quot;user&quot;, key = &quot;#userId&quot;) //表明对应方法的返回结果可以被缓存，首次调用后，下次就从缓存中读取结果，可以查到时，方法不会被执行。</span><br><span class="line">    @Override</span><br><span class="line">    public User getUserById(long userId) &#123;</span><br><span class="line">       log.info(&quot;加载user&quot;);</span><br><span class="line">       return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CacheEvict(value = &quot;user&quot;, key= &quot;#userId&quot;) //清除缓存，方法每次都会执行</span><br><span class="line">    @Override</span><br><span class="line">    public User updateUserNickname(long userId, String nickname) &#123;</span><br><span class="line">        log.info(&quot;修改名字，清除缓存&quot;);</span><br><span class="line">        user.setNickname(nickname);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @CachePut(value = &quot;user&quot;, key= &quot;#userId&quot;) //更新缓存，方法每次都会执行</span><br><span class="line">    @Override</span><br><span class="line">    public User updateUserMobile(long userId, String mobile) &#123;</span><br><span class="line">        log.info(&quot;修改手机，更新缓存&quot;);</span><br><span class="line">        user.setMobile(mobile);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-启动redis监控"><a href="#8-启动redis监控" class="headerlink" title="8.启动redis监控"></a>8.启动redis监控</h3><p>进入redis安装目录，双击<code>redis-cli.exe</code>,输入<code>monitor</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/UEFXkalCY9nH12p.png" alt="image-20200522163608886"></p>
<h3 id="9-APIPost测试q"><a href="#9-APIPost测试q" class="headerlink" title="9.APIPost测试q"></a>9.APIPost测试q</h3><p>启动springboot项目，打开Apipost</p>
<h4 id="1-Cacheable测试"><a href="#1-Cacheable测试" class="headerlink" title="1.@Cacheable测试"></a>1.@Cacheable测试</h4><p>发送请求，查看redis监控器中的变化</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oMpZUuDN7EwtH4c.png" alt="image-20200522164136415"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TR3mnLX7QeYUWCG.png" alt="image-20200522164207296"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/LHbgJUqorjpuRnk.png" alt="image-20200522164320735"></p>
<p>再发送三次</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/yBuAsTJCrc9omQZ.png" alt="image-20200522164431496"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/dmNgeVWGrR8ut7F.png" alt="image-20200522164451522"></p>
<p>加载user只打印了一次，方法内部只执行了一次</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4xQa5b3ToyhFqwf.png" alt="image-20200522164949723"></p>
<h4 id="2-CacheEvict测试"><a href="#2-CacheEvict测试" class="headerlink" title="2.@CacheEvict测试"></a>2.@CacheEvict测试</h4><p>发送两次请求</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/rK1xvcdqCbJX9p3.png" alt="image-20200522164734057"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/biqWDTYPdM7X1gy.png" alt="image-20200522164834405"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XEwOBgGp7UyhFYJ.png" alt="image-20200522164927084"></p>
<h4 id="3-CachePut测试"><a href="#3-CachePut测试" class="headerlink" title="3.CachePut测试"></a>3.CachePut测试</h4><p>发送两次请求</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Tqx7CP3njuph2eA.png" alt="image-20200522165145493"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/9D8xbBXWdh6mZt2.png" alt="image-20200522165212982"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oun1vPAICTfSslx.png" alt="image-20200522165257318"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-入门</title>
    <url>/2020/05/22/213Java%E6%A1%86%E6%9E%B6/Redis-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>了解redis功能和作用，会使用Redis</p>
<span id="more"></span>

<p><strong>目的：</strong>了解redis功能和作用，会使用Redis<br><strong>参考：</strong><a href="https://www.jianshu.com/p/56999f2b8e3b">https://www.jianshu.com/p/56999f2b8e3b</a><br><strong>功能：</strong>redis是内存数据库，可将数据存放在内存中。读写效率是mysql的几个量级。<br><strong>作用：</strong>缓存数据，大大提升访问速度。高速读写，并发<br><strong>场景：</strong>缓存热点数据，高速读写，并发场合。</p>
<h1 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis-入门"></a>Redis-入门</h1><h2 id="1-准备redis环境"><a href="#1-准备redis环境" class="headerlink" title="1.准备redis环境"></a>1.准备redis环境</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p>下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></p>
<p>版本3.0.503.zip</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vdMJrCyOEaZkYF4.png" alt="img"></p>
<h3 id="2-解压到指定位置"><a href="#2-解压到指定位置" class="headerlink" title="2.解压到指定位置"></a>2.解压到指定位置</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mREUpTxhbvJ53fd.png" alt="img"></p>
<h3 id="3-启动redis服务器："><a href="#3-启动redis服务器：" class="headerlink" title="3.启动redis服务器："></a>3.启动redis服务器：</h3><p>解压目录中新建文件<code>startup.cmd</code>，内容为：<code>redis-server redis.windows.conf</code></p>
<p>启动redis服务器：双击<code>startup.cmd</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/pMFru3qJyn7a9mO.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hu6OsdR3BfVUHDm.png" alt="img"></p>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>打开同一个文件夹下的 redis-cli.exe<br>输入测试语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br><span class="line"></span><br><span class="line">get key</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“value”</span><br></pre></td></tr></table></figure>

<h2 id="2-java中使用"><a href="#2-java中使用" class="headerlink" title="2.java中使用"></a>2.java中使用</h2><h3 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h3><p>我的环境 idea:<code>2018.3.3</code> jdk:<code>1.8.0_131</code><br>idea新建springboot项目</p>
<p>maven添加jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Redis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--先注释掉才能使用Junit--&gt;</span><br><span class="line">    &lt;!--&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


<h3 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h3><p><code>application.properties</code>中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># REDIS (RedisProperties)</span><br><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=0</span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line"># 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=0</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=0</span><br></pre></td></tr></table></figure>

<h3 id="3-操作Spring"><a href="#3-操作Spring" class="headerlink" title="3.操作Spring"></a>3.操作Spring</h3><p>新建类<code>ConnectRedisTest</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest()</span><br><span class="line">public class ConnectRedisTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate = new StringRedisTemplate();</span><br><span class="line"></span><br><span class="line">    //存储String</span><br><span class="line">    @Test</span><br><span class="line">    public void string() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">        //</span><br><span class="line">        stringRedisTemplate.opsForValue().set(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(&quot;key2&quot;,&quot;value2&quot;);</span><br><span class="line">        Assert.assertEquals(&quot;value3&quot;,stringRedisTemplate.opsForValue().get(&quot;key&quot;));</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-存储对象"><a href="#4-存储对象" class="headerlink" title="4.存储对象"></a>4.存储对象</h3><p>新建类<code>User</code>,注意需要实现接口<code>Serializable</code>。这里我还是用<code>lombok</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@ToString</span><br><span class="line">public class User implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConnectRedisTest</code>中注入<code>RedisTemplate</code>,添加测试方法<code>object</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @Autowired</span><br><span class="line"> RedisTemplate redisTemplate = new RedisTemplate();</span><br><span class="line"></span><br><span class="line">//存储对象</span><br><span class="line">@Test</span><br><span class="line">public void object() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;1&quot;);</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setId(&quot;1&quot;);</span><br><span class="line">    user.setName(&quot;zs&quot;);</span><br><span class="line">    //User需实现序列化接口</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;user&quot;,user);</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-操作List"><a href="#5-操作List" class="headerlink" title="5.操作List"></a>5.操作List</h3><p><code>ConnectRedisTest</code>添加测试方法<code>list</code> 和<code>listRemove</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//List</span><br><span class="line">@Test</span><br><span class="line">public void list() throws Exception&#123;</span><br><span class="line">    System.out.println(&quot;1&quot;);</span><br><span class="line">    redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;1&quot;);</span><br><span class="line">    redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;2&quot;);</span><br><span class="line">    redisTemplate.opsForList().rightPush(&quot;list&quot;,&quot;A&quot;);</span><br><span class="line"></span><br><span class="line">    redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;0&quot;);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = redisTemplate.opsForList().range(&quot;list&quot;, 0, -1);</span><br><span class="line">    System.out.println(list.toString());//[0, 1, 2, A]</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list2 = redisTemplate.opsForList().range(&quot;list&quot;, 0, 3);</span><br><span class="line">    System.out.println(list2.toString());//[0, 1, 2, A]</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = redisTemplate.opsForList().range(&quot;list&quot;, 1, 2);</span><br><span class="line">    System.out.println(list3.toString());//[0, 1, 2, A]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void listRemove()&#123;</span><br><span class="line">    System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1).toString());//[0, 0, 1, 2, 1, 2, 1, 2, A]</span><br><span class="line">    //删除第一个为A的元素</span><br><span class="line">    redisTemplate.opsForList().remove(&quot;list&quot;, 1, &quot;A&quot;);</span><br><span class="line">    System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1));//[0, 0, 1, 2, 1, 2, 1, 2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //删除所有的value为0的元素</span><br><span class="line">    redisTemplate.opsForList().remove(&quot;list&quot;, 0, &quot;0&quot;);</span><br><span class="line">    System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1));//[1, 2, 1, 2, 1, 2]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-windows下后台启动"><a href="#3-windows下后台启动" class="headerlink" title="3.windows下后台启动"></a>3.windows下后台启动</h2><h3 id="1-安装成windows服务"><a href="#1-安装成windows服务" class="headerlink" title="1.安装成windows服务"></a>1.安装成windows服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --service-install redis.windows.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/PsUG8i6h3NbCDdc.png" alt="image-20201029104307873"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/viEH4hSzsZMPFx5.png" alt="image-20201029104407433"></p>
<h3 id="2-启动Redis"><a href="#2-启动Redis" class="headerlink" title="2.启动Redis"></a>2.启动Redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --service-start</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/kc2D7FMvUCaWKS4.png" alt="image-20201029104515578"></p>
<h3 id="3-停止、卸载"><a href="#3-停止、卸载" class="headerlink" title="3.停止、卸载"></a>3.停止、卸载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --service-stop</span><br><span class="line">redis-server --service-uninstall</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper-安装</title>
    <url>/2020/08/25/213Java%E6%A1%86%E6%9E%B6/Zookeeper-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Zookeeper的安装</p>
<span id="more"></span>

<h1 id="ZooKeeper-安装"><a href="#ZooKeeper-安装" class="headerlink" title="ZooKeeper-安装"></a>ZooKeeper-安装</h1><p>官网：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p>
<p>版本：ZooKeeper3.5.6</p>
<p>支持JDK8、11、12</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RBHqshvYfZPKdwb.png" alt="image-20200825064140355"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装jdk,我已安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看JDK安装路径</span><br><span class="line">[root@localhost ~]# whereis java</span><br><span class="line">java: /usr/local/jdk1.8.0_151/bin/java</span><br></pre></td></tr></table></figure>

<p>上传解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#上传 apache-zookeeper-3.5.6-bin.tar.gz</span><br><span class="line">#打开 opt目录</span><br><span class="line">cd /opt</span><br><span class="line">#创建zooKeeper目录</span><br><span class="line">mkdir  zooKeeper</span><br><span class="line">#将zookeeper安装包移动到 /opt/zooKeeper</span><br><span class="line">mv /root/apache-zookeeper-3.5.6-bin.tar.gz /opt/zookeeper/</span><br><span class="line">#解压</span><br><span class="line">cd /opt/zookeeper/</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p>修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入到conf目录</span><br><span class="line">cd /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/</span><br><span class="line">#拷贝</span><br><span class="line">cp  zoo_sample.cfg  zoo.cfg</span><br><span class="line">#修改zoo.cfg</span><br><span class="line">vim /opt/zooKeeper/apache-zooKeeper-3.5.6-bin/conf/zoo.cfg</span><br><span class="line">#修改存储目录：dataDir=/opt/zookeeper/zkdata</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8V5Cwm4ujRfD7Wn.png" alt="image-20200913001445650"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/FeCjhZySlDXv3Oa.png" alt="image-20200913001619835"></p>
<p>创建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开目录</span><br><span class="line">cd /opt/zooKeeper/</span><br><span class="line">#创建zooKeeper存储目录</span><br><span class="line">mkdir zkdata</span><br></pre></td></tr></table></figure>

<p>启动zookeeper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/</span><br><span class="line">#启动</span><br><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure>

<p>退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger2入门</title>
    <url>/2019/09/08/213Java%E6%A1%86%E6%9E%B6/swagger2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>swagger2入门</p>
<span id="more"></span>

<h1 id="swagger2入门"><a href="#swagger2入门" class="headerlink" title="swagger2入门"></a>swagger2入门</h1><h2 id="1-idea新建springboot项目"><a href="#1-idea新建springboot项目" class="headerlink" title="1.idea新建springboot项目"></a>1.idea新建springboot项目</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/eafTzln1IDhOxN6.png" alt="image-20200414100202180"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/o94bDNLFvhtYnai.png" alt="image-20200414100238353"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/1pHj5zauQsvdk4o.png" alt="image-20200414100328628"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/jw9Zg62UsN5xfBW.png" alt="image-20200414100523771"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/tSwMurdNIxvWon9.png" alt="image-20200414100727061"></p>
<h2 id="2-引入swagger2的jar包"><a href="#2-引入swagger2的jar包" class="headerlink" title="2.引入swagger2的jar包"></a>2.引入swagger2的jar包</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OLMjzFGW8E2cfoV.png" alt="image-20200414101046464"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;       </span><br></pre></td></tr></table></figure>

<h2 id="3-写swagger2的配置类"><a href="#3-写swagger2的配置类" class="headerlink" title="3.写swagger2的配置类"></a>3.写swagger2的配置类</h2><p>新建包configuration，包下新建类Swagger2Config</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/YQ7pZ83hsGxPcvk.png" alt="image-20200414101825597"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/zBYWSb8q1J7DgR4.png" alt="image-20200414101737209"></p>
<p>Swagger2Config的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.demo.configuration;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line">import springfox.documentation.builders.PathSelectors;</span><br><span class="line">import springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line">import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration //表示这是一个配置类</span><br><span class="line">@EnableSwagger2 //启用Swagger2相关功能</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo&quot;))//基础路径</span><br><span class="line">                .paths(PathSelectors.regex(&quot;/*&quot;))//匹配开启接口文档的路径</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;学习swaggerRestful API&quot;)</span><br><span class="line">                .description(&quot;学习swaggerRestful API&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http://127.0.0.1:8080/&quot;)</span><br><span class="line">                .contact(&quot;demo&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-写一个测试类"><a href="#4-写一个测试类" class="headerlink" title="4.写一个测试类"></a>4.写一个测试类</h2><p>新建包controller，包下新建类TestSwagger2</p>
<p>类的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class TestSwagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;swagger2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-启动项目，访问-http-localhost-8080-swagger-ui-html"><a href="#5-启动项目，访问-http-localhost-8080-swagger-ui-html" class="headerlink" title="5.启动项目，访问 http://localhost:8080/swagger-ui.html"></a>5.启动项目，访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/143ONtwmK2QsMBu.png" alt="image-20200414103730999"></p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的数据结构Hash</title>
    <url>/2021/06/10/214%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Hash/</url>
    <content><![CDATA[<p>Redis的数据结构Hash</p>
<span id="more"></span>

<h1 id="Redis的数据结构Hash"><a href="#Redis的数据结构Hash" class="headerlink" title="Redis的数据结构Hash"></a>Redis的数据结构Hash</h1><p>适合存储对象，比存储在String类型类，占用 更小的内存空间，并方便存取整个对象。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="string结构"><a href="#string结构" class="headerlink" title="string结构"></a>string结构</h3><p>key，value</p>
<h3 id="hash结构"><a href="#hash结构" class="headerlink" title="hash结构"></a>hash结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key,&#123;&#123;field1,value1&#125;,&#123;field2,value2&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hset key field value</span><br><span class="line">hset user name zs</span><br></pre></td></tr></table></figure>

<h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hget user</span><br><span class="line">hget user</span><br></pre></td></tr></table></figure>

<h3 id="删除field"><a href="#删除field" class="headerlink" title="删除field"></a>删除field</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hdel key field [field......]</span><br><span class="line">hdel user name age</span><br></pre></td></tr></table></figure>

<h3 id="获取所有field"><a href="#获取所有field" class="headerlink" title="获取所有field"></a>获取所有field</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hkeys key</span><br></pre></td></tr></table></figure>

<h3 id="获取所有value"><a href="#获取所有value" class="headerlink" title="获取所有value"></a>获取所有value</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hvals key</span><br></pre></td></tr></table></figure>

<h3 id="获取所有field-value"><a href="#获取所有field-value" class="headerlink" title="获取所有field-value"></a>获取所有field-value</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hgetall key</span><br></pre></td></tr></table></figure>



<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p><a href="https://redis.io/commands/scan">参考</a></p>
<p>sscan 查询set结构</p>
<p>hscan 查询hash结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询key = swagger, field 模糊匹配*test* ,row &lt; 100000的所有值</span><br><span class="line">hscan swagger 0 match *test* count 100000</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Exception-HeadlessException</title>
    <url>/2020/09/21/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/Exception-HeadlessException/</url>
    <content><![CDATA[<p>以jar启动项目，访问接口时报java.awt.HeadlessException</p>
<span id="more"></span>

<h1 id="Exception-HeadlessException"><a href="#Exception-HeadlessException" class="headerlink" title="Exception-HeadlessException"></a>Exception-HeadlessException</h1><p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CST ERROR com.towery.support.GlobalExceptionHandler 54 notFoundException - 运行时异常: java.awt.HeadlessException: null</span><br><span class="line">	at sun.awt.HeadlessToolkit.getScreenSize(HeadlessToolkit.java:284) ~[?:1.8.0_121]</span><br><span class="line">	at com.towery.util.ResolutionUtil.getScreenSize(ResolutionUtil.java:22) ~[classes!/:0.0.1]</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目开启了Headless模式，在这种模式下系统缺少其他设备的支持，会报错。比如：显示设备、键盘、鼠标等外设。Headless模式在服务端是很常用的，因为大多数服务器就是运行在没有前述设备支持的情况下。</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>jar启动项目时，添加参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Djava.awt.headless=true -jar test.jar</span><br></pre></td></tr></table></figure>

<p>tomcat启动项目，提前在<code>catalina.sh</code>第一行添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Djava.awt.headless=true&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>Exception-Mybatis-BindingException</title>
    <url>/2020/08/12/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/Exception-Mybatis-BindingException/</url>
    <content><![CDATA[<p>Mybatis的BindingException异常解决</p>
<span id="more"></span>

<h1 id="Mybatis-BindingException"><a href="#Mybatis-BindingException" class="headerlink" title="Mybatis-BindingException"></a>Mybatis-BindingException</h1><p>来自 ：<a href="https://blog.csdn.net/weixin_42230885/article/details/84855041">https://blog.csdn.net/weixin_42230885/article/details/84855041</a></p>
<p>本地idea运行可以，服务器端jar包部署运行错误。</p>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter &#x27;id&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br></pre></td></tr></table></figure>



<p>注解SQL错误写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertObject</span><span class="params">(Integer userId,Integer[] roleIds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注解SQL正确写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertObject</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span>Integer userId,<span class="meta">@Param(&quot;roleIds&quot;)</span>Integer[] roleIds)</span></span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>jar包冲突</title>
    <url>/2020/05/18/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/jar%E5%8C%85%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>jar包冲突</p>
<span id="more"></span>

<h1 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>启动报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/jsontype/PolymorphicTypeValidator</span><br></pre></td></tr></table></figure>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>jar包冲突，jackjson2.9.8中没有类<code>PolymorphicTypeValidator</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/TmWJLBy4GpOszFb.png" alt="image-20210518094949654"></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="如何定位冲突jar与xml"><a href="#如何定位冲突jar与xml" class="headerlink" title="如何定位冲突jar与xml"></a>如何定位冲突jar与xml</h4><h5 id="定位jar"><a href="#定位jar" class="headerlink" title="定位jar"></a>定位jar</h5><ol>
<li><p>根据报错Caused by去依赖中找<code>com/fasterxml/jackson/databind/jsontype/PolymorphicTypeValidator</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/jsontype/PolymorphicTypeValidator</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ILaSpzh1YV6PtMX.png" alt="image-20210518095608269"></p>
</li>
<li><p>根据报错类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Failed to introspect Class [com.youlu.common.config.RedisConfig] from ClassLoader [sun.misc.Launcher$AppClassLoader@18b4aac2]</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Mwy1P6uj3HKrVLe.png" alt="image-20210518095808710"></p>
</li>
</ol>
<h4 id="jar定位xml"><a href="#jar定位xml" class="headerlink" title="jar定位xml"></a>jar定位xml</h4><p>命令行输入mvn命令<code>mvn dependency:tree</code>,会展示maven依赖拓扑关系，然后Ctrl+F搜索</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/cZIVQjf9UTHeA5O.png" alt="image-20210518102441361"></p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>一般保留高版本jar；也可能保留低版本jar，重新实现使用高版本的地方。</p>
<p>pom.xml去除jar</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;seata.vsersion&#125;&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-问题</title>
    <url>/2020/10/19/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/nginx-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>nginx-问题</p>
<span id="more"></span>

<h1 id="nginx-问题"><a href="#nginx-问题" class="headerlink" title="nginx-问题"></a>nginx-问题</h1><p><strong>访问报错：</strong></p>
<p>404 Not Found</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vfmhaGjUpRSbWEu.png" alt="image-20201019142343627"></p>
<p>日志文件nginx.1.10.3/logs/error.log信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020/10/19 14:05:51 [crit] 21512#26196: *3 CreateFile() &quot;D:	estweb/index.html&quot; failed (123: The filename, directory name, or volume label syntax is incorrect), client: 127.0.0.1, server: 127.0.0.1, request: &quot;GET /index.html HTTP/1.1&quot;, host: &quot;127.0.0.1:8850&quot;</span><br></pre></td></tr></table></figure>

<p><strong>原因:</strong></p>
<p>配置文件<code>nginx.conf</code>属性<code>location</code>中D:\test_web 路径含有\t，被解析为<code>D:    estweb/index.html</code></p>
<p>原配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            root   D:\test_web;</span><br><span class="line">            index  index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决：</strong></p>
<p>​    修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">            root   D:/test_web;</span><br><span class="line">            index  index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/PCcrRSkYNgaXl4I.png" alt="image-20201019141335011"></p>
]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>测试环境-问题</title>
    <url>/2020/10/17/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>测试环境-问题</p>
<span id="more"></span>

<h1 id="测试环境-问题"><a href="#测试环境-问题" class="headerlink" title="测试环境-问题"></a>测试环境-问题</h1><p>jwt</p>
<p>​    问题：操作时未到jwt过期时间，系统跳到登录页面。</p>
<p>​        测试环境操作同一账户，同一IP地址（127.0.0.1）,A的操作jwt续期生成新jwt返回给A，B使用旧jwt访问时，后端比对错误，返回给前端错误码，前端控制浏览器跳转到登录。</p>
<p>mysql</p>
<p>​    问题1：线上库无法连接</p>
<p>​        可能修改了账号权限</p>
<p>​    问题2：测试库无法修改字段，报错<code>no space left on device</code>。</p>
<p>​        磁盘空间满了，可以删除备份文件、日志文件</p>
<p>solor</p>
<p>​    问题：后端程序断点执行完毕，但方法无返回值。前端页面一直等待后端返回。</p>
<p>​        solor服务器挂掉。</p>
<p>redis</p>
<p>​    问题1：线上正常，本地环境无法连接线上redis。</p>
<p>​    问题2：redis经常宕机。</p>
<p>​        官方提供的redis是Linux环境。windows环境是第三方改的，redis不稳定，windows本身是多线程的也不稳定，都会造成redis宕机。迁移到linux环境。</p>
]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>测试环境</tag>
      </tags>
  </entry>
  <entry>
    <title>防止重复提交</title>
    <url>/2020/03/10/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>防止重复提交</p>
<span id="more"></span>

<h1 id="防止重复提交"><a href="#防止重复提交" class="headerlink" title="防止重复提交"></a>防止重复提交</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul>
<li><p>解释：持续触发高频事件，函数每n秒执行一次。</p>
</li>
<li><p>业务场景</p>
<p>输入框的模糊查询</p>
</li>
<li><p>目的</p>
<p>节约流量、内存的损耗，旨在提升性能，在高频率频发的事件中才会用到。</p>
</li>
</ul>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>持续触发高频事件，函数只会执行一次。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul>
<li><p>目的：防止绕过前端校验持续访问接口。</p>
</li>
<li><p>实现</p>
<ol>
<li><p>切面类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.aop;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.util.StringUtils;</span><br><span class="line">import com.xiaoruiit.common.utils.IPUtil;</span><br><span class="line">import com.xiaoruiit.common.utils.IdWorker;</span><br><span class="line">import com.xiaoruiit.common.utils.Result;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Aspect // 定义切面类</span><br><span class="line">public class AvoidDuplicateSubmitAspect &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;@annotation(com.xiaoruiit.common.aop.AvoidDuplicateSubmit)&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        // 获取request对象</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();</span><br><span class="line">        String ip = IPUtil.getIP(request);</span><br><span class="line">        // 获取方法签名</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        String ipKey = String.format(&quot;%s#%s&quot;, className, methodName);</span><br><span class="line">        int hashCode = Math.abs(ipKey.hashCode());</span><br><span class="line">        // 拼接redisKey,如：127.0.0.1_1234984393</span><br><span class="line">        String redisKey = String.format(&quot;%s_%d&quot;, ip, hashCode);</span><br><span class="line"></span><br><span class="line">        String value = (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">        if (!StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return Result.validateFailed(&quot;请勿重复提交&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取注解</span><br><span class="line">        AvoidDuplicateSubmit avoidDuplicateSubmit = method.getAnnotation(AvoidDuplicateSubmit.class);</span><br><span class="line">        long timeout = avoidDuplicateSubmit.timeout();</span><br><span class="line">        if (timeout &lt; 0) &#123;</span><br><span class="line">            timeout = 5000;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第一次提交，插入redis</span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, IdWorker.nextId(), timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        // 继续执行方法</span><br><span class="line">        return joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.aop;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface AvoidDuplicateSubmit &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 指定时间内不可重复提交，单位毫秒</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    long timeout() default 5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法上加注解 @AvoidDuplicateSubmit</span><br><span class="line">@AvoidDuplicateSubmit  默认时间5000毫秒</span><br><span class="line">@AvoidDuplicateSubmit(timeout = 100000) 单位毫秒自己设置控制时间</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取IP真实地址</p>
<p>代理服务器结合java代码</p>
<ul>
<li><p>1.nginx配置</p>
<p>参考：<a href="https://segmentfault.com/a/1190000019197577">https://segmentfault.com/a/1190000019197577</a></p>
</li>
<li><p>java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String[] HEADERS_TO_TRY = &#123;</span><br><span class="line">            &quot;X-Forwarded-For&quot;,</span><br><span class="line">            &quot;Proxy-Client-IP&quot;,</span><br><span class="line">            &quot;WL-Proxy-Client-IP&quot;,</span><br><span class="line">            &quot;HTTP_X_FORWARDED_FOR&quot;,</span><br><span class="line">            &quot;HTTP_X_FORWARDED&quot;,</span><br><span class="line">            &quot;HTTP_X_CLUSTER_CLIENT_IP&quot;,</span><br><span class="line">            &quot;HTTP_CLIENT_IP&quot;,</span><br><span class="line">            &quot;HTTP_FORWARDED_FOR&quot;,</span><br><span class="line">            &quot;HTTP_FORWARDED&quot;,</span><br><span class="line">            &quot;HTTP_VIA&quot;,</span><br><span class="line">            &quot;REMOTE_ADDR&quot; &#125;;</span><br><span class="line"></span><br><span class="line">private String getClientIpAddress(HttpServletRequest request) &#123;</span><br><span class="line">    for (String header : HEADERS_TO_TRY) &#123;</span><br><span class="line">        String ip = request.getHeader(header);</span><br><span class="line">        if (ip != null &amp;&amp; ip.length() != 0 &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            return ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return request.getRemoteAddr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>业务场景</category>
      </categories>
  </entry>
  <entry>
    <title>git-常见错误</title>
    <url>/2020/08/20/%E5%B7%A5%E5%85%B7/git-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>git-常见错误，没有使用分支的情况</p>
<span id="more"></span>

<h1 id="git-常见错误"><a href="#git-常见错误" class="headerlink" title="git-常见错误"></a>git-常见错误</h1><h2 id="git流程："><a href="#git流程：" class="headerlink" title="git流程："></a>git流程：</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/IPzvlRdumkUwn23.png" alt="image-20200819205443771"></p>
<p>图片来源于网络</p>
<h2 id="正确操作："><a href="#正确操作：" class="headerlink" title="正确操作："></a>正确操作：</h2><p>​    无冲突：</p>
<p>​        pull,commit,push</p>
<p>​    有冲突：</p>
<p>​        pull失败，stash,pull,unstash,解决冲突代码,commit,push</p>
<h2 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h2><p>B提交的更改没有了，远程服务器的版本回退到了没有更改的时候。</p>
<h3 id="错误操作："><a href="#错误操作：" class="headerlink" title="错误操作："></a>错误操作：</h3><p>git仓库有a.html，b.html</p>
<p>A </p>
<p>​    12:00 commit</p>
<p>​    18:00 commit push </p>
<p>B </p>
<p>​    修改b.html</p>
<p>​    14:00 commit b.html  push</p>
<p>A 在18:00的push操作会将12：00commit的b.html提交到远程仓库，从而覆盖B在14:01push的b.html.</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>1.commit后需要push</p>
<p>2.commit后未push，第二次commit之后的push要把B的新的b.html推送到远程仓库。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>正常使用也会发生：B提交的更改没有了，远程服务器的版本回退到了没有更改的时候。</p>
<p>例如：A pull和push中间的时间，B 做了push操作。团队开发发生这种时间差push的情况很少。</p>
<h2 id="pull报443"><a href="#pull报443" class="headerlink" title="pull报443"></a>pull报443</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># git中执行下行代码，取消代理</span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>kettle-入门</title>
    <url>/2021/06/10/%E5%B7%A5%E5%85%B7/kettle-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>kettle-入门</p>
<span id="more"></span>

<h2 id="kettle-入门"><a href="#kettle-入门" class="headerlink" title="kettle-入门"></a>kettle-入门</h2><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>抽取、转换、装载。将一种数据格式转换为另一种数据格式。例如：旧系统导出的.json人员数据通过转换导入到新系统数据库中。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>spoon图形化工具：写出抽取、转换、装载的文件。</p>
<p>KettleOnline在线调度系统（java项目）：定时执行文件。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>视频：<a href="https://www.bilibili.com/video/BV1jE411B7J8?from=search&amp;seid=8259670291223952308">https://www.bilibili.com/video/BV1jE411B7J8?from=search&amp;seid=8259670291223952308</a></p>
<p>官网：<a href="https://www.kettle.net.cn/2401.html">https://www.kettle.net.cn/2401.html</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>版本：8.2</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要安装1.8jdk环境。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>双击spoon.bat</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>json → mysql数据库</p>
<ol>
<li><p>新建转换</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/E2S3dFlGDOB6mrh.png" alt="image-20210221160938883"></p>
</li>
<li><p>提取json数据</p>
<ol>
<li><p>新建输入组件 json</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/u1xZPOS9fTvnlMF.png" alt="image-20210221161047332"></p>
</li>
<li><p>选择文件</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/PxNCAbX4RkKqyD7.png" alt="image-20210221161240144"></p>
</li>
<li><p>提取字段</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Vnxykg5BXmZFMCT.png" alt="image-20210221161448619"></p>
</li>
<li><p>预览</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NLoUtzjWu5eglmc.png" alt="image-20210221161627613"></p>
</li>
</ol>
</li>
<li><p>将json数据插入mysql数据库</p>
<ol>
<li><p>mysql中新建表</p>
</li>
<li><p>新建表输出组件</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/nb2cYsrRD8LpxQW.png" alt="image-20210221161939392"></p>
</li>
<li><p>连线</p>
<p>点击+shift→shift+移动鼠标到另一个组件。选择主输出步骤</p>
</li>
<li><p>新建mysql连接</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/CcWYLox28zhVjPi.png" alt="image-20210221162245428"></p>
</li>
<li><p>选择连接和表</p>
<p>双击组件。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/w1GENrO4Udnfb57.png" alt="image-20210221162333583"></p>
</li>
<li><p>将json的字段与表中字段对应起来</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Rz2ICxavVdqL6jS.png" alt="image-20210221162425679"></p>
</li>
<li><p>启动</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Yyd4S1FNa5Aifj7.png" alt="image-20210221162511493"></p>
</li>
</ol>
</li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="转换文件中不要有中文"><a href="#转换文件中不要有中文" class="headerlink" title="转换文件中不要有中文"></a>转换文件中不要有中文</h3><p>步骤命名</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/mhMzZa7LK58Yb3A.png" alt="image-20210220115924186"></p>
<p>文件的路径</p>
<p>（D:\Users\Administrator\Desktop\测试\4.json）</p>
<p>数据库连接命名</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hnC83HB2SlOQbm9.png" alt="image-20210220120012726"></p>
<h3 id="jsonpath读取json数据"><a href="#jsonpath读取json数据" class="headerlink" title="jsonpath读取json数据"></a>jsonpath读取json数据</h3><p>json中的key中含有jsonpath语法<code>.</code>时读取该key的方法。key:<code>parent_id.department_code</code></p>
<p>数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;data&quot;: &#123;</span><br><span class="line">            &quot;query_data&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;start_date&quot;: &quot;2000-01-01&quot;,</span><br><span class="line">                    &quot;parent_id.department_code&quot;: &quot;D0115&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;start_date&quot;: &quot;2000-01-01&quot;,</span><br><span class="line">                    &quot;parent_id.department_code&quot;: &quot;D0136&quot;</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure>

<p>读取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.data.query_data..[&#x27;parent_id.department_code&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="数据库连接问题"><a href="#数据库连接问题" class="headerlink" title="数据库连接问题"></a>数据库连接问题</h3><h4 id="添加对应数据库的jar包"><a href="#添加对应数据库的jar包" class="headerlink" title="添加对应数据库的jar包"></a>添加对应数据库的jar包</h4><p>根据mysql数据库版本8.0.18，去mysql官网下载 <code>mysql-connector-java-8.0.18.zip</code> ，将其中的<code>mysql-connector-java-8.0.18.jar</code>添加jar包到lib目录下.</p>
<p>将mysql.jar放入到lib下。</p>
<h4 id="mysql数据库时区"><a href="#mysql数据库时区" class="headerlink" title="mysql数据库时区"></a>mysql数据库时区</h4><ul>
<li><p>报错</p>
<p>The server time zone value ‘�й���׼ʱ��’ is unrecognized</p>
</li>
<li><p>解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%time_zone%&#x27;;</span><br><span class="line">set global time_zone=&#x27;+8:00&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>kettle</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器-非信任证书</title>
    <url>/2020/10/29/%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%9D%9E%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>浏览器-谷歌</p>
<span id="more"></span>

<h1 id="浏览器-非信任证书"><a href="#浏览器-非信任证书" class="headerlink" title="浏览器-非信任证书"></a>浏览器-非信任证书</h1><p>问题：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ivPNLqhudzxmeSX.png" alt="image-20201029134637643"></p>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--test-type --ignore-certificate-errors --disable-web-security --user-data-dir</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4nJjHwCIdvr8i6G.png" alt="image-20201029135339320"></p>
<p>解决提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--test-type</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/YOB4VAQlimWJUth.png" alt="image-20201029134849030"></p>
<p>解决证书错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--ignore-certificate-errors</span><br></pre></td></tr></table></figure>

<p>解决跨域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--test-type --ignore-certificate-errors </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>RandomAccessFile-分块加载</title>
    <url>/2020/09/10/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/RandomAccessFile-%E5%88%86%E5%9D%97%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>RandomAccessFile-分块加载</p>
<span id="more"></span>

<h1 id="RandomAccessFile-分块加载"><a href="#RandomAccessFile-分块加载" class="headerlink" title="RandomAccessFile-分块加载"></a>RandomAccessFile-分块加载</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>加载PDF时，按照自己设定的分块的大小，分多次请求。</p>
<p>RandomAccessFile可以从任意位置开始，任意位置结束读取文件内容。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/BbMtWeXIEcTnqy5.png" alt="image-20200910154816957"></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>foxit-web-sdk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pdfui.openPDFByHttpRangeRequest(&#123;</span><br><span class="line">	range: &#123;</span><br><span class="line">		//url: &quot;http://127.0.0.1:8849/FoxitPDFSDKforWeb_DemoGuide.pdf&quot;,</span><br><span class="line">		url: &quot;http://127.0.0.1:8849/foxit/&quot;?pdfId=&quot; + pdfId,</span><br><span class="line">		chunkSize: 131072</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求头Request Headers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Range: bytes=0-131071</span><br><span class="line">Referer: http://127.0.0.1:8849/foxit/lib/WebPDFJRWorker.js?h=245349c6d66690b2cd6362d2643584e9</span><br><span class="line">Sec-Fetch-Dest: empty</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.100 Safari/537.36</span><br></pre></td></tr></table></figure>



<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/foxit&quot;)</span><br><span class="line">    public void foxit(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        int pdfId = Integer.parseInt(request.getParameter(&quot;pdfId&quot;));</span><br><span class="line"></span><br><span class="line">        //获取文件</span><br><span class="line">        String filePath = foxitService.getPdfurl(pdfId);</span><br><span class="line">        if (filePath == null || &quot;&quot;.equals(filePath)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        /* 不分片</span><br><span class="line">        response.setContentType(&quot;application/pdf&quot;); </span><br><span class="line">        // 读取路径下面的文件</span><br><span class="line">        try &#123;  </span><br><span class="line">            FileCopyUtils.copy(new FileInputStream(filePath),response.getOutputStream());</span><br><span class="line">        &#125; catch (IOException e)&#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125; */</span><br><span class="line">        </span><br><span class="line">        File downloadFile = new File(filePath);</span><br><span class="line">        if (downloadFile == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取分片起始位置并处理</span><br><span class="line">        long downloadSize = downloadFile.length();</span><br><span class="line">        long fromPos = 0,toPos = 0;</span><br><span class="line">        String range = request.getHeader(&quot;Range&quot;);</span><br><span class="line">        String bytes = range.replaceAll(&quot;bytes=&quot;, &quot;&quot;);</span><br><span class="line">        String[] ary = bytes.split(&quot;-&quot;);</span><br><span class="line">        fromPos = Long.parseLong(ary[0]);</span><br><span class="line">        if (ary.length == 2) &#123;</span><br><span class="line">            toPos = Long.parseLong(ary[1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (toPos - fromPos &gt; 131072)</span><br><span class="line">            return;</span><br><span class="line">        int size;</span><br><span class="line">        if (toPos &gt; fromPos) &#123;</span><br><span class="line">            size = (int) (toPos - fromPos + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size = (int) (downloadSize - fromPos + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 响应头 */</span><br><span class="line">        // 返回流信息 开始-结束/流总大小</span><br><span class="line">        response.setHeader(&quot;Content-Range&quot;, &quot;bytes &quot; + fromPos + &quot;-&quot; + toPos + &quot;/&quot; + downloadSize);</span><br><span class="line">        // 返回流大小</span><br><span class="line">        response.setHeader(&quot;Content-Length&quot;, size + &quot;&quot;);</span><br><span class="line">        response.setContentType(&quot;application/pdf&quot;);</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;, String.format(&quot;inline; filename=\&quot;%s\&quot;&quot;, downloadFile.getName()));</span><br><span class="line">        response.setHeader(&quot;Accept-Ranges&quot;, &quot;bytes&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;content-range, content-length, accept-ranges&quot;);// 坑点，前后端分离时必须添加</span><br><span class="line">        // 206</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span><br><span class="line">        response.setHeader(&quot;Connetion&quot;, &quot;keep-alive&quot;);</span><br><span class="line"></span><br><span class="line">        // 返回流内容</span><br><span class="line">        downloadSize = size;</span><br><span class="line">        RandomAccessFile in = null;</span><br><span class="line">        OutputStream out = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new RandomAccessFile(downloadFile, &quot;r&quot;);</span><br><span class="line">            // 设置下载起始位置</span><br><span class="line">            if (fromPos &gt; 0) &#123;</span><br><span class="line">                in.seek(fromPos);</span><br><span class="line">            &#125;</span><br><span class="line">            // 缓冲区大小</span><br><span class="line">            int bufLen = (int) (downloadSize &lt; 2048 ? downloadSize : 2048);</span><br><span class="line">            byte[] buffer = new byte[bufLen];</span><br><span class="line">            int num;</span><br><span class="line">            int count = 0; // 当前写到客户端的大小</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            while ((num = in.read(buffer)) != -1) &#123;</span><br><span class="line">                out.write(buffer, 0, num);</span><br><span class="line">                count += num;</span><br><span class="line">                //处理最后一段，计算不满缓冲区的大小</span><br><span class="line">                if (downloadSize - count &lt; bufLen) &#123;</span><br><span class="line">                    bufLen = (int) (downloadSize - count);</span><br><span class="line">                    if (bufLen == 0) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer = new byte[bufLen];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            response.flushBuffer();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (null != out) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (null != in) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>响应头Response Headers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Methods: GET</span><br><span class="line">Access-Control-Allow-Origin: http://127.0.0.1:8849</span><br><span class="line">Access-Control-Expose-Headers: content-range, content-length, accept-ranges</span><br><span class="line">Access-Control-Max-Age: 3600</span><br><span class="line">Connetion: keep-alive</span><br><span class="line">Content-Disposition: inline; filename=&quot;1.pdf&quot;</span><br><span class="line">Content-Length: 131072</span><br><span class="line">Content-Range: bytes 0-131071/526889</span><br><span class="line">Content-Type: application/pdf</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>RandomAccessFile</tag>
        <tag>分块加载</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue+SpringBoot实战 打通前后端联调</title>
    <url>/2019/12/11/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/Vue+SpringBoot%E5%AE%9E%E6%88%98%20%E6%89%93%E9%80%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E8%81%94%E8%B0%83/</url>
    <content><![CDATA[<p>开发工具：HbuilderX+IDEA</p>
<span id="more"></span>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="1-创建vue项目（已安装node-js和vue的脚手架cli）"><a href="#1-创建vue项目（已安装node-js和vue的脚手架cli）" class="headerlink" title="1.创建vue项目（已安装node.js和vue的脚手架cli）"></a>1.创建vue项目（已安装node.js和vue的脚手架cli）</h2><p>在D盘新建文件夹Vue-SpringBoot <img src="https://img-blog.csdnimg.cn/20191211152847386.png" alt="新建文件夹"><br>  在此处进入命令行<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20191211153003220.png">https://img-blog.csdnimg.cn/20191211153003220.png</a><br>  输入命令<code>vue init webpack vue_springboot_demo</code>，<br>  <img src="https://img-blog.csdnimg.cn/20191211153216920.png" alt="在这里插入图片描述"><br>然后一路回车。<br><img src="https://img-blog.csdnimg.cn/20191211153241407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  等待项目构建完毕<br><img src="https://img-blog.csdnimg.cn/20191211153326363.png" alt="在这里插入图片描述">进入项目 <code>cd D:\workspace\vue_springboot_demo</code><br>加载项目所需的依赖包，输入命令<code>npm install</code><br>加载axios,输入<code>npm install --save axios</code><br><img src="https://img-blog.csdnimg.cn/20191211163214487.png" alt="在这里插入图片描述"><br>启动项目：<code>npm run dev</code><br><img src="https://img-blog.csdnimg.cn/20191211155125517.png" alt="在这里插入图片描述"><br>在浏览器输入<code>localhost:8080</code> 效果如下：<br><img src="https://img-blog.csdnimg.cn/20191211155155726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">将vue_springboot_demo拖到hbuilderX中</p>
<h2 id="2-访问后端"><a href="#2-访问后端" class="headerlink" title="2.访问后端"></a>2.访问后端</h2><p>在HelloWord.vue增加访问后端内容<br><img src="https://img-blog.csdnimg.cn/20191211170121634.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191211170242396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;p&gt;springbootdata:&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;getdata()&quot;&gt;获取数据&lt;/button&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Essential Links&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://vuejs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Core Docs</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://forum.vuejs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Forum</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://chat.vuejs.org&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Community Chat</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://twitter.com/vuejs&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Twitter</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://vuejs-templates.github.io/webpack/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          Docs for This Template</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;Ecosystem&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://router.vuejs.org/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vue-router</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://vuex.vuejs.org/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vuex</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;http://vue-loader.vuejs.org/&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          vue-loader</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          href=&quot;https://github.com/vuejs/awesome-vue&quot;</span><br><span class="line">          target=&quot;_blank&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          awesome-vue</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Welcome to Your Vue.js App&#x27;,</span><br><span class="line">      message: &#x27;1&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getdata () &#123;</span><br><span class="line">        this.$axios</span><br><span class="line">          .post(&#x27;/getdata&#x27;).then(successResponse =&gt;  &#123;</span><br><span class="line">            console.log(successResponse.data);</span><br><span class="line">					&#125;)</span><br><span class="line">          .catch(failResponse =&gt; &#123;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1, h2 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">li &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;</span><br><span class="line">  color: #42b983;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-前端相关配置"><a href="#3-前端相关配置" class="headerlink" title="3.前端相关配置"></a>3.前端相关配置</h2><h3 id="1-设置反向代理"><a href="#1-设置反向代理" class="headerlink" title="(1)设置反向代理"></a>(1)设置反向代理</h3><p>修改 <code>src\main.js</code> 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">// 设置反向代理，前端请求默认发送到 http://localhost:8443/api</span><br><span class="line">var axios = require(&#x27;axios&#x27;)</span><br><span class="line">axios.defaults.baseURL = &#x27;http://localhost:8443/api&#x27;</span><br><span class="line">// 注册axios</span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2-跨域支持"><a href="#2-跨域支持" class="headerlink" title="(2)跨域支持"></a>(2)跨域支持</h3><p>在 <code>config\index.js</code> 中，找到 proxyTable 位置，<br><img src="https://img-blog.csdnimg.cn/20191211163750706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://localhost:8443&#x27;,</span><br><span class="line">        changeOrigin: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20191211164012872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">断开服务器Ctrl + C 然后Enter<br>运行服务器 npm run dev</p>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="4-创建SpringBoot项目"><a href="#4-创建SpringBoot项目" class="headerlink" title="4.创建SpringBoot项目"></a>4.创建SpringBoot项目</h2><p>创建一个springboot项目并运行起来<br><img src="https://img-blog.csdnimg.cn/20191211173248555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">第一次创建需要等待下载jar依赖<br>在<code>application.properties</code>文件中添加 <code>server.port=8443</code><br>运行项目：<br><img src="https://img-blog.csdnimg.cn/20191211175108417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">浏览器输入：<code>localhost:8443</code>,成功页面如下：<br><img src="https://img-blog.csdnimg.cn/20191211175159181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-开发后端"><a href="#5-开发后端" class="headerlink" title="5.开发后端"></a>5.开发后端</h2><p>在<code>com.xiaoruiit.springbootdemo</code>下新建包package <code>controller</code>,在包下新建类<code>TestConnectController</code>。内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class TestConnectController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;api/test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;hxr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//@CrossOrigin 后端开启跨域访问</span><br><span class="line">    @CrossOrigin</span><br><span class="line">    @PostMapping(value = &quot;/api/getdata&quot;)</span><br><span class="line">    public String getdata()&#123;</span><br><span class="line">        return &quot;hxr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器输入<code>localhost:8443/api/test</code>，可获取hxr。<br><img src="https://img-blog.csdnimg.cn/20191211182926381.png" alt="在这里插入图片描述"></p>
<h2 id="6-前后端联动效果"><a href="#6-前后端联动效果" class="headerlink" title="6.前后端联动效果"></a>6.前后端联动效果</h2><p>浏览器输入<code>localhost:8080</code>，点击<code>获取数据</code>，浏览器控制台打印出<code>hxr</code></p>
<p><img src="https://img-blog.csdnimg.cn/2019121118284076.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDE2ODY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>前后端</tag>
      </tags>
  </entry>
  <entry>
    <title>ecxel导出</title>
    <url>/2020/03/23/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/ecxel%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>ecxel导出</p>
<span id="more"></span>

<h1 id="ecxel导出"><a href="#ecxel导出" class="headerlink" title="ecxel导出"></a>ecxel导出</h1><ul>
<li><p>maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.5.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>后端</p>
<ul>
<li><p>controller接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiOperation(value = &quot;数据导出--待完成&quot;, notes = &quot;数据导出&quot;, httpMethod = &quot;POST&quot;)</span><br><span class="line">    @PostMapping(value = &quot;/excel/export&quot;, headers = &quot;Accept=application/octet-stream&quot;)</span><br><span class="line">    public void export(@ApiParam HttpServletResponse response,@RequestBody String matrixId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(matrixId);</span><br><span class="line">            bodyService.excelExport(response);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;批量导出失败！&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>serviceImpl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 矩阵管理-数据导出</span><br><span class="line">     *</span><br><span class="line">     * @param response</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void excelExport(HttpServletResponse response) &#123;</span><br><span class="line">        // 创建excel表格数据</span><br><span class="line">        ArrayList&lt;Map&lt;String, Object&gt;&gt; rows = createExcelData();</span><br><span class="line"></span><br><span class="line">        ExcelWriter writer = ExcelUtil.getWriter(false);</span><br><span class="line">        OutputStream out = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 一次性写出内容，强制输出标题</span><br><span class="line">            writer.write(rows, true);</span><br><span class="line">            // 矩阵名称 TODO</span><br><span class="line">            String fileName = URLEncoder.encode(&quot;数据导出&quot;, &quot;UTF-8&quot;);</span><br><span class="line">            response.setContentType(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8&quot;);</span><br><span class="line">            response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileName + &quot;.xls&quot;);</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            writer.flush(out, true);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">            IoUtil.close(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 创建excel表格数据 TODO 1.添加隐藏列，校验动态列 2.下拉框</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private ArrayList&lt;Map&lt;String, Object&gt;&gt; createExcelData() &#123;</span><br><span class="line"></span><br><span class="line">        // 创建excel表格数据</span><br><span class="line">        Map&lt;String, Object&gt; row = new LinkedHashMap&lt;&gt;();</span><br><span class="line">        row.put(&quot;序号&quot;, &quot;1&quot;);</span><br><span class="line">        row.put(&quot;组织单元编码&quot;, &quot;A020&quot;);</span><br><span class="line">        row.put(&quot;组织单元&quot;, &quot;集团总部 / 人力资源部&quot;);</span><br><span class="line">        row.put(&quot;岗位编码&quot;, &quot;P001&quot;);</span><br><span class="line">        row.put(&quot;岗位名称&quot;, &quot;COE&quot;);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Map&lt;String, Object&gt;&gt; rows = CollUtil.newArrayList();</span><br><span class="line">        rows.add(row);</span><br><span class="line">        return rows;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>postMan测试</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Owcn83oxq94r7YQ.png" alt="img"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>ecxel操作</tag>
      </tags>
  </entry>
  <entry>
    <title>参数校验</title>
    <url>/2021/06/10/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>参数校验</p>
<span id="more"></span>

<h1 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h1><p>客户端校验和服务端校验</p>
<h2 id="客户端校验"><a href="#客户端校验" class="headerlink" title="客户端校验"></a>客户端校验</h2><p>客户端校验：提示用户正确输入，密码的输入等准确性来加强用户体验。</p>
<h2 id="服务端校验"><a href="#服务端校验" class="headerlink" title="服务端校验"></a>服务端校验</h2><p>服务端校验即接口校验：更多的是为了接口安全，数据库安全，防止非法用户。</p>
<p>java规范:JSR-303</p>
<h3 id="为什么对接口参数校验"><a href="#为什么对接口参数校验" class="headerlink" title="为什么对接口参数校验"></a>为什么对接口参数校验</h3><ul>
<li><p>数据库汇中字段对应的数据，应该遵循业务要求和数据库设计</p>
</li>
<li><p>防止（减小）范围外的输入的数据入库后影响业务正常运行的风险</p>
</li>
<li><p>数据来源是接口，从入口处（接口）进行校验。</p>
</li>
</ul>
<h3 id="如何进行接口参数校验实现"><a href="#如何进行接口参数校验实现" class="headerlink" title="如何进行接口参数校验实现"></a>如何进行接口参数校验实现</h3><h4 id="使用-Valid"><a href="#使用-Valid" class="headerlink" title="使用@Valid"></a>使用@Valid</h4><p>spring基于规范的实现：@Valid，对@Valid的扩展：@Validated</p>
<p>注解 springboot中@Validated @Valid，通过注解的方法，在实体上加注解。</p>
<ol>
<li><p>非实体校验</p>
<p>   形参校验注解（@NotBlank、@NotNull等）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result delete(@RequestParam @NotBlank(message = &quot;主键不能为空&quot;) String id)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实体校验</p>
<p>   @Validated + 属性校验注解（@NotBlank、@NotNull等）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result update(@RequestBody @Validated UserUpdateVO data) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class UserUpdateVO &#123;</span><br><span class="line">   </span><br><span class="line">    @NotBlank(message = &quot;id不能为空&quot;)</span><br><span class="line">    private String id;</span><br><span class="line">   </span><br><span class="line">    @NotNull(message = &quot;小数位数不能为空&quot;)</span><br><span class="line"> @Max(value = 2,message = &quot;小数位数格式错误&quot;)</span><br><span class="line">    @Min(value = 0, message = &quot;小数位数格式错误&quot;)</span><br><span class="line">    private Integer decimalDigits;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>List<Bean>校验</p>
<p>@Valid + ValidList</p>
<p>@Valid 起嵌套校验的作用</p>
<p>原Controller方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result add(@RequestBody List&lt;实体&gt; data) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>List是jdk的接口。@Valid，@Validated 无法校验非实体Bean.</p>
<p>校验List&lt;实体&gt;的方法。 定义ValidList 实现List接口。List&lt;实体&gt; → ValidList&lt;实体&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result add( @RequestBody @Valid ValidList&lt;实体&gt; data) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ValidList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Valid</span><br><span class="line">    private List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    public ValidList() &#123;</span><br><span class="line">        this.list = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ValidList(List&lt;E&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;E&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;E&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return list.contains(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return list.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return list.toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        return list.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return list.containsAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return list.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return list.addAll(index, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return list.removeAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return list.retainAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        return list.set(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        return list.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        return list.indexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int lastIndexOf(Object o) &#123;</span><br><span class="line">        return list.lastIndexOf(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator() &#123;</span><br><span class="line">        return list.listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">        return list.listIterator(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">        return list.subList(fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实体内List校验</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result update(@RequestBody @Validated UserUpdateVO data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class UserUpdateVO &#123;</span><br><span class="line"></span><br><span class="line">	@NotBlank(message = &quot;id不能为空&quot;)</span><br><span class="line">	private String id;</span><br><span class="line"></span><br><span class="line">	@NotNull(message = &quot;小数位数不能为空&quot;)</span><br><span class="line">	@Max(value = 2,message = &quot;小数位数格式错误&quot;)</span><br><span class="line">	@Min(value = 0, message = &quot;小数位数格式错误&quot;)</span><br><span class="line">	private Integer decimalDigits;</span><br><span class="line">	</span><br><span class="line">	@Size(min = 1,message = &quot;角色不能为空&quot;)</span><br><span class="line">    @Valid</span><br><span class="line">    // @Valid 开启递归校验Role</span><br><span class="line">	private List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Role&#123;</span><br><span class="line">	</span><br><span class="line">	@NotBlank(message = &quot;角色不能为空&quot;)</span><br><span class="line">	private String roleId;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="通过工具类"><a href="#通过工具类" class="headerlink" title="通过工具类"></a>通过工具类</h4><p>RegexUtils.java</p>
<p>将常用的校验方法放在一个类中，然后哪个参数需要校验，就调用工具类中的方法。</p>
<h3 id="校验失败处理"><a href="#校验失败处理" class="headerlink" title="校验失败处理"></a>校验失败处理</h3><p>使用全局异常捕获。 使用 @ControllerAdvice 分别定义方法，捕获并处理MethodArgumentNotValidException、BindException、ConstraintViolationException</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.hibernate.validator.internal.engine.path.PathImpl;</span><br><span class="line">import org.springframework.validation.BindException;</span><br><span class="line">import org.springframework.validation.BindingResult;</span><br><span class="line">import org.springframework.validation.FieldError;</span><br><span class="line">import org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line">import org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">import javax.validation.ConstraintViolation;</span><br><span class="line">import javax.validation.ConstraintViolationException;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 参数异常处理</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = MethodArgumentNotValidException.class)</span><br><span class="line">    public Result handleValidException(MethodArgumentNotValidException e) &#123;</span><br><span class="line">        BindingResult bindingResult = e.getBindingResult();</span><br><span class="line">        String message = null;</span><br><span class="line">        if (bindingResult.hasErrors()) &#123;</span><br><span class="line">            FieldError fieldError = bindingResult.getFieldError();</span><br><span class="line">            if (fieldError != null) &#123;</span><br><span class="line">                message = fieldError.getField() + fieldError.getDefaultMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.validateFailed(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = BindException.class)</span><br><span class="line">    public Result handleValidException(BindException e) &#123;</span><br><span class="line">        BindingResult bindingResult = e.getBindingResult();</span><br><span class="line">        String message = null;</span><br><span class="line">        if (bindingResult.hasErrors()) &#123;</span><br><span class="line">            FieldError fieldError = bindingResult.getFieldError();</span><br><span class="line">            if (fieldError != null) &#123;</span><br><span class="line">                message = fieldError.getField() + fieldError.getDefaultMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.validateFailed(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = ConstraintViolationException.class)</span><br><span class="line">    public Result handleValidException(ConstraintViolationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.info(&quot;全局异常捕获：&#123;&#125;&quot;, e.getStackTrace());</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = e.getConstraintViolations();</span><br><span class="line">        for (ConstraintViolation&lt;?&gt; constraintViolation : constraintViolations) &#123;</span><br><span class="line">            PathImpl pathImpl = (PathImpl) constraintViolation.getPropertyPath();</span><br><span class="line">            // 读取参数字段，constraintViolation.getMessage() 读取验证注解中的message值</span><br><span class="line">            String paramName = pathImpl.getLeafNode().getName();</span><br><span class="line">            String message = constraintViolation.getMessage();</span><br><span class="line">            return Result.validateFailed(message);</span><br><span class="line">        &#125;</span><br><span class="line">        return Result.validateFailed(e.getMessage());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用校验注解"><a href="#常用校验注解" class="headerlink" title="常用校验注解"></a>常用校验注解</h3><table>
<thead>
<tr>
<th>空校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Null</td>
<td>任何类型</td>
<td>校验对象必须为空</td>
</tr>
<tr>
<td>@NotNull</td>
<td>任何类型</td>
<td>校验对象不为空，不能校验字符串长度为0的对象</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>字符串</td>
<td>只对字符串有效，校验字符串去掉前后空格后长度不为0</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>字符串、集合、数组</td>
<td>校验对象不能为空 (字符串长度不为0、集合大小不为0)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>boolean校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@AssertTrue</td>
<td>布尔</td>
<td>校验boolean类型必须为true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>布尔</td>
<td>校验boolean类型必须为false</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>日期校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Past</td>
<td>日期类型</td>
<td>校验必须是一个过去的日期</td>
</tr>
<tr>
<td>@Future</td>
<td>日期类型</td>
<td>校验必须是一个将来的日期</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>数值校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Min</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须大于或等于指定的最小值</td>
</tr>
<tr>
<td>@Max</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须小于或等于指定的最大值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须大于或等于指定的最小值</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>数字类型</td>
<td>校验必须是一个数字，其值必须小于或等于指定的最大值</td>
</tr>
<tr>
<td>@Digits(integer=,fraction=)</td>
<td>数字类型</td>
<td>校验必须是一个数字，interger指定整数精度，fraction指定小数精度</td>
</tr>
<tr>
<td>@Range(min =,max = )</td>
<td>数字类型、字符串</td>
<td>校验对象的值在min和max区间内</td>
</tr>
<tr>
<td>@Length(min =,max = )</td>
<td>字符串</td>
<td>校验对象的值的长度在min和max区间内</td>
</tr>
<tr>
<td>@Size(min =,max = )</td>
<td>字符串、集合、数组</td>
<td>校验对象的值在min和max区间内，如字符长度、集合大小</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他校验</th>
<th>针对类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Email</td>
<td>字符串</td>
<td>校验对象的值必须是Email类型，也可以通过regexp和flag指定自定义的email格式</td>
</tr>
<tr>
<td>@Pattern</td>
<td>字符串</td>
<td>校验对象的值必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@CreditCardNumber</td>
<td>数字类型、字符串</td>
<td>校验对象的值必须是信用卡类型</td>
</tr>
<tr>
<td>@URL</td>
<td>字符串</td>
<td>校验对象的值必须是URL地址</td>
</tr>
</tbody></table>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><ol>
<li>自己写注解类。</li>
<li>约束规则“分组”（group）</li>
<li>校验方法的返回值</li>
<li>约束规则支持正则表达式</li>
<li>支持跨参数校验 ？</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/sj13074480550/article/details/103399503">https://blog.csdn.net/sj13074480550/article/details/103399503</a></p>
]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>参数校验</tag>
      </tags>
  </entry>
  <entry>
    <title>《渴望生活》读后感</title>
    <url>/2018/05/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%B8%B4%E6%9C%9B%E7%94%9F%E6%B4%BB%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>《渴望生活》即梵高传，描写了温森特·梵高青年到37岁时的生活。</p>
<span id="more"></span>
<p>他人生的每个转折点对我触动都很大。</p>
<p>为讲真话辞职古比尔公司，为了当牧师而努力考大学，努力到每天学18-20个小时。</p>
<p>努力学一年后因觉得上大学后的牧师并不是真的解决需要的人的穷苦人民的疾苦而放弃。然后去学做一名福音传教士。他学习时，不做表面的演讲，努力深入讲解，却因自己学这种太慢而被孤立、欺负。(梵高得这种做法是否就不应该？)</p>
<p>决定去做福音传教士时与老师的对话，老师在人生路对梵高的指点。</p>
<p>被好心的皮特森牧师派到博里纳日煤矿。在煤矿先布道演讲，效果不错。跟着下了一次煤矿后，发现自己太虚伪了，也发现演讲并不实际。(当时的煤矿太苦了，小孩8岁开始下井，20就会的肺病，最多不超过40岁。一直生活在死亡的威胁下。井下很热，不通风，也没法通风，通风意味着不能工作，不工作就没钱，一样会饿死。凌晨3点开始，13个小时的高强度体力活，只就着空气中的煤吃一点面包，奶酪，咖啡。稍上层的煤矿只能弯腰干活，底层只能趴着向前凿。)一次煤矿的塌方，60人的死亡，与煤矿经理的交流，让他彻底失去了上帝。(经理也想提高工资，但做不到，这个矿是最贫的一个矿，提高工资或缩短工作时间，或买安全设备，煤价就会低于市场价，矿主就会撤资，煤矿就会倒闭。最终工人会没有活干，没有钱。)</p>
<p>生病一段时间（大概一个月）后开始素描。</p>
<p>他每次有了自己想做的事后都很疯狂，每天只睡很短的时间，其余时间就是工作。</p>
<p>在家乡画画被村民称作二流子，说他该干正经事了。村民异样的眼光，精神的压力。(疑惑:自己的生活别人无法理解，并实施干扰时，怎么办？梵高当时想逃离，但在家乡的工作还没完成。)</p>
<p>想拜毛威表哥为师时毛威表哥的推辞，毛威表哥的严肃。毛威的独白：艺术家都是自私的，尤其保护自己工作的时间，除非能互相帮忙，不然不会要一个累赘。我并不经常有那种想要谈论自己创作的欲望。</p>
<p>在阿尔这个地方，他因为长期不带帽子暴露在强烈的阳光下作画，得了三个月一犯的精神病。（这的阳光特别毒）</p>
<p>最后，从阿尔的疗养院回巴黎后，在伽塞大夫那画了一些画后，梵高什么也不想画了，他已把自己要表现的都表现了。到了一个星期两幅油画，还不是完全想画。(之前都是一天至少一幅。)自己想做的事做完了，也就枯竭了。</p>
<p>如果自己能懂一些画画、油画、欧洲文化，就能更读懂书中艺术家作画，争论画，争论自己画画的理论的心情。</p>
<p>其实看这本书前面触动大，后边少，后边就是一直在描述主角不被人理解自己的画。但好像只是接触到这么一种没见过的情景的触动，对我自己并没有什么影响。（尤其与人类简史、未来简史、孤独的行路人相比较，这几本书都改变了我很多的思想。）不过这本书更完整，鲜活。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>读后感</tag>
        <tag>传记</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis两种开发方式-Mybatis</title>
    <url>/2019/10/22/213Java%E6%A1%86%E6%9E%B6/Mybatis/Mybatis-Mybatis%E4%B8%A4%E7%A7%8D%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Mybatis两种开发方式</p>
<span id="more"></span>

<h1 id="Mybatis两种开发方式"><a href="#Mybatis两种开发方式" class="headerlink" title="Mybatis两种开发方式"></a>Mybatis两种开发方式</h1><h2 id="1-xml开发："><a href="#1-xml开发：" class="headerlink" title="1.xml开发："></a>1.xml开发：</h2><h3 id="1-全局配置文件"><a href="#1-全局配置文件" class="headerlink" title="1.全局配置文件"></a>1.全局配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载属性文件 --&gt;</span><br><span class="line">    &lt;properties resource=&quot;config.properties&quot;&gt;</span><br><span class="line">        &lt;!--properties中还可以配置一些属性名和属性值 --&gt;</span><br><span class="line">        &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 全局配置参数，需要时再设置 --&gt;</span><br><span class="line">    &lt;!-- &lt;settings&gt; &lt;/settings&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;!-- 别名定义 --&gt;</span><br><span class="line">        &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名，类名不能写错</span><br><span class="line">         别名可以随便起，但最好规范--&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;xiaoruiit.mybatis_introduction.pojo.User&quot; alias=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">        &lt;package name=&quot;xiaoruiit.mybatis_introduction.pojo&quot; /&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理，事务控制由mybatis --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池，由mybatis管理 --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载映射文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--通过resource方法一次加载一个映射文件 --&gt;</span><br><span class="line">        &lt;!--注意这里的路径和xml文件 --&gt;</span><br><span class="line">        &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 --&gt;</span><br><span class="line">        &lt;!-- 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 --&gt;</span><br><span class="line">        &lt;!-- 中上边规范的前提是：使用的是mapper代理方法</span><br><span class="line">        &lt;package name=&quot;....&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>​    <code>properties</code>配置数据库属性,可覆盖<code>property</code>,<code>dataSource</code>中的<code>value</code>需要增加jdbc前缀，否则可能读取到windows系统的配置</p>
<p>​    <code>typeAliases</code>配置别名</p>
<p>​    <code>mappers</code>配置mapper.xml所在位置</p>
<h3 id="2-Mapper接口-即dao"><a href="#2-Mapper接口-即dao" class="headerlink" title="2.***Mapper接口,即dao"></a>2.<code>***Mapper</code>接口,即dao</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">	User findUserById(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Mapper-xml"><a href="#3-Mapper-xml" class="headerlink" title="3.***Mapper.xml"></a>3.<code>***Mapper.xml</code></h3><p>​    <code>namespace</code>对应<code>***Mapper</code>接口所在路径</p>
<p>​    id对应Mapper接口方法名</p>
<p>​    <code>parameterType</code>对应Mapper接口的参数类型</p>
<p>​    <code>resultType</code>对应Mapper接口的返回值类型，可以使用全局配置文件的别名<code>typeAliases</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;xiaoruiit.mybatis_introduction.dao.UserMapper&quot;&gt;</span><br><span class="line">	&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">		SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>输入映射<code>parameterType</code>：</p>
<ul>
<li><p>简单类型，java</p>
</li>
<li><p>pojo类型、map类型，两种类型一样的处理</p>
</li>
<li><p>List类型，List里边是什么类型就放什么类型</p>
</li>
<li><p>pojo包装pojo类型 </p>
</li>
</ul>
</li>
<li><p>输出映射<code>resultType</code>、<code>resultMap</code></p>
<ul>
<li>``resultType`可映射简单类型、pojo类型、Map类型</li>
<li><code>resultMap</code>可实现，查询列和属性不一致、关联关系，延迟加载</li>
</ul>
</li>
</ol>
<p><code>resultMap</code>：需要单独写resultMap标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义resultMap：将查询的列名和映射的pojo的属性名做一个对应关系 --&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">	 	 type：指定查询结果要映射的pojo的类型</span><br><span class="line">	 	 id：指定resultMap的唯一标示</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;resultMap type=&quot;user&quot; id=&quot;userListResultMap&quot;&gt;</span><br><span class="line">	 	 &lt;!--</span><br><span class="line">	 	 id标签：映射查询结果的唯一列（主键列）</span><br><span class="line">	 	 	 column：查询sql的列名</span><br><span class="line">	 	 	 property：映射结果的属性名</span><br><span class="line">	 	 --&gt;</span><br><span class="line">	 	 &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">	 	 &lt;!-- result标签：映射查询结果的普通列 --&gt;</span><br><span class="line">	 	 &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;birthday_&quot; property=&quot;birthday&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!-- resultMap入门 --&gt;</span><br><span class="line">&lt;select id=&quot;findUserListResultMap&quot; resultMap=&quot;userListResultMap&quot;&gt;</span><br><span class="line">	 	 SELECT id id_,username username_,birthday birthday_ FROM user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>加载全局配置文件</p>
<p>获取sqlSessionFactory对象，通过sqlSessionFactory的getMapper获取业务对象mapper，</p>
<p>mapper对象执行Mapper接口的实际业务相关的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void init() throws Exception &#123;</span><br><span class="line">    // 加载全局配置文件（同时把映射文件也加载了）</span><br><span class="line">    String resource = &quot;phase02/SqlMapConfig.xml&quot;;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    // sqlsessionFactory需要通过sqlsessionFactoryBuilder读取全局配置文件信息之后</span><br><span class="line">    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void testFindUserById() &#123;</span><br><span class="line">    //创建UserMapper对象</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    //调用UserMapper对象的API</span><br><span class="line">    User user = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-注解开发"><a href="#2-注解开发" class="headerlink" title="2.注解开发"></a>2.注解开发</h2><h3 id="1-全局配置文件-1"><a href="#1-全局配置文件-1" class="headerlink" title="1.全局配置文件"></a>1.全局配置文件</h3><p>和XML方式一样,不需要配置mappers属性</p>
<h3 id="2-Mapper接口"><a href="#2-Mapper接口" class="headerlink" title="2.***Mapper接口"></a>2.***Mapper接口</h3><p>接口方法</p>
<p>接口方法上写注解，不需要xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查询</span><br><span class="line">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span><br><span class="line">public User findUserById(int id);</span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><p>和XML方式一样</p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-入门</title>
    <url>/2019/10/21/213Java%E6%A1%86%E6%9E%B6/Mybatis/Mybatis-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>使用mybatis从数据库中通过User类的id查询出user</p>
<span id="more"></span>

<p>中文官网：<a href="http://www.mybatis.org/mybatis-3/zh/index.html">www.mybatis.org/mybatis-3/zh/index.html</a></p>
<p><strong>目标：</strong>使用mybatis从数据库中通过User类的id查询出user</p>
<p><strong>介绍：</strong>优秀的持久层框架，支持定制化SQL、存储过程、高级映射。</p>
<p><strong>Implement</strong></p>
<h2 id="1-新建Maven项目"><a href="#1-新建Maven项目" class="headerlink" title="1.新建Maven项目"></a>1.新建Maven项目</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/AoXgIEdWjDHr8h7.png" alt="image-20200523210231180"></p>
<h2 id="2-导入Mybatis的jar包"><a href="#2-导入Mybatis的jar包" class="headerlink" title="2.导入Mybatis的jar包"></a>2.导入Mybatis的jar包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- mybatis核心包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- mysql驱动包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.29&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- junit测试包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 日志文件管理包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-User类"><a href="#3-User类" class="headerlink" title="3.User类"></a>3.User类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname User</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-创建数据库"><a href="#4-创建数据库" class="headerlink" title="4.创建数据库"></a>4.创建数据库</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/8WFmVBPRbQq7y5U.png" alt="image-20200523184805091"></p>
<h2 id="5-Mybatis全局配置文件"><a href="#5-Mybatis全局配置文件" class="headerlink" title="5.Mybatis全局配置文件"></a>5.Mybatis全局配置文件</h2><p>resource下新建config.properties和mybatis-config.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.driver = com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url = jdbc:mysql://127.0.0.1:3306/mybatis?characterEncoding=UTF-8</span><br><span class="line">jdbc.username = root</span><br><span class="line">jdbc.password = 123456</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载属性文件 --&gt;</span><br><span class="line">    &lt;properties resource=&quot;config.properties&quot;&gt;</span><br><span class="line">        &lt;!--properties中还可以配置一些属性名和属性值 --&gt;</span><br><span class="line">        &lt;!-- &lt;property name=&quot;jdbc.driver&quot; value=&quot;&quot;/&gt; --&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 全局配置参数，需要时再设置 --&gt;</span><br><span class="line">    &lt;!-- &lt;settings&gt; &lt;/settings&gt; --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;!-- 别名定义 --&gt;</span><br><span class="line">        &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名，类名不能写错</span><br><span class="line">         别名可以随便起，但最好规范--&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;xiaoruiit.mybatis_introduction.pojo.User&quot; alias=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以） --&gt;</span><br><span class="line">        &lt;package name=&quot;xiaoruiit.mybatis_introduction.pojo&quot; /&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除 --&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理，事务控制由mybatis --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池，由mybatis管理 --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 加载映射文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--通过resource方法一次加载一个映射文件 --&gt;</span><br><span class="line">        &lt;!--注意这里的路径和xml文件 --&gt;</span><br><span class="line">        &lt;mapper resource=&quot;UserMapper.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 --&gt;</span><br><span class="line">        &lt;!-- 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 --&gt;</span><br><span class="line">        &lt;!-- 中上边规范的前提是：使用的是mapper代理方法</span><br><span class="line">        &lt;package name=&quot;....&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-Mapper-xml配置文件-sql语句"><a href="#6-Mapper-xml配置文件-sql语句" class="headerlink" title="6.***Mapper.xml配置文件(sql语句)"></a>6.***Mapper.xml配置文件(sql语句)</h2><p>resource下新建UserMapper.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 在映射文件中配置很多sql语句 --&gt;</span><br><span class="line">    &lt;!-- 将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt;</span><br><span class="line">    &lt;!-- parameterType：指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符号 --&gt;</span><br><span class="line">    &lt;!-- #&#123;id&#125;：其中的id表示接收输入的参数，参数名称就是id，如果输入 --&gt;</span><br><span class="line">    &lt;!-- 参数是简单类型，#&#123;&#125;中的参数名可以任意，可以value或其它名称 --&gt;</span><br><span class="line">    &lt;!-- resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。 --&gt;</span><br><span class="line">    &lt;!-- 表名要对，但是不区分大小写，resultType要写类名，同样不区分大小写 user对应mybatis-config里边的typeAliases别名属性--&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot;  resultType=&quot;user&quot;&gt;</span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7-单元测试"><a href="#7-单元测试" class="headerlink" title="7.单元测试"></a>7.单元测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import xiaoruiit.mybatis_introduction.pojo.User;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname UserTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">    public SqlSessionFactory getSqlSessionFactory() throws IOException &#123;</span><br><span class="line">        // mybatis配置文件，这个地方的root地址为：resources，路径要对。</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        // 得到配置文件流</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        // 创建会话工厂，传入mybatis的配置文件信息</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据id查询用户信息，得到一条记录结果</span><br><span class="line">    @Test</span><br><span class="line">    public void findUserByIdTest() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 通过工厂得到SqlSession</span><br><span class="line">        SqlSession sqlSession = this.getSqlSessionFactory().openSession();</span><br><span class="line"></span><br><span class="line">        // 通过SqlSession操作数据库</span><br><span class="line">        // 第一个参数：映射文件中statement的id，等于=namespace+&quot;.&quot;+statement的id</span><br><span class="line">        // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数</span><br><span class="line">        // sqlSession.selectOne结果 是与映射文件中所匹配的resultType类型的对象</span><br><span class="line"></span><br><span class="line">        // selectOne查询出一条记录（这种很麻烦的！！！往后看看）</span><br><span class="line">        //这里的参数test.findUserById，test为命名空间，要与user.xml中的对应起来，</span><br><span class="line">        //同理，findUserById也要在user.xml中存在，不然都会报错</span><br><span class="line"></span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);</span><br><span class="line"></span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        // 释放资源</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">zs</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>高级特性</title>
    <url>/2019/10/23/213Java%E6%A1%86%E6%9E%B6/Mybatis/Mybatis-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>高级特性，包括关联查询、延迟加载、动态SQL、缓存、逆向工程、PageHelper分页插件</p>
<span id="more"></span>

<h1 id="1-关联查询"><a href="#1-关联查询" class="headerlink" title="1.关联查询"></a>1.关联查询</h1><h2 id="1-一对一"><a href="#1-一对一" class="headerlink" title="1.一对一"></a>1.一对一</h2><p>例子：一个order订单对应一个user</p>
<p>需要创建专门的结果映射类，OrderExt，里边有User属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OrdersExt extends Orders &#123;</span><br><span class="line"> private User user;// 用户对象</span><br><span class="line">// get/set。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resultMap配置普通的OrderExp的属性+User属性</p>
<ul>
<li><p>​    普通属性直接用result</p>
</li>
<li><p>​    User属性用association内嵌result</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查询订单关联用户信息使用resultmap --&gt;</span><br><span class="line">&lt;resultMap type=&quot;OrdersExt&quot; id=&quot;ordersAndUserRstMap&quot;&gt;</span><br><span class="line">	 	 &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">	 	 &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;</span><br><span class="line">	 	 &lt;!-- 一对一关联映射 --&gt;</span><br><span class="line">	 	 &lt;!--</span><br><span class="line">	 	 property:Orders对象的user属性</span><br><span class="line">	 	 javaType：user属性对应 的类型</span><br><span class="line">	 	 --&gt;</span><br><span class="line">	 	 &lt;association property=&quot;user&quot; javaType=&quot;com.kkb.mybatis.po.User&quot;&gt;</span><br><span class="line">	 	 	 &lt;!-- column:user表的主键对应的列 property：user对象中id属性--&gt;</span><br><span class="line">	 	 	 &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;</span><br><span class="line">	 	 &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;findOrdersAndUserRstMap&quot; resultMap=&quot;ordersAndUserRstMap&quot;&gt;</span><br><span class="line">	 	 SELECT</span><br><span class="line">	 	 	 o.id,</span><br><span class="line">	 	 	 o.user_id,</span><br><span class="line">	 	 	 o.number,</span><br><span class="line">	 	 	 o.createtime,</span><br><span class="line">	 	 	 o.note,</span><br><span class="line">	 	 	 u.username,</span><br><span class="line">	 	 	 u.address</span><br><span class="line">	 	 FROM</span><br><span class="line">	 	 	 orders o</span><br><span class="line">	 	 JOIN `user` u ON u.id = o.user_id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2.一对多"></a>2.一对多</h2><p>例子：一个用户有多个订单</p>
<p>User类中有<code>List&lt;Orders&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String  username;</span><br><span class="line">	private String sex;</span><br><span class="line">	private Date birthday;</span><br><span class="line">	private String address;</span><br><span class="line">	private List&lt;Orders&gt; orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resultMap配置User的普通属性+<code>List&lt;Orders&gt;</code>属性</p>
<ul>
<li>普通属性用result</li>
<li><code>List&lt;Orders&gt;</code>用collection,collection的返回类型用ofType配置为List内的泛型orders</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type=&quot;user&quot; id=&quot;userAndOrderRstMap&quot;&gt;</span><br><span class="line">	 	 &lt;!-- 用户信息映射 --&gt;</span><br><span class="line">	 	 &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;</span><br><span class="line">	 	 &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;</span><br><span class="line">	 	 &lt;!-- 一对多关联映射 --&gt;</span><br><span class="line">	 	 &lt;collection property=&quot;orders&quot; ofType=&quot;orders&quot;&gt;</span><br><span class="line">	 	 	 &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt;</span><br><span class="line">	 	 	 &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt;</span><br><span class="line">	 	 &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;findUserAndOrderRstMap&quot; resultMap=&quot;userAndOrderRstMap&quot;&gt;</span><br><span class="line">	 	 SELECT</span><br><span class="line">	 	 u.*,</span><br><span class="line"> o.id oid,</span><br><span class="line">	 	 o.number,</span><br><span class="line">	 	 o.createtime,</span><br><span class="line">	 	 o.note</span><br><span class="line">	 	 FROM</span><br><span class="line">	 	 `user` u</span><br><span class="line">	 	 LEFT JOIN orders o ON u.id = o.user_id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h1 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2.延迟加载"></a>2.延迟加载</h1><p>延迟加载，也称为懒加载，关联查询时，推迟查询关联对象的查询。</p>
<p>目的：减少数据库的压力。</p>
<p>分类：直接加载、侵入式加载、深度延迟加载</p>
<p>存在的问题：深度加载存在N+1的问题。深度加载的实现是主查询+N次子查询，会发送N次SQL子查询语句。子查询记录比较多时，发送SQL子查询语句很消耗资源。</p>
<p>使用：需要resultMap中的association和collection子标签，主配置文件中settings配置延迟加载<code>lazyLoadingEnabled</code>和<code>aggressiveLazyLoading</code>，resultMap子标签也可开启延迟加载属性<code>fetchType</code>，子标签的<code>fetchType</code>可覆盖全局属性</p>
<p><strong>直接加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;!-- 延迟加载总开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p><strong>侵入式延迟加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;!-- 延迟加载总开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line"> &lt;!-- 侵入式延迟加载开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p><strong>深度延迟加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line"> &lt;!-- 延迟加载总开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line"> &lt;!-- 侵入式延迟加载开关 --&gt;</span><br><span class="line"> &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<h1 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3.缓存"></a>3.缓存</h1><h2 id="1-一级缓存"><a href="#1-一级缓存" class="headerlink" title="1.一级缓存"></a>1.一级缓存</h2><p>默认开启，作用域：同一个sqlsession中。修改和删除会清除缓存。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOneLevelCache() &#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库</span><br><span class="line">    User user1 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    // 第二次查询ID为1的用户</span><br><span class="line">    User user2 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testOneLevelCache() &#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库</span><br><span class="line">    User user1 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setUsername(&quot;隔壁老詹1&quot;);</span><br><span class="line">    user.setAddress(&quot;洛杉矶湖人&quot;);</span><br><span class="line">    //执行增删改操作，清空缓存</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">    // 第二次查询ID为1的用户</span><br><span class="line">    User user2 = mapper.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-二级缓存"><a href="#2-二级缓存" class="headerlink" title="2.二级缓存"></a>2.二级缓存</h2><p>默认不开启，作用域：同一个Mapper（namespace）中。不同的sqlsseion可查询到同一个Mapper缓存中的数据。</p>
<p>开启方式：全局配置settings+namespace配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启二级缓存总开关 --&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启本mapper下的namespace的二级缓存，默认使用的是mybatis提供的PerpetualCache --&gt;</span><br><span class="line">&lt;cache&gt;&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<p>一般不用，二级缓存控制粒度较粗，同一个namespace中执行任何增删改都会清除缓存。</p>
<p>二级缓存的数据不一定都是存储到内存中  ，比如文件系统 ，二级缓存相关的类和父类需要实现序列化。</p>
<p>一种办法：namespace中只存放查询语句。不清楚其他地方修改了数据库中此namespace中的记录，是否会读到脏数据？</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testTwoLevelCache() &#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">    SqlSession sqlSession3 = sqlSessionFactory.openSession();</span><br><span class="line">    UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line">    UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class);</span><br><span class="line">    // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库</span><br><span class="line">    User user1 = mapper1.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    // 关闭SqlSession1</span><br><span class="line">    sqlSession1.close();</span><br><span class="line">    // 第二次查询ID为1的用户</span><br><span class="line">    User user2 = mapper2.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    // 关闭SqlSession2</span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-动态SQL"><a href="#4-动态SQL" class="headerlink" title="4.动态SQL"></a>4.动态SQL</h1><p>解决：字符串的拼接处理、循环判断。  </p>
<h2 id="1-if标签"><a href="#1-if标签" class="headerlink" title="1.if标签"></a>1.if标签</h2><p>queryvo中封装有user对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    SELECT * FROM user where 1=1</span><br><span class="line">    &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">        	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-where标签"><a href="#2-where标签" class="headerlink" title="2.where标签"></a>2.where标签</h2><p>解决 if标签内容开头规定为AND，where 后需要 1 = 1，解决1=1的性能问题 。1=1时不使用索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    &lt;!-- where标签会处理它后面的第一个and --&gt;</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">            &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-SQL片段复用"><a href="#3-SQL片段复用" class="headerlink" title="3.SQL片段复用"></a>3.SQL片段复用</h2><p>include标签，提取可复用代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;query_user_where&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">        	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sq</span><br></pre></td></tr></table></figure>

<p>使用include标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用包装类型查询用户 使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内</span><br><span class="line">容部的属性 --&gt;</span><br><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;queryVo&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    &lt;!-- where标签会处理它后面的第一个and --&gt;</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">    	&lt;include refid=&quot;query_user_where&quot;&gt;&lt;/include&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>引用其他Mapper标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;namespace.sql片段”/&gt;  </span><br></pre></td></tr></table></figure>

<h2 id="4-foreach标签"><a href="#4-foreach标签" class="headerlink" title="4.foreach标签"></a>4.foreach标签</h2><p>需求：综合查询时，传入多个id查询用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM USER WHERE username LIKE &#x27;%老郭%&#x27; AND id IN (1,10,16)</span><br></pre></td></tr></table></figure>

<p>pojo中添加<code>List&lt;Interger&gt; ids</code>属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class QueryVo &#123;</span><br><span class="line">	private User user;</span><br><span class="line">	private List&lt;Interger&gt; ids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;query_user_where&quot;&gt;</span><br><span class="line">    &lt;if test=&quot;user != null&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;user.username != null and user.username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">        	AND username like &#x27;%$&#123;user.username&#125;%&#x27;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt;</span><br><span class="line">        &lt;!-- collection： 指定输入的集合参数的参数名称 --&gt;</span><br><span class="line">        &lt;!-- item： 声明集合参数中的元素变量名 --&gt;</span><br><span class="line">        &lt;!-- open： 集合遍历时，需要拼接到遍历sql语句的前面 --&gt;</span><br><span class="line">        &lt;!-- close： 集合遍历时，需要拼接到遍历sql语句的后面 --&gt;</span><br><span class="line">        &lt;!-- separator： 集合遍历时，需要拼接到遍历sql语句之间的分隔符号 --&gt;</span><br><span class="line">        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot; AND id IN ( &quot;</span><br><span class="line">            close=&quot; ) &quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<h1 id="5-逆向工程"><a href="#5-逆向工程" class="headerlink" title="5.逆向工程"></a>5.逆向工程</h1><p><strong>功能：</strong>可以依据数据库表生成User实体类、UserExample扩展类、UserMapper接口、UserMapper.xml。UserMapper.xml包括增删改查。不可自动实现部分：一对一、一对多映射。</p>
<p><strong>如何使用：</strong>导入逆向工程项目，配置生成的各个类的路径，执行逆向工程main函数。</p>
<p><strong>配置文件：</strong></p>
<ol>
<li><p>修改要生成的数据库表</p>
</li>
<li><p>pojo文件所在包路径</p>
</li>
<li><p>Mapper所在的包路径  </p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;commentGenerator&gt;&lt;!-- 是否去除自动生成的注释 true： 是 ： false:否 --&gt;</span><br><span class="line">        	&lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        	connectionURL=&quot;jdbc:mysql://localhost:3306/ssm&quot; userId=&quot;root&quot;</span><br><span class="line">        	password=&quot;root&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;</span><br><span class="line">        	connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;</span><br><span class="line">        	userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt;</span><br><span class="line">        &lt;!-- 默认false， 把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer， 为 true时</span><br><span class="line">        	把JDBC DECIMAL和 NUMERIC 类型解析为java.math.BigDecimal --&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">        	&lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line">        &lt;!-- targetProject:生成PO类的位置 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.kkb.ms.po&quot; targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.kkb.ms.mapper&quot; targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- targetPackage： mapper接口生成的位置 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.kkb.ms.mapper&quot; targetProject=&quot;.\src&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 指定数据库表 --&gt;</span><br><span class="line">        &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table schema=&quot;&quot; tableName=&quot;order&quot;&gt;&lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>

<h1 id="6-分页插件PageHelper"><a href="#6-分页插件PageHelper" class="headerlink" title="6.分页插件PageHelper"></a>6.分页插件PageHelper</h1><p><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/en/HowToUse.md">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/en/HowToUse.md</a></p>
<p>功能：分页</p>
<p>原理：实现Mybatis预留的分页接口。</p>
<p>使用：</p>
<p>​    导入jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置全局配置文件plugins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;</span><br><span class="line">        &lt;!-- config params as the following --&gt;</span><br><span class="line">        &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取第1页， 每页10条内容，默认查询总数count</span><br><span class="line">PageHelper.startPage(1, 10);</span><br><span class="line">//增加上边一行后，此处的返回的list变为PageHelper提供的Page对象。</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectAll();</span><br><span class="line">//用PageInfo对结果进行包装</span><br><span class="line">PageInfo page = new PageInfo(list);</span><br><span class="line">//测试PageInfo全部属性</span><br><span class="line">//PageInfo包含了非常全面的分页属性</span><br><span class="line">assertEquals(1, page.getPageNum());</span><br><span class="line">assertEquals(10, page.getPageSize());</span><br><span class="line">assertEquals(1, page.getStartRow());</span><br><span class="line">assertEquals(10, page.getEndRow());</span><br><span class="line">assertEquals(183, page.getTotal());</span><br><span class="line">assertEquals(19, page.getPages());</span><br><span class="line">assertEquals(1, page.getFirstPage());</span><br><span class="line">assertEquals(8, page.getLastPage());</span><br><span class="line">assertEquals(true, page.isFirstPage());</span><br><span class="line">assertEquals(false, page.isLastPage());</span><br><span class="line">assertEquals(false, page.isHasPreviousPage());</span><br><span class="line">assertEquals(true, page.isHasNextPage());</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>​    查询语句是使用resultMap进行的嵌套结果映射，则无法使用PageHelper进行分页  </p>
<p><strong><code>PageHelper</code> 安全调用</strong></p>
<ul>
<li><p>不安全：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(1, 10);</span><br><span class="line">List&lt;User&gt; list;</span><br><span class="line">if(param1 != null)&#123;</span><br><span class="line">    list = userMapper.selectIf(param1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    list = new ArrayList&lt;User&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>安全：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list;</span><br><span class="line">if(param1 != null)&#123;</span><br><span class="line">    PageHelper.startPage(1, 10);</span><br><span class="line">    list = userMapper.selectIf(param1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    list = new ArrayList&lt;User&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>高级特性</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-jwt</title>
    <url>/2020/09/18/213Java%E6%A1%86%E6%9E%B6/shiro/shiro-jwt/</url>
    <content><![CDATA[<p>学习官网10分钟教程</p>
<span id="more"></span>

<h1 id="shiro-jwt"><a href="#shiro-jwt" class="headerlink" title="shiro-jwt"></a>shiro-jwt</h1><p>shiro：Java安全框架,执行身份验证、授权、密码和会话管理。</p>
<p>jwt：客户端与服务端之间验证的一种技术，具体说就是服务器端对每次请求的来源认证。</p>
<h2 id="shiro的三个核心组件"><a href="#shiro的三个核心组件" class="headerlink" title="shiro的三个核心组件"></a>shiro的三个核心组件</h2><p>subject：当前操作用户，也可以是第三方进程、后台帐户。</p>
<p>securityManager：</p>
<p>Realm:提供用户及其权限信息</p>
<h2 id="jwt构成"><a href="#jwt构成" class="headerlink" title="jwt构成"></a>jwt构成</h2><p>header：签名类型和签名算法</p>
<p>payload：存储数据</p>
<p>signature：使用秘钥和算法对header和payload签名。</p>
<h2 id="shiro与jwt整合"><a href="#shiro与jwt整合" class="headerlink" title="shiro与jwt整合"></a>shiro与jwt整合</h2><ol>
<li>编写jwtRealm</li>
<li>将jwtRealm配置到securiManager中</li>
<li>shiro的过滤器处判断  登录请求or jwt请求。</li>
<li>subject.login验证失败后，jwt过期处理。</li>
</ol>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-web</title>
    <url>/2020/09/26/213Java%E6%A1%86%E6%9E%B6/shiro/shiro-web/</url>
    <content><![CDATA[<p>servlet+jsp+shiro</p>
<span id="more"></span>

<h1 id="shiro-web"><a href="#shiro-web" class="headerlink" title="shiro-web"></a>shiro-web</h1><ol>
<li><p>新建模块</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/reVCtPg3pqIbXBQ.png" alt="image-20200926131453085"></p>
</li>
<li><p>导入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-learn&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;chapter4-web&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.23&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;chapter4-web&lt;/finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;8.1.8.v20121106&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;webAppConfig&gt;</span><br><span class="line">                        &lt;contextPath&gt;/$&#123;project.build.finalName&#125;&lt;/contextPath&gt;</span><br><span class="line">                    &lt;/webAppConfig&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;path&gt;/$&#123;project.build.finalName&#125;&lt;/path&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app</span><br><span class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">        version=&quot;3.0&quot;</span><br><span class="line">        metadata-complete=&quot;false&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--- shiro 1.2 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt;&lt;!-- 默认先从/WEB-INF/shiro.ini，如果没有找classpath:shiro.ini --&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:shiro-web.ini&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--&lt;error-page&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;error-code&gt;401&lt;/error-code&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;location&gt;/WEB-INF/jsp/unauthorized.jsp&lt;/location&gt;--&gt;</span><br><span class="line">    &lt;!--&lt;/error-page&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置web环境</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Jqu1VckA3a9NGdI.png" alt="image-20200926193310648"></p>
</li>
<li><p>配置shiro-web.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">#默认是/login.jsp，配置访问servleturl</span><br><span class="line">authc.loginUrl=/login</span><br><span class="line">roles.unauthorizedUrl=/unauthorized</span><br><span class="line">perms.unauthorizedUrl=/unauthorized</span><br><span class="line"></span><br><span class="line">logout.redirectUrl=/login</span><br><span class="line"></span><br><span class="line">[users]</span><br><span class="line">zhang=123,admin</span><br><span class="line">wang=123</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line">admin=user:*,menu:*</span><br><span class="line"></span><br><span class="line">[urls]</span><br><span class="line">/logout2=logout</span><br><span class="line">/login=anon</span><br><span class="line">/logout=anon</span><br><span class="line">/unauthorized=anon</span><br><span class="line">/static/**=anon</span><br><span class="line"># 需要认证通过</span><br><span class="line">/authenticated=authc</span><br><span class="line"># 需要认证通过，并拥有admin角色</span><br><span class="line">/role=authc,roles[admin]</span><br><span class="line"># 需要认证通过，并拥有user下的create权限</span><br><span class="line">/permission=authc,perms[&quot;user:create&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编写Servlet</p>
<p>LoginServlet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.userServlet;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationException;</span><br><span class="line">import org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line">import org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname LoginServlet</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@WebServlet(name = &quot;loginServelt&quot;, urlPatterns = &quot;/login&quot;)</span><br><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        String error = null;</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">        try &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; catch (UnknownAccountException e) &#123;</span><br><span class="line">            error = &quot;用户名/密码错误&quot;;</span><br><span class="line">        &#125; catch (IncorrectCredentialsException e) &#123;</span><br><span class="line">            error = &quot;用户名/密码错误&quot;;</span><br><span class="line">        &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">            //其他错误，比如锁定，如果想单独处理请单独catch处理</span><br><span class="line">            error = &quot;其他错误：&quot; + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        if (error != null) &#123;//出错了，返回登录页面</span><br><span class="line">            req.setAttribute(&quot;error&quot;, error);</span><br><span class="line">            req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(req, resp);</span><br><span class="line">        &#125; else &#123;//登录成功</span><br><span class="line">            req.getRequestDispatcher(&quot;/WEB-INF/jsp/loginSuccess.jsp&quot;).forward(req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogoutServlet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.userServlet;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname LogoutServlet</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">@WebServlet(name = &quot;logoutServlet&quot;, urlPatterns = &quot;/logout&quot;)</span><br><span class="line">public class LogoutServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        SecurityUtils.getSubject().logout();</span><br><span class="line">        req.getRequestDispatcher(&quot;/index.jsp&quot;).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写jsp</p>
<p>login.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;.error&#123;color:red;&#125;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;error&quot;&gt;$&#123;error&#125;&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>loginSuccess.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">欢迎$&#123;subject.principal&#125;登录成功！&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;&gt;退出&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>index.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;&gt;登录&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/authenticated&quot;&gt;已身份认证&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/role&quot;&gt;角色授权&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/permission&quot;&gt;权限授权&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<p>先配置maven环境</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wBZO9epVWkToRul.png" alt="image-20200926131907024"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/coKNq8WB1MXtJF3.png" alt="image-20200926131944076"></p>
</li>
<li><p>测试</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/C8m7XBGzJc1s2HK.png" alt="image-20200926131739585"><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RfMCa16ySGKTrzI.png" alt="image-20200926131755401"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-入门</title>
    <url>/2020/09/18/213Java%E6%A1%86%E6%9E%B6/shiro/shiro-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>学习官网10分钟教程</p>
<span id="more"></span>

<h1 id="shiro-入门"><a href="#shiro-入门" class="headerlink" title="shiro-入门"></a>shiro-入门</h1><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p><a href="http://shiro.apache.org/10-minute-tutorial.html">官网地址</a></p>
<p>用途：solution to authentication, authorization, cryptography, and session management.<a href="http://shiro.apache.org/features.html">更详细</a></p>
<p>此教程：了解shiro的API</p>
<h2 id="practice"><a href="#practice" class="headerlink" title="practice:"></a>practice:</h2><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><ol>
<li><p>require: JDK 1.8+ and Maven 3.0.3+</p>
</li>
<li><p><a href="http://shiro.apache.org/download.html">download</a></p>
<p>版本1.6.0</p>
</li>
<li><p>unzip 解压</p>
</li>
<li><p>cmd下进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">cd shiro-learn\shiro-root-1.6.0\samples\quickstart</span><br></pre></td></tr></table></figure></li>
<li><p>maven编译并启动Quickstart.java 需等待下载jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile exec:java</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/EfF3iMILywYzqko.png" alt="image-20200918184659372"></p>
</li>
</ol>
<h3 id="learn-Quickstart-java"><a href="#learn-Quickstart-java" class="headerlink" title="learn Quickstart.java"></a>learn Quickstart.java</h3><p>获取当前用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">log.info(&quot;currentUser: &quot; + currentUser);</span><br></pre></td></tr></table></figure>



<p>设置当前用户的session</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Session session = currentUser.getSession();</span><br><span class="line">session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; );</span><br></pre></td></tr></table></figure>

<p>认证用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果没被认证过。（可能认证过并且记录以后不需要认证。）</span><br><span class="line">if ( !currentUser.isAuthenticated() ) &#123;</span><br><span class="line">    //collect user principals and credentials in a gui specific manner</span><br><span class="line">    //such as username/password html form, X509 certificate, OpenID, etc.</span><br><span class="line">    //We&#x27;ll use the username/password example here since it is the most common.</span><br><span class="line">    //(do you know what movie this is from? ;)</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">    //this is all you have to do to support &#x27;remember me&#x27; (no config - built in!):</span><br><span class="line">    token.setRememberMe(true);</span><br><span class="line">    // 认证从登录框输入的token用户是否存在于currentUser中。</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获不同的异常，对应认证不通过的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    currentUser.login( token );</span><br><span class="line">    //if no exception, that&#x27;s it, we&#x27;re done!</span><br><span class="line">&#125; catch ( UnknownAccountException uae ) &#123;</span><br><span class="line">	// 无此账号</span><br><span class="line">    //username wasn&#x27;t in the system, show them an error message?</span><br><span class="line">&#125; catch ( IncorrectCredentialsException ice ) &#123;</span><br><span class="line">	// 密码错误</span><br><span class="line">    //password didn&#x27;t match, try again?</span><br><span class="line">&#125; catch ( LockedAccountException lae ) &#123;</span><br><span class="line">	//账号被锁定。</span><br><span class="line">    //account for that username is locked - can&#x27;t login.  Show them a message?</span><br><span class="line">&#125;</span><br><span class="line">    ... more types exceptions to check if you want ...</span><br><span class="line">&#125; catch ( AuthenticationException ae ) &#123;</span><br><span class="line">    //unexpected condition - error?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录成功，打印用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info( &quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot; );</span><br></pre></td></tr></table></figure>

<p>判断用户是否拥有某个角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( currentUser.hasRole( &quot;schwartz&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;May the Schwartz be with you!&quot; );</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info( &quot;Hello, mere mortal.&quot; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断用户是否拥有某个权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( currentUser.isPermitted( &quot;lightsaber:weild&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ( currentUser.isPermitted( &quot;winnebago:drive:eagle5&quot; ) ) &#123;</span><br><span class="line">    log.info(&quot;You are permitted to &#x27;drive&#x27; the &#x27;winnebago&#x27; with license plate (id) &#x27;eagle5&#x27;.  &quot; +</span><br><span class="line">                &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登出，清理session</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentUser.logout(); </span><br></pre></td></tr></table></figure>



<h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing,</span><br><span class="line"> * software distributed under the License is distributed on an</span><br><span class="line"> * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="line"> * KIND, either express or implied.  See the License for the</span><br><span class="line"> * specific language governing permissions and limitations</span><br><span class="line"> * under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Simple Quickstart application showing how to use Shiro&#x27;s API.</span><br><span class="line"> *</span><br><span class="line"> * @since 0.9 RC2</span><br><span class="line"> */</span><br><span class="line">public class Quickstart &#123;</span><br><span class="line"></span><br><span class="line">    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // The easiest way to create a Shiro SecurityManager with configured</span><br><span class="line">        // realms, users, roles and permissions is to use the simple INI config.</span><br><span class="line">        // We&#x27;ll do that by using a factory that can ingest a .ini file and</span><br><span class="line">        // return a SecurityManager instance:</span><br><span class="line"></span><br><span class="line">        // Use the shiro.ini file at the root of the classpath</span><br><span class="line">        // (file: and url: prefixes load from files and urls respectively):</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">        // for this simple example quickstart, make the SecurityManager</span><br><span class="line">        // accessible as a JVM singleton.  Most applications wouldn&#x27;t do this</span><br><span class="line">        // and instead rely on their container configuration or web.xml for</span><br><span class="line">        // webapps.  That is outside the scope of this simple quickstart, so</span><br><span class="line">        // we&#x27;ll just do the bare minimum so you can continue to get a feel</span><br><span class="line">        // for things.</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        // Now that a simple Shiro environment is set up, let&#x27;s see what you can do:</span><br><span class="line"></span><br><span class="line">        // get the currently executing user:</span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        // Do some stuff with a Session (no need for a web or EJB container!!!)</span><br><span class="line">        Session session = currentUser.getSession();</span><br><span class="line">        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);</span><br><span class="line">        String value = (String) session.getAttribute(&quot;someKey&quot;);</span><br><span class="line">        if (value.equals(&quot;aValue&quot;)) &#123;</span><br><span class="line">            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // let&#x27;s login the current user so we can check against roles and permissions:</span><br><span class="line">        if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">            token.setRememberMe(true);</span><br><span class="line">            try &#123;</span><br><span class="line">                currentUser.login(token);</span><br><span class="line">            &#125; catch (UnknownAccountException uae) &#123;</span><br><span class="line">                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());</span><br><span class="line">            &#125; catch (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);</span><br><span class="line">            &#125; catch (LockedAccountException lae) &#123;</span><br><span class="line">                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +</span><br><span class="line">                        &quot;Please contact your administrator to unlock it.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // ... catch more exceptions here (maybe custom ones specific to your application?</span><br><span class="line">            catch (AuthenticationException ae) &#123;</span><br><span class="line">                //unexpected condition?  error?</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //say who they are:</span><br><span class="line">        //print their identifying principal (in this case, a username):</span><br><span class="line">        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);</span><br><span class="line"></span><br><span class="line">        //test a role:</span><br><span class="line">        if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;</span><br><span class="line">            log.info(&quot;May the Schwartz be with you!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Hello, mere mortal.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //test a typed permission (not instance-level)</span><br><span class="line">        if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;</span><br><span class="line">            log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //a (very powerful) Instance Level permission:</span><br><span class="line">        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;</span><br><span class="line">            log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot; +</span><br><span class="line">                    &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //all done - log out!</span><br><span class="line">        currentUser.logout();</span><br><span class="line"></span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>classparh:shiro.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"># or more contributor license agreements.  See the NOTICE file</span><br><span class="line"># distributed with this work for additional information</span><br><span class="line"># regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"># to you under the Apache License, Version 2.0 (the</span><br><span class="line"># &quot;License&quot;); you may not use this file except in compliance</span><br><span class="line"># with the License.  You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing,</span><br><span class="line"># software distributed under the License is distributed on an</span><br><span class="line"># &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="line"># KIND, either express or implied.  See the License for the</span><br><span class="line"># specific language governing permissions and limitations</span><br><span class="line"># under the License.</span><br><span class="line">#</span><br><span class="line"># =============================================================================</span><br><span class="line"># Quickstart INI Realm configuration</span><br><span class="line">#</span><br><span class="line"># For those that might not understand the references in this file, the</span><br><span class="line"># definitions are all based on the classic Mel Brooks&#x27; film &quot;Spaceballs&quot;. ;)</span><br><span class="line"># =============================================================================</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Users and their assigned roles</span><br><span class="line">#</span><br><span class="line"># Each line conforms to the format defined in the</span><br><span class="line"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[users]</span><br><span class="line"># user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; role</span><br><span class="line">root = secret, admin</span><br><span class="line"># user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; role</span><br><span class="line">guest = guest, guest</span><br><span class="line"># user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on</span><br><span class="line"># my luggage!!!&quot; ;)), and role &#x27;president&#x27;</span><br><span class="line">presidentskroob = 12345, president</span><br><span class="line"># user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;</span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line"># user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;</span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Roles with assigned permissions</span><br><span class="line"># </span><br><span class="line"># Each line conforms to the format defined in the</span><br><span class="line"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[roles]</span><br><span class="line"># &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;</span><br><span class="line">admin = *</span><br><span class="line"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line"># The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with</span><br><span class="line"># license plate &#x27;eagle5&#x27; (instance specific id)</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java框架</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-权限</title>
    <url>/2020/09/18/213Java%E6%A1%86%E6%9E%B6/shiro/shiro-%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>权限管理</p>
<span id="more"></span>

<h1 id="shiro-权限"><a href="#shiro-权限" class="headerlink" title="shiro-权限"></a>shiro-权限</h1><p>控制谁能访问哪些资源。</p>
<p>谁：主体（Subject）、角色（Role）</p>
<p>哪些资源：资源（Resource）、权限（Permission） </p>
<h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><ol>
<li><p>编程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">if(subject.hasRole(“admin”)) &#123;</span><br><span class="line">    //有权限</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //无权限</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequiresRoles(&quot;admin&quot;)</span><br><span class="line">public void hello() &#123;</span><br><span class="line">    //有权限</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>标签</p>
<p>JSP/GSP 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">&lt;!— 有权限 —&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h2><ol>
<li><p>配置shiro-role.ini</p>
<p>resource下新建shiro-role.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhang=123,role1,role2</span><br><span class="line">wang=123,role1</span><br></pre></td></tr></table></figure></li>
<li><p>Base</p>
<p>封装了开头和结尾的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.apache.shiro.util.ThreadContext;</span><br><span class="line">import org.junit.After;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname BaseAuthorizationTest</span><br><span class="line"> * @Description Authorization base</span><br><span class="line"> */</span><br><span class="line">public class BaseAuthorizationTest &#123;</span><br><span class="line"></span><br><span class="line">    protected void login(String configFile, String username, String password) &#123;</span><br><span class="line">        //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory =</span><br><span class="line">                new IniSecurityManagerFactory(configFile);</span><br><span class="line"></span><br><span class="line">        //2、得到SecurityManager实例 并绑定给SecurityUtils</span><br><span class="line">        org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line"></span><br><span class="line">        subject.login(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public void tearDown() throws Exception &#123;</span><br><span class="line">        ThreadContext.unbindSubject();//退出时请解除绑定Subject到线程 否则对下次测试造成影响</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试用例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname AuthorizationTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class AuthorizationTest extends  BaseAuthorizationTest&#123;</span><br><span class="line"></span><br><span class="line">    // 基于角色的访问控制（隐式）</span><br><span class="line">    // 1.基于角色的访问控制（隐式）</span><br><span class="line">    @Test</span><br><span class="line">    public void testHasRole()&#123;</span><br><span class="line">        login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //判断拥有角色：role1</span><br><span class="line">        ;</span><br><span class="line">        Assert.assertTrue(SecurityUtils.getSubject().hasRole(&quot;role1&quot;));</span><br><span class="line">        //判断拥有角色：role1 and role2</span><br><span class="line">        Assert.assertTrue(SecurityUtils.getSubject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));</span><br><span class="line">        //判断拥有角色：role1 and role2 and !role3</span><br><span class="line">        boolean[] result = SecurityUtils.getSubject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));</span><br><span class="line">        Assert.assertEquals(true, result[0]);</span><br><span class="line">        Assert.assertEquals(true, result[1]);</span><br><span class="line">        Assert.assertEquals(false, result[2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.基于角色的访问控制（隐式）</span><br><span class="line">    // checkRole/checkRoles 和 hasRole/hasAllRoles 不同的地方是它在判断为假的情况下会抛出 UnauthorizedException 异常。</span><br><span class="line">    @Test(expected = UnauthorizedException.class)</span><br><span class="line">    public void testCheckRole() &#123;</span><br><span class="line">        login(&quot;classpath:shiro-role.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //断言拥有角色：role1</span><br><span class="line">        SecurityUtils.getSubject().checkRole(&quot;role1&quot;);</span><br><span class="line">        //断言拥有角色：role1 and role3 失败抛出异常</span><br><span class="line">        SecurityUtils.getSubject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基于资源的访问控制（显示角色）"><a href="#基于资源的访问控制（显示角色）" class="headerlink" title="基于资源的访问控制（显示角色）"></a>基于资源的访问控制（显示角色）</h2><ol>
<li><p>配置shrio-permission.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhang=123,role1,role2</span><br><span class="line">wang=123,role1</span><br><span class="line">[roles]</span><br><span class="line">role1=user:create,user:update</span><br><span class="line">role2=user:create,user:delete</span><br></pre></td></tr></table></figure></li>
<li><p>BaseAuthorizationTest</p>
<p>同上的BaseAuthorizationTest</p>
</li>
<li><p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authz.UnauthorizedException;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname AuthorizationPermittedTest</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class AuthorizationPermittedTest extends BaseAuthorizationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testIsPermitted() &#123;</span><br><span class="line">        login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //判断拥有权限：user:create</span><br><span class="line">        boolean permitted = SecurityUtils.getSubject().isPermitted(&quot;user:create&quot;);</span><br><span class="line">        //判断拥有权限：user:update and user:delete</span><br><span class="line">        boolean permittedAll = SecurityUtils.getSubject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;);</span><br><span class="line">        //判断没有权限：user:view</span><br><span class="line">        boolean permitted1 = SecurityUtils.getSubject().isPermitted(&quot;user:view&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(permitted + &quot; &quot; + permittedAll + &quot; &quot; + permitted1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test(expected = UnauthorizedException.class)</span><br><span class="line">    public void testCheckPermission () &#123;</span><br><span class="line">        login(&quot;classpath:shiro-permission.ini&quot;, &quot;zhang&quot;, &quot;123&quot;);</span><br><span class="line">        //断言拥有权限：user:create</span><br><span class="line">        SecurityUtils.getSubject().checkPermission(&quot;user:create&quot;);</span><br><span class="line">        //断言拥有权限：user:delete and user:update</span><br><span class="line">        SecurityUtils.getSubject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);</span><br><span class="line">        //断言拥有权限：user:view 失败抛出异常</span><br><span class="line">        SecurityUtils.getSubject().checkPermissions(&quot;user:view&quot;);</span><br><span class="line">        // 阻塞了后续代码，即使@Test(expected = UnauthorizedException.class)</span><br><span class="line">        System.out.println(1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-身份认证</title>
    <url>/2020/09/20/213Java%E6%A1%86%E6%9E%B6/shiro/shiro-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>junit学习并总结shiro的身份认证</p>
<span id="more"></span>

<h1 id="shiro-身份认证"><a href="#shiro-身份认证" class="headerlink" title="shiro-身份认证"></a>shiro-身份认证</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p><a href="http://shiro.apache.org/10-minute-tutorial.html">官网地址</a></p>
<p>验证主体Subject（会存入前端的账号/密码）是否存在于realm（后端数据源）中</p>
<h2 id="code-Implementation"><a href="#code-Implementation" class="headerlink" title="code Implementation"></a>code Implementation</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>使用junit的shiro入门demo</p>
<ol>
<li><p>新建项目</p>
</li>
<li><p>导入maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-learn&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置后端数据源</p>
<p>resources下新建shiro.ini文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">   zhang=123</span><br><span class="line">   wang=123</span><br></pre></td></tr></table></figure>

<p>notice:idea需要ini4idea插件，并配置。<a href="https://blog.csdn.net/lintianlin/article/details/80050309">参考</a></p>
</li>
<li><p>junit测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationException;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.apache.shiro.util.ThreadContext;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">public class LoginLogout &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHelloword ()&#123;</span><br><span class="line">        //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">        //2、得到SecurityManager实例 并绑定给SecurityUtils</span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        // 4.从前端传来的账号/密码</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 身份验证</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; catch (AuthenticationException e)&#123;</span><br><span class="line">            // 认证失败</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;登录失败&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(true, subject.isAuthenticated());// 断言用户已经登录</span><br><span class="line">        // 退出，会清理session</span><br><span class="line">        subject.logout();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @After</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        // 不执行可能影响第二次运行Test</span><br><span class="line">        ThreadContext.unbindSubject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Singlon-Realm"><a href="#Singlon-Realm" class="headerlink" title="Singlon-Realm"></a>Singlon-Realm</h3><ol>
<li><p>从demo的3开始</p>
<p>新建MyRealm类实现Realm接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.realm.Realm;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname MyRealm</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class MyRealm implements Realm &#123;</span><br><span class="line">    // 返回一个唯一的Realm名字</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;myRealm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断此Realm是否支持此Token</span><br><span class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</span><br><span class="line">        // 仅支持UsernamePasswordToken类型的Token</span><br><span class="line">        return authenticationToken instanceof UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据Token获取认证信息</span><br><span class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">        // 获取用户名</span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        // 获取密码</span><br><span class="line">        String password = new String((char[])authenticationToken.getCredentials());</span><br><span class="line"></span><br><span class="line">        if (!&quot;zhang&quot;.equals(username))&#123;</span><br><span class="line">            throw new UnknownAccountException();// 用户名不存在</span><br><span class="line">        &#125;</span><br><span class="line">        if (!&quot;123&quot;.equals(password))&#123;</span><br><span class="line">            throw new IncorrectCredentialsException();// 密码错误</span><br><span class="line">        &#125;</span><br><span class="line">        // 认证成功，返回AutnenticationInfo信息</span><br><span class="line">        return new SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置MyRealm</p>
<p>resource下新建shiro-realm文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">#声明一个realm</span><br><span class="line">myRealm = com.xiaoruiit.shiro.config.MyRealm</span><br><span class="line">#指定securityManager的realms实现</span><br><span class="line">securityManager.realms=$myRealm</span><br></pre></td></tr></table></figure></li>
<li><p>junit测试</p>
<p>增加一个测试方法，修改shrio-reaml.ini即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testSingleRealm()&#123;</span><br><span class="line">       Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-realm.ini&quot;);</span><br><span class="line">       SecurityManager securityManager = factory.getInstance();</span><br><span class="line">       SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);</span><br><span class="line">       try &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125; catch (AuthenticationException e)&#123;</span><br><span class="line">           // 认证失败</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(&quot;登录失败&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Assert.assertEquals(true, subject.isAuthenticated());// 断言用户已经登录</span><br><span class="line">       subject.logout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JDBC-Realm"><a href="#JDBC-Realm" class="headerlink" title="JDBC-Realm"></a>JDBC-Realm</h3><p>建立在在demo的基础上</p>
<ol>
<li><p>导入数据库依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.1.25&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;0.2.23&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在mysql中新建库shiro</p>
</li>
<li><p>新建三个表+1条user信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database if exists shiro;</span><br><span class="line">create database shiro;</span><br><span class="line">use shiro;</span><br><span class="line"></span><br><span class="line">create table users (</span><br><span class="line">  id bigint auto_increment,</span><br><span class="line">  username varchar(100),</span><br><span class="line">  password varchar(100),</span><br><span class="line">  password_salt varchar(100),</span><br><span class="line">  constraint pk_users primary key(id)</span><br><span class="line">) charset=utf8 ENGINE=InnoDB;</span><br><span class="line">create unique index idx_users_username on users(username);</span><br><span class="line"></span><br><span class="line">create table user_roles(</span><br><span class="line">  id bigint auto_increment,</span><br><span class="line">  username varchar(100),</span><br><span class="line">  role_name varchar(100),</span><br><span class="line">  constraint pk_user_roles primary key(id)</span><br><span class="line">) charset=utf8 ENGINE=InnoDB;</span><br><span class="line">create unique index idx_user_roles on user_roles(username, role_name);</span><br><span class="line"></span><br><span class="line">create table roles_permissions(</span><br><span class="line">  id bigint auto_increment,</span><br><span class="line">  role_name varchar(100),</span><br><span class="line">  permission varchar(100),</span><br><span class="line">  constraint pk_roles_permissions primary key(id)</span><br><span class="line">) charset=utf8 ENGINE=InnoDB;</span><br><span class="line">create unique index idx_roles_permissions on roles_permissions(role_name, permission);</span><br><span class="line"></span><br><span class="line">insert into users(username,password)values(&#x27;zhang&#x27;,&#x27;123&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>配置shiro-jdbc-realm</p>
<p>resource下新建shiro-jdbc-realm.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123456</span><br><span class="line"></span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure>

<p>JdbcRealm是shrio提供的。可继承并重写方法来改写sql</p>
</li>
<li><p>junit测试</p>
<p>修改shiro-jdbc-realm.ini</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void testJdbcRealm()&#123;</span><br><span class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-jdbc-realm.ini&quot;);</span><br><span class="line">       SecurityManager securityManager = factory.getInstance();</span><br><span class="line">       SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);</span><br><span class="line">       try &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125; catch (AuthenticationException e)&#123;</span><br><span class="line">           // 认证失败</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           System.out.println(&quot;登录失败&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Assert.assertEquals(true, subject.isAuthenticated());// 断言用户已经登录</span><br><span class="line">       subject.logout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>bootshiro-学习</title>
    <url>/2020/09/27/213Java%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/bootshiro-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>学习搭建后端脚手架。</p>
<span id="more"></span>

<h1 id="bootshiro-学习"><a href="#bootshiro-学习" class="headerlink" title="bootshiro-学习"></a>bootshiro-学习</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>此脚手架的功能：前后端分离，后端接口开发。</p>
<ul>
<li>支持RESTful风格。</li>
<li>用户-角色-接口功能。</li>
<li>用户登录日志、操作日志</li>
<li>封装后端返回结果，code,msg+data</li>
</ul>
<p>使用的技术：</p>
<ul>
<li>springboot</li>
<li>mybatis</li>
<li>shiro 权限管理，用户-角色-接口</li>
<li>jwt token，每次访问后端使用jwt做验证</li>
<li>redis 存jwt</li>
<li>jasypt 数据库密码密文配置在yum中</li>
</ul>
<h2 id="学习流程："><a href="#学习流程：" class="headerlink" title="学习流程："></a>学习流程：</h2><ol>
<li>down</li>
<li>等待下载jar包</li>
<li>启动</li>
<li>postman测试</li>
<li>本地mysql导入usthe.sql</li>
<li>修改yum中的SQL配置和jasypt配置</li>
<li>启动</li>
<li>postman测试，导入测试数据postman_test_example.json<ol>
<li><p>注册</p>
<p>问题：bootshiro-register-no-encrpty <a href="http://localhost:8080/account/register">http://localhost:8080/account/register</a> 注册时ase秘钥为空</p>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bootshiro:</span><br><span class="line">  enableEncryptPassword: false</span><br></pre></td></tr></table></figure>

<p>注册为访客角色，在数据库改为了role_admin</p>
</li>
<li><p>登录</p>
<p>bootshiro-login <a href="http://localhost:8080/account/login">http://localhost:8080/account/login</a></p>
<p>修改body中的”appId”: “tom33”,”password”: “1234”,</p>
<p>拿到jwt：eyJhbGciOiJIUzUx…</p>
</li>
<li><p>获取角色</p>
<p>bootshiro-jwt <a href="http://localhost:8080/user/role/tom33">http://localhost:8080/user/role/tom33</a></p>
<p>修改jwt，修改restful风格tom33</p>
<p>结果：拿到角色role_admin</p>
</li>
</ol>
</li>
</ol>
<p>具体内容：</p>
<ul>
<li><p>yum文件设置了开发、测试、生产三种环境</p>
</li>
<li><p>jasypt</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>脚手架</category>
      </categories>
      <tags>
        <tag>bootshiro</tag>
      </tags>
  </entry>
  <entry>
    <title>jeecg按钮权限</title>
    <url>/2019/06/20/213Java%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/jeecg%E6%8C%89%E9%92%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>jeecg按钮权限</p>
<span id="more"></span>
<h1 id="jeecg按钮权限"><a href="#jeecg按钮权限" class="headerlink" title="jeecg按钮权限"></a>jeecg按钮权限</h1><p>参考官方文档 <a href="http://idoc.jeecg.com/1275970">http://idoc.jeecg.com/1275970</a></p>
<h2 id="1-在要控制的页面按钮添加属性"><a href="#1-在要控制的页面按钮添加属性" class="headerlink" title="1.在要控制的页面按钮添加属性"></a>1.在要控制的页面按钮添加属性</h2><p><code>operationCode=&quot;test_delete&quot;</code></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/vmZLRBwyzOji3KI.png" alt="image-20200414132620754"></p>
<h2 id="2-在菜单管理的对应页面设置页面控件权限"><a href="#2-在菜单管理的对应页面设置页面控件权限" class="headerlink" title="2.在菜单管理的对应页面设置页面控件权限"></a>2.在菜单管理的对应页面设置页面控件权限</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/CPmEGlcqKDoRUWg.png" alt="image-20200414133436351"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JpZofajOYvMuz5Q.png" alt="image-20200414133727176"></p>
<h2 id="3-确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限"><a href="#3-确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限" class="headerlink" title="3.确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限"></a>3.确保demo角色的用户有访问此页面的权限，无访问“批量删除”按钮的权限</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iMevSwTIn9HsQlL.png" alt="image-20200414134012108"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/lC5HgiqmozGVBkP.png" alt="image-20200414134326453"></p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>脚手架</category>
      </categories>
      <tags>
        <tag>jeecg</tag>
      </tags>
  </entry>
  <entry>
    <title>jeecg用代码生成器添加一个功能</title>
    <url>/2019/06/18/213Java%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/jeecg%E7%94%A8%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>jeecg用代码生成器添加一个功能</p>
<span id="more"></span>
<h1 id="jeecg用代码生成器添加一个功能"><a href="#jeecg用代码生成器添加一个功能" class="headerlink" title="jeecg用代码生成器添加一个功能"></a>jeecg用代码生成器添加一个功能</h1><h2 id="1-创建表单"><a href="#1-创建表单" class="headerlink" title="1.创建表单"></a>1.创建表单</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/1wBSdpvFsI82mf6.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/74zetYh3S8OEFUn.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/QdavBg2GThiuVAy.png" alt="img"></p>
<h2 id="2-同步表单信息到数据库"><a href="#2-同步表单信息到数据库" class="headerlink" title="2.同步表单信息到数据库"></a>2.同步表单信息到数据库</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/bSvdYFm2kyDciQq.png" alt="img"></p>
<p><strong>同步效果：</strong></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/u93mNwTWA6SYbnc.png" alt="img"></p>
<h2 id="3-测试功能"><a href="#3-测试功能" class="headerlink" title="3.测试功能"></a>3.测试功能</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/hyaH7ueB5NzToCq.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/WLjZw2g1HFeiGOm.png" alt="image-20200413180405257"></p>
<h2 id="4-生成后台功能代码"><a href="#4-生成后台功能代码" class="headerlink" title="4.生成后台功能代码"></a>4.生成后台功能代码</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ozw1d9yJCkDpLxG.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ehqwInbLcOlRDxS.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NfhaIeHlA84oREG.png" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Mk9BVGpmzaSsbKf.png" alt="img"></p>
<h2 id="5-刷新项目，并重启启动"><a href="#5-刷新项目，并重启启动" class="headerlink" title="5.刷新项目，并重启启动"></a>5.刷新项目，并重启启动</h2>]]></content>
      <categories>
        <category>Java框架</category>
        <category>脚手架</category>
      </categories>
      <tags>
        <tag>jeecg</tag>
      </tags>
  </entry>
  <entry>
    <title>jspxcms添加一个功能</title>
    <url>/2019/08/06/213Java%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/jspxcms%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p> jspxcms二次开发配置文件的介绍</p>
<span id="more"></span>
<h1 id="jspxcms添加一个功能"><a href="#jspxcms添加一个功能" class="headerlink" title="jspxcms添加一个功能"></a>jspxcms添加一个功能</h1><p>向菜单后台管理-功能插件下，添加“领导管理”（不修改配置文件，使用默认前台模板添加功能）</p>
<h2 id="（1）添加菜单"><a href="#（1）添加菜单" class="headerlink" title="（1）添加菜单"></a>（1）添加菜单</h2><p><code>\src\main\resources\conf\plugin\plug</code>下的<code>backend.xml</code>,<code>conf.properties</code>,<code>context.xml</code>不动，<code>menu.yml</code>下添加要增加的菜单名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">600-1001:</span><br><span class="line">  name: lead.management</span><br><span class="line">  url: plug/lead/list.do</span><br><span class="line">  perms: plug:lead:list</span><br><span class="line">  ops:</span><br><span class="line">    - create@plug:lead:create</span><br><span class="line">    - copy@plug:lead:copy</span><br><span class="line">    - edit@plug:lead:edit</span><br><span class="line">    - save@plug:lead:save</span><br><span class="line">    - update@plug:lead:update</span><br><span class="line">    - delete@plug:lead:delete</span><br></pre></td></tr></table></figure>



<h2 id="（2）添加国际化代码"><a href="#（2）添加国际化代码" class="headerlink" title="（2）添加国际化代码"></a>（2）添加国际化代码</h2><p><code>src\main\resources\messages\plugin\plug\</code>plug.properties中仿照原例子添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lead.management=领导管理</span><br><span class="line">opr.lead.add=领导新增</span><br><span class="line">opr.lead.edit=领导修改</span><br><span class="line">opr.lead.delete=领导删除</span><br><span class="line">lead.name=姓名</span><br><span class="line">lead.partyPosts=党内职务</span><br><span class="line">lead.administrativePost=行政职务</span><br></pre></td></tr></table></figure>



<h2 id="（3）添加功能代码"><a href="#（3）添加功能代码" class="headerlink" title="（3）添加功能代码"></a>（3）添加功能代码</h2><p><code>仿照\src\main\java\com\jspxcms\plug</code>下内容并添加新的domain、repository、service、web（主要是将resume修改为lead）</p>
<h2 id="4-创建数据库"><a href="#4-创建数据库" class="headerlink" title="(4)创建数据库"></a>(4)创建数据库</h2><p>在数据库中执行下列语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table introduction_lead</span><br><span class="line">(</span><br><span class="line">   j_lead_id          		int not null,</span><br><span class="line">   f_site_id            	int not null,</span><br><span class="line">   j_name               	varchar(100) not null comment &#x27;领导姓名&#x27;,</span><br><span class="line">   j_party_posts            varchar(100)  comment &#x27;党内职务&#x27;,</span><br><span class="line">   j_administrative_post    varchar(100)  comment &#x27;行政职务&#x27;,</span><br><span class="line">   primary key (j_lead_id)</span><br><span class="line">)</span><br><span class="line">engine = innodb;</span><br><span class="line">alter table introduction_lead comment &#x27;领导信息表&#x27;;</span><br><span class="line">alter table introduction_lead add constraint `fk_introduction_lead_site` foreign key (`f_site_id`)</span><br><span class="line">      references cms_site(`f_site_id`) on delete restrict on update restrict;</span><br></pre></td></tr></table></figure>

<h2 id="（5）添加页面"><a href="#（5）添加页面" class="headerlink" title="（5）添加页面"></a>（5）添加页面</h2><p>在\src\main\webapp\WEB-INF\views\plug下新建文件夹lead，复制resume的文件到lead中，修改文件（主要是将resume修改为lead，还需要根据实体类lead字段不同修改）</p>
<h2 id="（6）效果"><a href="#（6）效果" class="headerlink" title="（6）效果"></a>（6）效果</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OgXeI8TxZMfSsWd.png" alt="image-20200428151003349"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/XpYvcAoUy9Qbl3i.png" alt="image-20200428151037539"></p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>脚手架</category>
      </categories>
      <tags>
        <tag>jspxcms</tag>
        <tag>论坛</tag>
      </tags>
  </entry>
  <entry>
    <title>jspxcms二次开发配置文件</title>
    <url>/2019/08/05/213Java%E6%A1%86%E6%9E%B6/%E8%84%9A%E6%89%8B%E6%9E%B6/jspxcms%E6%B7%BB%E5%8A%A0%E5%8A%9F%E8%83%BD%E6%9C%89%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p> jspxcms二次开发配置文件的介绍</p>
<span id="more"></span>
<h1 id="jspxcms添加功能有关配置文件介绍"><a href="#jspxcms添加功能有关配置文件介绍" class="headerlink" title="jspxcms添加功能有关配置文件介绍"></a>jspxcms添加功能有关配置文件介绍</h1><p>配置文件位置：src\main\resources\conf\plugin\plug\</p>
<h2 id="1-context-xml"><a href="#1-context-xml" class="headerlink" title="1.context.xml"></a>1.context.xml</h2><p>配置实体Entity、数据库操作类Dao、service、前台controller的路径</p>
<p><code>&lt;bean class=&quot;com.jspxcms.plug.ContextConfig&quot; /&gt;</code></p>
<p>配置模板类<!--FreeMarker标签类--></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;IntroductionLeadList&quot; class=&quot;com.jspxcms.plug.web.directive.LeadListDirective&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>​    向\src\main\java\com\jspxcms\plug下添加功能的代码</p>
<h2 id="2-backend-xml"><a href="#2-backend-xml" class="headerlink" title="2.backend.xml"></a>2.backend.xml</h2><p>配置后台controller路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.jspxcms.plug.web.back&quot; use-default-filters=&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-conf-properties"><a href="#3-conf-properties" class="headerlink" title="3.conf.properties"></a>3.conf.properties</h2><p>前台模板Freemarker标签、国际化文件目录？？</p>
<p>前端页面标签英文对应中文，包括菜单、类的属性、增删改，几乎页面的所有中文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">messageSource.basenames.plug=classpath:messages/plugin/plug/plug</span><br></pre></td></tr></table></figure>

<p>？？？路径文件内容为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">messageSource.basenames.plugfore=classpath:messages/plugin/plugfore/plugfore</span><br></pre></td></tr></table></figure>

<p>和模板Freemarker有关，具体？？？</p>
<p>ResumeList 在模板中调用标签的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">freemarkerVariables.ResumeList=PlugLeadList</span><br></pre></td></tr></table></figure>

<p>模板中的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[@ResumeList; result]</span><br><span class="line">[#list result as bean]</span><br><span class="line">    $&#123;bean.name&#125;, $&#123;bean.mobile&#125;</span><br><span class="line">[/#list]</span><br><span class="line">[/@ResumeList]</span><br></pre></td></tr></table></figure>

<h2 id="4-menu-yml"><a href="#4-menu-yml" class="headerlink" title="4.menu.yml"></a>4.menu.yml</h2><p><a href="http://www.jspxcms.com/documentation/366.html">http://www.jspxcms.com/documentation/366.html</a></p>
<p>配置后台的左侧菜单，使其显示</p>
<p>600：一级菜单 1000：二级菜单代表的数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">600-1000:</span><br></pre></td></tr></table></figure>

<p><code>perms: plug:resume:list</code> 菜单权限值。这个权限值必须要对应url的Controller方法的<code>@RequiresPermissions(&quot;plug:resume:list&quot;)</code>一致。</p>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>脚手架</category>
      </categories>
      <tags>
        <tag>jspxcms</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper-入门</title>
    <url>/2020/08/25/213Java%E6%A1%86%E6%9E%B6/Zookeeper-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Zookeeper的介绍，helloword，Curator,分布式锁，集群</p>
<span id="more"></span>

<h1 id="ZooKeeper-基础"><a href="#ZooKeeper-基础" class="headerlink" title="ZooKeeper-基础"></a>ZooKeeper-基础</h1><p>官网：</p>
<p>版本：ZooKeeper3.6</p>
<p>支持JDK8、11、12</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/RBHqshvYfZPKdwb.png" alt="image-20200825064140355"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hadoop的一个子项目，用于管理服务。</p>
<ul>
<li>服务注册中心</li>
<li>服务配置</li>
<li>分布式锁</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Zookeeper-安装</p>
<h2 id="zookeeper命令行操作"><a href="#zookeeper命令行操作" class="headerlink" title="zookeeper命令行操作"></a>zookeeper命令行操作</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>zookeeper的结构类似Linux树形目录结构。</p>
<p>由一个个节点+节点之间的联系构成。</p>
<p>zookeeper的节点可以有子节点，并且可以存储少量信息（1M，如：地址信息，172.168.0.1）</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Iacr7Q6HEdUfAjK.png" alt="image-20200903180546203"></p>
<p>节点可以分为四大类：</p>
<ul>
<li>PERSISTENT 持久化节点 </li>
</ul>
<ul>
<li>EPHEMERAL 临时节点 ：-e</li>
</ul>
<ul>
<li>PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</li>
</ul>
<ul>
<li>EPHEMERAL_SEQUENTIAL 临时顺序节点  ：-es</li>
</ul>
<h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li>
<li><p>停止</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br></pre></td></tr></table></figure></li>
<li><p>重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh restart</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li>
<li><p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#未启动</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Error contacting service. It is probably not running.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul>
<li><p>克隆会话</p>
</li>
<li><p>进入zookeeper的bin目录</p>
</li>
<li><p>连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#./zkCli.sh –server ip:port</span><br><span class="line">./zkCli.sh –server localhost:2181</span><br><span class="line">#或者</span><br><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Q74wNtbd5ixL8RG.png" alt="image-20200913123531063"></p>
</li>
</ul>
<h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ul>
<li><p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /</span><br><span class="line">#结果：[zookeeper]</span><br></pre></td></tr></table></figure></li>
<li><p>查看详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls -s /</span><br><span class="line">[zookeeper]cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<p>解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">czxid：节点被创建的事务ID </span><br><span class="line">ctime: 创建时间 </span><br><span class="line">mzxid: 最后一次被更新的事务ID </span><br><span class="line">mtime: 修改时间 </span><br><span class="line">pzxid：子节点列表最后一次被更新的事务ID</span><br><span class="line">cversion：子节点的版本号 </span><br><span class="line">dataversion：数据版本号 </span><br><span class="line">aclversion：权限版本号 </span><br><span class="line">ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0 </span><br><span class="line">dataLength：节点存储的数据的长度 </span><br><span class="line">numChildren：当前节点的子节点个数 </span><br></pre></td></tr></table></figure></li>
<li><p>创建持久节点 默认</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] create /xiaorui</span><br><span class="line">Created /xiaorui</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /</span><br><span class="line">[xiaorui, zookeeper]</span><br></pre></td></tr></table></figure></li>
<li><p>获取节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] get /xiaorui</span><br><span class="line">null</span><br></pre></td></tr></table></figure></li>
<li><p>设置节点值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#set path value</span><br><span class="line">set /xiaorui han</span><br></pre></td></tr></table></figure></li>
<li><p>删除单个节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete /节点path</span><br></pre></td></tr></table></figure></li>
<li><p>删除带有子节点的节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deleteall /节点path</span><br></pre></td></tr></table></figure></li>
<li><p>临时节点 -e 会话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create -e /节点path value</span><br></pre></td></tr></table></figure></li>
<li><p>顺序节点 -s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create -s /节点path value</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="zookeeper-JavaAPI操作"><a href="#zookeeper-JavaAPI操作" class="headerlink" title="zookeeper JavaAPI操作"></a>zookeeper JavaAPI操作</h2><h3 id="curator"><a href="#curator" class="headerlink" title="curator"></a>curator</h3><p>官网：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p>
<p>简化原生JavaAPI对zookeeper的操作。</p>
<p>Apache的顶级项目</p>
<p>版本:与zookeeper版本对应</p>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><h4 id="导入curator-junit"><a href="#导入curator-junit" class="headerlink" title="导入curator+junit"></a>导入curator+junit</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper-curator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--curator--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日志--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>



<h4 id="操作curator"><a href="#操作curator" class="headerlink" title="操作curator"></a>操作curator</h4><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private CuratorFramework client;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 建立连接</span><br><span class="line">    */</span><br><span class="line">   @Before</span><br><span class="line">   public void testConnect() &#123;</span><br><span class="line"></span><br><span class="line">       /*</span><br><span class="line">        *</span><br><span class="line">        * @param connectString       连接字符串。zk server 地址和端口 &quot;192.168.3.3:2181&quot;</span><br><span class="line">        * @param sessionTimeoutMs    会话超时时间 单位ms</span><br><span class="line">        * @param connectionTimeoutMs 连接超时时间 单位ms</span><br><span class="line">        * @param retryPolicy         重试策略</span><br><span class="line">        */</span><br><span class="line">      /* //重试策略</span><br><span class="line">       RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000,10);</span><br><span class="line">       //1.第一种方式</span><br><span class="line">       CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.3.3:2181&quot;,</span><br><span class="line">               60 * 1000, 15 * 1000, retryPolicy);*/</span><br><span class="line">       //重试策略</span><br><span class="line">       RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10);</span><br><span class="line">       //2.第二种方式</span><br><span class="line">       //CuratorFrameworkFactory.builder();</span><br><span class="line">       client = CuratorFrameworkFactory.builder()</span><br><span class="line">               .connectString(&quot;192.168.3.3:2181&quot;)</span><br><span class="line">               .sessionTimeoutMs(60 * 1000)</span><br><span class="line">               .connectionTimeoutMs(15 * 1000)</span><br><span class="line">               .retryPolicy(retryPolicy)</span><br><span class="line">               .namespace(&quot;xiaoruiit&quot;)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       //开启连接</span><br><span class="line">       client.start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @After</span><br><span class="line">   public void close() &#123;</span><br><span class="line">       if (client != null) &#123;</span><br><span class="line">           client.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建节点：create 持久 临时 顺序 数据</span><br><span class="line">    * 1. 基本创建 ：create().forPath(&quot;&quot;)</span><br><span class="line">    * 2. 创建节点 带有数据:create().forPath(&quot;&quot;,data)</span><br><span class="line">    * 3. 设置节点的类型：create().withMode().forPath(&quot;&quot;,data)</span><br><span class="line">    * 4. 创建多级节点  /app1/p1 ：create().creatingParentsIfNeeded().forPath(&quot;&quot;,data)</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate() throws Exception &#123;</span><br><span class="line">       //2. 创建节点 带有数据</span><br><span class="line">       //如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span><br><span class="line">       String path = client.create().forPath(&quot;/app2&quot;, &quot;haha&quot;.getBytes());</span><br><span class="line">       System.out.println(path);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate2() throws Exception &#123;</span><br><span class="line">       //1. 基本创建</span><br><span class="line">       //如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span><br><span class="line">       String path = client.create().forPath(&quot;/app1&quot;);</span><br><span class="line">       System.out.println(path);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate3() throws Exception &#123;</span><br><span class="line">       //3. 设置节点的类型</span><br><span class="line">       //默认类型：持久化</span><br><span class="line">       String path = client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;/app3&quot;);</span><br><span class="line">       System.out.println(path);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testCreate4() throws Exception &#123;</span><br><span class="line">       //4. 创建多级节点  /app1/p1</span><br><span class="line">       //creatingParentsIfNeeded():如果父节点不存在，则创建父节点</span><br><span class="line">       String path = client.create().creatingParentsIfNeeded().forPath(&quot;/app4/p1&quot;);</span><br><span class="line">       System.out.println(path);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/J3RLSxczs9OoTU7.png" alt="image-20200913185407017"></p>
<h5 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 查询节点：</span><br><span class="line">    * 1. 查询数据：get: getData().forPath()</span><br><span class="line">    * 2. 查询子节点： ls: getChildren().forPath()</span><br><span class="line">    * 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath()</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testGet1() throws Exception &#123;</span><br><span class="line">       //1. 查询数据：get</span><br><span class="line">       byte[] data = client.getData().forPath(&quot;/app1&quot;);</span><br><span class="line">       System.out.println(new String(data));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testGet2() throws Exception &#123;</span><br><span class="line">       // 2. 查询子节点： ls</span><br><span class="line">       List&lt;String&gt; path = client.getChildren().forPath(&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(path);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testGet3() throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       Stat status = new Stat();</span><br><span class="line">       System.out.println(status);</span><br><span class="line">       //3. 查询节点状态信息：ls -s</span><br><span class="line">       client.getData().storingStatIn(status).forPath(&quot;/app1&quot;);</span><br><span class="line"></span><br><span class="line">       System.out.println(status);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 修改数据</span><br><span class="line">    * 1. 基本修改数据：setData().forPath()</span><br><span class="line">    * 2. 根据版本修改: setData().withVersion().forPath()</span><br><span class="line">    * * version 是查询出来的。目的是为了让其他客户端或者线程不干扰我。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void testSet() throws Exception &#123;</span><br><span class="line">       client.setData().forPath(&quot;/app1&quot;, &quot;itcast&quot;.getBytes());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testSetForVersion() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       Stat status = new Stat();</span><br><span class="line">       //3. 查询节点状态信息：ls -s</span><br><span class="line">       client.getData().storingStatIn(status).forPath(&quot;/app1&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       int version = status.getVersion();//查询出来的 3</span><br><span class="line">       System.out.println(version);</span><br><span class="line">       client.setData().withVersion(version).forPath(&quot;/app1&quot;, &quot;haha&quot;.getBytes());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 删除节点： delete deleteall</span><br><span class="line">    * 1. 删除单个节点:delete().forPath(&quot;/app1&quot;);</span><br><span class="line">    * 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath(&quot;/app1&quot;);</span><br><span class="line">    * 3. 必须成功的删除:为了防止网络抖动。本质就是重试。  client.delete().guaranteed().forPath(&quot;/app2&quot;);</span><br><span class="line">    * 4. 回调：inBackground</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete() throws Exception &#123;</span><br><span class="line">       // 1. 删除单个节点</span><br><span class="line">       client.delete().forPath(&quot;/app1&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete2() throws Exception &#123;</span><br><span class="line">       //2. 删除带有子节点的节点</span><br><span class="line">       client.delete().deletingChildrenIfNeeded().forPath(&quot;/app4&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete3() throws Exception &#123;</span><br><span class="line">       //3. 必须成功的删除</span><br><span class="line">       client.delete().guaranteed().forPath(&quot;/app2&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @Test</span><br><span class="line">   public void testDelete4() throws Exception &#123;</span><br><span class="line">       //4. 回调</span><br><span class="line">       client.delete().guaranteed().inBackground(new BackgroundCallback()&#123;</span><br><span class="line"></span><br><span class="line">           @Override</span><br><span class="line">           public void processResult(CuratorFramework client, CuratorEvent event) throws Exception &#123;</span><br><span class="line">               System.out.println(&quot;删除了~&quot;);</span><br><span class="line">               System.out.println(event);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).forPath(&quot;/app1&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Watch监听"><a href="#Watch监听" class="headerlink" title="Watch监听"></a>Watch监听</h5><p>ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<p>Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</p>
<p>ZooKeeper提供了三种Watcher：</p>
<ul>
<li>NodeCache : 只是监听某一个特定的节点</li>
</ul>
<ul>
<li>PathChildrenCache : 监控一个ZNode的子节点. </li>
</ul>
<ul>
<li>TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li>
</ul>
<p><strong>implementation</strong></p>
<ul>
<li><p>Watch监听-NodeCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 演示 NodeCache：给指定一个节点注册监听器</span><br><span class="line">*/</span><br><span class="line">@Test</span><br><span class="line">public void testNodeCache() throws Exception &#123;</span><br><span class="line">    //1. 创建NodeCache对象</span><br><span class="line">    final NodeCache nodeCache = new NodeCache(client,&quot;/app1&quot;);</span><br><span class="line">    //2. 注册监听</span><br><span class="line">   	nodeCache.getListenable().addListener(new NodeCacheListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void nodeChanged() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;节点变了~&quot;);</span><br><span class="line">            //获取修改节点后的数据</span><br><span class="line">            byte[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">            System.out.println(new String(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	//3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据</span><br><span class="line">    	nodeCache.start(true);</span><br><span class="line">    	while (true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Watch监听-PathChildrenCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPathChildrenCache() throws Exception &#123;</span><br><span class="line">    //1.创建监听对象</span><br><span class="line">    PathChildrenCache pathChildrenCache = new PathChildrenCache(client,&quot;/app2&quot;,true);</span><br><span class="line">    //2. 绑定监听器</span><br><span class="line">    pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() &#123;    			</span><br><span class="line">    	@Override</span><br><span class="line">        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;子节点变化了~&quot;);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">            //监听子节点的数据变更，并且拿到变更后的数据</span><br><span class="line">            //1.获取类型</span><br><span class="line">            PathChildrenCacheEvent.Type type = event.getType();</span><br><span class="line">            //2.判断类型是否是update</span><br><span class="line">            if(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</span><br><span class="line">                System.out.println(&quot;数据变了&quot;);</span><br><span class="line">                byte[] data = event.getData().getData();</span><br><span class="line">                System.out.println(new String(data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //3. 开启</span><br><span class="line">    pathChildrenCache.start();</span><br><span class="line">    while (true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Watch监听-TreeCache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 演示 TreeCache：监听某个节点自己和所有子节点们</span><br><span class="line">*/</span><br><span class="line">@Test</span><br><span class="line">public void testTreeCache() throws Exception &#123;</span><br><span class="line">    //1. 创建监听器</span><br><span class="line">    TreeCache treeCache = new TreeCache(client,&quot;/app2&quot;);</span><br><span class="line">    //2. 注册监听</span><br><span class="line">    treeCache.getListenable().addListener(new TreeCacheListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;节点变了&quot;);</span><br><span class="line">            System.out.println(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //3. 开启</span><br><span class="line">    treeCache.start();</span><br><span class="line">    while (true)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p><strong>介绍：</strong>后端项目使用分布式集群时，这时是多jvm环境，锁无法解决多机同步问题。出现了分布式锁。</p>
<p><strong>zookeeper分布式锁原理</strong>：客户端要获取锁，1.在请求下创建临时顺序子节点，2.若节点最小，则获得了锁，执行业务3.使用完锁，则删除该节点，释放锁。</p>
<p><strong>原理详解：</strong></p>
<p>1.客户端在lock节点下创建临时顺序节点。</p>
<p>2.获取lock下面的所有子节点，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁，执行业务代码。使用完锁后，将该节点删除。</p>
<p>3.如果自己创建的节点并非lock所有子节点中最小的，找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</p>
<p>4.如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤（监听比自己小一个节点的删除事件，判断自己是否是最小节点）。</p>
<p><strong>Curator实现分布式锁：</strong></p>
<ul>
<li><p>五种锁方案：</p>
<ul>
<li><p>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</p>
</li>
<li><p>InterProcessMutex：分布式可重入排它锁</p>
</li>
<li><p>InterProcessReadWriteLock：分布式读写锁</p>
</li>
<li><p>InterProcessMultiLock：将多个锁作为单个实体管理的容器</p>
</li>
<li><p>InterProcessSemaphoreV2：共享信号量</p>
</li>
</ul>
</li>
<li><p><strong>implementation：</strong></p>
<p><strong>InterProcessMutex 方式</strong></p>
<p>1.创建线程，加锁设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Ticket12306 implements Runnable&#123;</span><br><span class="line">    private int tickets = 20; //数据库的票数</span><br><span class="line">    private InterProcessMutex lock ;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //获取锁</span><br><span class="line">            try &#123;</span><br><span class="line">            lock.acquire(2, TimeUnit.SECONDS);</span><br><span class="line">                if(tickets &gt; 0)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+&quot;:&quot;+tickets);</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                //释放锁</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建连接，初始化锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Ticket12306()&#123;</span><br><span class="line">    //重试策略</span><br><span class="line">    RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10);</span><br><span class="line">    //2.第二种方式</span><br><span class="line">    //CuratorFrameworkFactory.builder();</span><br><span class="line">    CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(&quot;192.168.3.3:2181&quot;)</span><br><span class="line">        .sessionTimeoutMs(60 * 1000)</span><br><span class="line">        .connectionTimeoutMs(15 * 1000)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .build();</span><br><span class="line">    //开启连接</span><br><span class="line">    client.start();</span><br><span class="line">    lock = new InterProcessMutex(client,&quot;/lock&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.多个线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LockTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket12306 ticket12306 = new Ticket12306();</span><br><span class="line">        //创建客户端</span><br><span class="line">        Thread t1 = new Thread(ticket12306,&quot;骆驼旅行&quot;);</span><br><span class="line">        Thread t2 = new Thread(ticket12306,&quot;分流抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h2 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h2><ul>
<li>leader 领导<ul>
<li>处理事务请求</li>
<li>集群内部各服务器的调度</li>
</ul>
</li>
<li>follower 跟随者<ul>
<li>处理客户端非事务请求，转发事务给leader服务器</li>
<li>参与leader选举投票</li>
</ul>
</li>
<li>observer 观察者<ul>
<li>处理客户端非事务请求，转发事务给leader服务器</li>
</ul>
</li>
</ul>
<h3 id="领导算法"><a href="#领导算法" class="headerlink" title="领导算法"></a>领导算法</h3><p><strong>介绍：</strong>服务器投票选举主服务器，名称为领导（leader）。</p>
<p><strong>逻辑：</strong></p>
<ul>
<li><p>服务器id越大，权重越大。</p>
</li>
<li><p>半数投票前，每加入一个服务器都重新投票和选举。</p>
</li>
<li><p>某个服务器得到半数投票后，角色变为leader。集群变为可用状态。</p>
</li>
<li><p>有leader角色后，新服务器加入集群，不会重新投票和选举。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>服务器id=1,2,3三个服务器，1,2,3依次启动。1启动，给自己投一票；2启动，1重新投票，投给2一票，2投给自己一票，2一共的了2票，超过半票，2的角色变为leader,1的角色为follower，<strong>集群启动</strong>；3启动，已经有leader角色，不投票，3的角色为follower.</p>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>集群</tag>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>企业微信通讯录变更时同步到本地系统</title>
    <url>/2021/06/30/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E5%BD%95%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>记录操作日志</p>
<span id="more"></span>

<h1 id="企业微信通讯录变更时同步到本地系统"><a href="#企业微信通讯录变更时同步到本地系统" class="headerlink" title="企业微信通讯录变更时同步到本地系统"></a>企业微信通讯录变更时同步到本地系统</h1><p><a href="https://open.work.weixin.qq.com/api/doc/90001/90143/91201">企业微信API文档</a></p>
<p>第三方微信sdk: com.github.binarywang  </p>
<h2 id="1-申请企业微信企业测试账号"><a href="#1-申请企业微信企业测试账号" class="headerlink" title="1.申请企业微信企业测试账号"></a>1.申请企业微信企业测试账号</h2><h2 id="2-根据企业微信文档写回调接口，配置回调接口属性"><a href="#2-根据企业微信文档写回调接口，配置回调接口属性" class="headerlink" title="2.根据企业微信文档写回调接口，配置回调接口属性"></a>2.根据企业微信文档写回调接口，配置回调接口属性</h2><h3 id="从企业微信后台获取配置属性"><a href="#从企业微信后台获取配置属性" class="headerlink" title="从企业微信后台获取配置属性"></a>从企业微信后台获取配置属性</h3><p>(1) 超级管理员登录企业微信后台</p>
<p>企业微信后台地址：</p>
<p><a href="https://work.weixin.qq.com/wework_admin/loginpage_wx?etype=expired#apps/contactsApi">https://work.weixin.qq.com/wework_admin/loginpage_wx?etype=expired#apps/contactsApi</a></p>
<p>(2) 获取参数</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Oty8GMBeUl91rZE.jpg" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/SUDRf3VnXx4YBJb.jpg" alt="img"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/w8eMCHcqxIvVgPK.jpg" alt="img"></p>
<h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(tags = &quot;企业微信-回调接口服务&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/callback/&#123;agentId&#125;&quot;)</span><br><span class="line">public class WxCallBackController &#123;</span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @GetMapping(produces = &quot;text/plain;charset=utf-8&quot;)</span><br><span class="line">    public String authGet(@PathVariable Integer agentId,</span><br><span class="line">                          @RequestParam(name = &quot;msg_signature&quot;, required = false) String signature,</span><br><span class="line">                          @RequestParam(name = &quot;timestamp&quot;, required = false) String timestamp,</span><br><span class="line">                          @RequestParam(name = &quot;nonce&quot;, required = false) String nonce,</span><br><span class="line">                          @RequestParam(name = &quot;echostr&quot;, required = false) String echostr) &#123;</span><br><span class="line">        this.logger.info(&quot;\n接收到来自微信服务器的认证消息：signature = [&#123;&#125;], timestamp = [&#123;&#125;], nonce = [&#123;&#125;], echostr = [&#123;&#125;]&quot;,</span><br><span class="line">                signature, timestamp, nonce, echostr);</span><br><span class="line"></span><br><span class="line">        if (StringUtils.isAnyBlank(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;请求参数非法，请核实!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final WxCpService wxCpService = WxCpConfiguration.getCpService(agentId);</span><br><span class="line">        if (wxCpService == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;未找到对应agentId=[%d]的配置&quot;, agentId));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (wxCpService.checkSignature(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">            return new WxCpCryptUtil(wxCpService.getWxCpConfigStorage()).decrypt(echostr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;非法请求&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(produces = &quot;application/xml; charset=UTF-8&quot;)</span><br><span class="line">    public String post(@PathVariable Integer agentId,</span><br><span class="line">                       @RequestBody String requestBody,</span><br><span class="line">                       @RequestParam(&quot;msg_signature&quot;) String signature,</span><br><span class="line">                       @RequestParam(&quot;timestamp&quot;) String timestamp,</span><br><span class="line">                       @RequestParam(&quot;nonce&quot;) String nonce) &#123;</span><br><span class="line">        this.logger.info(&quot;\n接收微信请求：[signature=[&#123;&#125;], timestamp=[&#123;&#125;], nonce=[&#123;&#125;], requestBody=[\n&#123;&#125;\n] &quot;,</span><br><span class="line">                signature, timestamp, nonce, requestBody);</span><br><span class="line"></span><br><span class="line">        final WxCpService wxCpService = WxCpConfiguration.getCpService(agentId);</span><br><span class="line">        WxCpXmlMessage inMessage = WxCpXmlMessage.fromEncryptedXml(requestBody, wxCpService.getWxCpConfigStorage(),</span><br><span class="line">                timestamp, nonce, signature);</span><br><span class="line">        this.logger.debug(&quot;\n消息解密内容为：\n&#123;&#125; &quot;, JSONObject.toJSONString(inMessage));</span><br><span class="line">        WxCpXmlOutMessage outMessage = this.route(agentId, inMessage);</span><br><span class="line">        if (outMessage == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String out = outMessage.toEncryptedXml(wxCpService.getWxCpConfigStorage());</span><br><span class="line">        this.logger.debug(&quot;\n回复信息：&#123;&#125;&quot;, out);</span><br><span class="line">        return out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private WxCpXmlOutMessage route(Integer agentId, WxCpXmlMessage message) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return WxCpConfiguration.getRouters().get(agentId).route(message);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            this.logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p>corpId,agentId,secret,token,aesKey</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 企业微信帐号</span><br><span class="line">wx:</span><br><span class="line">  cp:</span><br><span class="line">    application:</span><br><span class="line">      - corpId: ww234234223429bd7 # han申请的企业微信ID</span><br><span class="line">        appConfigs:</span><br><span class="line">            - agentId: 60023001 # 虚拟agentId 为注入配置使用</span><br><span class="line">              secret: q4asdfqedRasdfadfasdfasdfb5R93dRZasdfaXfkEk # 通讯录secret</span><br><span class="line">              token: uAasdfasdfasdf8u # 与企业微信回调一致</span><br><span class="line">              aesKey: AcYasdfasdfasdfasdfasdfasdfasd234234lAa # 与企业微信回调一致</span><br><span class="line">      - corpId: ww123123131213219d4 # 开发人员申请的企业微信ID</span><br><span class="line">        appConfigs:</span><br><span class="line">          - agentId: 40123002 # 虚拟agentId 为注入配置使用</span><br><span class="line">            secret: bSIyH1234123123123fsd1213123H1U</span><br><span class="line">            token:</span><br><span class="line">            aesKey:</span><br><span class="line">          - agentId: 62322303 # 虚拟agentId 为注入配置使用</span><br><span class="line">            secret: ix12312123123123123123b-NNc</span><br><span class="line">            token:</span><br><span class="line">            aesKey:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性读取"><a href="#属性读取" class="headerlink" title="属性读取"></a>属性读取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;wx.cp&quot;)</span><br><span class="line">public class EnterpriseWechatApplication &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;WxCpProperties&gt; application;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class WxCpProperties &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 设置企业微信的corpId</span><br><span class="line">     */</span><br><span class="line">    private String corpId;</span><br><span class="line"></span><br><span class="line">    private List&lt;AppConfig&gt; appConfigs;</span><br><span class="line"></span><br><span class="line">    @Getter</span><br><span class="line">    @Setter</span><br><span class="line">    public static class AppConfig &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的AgentId</span><br><span class="line">         */</span><br><span class="line">        private Integer agentId;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的Secret</span><br><span class="line">         */</span><br><span class="line">        private String secret;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的token</span><br><span class="line">         */</span><br><span class="line">        private String token;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 设置企业微信应用的EncodingAESKey</span><br><span class="line">         */</span><br><span class="line">        private String aesKey;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return JSONObject.toJSONString(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(EnterpriseWechatApplication.class)</span><br><span class="line">public class WxCpConfiguration &#123;</span><br><span class="line">    private LogHandler logHandler;</span><br><span class="line">    private NullHandler nullHandler;</span><br><span class="line">    private LocationHandler locationHandler;</span><br><span class="line">    private MenuHandler menuHandler;</span><br><span class="line">    private MsgHandler msgHandler;</span><br><span class="line">    private UnsubscribeHandler unsubscribeHandler;</span><br><span class="line">    private SubscribeHandler subscribeHandler;</span><br><span class="line">    private ContactChangeHandler contactChangeHandler;</span><br><span class="line">    private EnterAgentHandler enterAgentHandler;</span><br><span class="line"></span><br><span class="line">    // private WxCpProperties properties;</span><br><span class="line"></span><br><span class="line">    private EnterpriseWechatApplication enterpriseWechatApplication;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;Integer, WxCpMessageRouter&gt; routers = Maps.newHashMap();</span><br><span class="line">    private static Map&lt;Integer, WxCpService&gt; cpServices = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public WxCpConfiguration(LogHandler logHandler, NullHandler nullHandler, LocationHandler locationHandler,</span><br><span class="line">                             MenuHandler menuHandler, MsgHandler msgHandler, UnsubscribeHandler unsubscribeHandler,</span><br><span class="line">                             SubscribeHandler subscribeHandler, ContactChangeHandler contactChangeHandler,EnterAgentHandler enterAgentHandler</span><br><span class="line">                             // , WxCpProperties properties</span><br><span class="line">            , EnterpriseWechatApplication enterpriseWechatApplication</span><br><span class="line">    ) &#123;</span><br><span class="line">        this.logHandler = logHandler;</span><br><span class="line">        this.nullHandler = nullHandler;</span><br><span class="line">        this.locationHandler = locationHandler;</span><br><span class="line">        this.menuHandler = menuHandler;</span><br><span class="line">        this.msgHandler = msgHandler;</span><br><span class="line">        this.unsubscribeHandler = unsubscribeHandler;</span><br><span class="line">        this.subscribeHandler = subscribeHandler;</span><br><span class="line">        // this.properties = properties;</span><br><span class="line">        this.enterpriseWechatApplication = enterpriseWechatApplication;</span><br><span class="line">        this.contactChangeHandler = contactChangeHandler;</span><br><span class="line">        this.enterAgentHandler = enterAgentHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static Map&lt;Integer, WxCpMessageRouter&gt; getRouters() &#123;</span><br><span class="line">        return routers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static WxCpService getCpService(Integer agentId) &#123;</span><br><span class="line">        return cpServices.get(agentId);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    @PostConstruct // 初始化加载，加载Autowire之后</span><br><span class="line">    public void initServices() &#123;</span><br><span class="line">        this.enterpriseWechatApplication.getApplication().forEach(wxCpProperties -&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Map&lt;Integer, WxCpServiceImpl&gt; wxCpServiceMap = wxCpProperties.getAppConfigs().stream().map(a -&gt; &#123;</span><br><span class="line">                        WxCpRedissonConfigImpl configStorage = new WxCpRedissonConfigImpl(redissonClient);</span><br><span class="line">                        configStorage.setCorpId(wxCpProperties.getCorpId());</span><br><span class="line">                        configStorage.setAgentId(a.getAgentId());</span><br><span class="line">                        configStorage.setCorpSecret(a.getSecret());</span><br><span class="line">                        configStorage.setToken(a.getToken());</span><br><span class="line">                        configStorage.setAesKey(a.getAesKey());</span><br><span class="line"></span><br><span class="line">                        val service = new WxCpServiceImpl();</span><br><span class="line">                        service.setWxCpConfigStorage(configStorage);</span><br><span class="line">                        routers.put(a.getAgentId(), this.newRouter(service));</span><br><span class="line">                        return service;</span><br><span class="line">                    &#125;).collect(Collectors.toMap(service -&gt; service.getWxCpConfigStorage().getAgentId(), a -&gt; a));</span><br><span class="line"></span><br><span class="line">                    cpServices.putAll(wxCpServiceMap);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private WxCpMessageRouter newRouter(WxCpService wxCpService) &#123;</span><br><span class="line">        final val newRouter = new WxCpMessageRouter(wxCpService);</span><br><span class="line"></span><br><span class="line">        // 记录所有事件的日志 （异步执行）</span><br><span class="line">        newRouter.rule().handler(this.logHandler).next();</span><br><span class="line">		// 通讯录变更事件</span><br><span class="line">        newRouter.rule().async(false).msgType(WxConsts.XmlMsgType.EVENT)</span><br><span class="line">                .event(WxCpConsts.EventType.CHANGE_CONTACT).handler(this.contactChangeHandler).end();</span><br><span class="line">        // 默认</span><br><span class="line">        newRouter.rule().async(false).handler(this.msgHandler).end();</span><br><span class="line"></span><br><span class="line">        return newRouter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-gatway服务配置企业微信回调地址token过滤白名单"><a href="#3-gatway服务配置企业微信回调地址token过滤白名单" class="headerlink" title="3.gatway服务配置企业微信回调地址token过滤白名单"></a>3.gatway服务配置企业微信回调地址token过滤白名单</h2><p>bootstrap.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secure:</span><br><span class="line">  ignore:</span><br><span class="line">    urls: #配置白名单路径</span><br><span class="line">      - &quot;/wx/callback/**&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-使用企业微信回调接口工具测试"><a href="#4-使用企业微信回调接口工具测试" class="headerlink" title="4.使用企业微信回调接口工具测试"></a>4.使用企业微信回调接口工具测试</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/O5j1nR9WqNSMcD4.png" alt="image-20210630114634938"></p>
<h2 id="5-企业微信管理后台设置通讯录同步-接收事件服务器"><a href="#5-企业微信管理后台设置通讯录同步-接收事件服务器" class="headerlink" title="5.企业微信管理后台设置通讯录同步-接收事件服务器"></a>5.企业微信管理后台设置通讯录同步-接收事件服务器</h2><p>参考：<a href="https://open.work.weixin.qq.com/api/doc/90000/90135/90966">https://open.work.weixin.qq.com/api/doc/90000/90135/90966</a></p>
<h2 id="6-代码中获取通讯录变更事件，写变更时的处理逻辑"><a href="#6-代码中获取通讯录变更事件，写变更时的处理逻辑" class="headerlink" title="6.代码中获取通讯录变更事件，写变更时的处理逻辑"></a>6.代码中获取通讯录变更事件，写变更时的处理逻辑</h2><p>注意：失败重试+持久化需要同步的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ContactChangeHandler extends AbstractHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MdmService mdmService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public WxCpXmlOutMessage handle(WxCpXmlMessage wxMessage, Map&lt;String, Object&gt; context, WxCpService cpService,</span><br><span class="line">                                    WxSessionManager sessionManager) &#123;</span><br><span class="line">        String content = &quot;收到通讯录变更事件，内容：&quot; + JSONObject.toJSONString(wxMessage);</span><br><span class="line">        this.logger.info(content);</span><br><span class="line"></span><br><span class="line">        // 企业微信修改手机号、邮箱后调用wanma和crm接口，同步数据</span><br><span class="line">        if (WxCpConsts.EventType.CHANGE_CONTACT.equals(wxMessage.getEvent())) &#123;// 通讯录变更事件</span><br><span class="line">            if (WxCpConsts.ContactChangeType.UPDATE_USER.equals(wxMessage.getChangeType())) &#123;// 从通讯录变更-更新成员</span><br><span class="line">                log.info(&quot;企业微信更新成员消息：&quot; + wxMessage.toString());</span><br><span class="line">                // 通过微信userId查询变更人信息</span><br><span class="line">                Result&lt;MdmUserInfoDTO&gt; mdmUserInfoDTOResult = mdmService.queryUserDetailByWxUserId(wxMessage.getUserId());</span><br><span class="line">                if (mdmUserInfoDTOResult.getCode() != 0) &#123;</span><br><span class="line">                    log.error(&quot;通过wxUserId获取用户信息失败：&quot;, wxMessage.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                MdmUserInfoDTO oldUser = mdmUserInfoDTOResult.getData();</span><br><span class="line">                log.info(&quot;企业微信通讯录变更前用户信息：&quot; + mdmUserInfoDTOResult.getData().toString());</span><br><span class="line">                MdmUserInfoDTO newUser = new MdmUserInfoDTO();</span><br><span class="line">                newUser.setUserId(oldUser.getUserId());</span><br><span class="line">                newUser.setWxUserId(wxMessage.getUserId());// 变更信息的成员UserID</span><br><span class="line">                newUser.setGender(&quot;1&quot;.equals(wxMessage.getGender()) ? &quot;1&quot; : &quot;0&quot;);// 企业微信的性别 1男2女</span><br><span class="line">                newUser.setUserEmail(StringUtils.isNotBlank(wxMessage.getEmail()) ? AESUtil.encryptHex(wxMessage.getEmail()) : null);// 变更信息的邮箱 加密</span><br><span class="line">                newUser.setUserMobile(StringUtils.isNotBlank(wxMessage.getMobile()) ? AESUtil.encryptHex(wxMessage.getMobile()) : null);// 变更信息的手机号 加密</span><br><span class="line">                newUser.setUserName(wxMessage.getName());// 姓名</span><br><span class="line"></span><br><span class="line">                // 调用本地系统同步接口</span><br><span class="line">                Result result = mdmService.updateUser(newUser);</span><br><span class="line"></span><br><span class="line">                if (result.getCode() != 0) &#123;</span><br><span class="line">                    log.error(&quot;企业微信通讯录更新同步本地系统失败，同步数据：&quot;+newUser);</span><br><span class="line">                &#125;</span><br><span class="line">                //调用crm同步接口</span><br><span class="line">                Result result1 = mdmService.userDataSync(oldUser.getUserId());</span><br><span class="line">                if (result1.getCode() != 0) &#123;</span><br><span class="line">                    log.error(&quot;企业微信通讯录更新同步crm失败，同步userId：&quot;+oldUser.getUserId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new TextBuilder().build(content, wxMessage, cpService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-IP白名单配置定时更新任务，更新定时变化的企业微信IP"><a href="#7-IP白名单配置定时更新任务，更新定时变化的企业微信IP" class="headerlink" title="7.IP白名单配置定时更新任务，更新定时变化的企业微信IP"></a>7.IP白名单配置定时更新任务，更新定时变化的企业微信IP</h2><h3 id="7-1quartz设置定时任务"><a href="#7-1quartz设置定时任务" class="headerlink" title="7.1quartz设置定时任务"></a>7.1quartz设置定时任务</h3><p>任务job</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class WxIpWhitelistJob extends QuartzJobBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WxcpService wxcpService;//wx服务</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        log.info(&quot;拉取企业微信IP并更新白名单任务执行开始: ==&gt; ... &quot;);</span><br><span class="line">        wxcpService.ipWhitelist();</span><br><span class="line">        log.info(&quot;拉取企业微信IP并更新白名单任务执行开始: ==&gt; end &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动quartz服务时，将job和触发器加入scheduler(任务调度)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SchedulerInitListener implements CommandLineRunner &#123;// 启动监听并执行run</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws SchedulerException &#123;</span><br><span class="line">        List&lt;QuartzJob&gt; quartzJobs = quartzJobMapper.selectByExample(QuartzJobExample.newAndCreateCriteria()</span><br><span class="line">                .andStatusEqualTo(true).andIsDelEqualTo(false).example());// 从库汇中查询定时任务</span><br><span class="line">        if (!Optional.ofNullable(quartzJobs).isPresent() || quartzJobs.size() &lt;= 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (QuartzJob quartzJob : quartzJobs) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                quartzManager.addQuartzJob(quartzJob);// 将job和触发器加入scheduler(任务调度)</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.info(&quot;定时任务启动失败, jobName = &#123;&#125;, 异常信息: &#123;&#125;&quot;, quartzJob.getJobName(), e.getMessage());</span><br><span class="line">                quartzJob.setStatus(false);</span><br><span class="line">                quartzJobMapper.updateByPrimaryKeySelective(quartzJob);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class QuartzManager &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    public void addQuartzJob(QuartzJob quartzTask) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建jobDetail实例，绑定Job实现类</span><br><span class="line">            // 指明job的名称，所在组的名称，以及绑定job类</span><br><span class="line">            Class&lt;? extends QuartzJobBean&gt; jobClass = (Class&lt;? extends QuartzJobBean&gt;) (Class.forName(quartzTask.getBeanClass()).newInstance().getClass());</span><br><span class="line">            // 任务名称和组构成任务key</span><br><span class="line">            // 判断参数是否为空</span><br><span class="line">            JobDetail jobDetail = null;</span><br><span class="line">            if (!quartzTask.getParam().isEmpty()) &#123;</span><br><span class="line">                JSONObject jsonObject = quartzTask.getParam();</span><br><span class="line">                JobDataMap dataMap = new JobDataMap();</span><br><span class="line">                Set&lt;String&gt; strings = jsonObject.keySet();</span><br><span class="line">                strings.forEach(str -&gt; &#123;</span><br><span class="line">                    dataMap.put(str, jsonObject.getString(str));</span><br><span class="line">                &#125;);</span><br><span class="line">                jobDetail = JobBuilder.newJob(jobClass)</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        .usingJobData(dataMap)</span><br><span class="line">                        .build();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                jobDetail = JobBuilder.newJob(jobClass)</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 定义调度触发规则</span><br><span class="line">            // 使用cornTrigger规则</span><br><span class="line">            // 触发器key</span><br><span class="line">            // 判断任务类型，生成对应类型的调度器</span><br><span class="line">            Trigger trigger = null;</span><br><span class="line">            if (JobTypeEnum.SIMPLE.getType().equals(quartzTask.getJobType())) &#123;</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        // 立即执行</span><br><span class="line">                        .startNow()</span><br><span class="line">                        .withSchedule(</span><br><span class="line">                                SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                                        // 执行间隔，单位：毫秒</span><br><span class="line">                                        .withIntervalInMilliseconds(quartzTask.getMilliSeconds())</span><br><span class="line">                                        // 一直执行</span><br><span class="line">                                        .repeatForever()</span><br><span class="line">                        )</span><br><span class="line">                        .build();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(quartzTask.getJobName(), quartzTask.getGroup())</span><br><span class="line">                        .startAt(DateBuilder.futureDate(1, DateBuilder.IntervalUnit.SECOND))</span><br><span class="line">                        .withSchedule(CronScheduleBuilder.cronSchedule(quartzTask.getCronExpression())).startNow().build();</span><br><span class="line">            &#125;</span><br><span class="line">            // 把作业和触发器注册到任务调度中</span><br><span class="line">            if (Optional.ofNullable(jobDetail).isPresent() &amp;&amp; Optional.ofNullable(trigger).isPresent()) &#123;</span><br><span class="line">                scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            &#125;</span><br><span class="line">            // 启动</span><br><span class="line">            if (!scheduler.isShutdown()) &#123;</span><br><span class="line">                scheduler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2wx服务获取企业微信ip"><a href="#7-2wx服务获取企业微信ip" class="headerlink" title="7.2wx服务获取企业微信ip"></a>7.2wx服务获取企业微信ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Api(tags = &quot;企业微信-IP白名单接口&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/ip&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">public class WxIPController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;wx.cp.application[0].appConfigs[0].agentId&#125;&quot;)</span><br><span class="line">    private Integer mobileAgentId;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MdmService mdmService;// 主数据服务</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;获取企业微信IP集合&quot;, notes = &quot;获取企业微信IP集合&quot;, httpMethod = &quot;POST&quot;)</span><br><span class="line">    @RequestMapping(&quot;/getIpList&quot;)</span><br><span class="line">    public Result getIpList() &#123;</span><br><span class="line">        log.info(&quot;开始获取企业微信IP集合: &quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            String[] callbackIp = WxCpTempConfiguration.getCpService(mobileAgentId).getCallbackIp();</span><br><span class="line">            log.info(&quot;获取企业微信IP集合成功: &quot;+Arrays.toString(callbackIp));</span><br><span class="line">            // 白名单更新企业微信IP</span><br><span class="line">            if (ArrayUtil.isNotEmpty(callbackIp))&#123;</span><br><span class="line">                mdmService.updateWxIp(callbackIp);</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                log.error(&quot;获取的企业微信IP集合为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return Result.success();</span><br><span class="line">        &#125; catch (WxErrorException e) &#123;</span><br><span class="line">            log.info(&quot;获取企业微信IP集合失败: &quot;, e);</span><br><span class="line">            return Result.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3主数据服务更新企业微信ip"><a href="#7-3主数据服务更新企业微信ip" class="headerlink" title="7.3主数据服务更新企业微信ip"></a>7.3主数据服务更新企业微信ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   @Transactional(rollbackFor = Exception.class)</span><br><span class="line">   public Result updateWxIp(String[] callbackIp) &#123;</span><br><span class="line">       // 插入</span><br><span class="line">       LocalDateTime now = LocalDateTime.now().minusSeconds(30l);</span><br><span class="line">       if (ArrayUtils.isNotEmpty(callbackIp))&#123;</span><br><span class="line">           List&lt;MdmLoginIp&gt; mdmLoginIpList = new ArrayList&lt;&gt;();</span><br><span class="line">           for (String ip : callbackIp) &#123;</span><br><span class="line">               MdmLoginIp mdmLoginIp = new MdmLoginIp();</span><br><span class="line">               mdmLoginIp.setLoginIpId(IdWorker.nextId(CommonConstant.MDM_LOGIN_IP_ID_PREFIX));</span><br><span class="line">               mdmLoginIp.setLoginIp(ip);</span><br><span class="line">               mdmLoginIp.setIsDel(false);</span><br><span class="line">               mdmLoginIp.setCreateTime(LocalDateTime.now());</span><br><span class="line">               mdmLoginIp.setLoginIpType(&quot;QYWX&quot;);</span><br><span class="line">               mdmLoginIpList.add(mdmLoginIp);</span><br><span class="line">           &#125;</span><br><span class="line">           mdmLoginIpMapper.batchInsert(mdmLoginIpList);</span><br><span class="line">           // 删除</span><br><span class="line">           mdmLoginIpMapper.deleteByExample(MdmLoginIpExample.newAndCreateCriteria().andLoginIpTypeEqualTo(&quot;QYWX&quot;).andCreateTimeLessThan(now).example());</span><br><span class="line">           return Result.success();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return Result.error(&quot;ip集合为空&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>业务场景</category>
      </categories>
      <tags>
        <tag>同步数据</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro-拦截器</title>
    <url>/2020/09/21/213Java%E6%A1%86%E6%9E%B6/shiro/shiro-%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>可以处理每次请求的认证。</p>
<span id="more"></span>

<h1 id="shiro-拦截器"><a href="#shiro-拦截器" class="headerlink" title="shiro-拦截器"></a>shiro-拦截器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>需求：</p>
<ul>
<li><p>登录：</p>
<ul>
<li>是否请求跳转登录页面。<ul>
<li>是get的登录请求，返回登录页面。</li>
<li>是post的登录请求（输入了账号密码，要登录了）。</li>
<li>非登录请求，保存当前请求，重定向到登录页面。</li>
</ul>
</li>
</ul>
</li>
<li><p>认证：</p>
<ol>
<li>是否携带认证信息<ul>
<li>未携带认证信息，返回错误码</li>
</ul>
</li>
<li>认证信息是否正确</li>
<li>执行拦截器链<ul>
<li>路径匹配</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>​        </p>
<h2 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h2><ol>
<li><p>新建模块</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20201006212116681.png" alt="image-20201006212116681"></p>
</li>
<li><p>导入maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.xiaoruiit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;chapter5-interceptor&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.25&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.23&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;chapter5-interceptor&lt;/finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;8.1.8.v20121106&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;webAppConfig&gt;</span><br><span class="line">                        &lt;contextPath&gt;/$&#123;project.build.finalName&#125;&lt;/contextPath&gt;</span><br><span class="line">                    &lt;/webAppConfig&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;path&gt;/$&#123;project.build.finalName&#125;&lt;/path&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>web.xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app</span><br><span class="line">        xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">        version=&quot;3.0&quot;</span><br><span class="line">        metadata-complete=&quot;false&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--- shiro 1.2 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:shiro-interceptor.ini&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>shiro-interceptor.ini配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line">zhang=123,admin</span><br><span class="line">wang=123</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line">admin=user:*,menu:*</span><br><span class="line"></span><br><span class="line">[filters]</span><br><span class="line">myFilter1=com.xiaoruiit.shiro.filter.MyOncePerRequestFilter</span><br><span class="line">myFilter2=com.xiaoruiit.shiro.filter.MyAdviceFilter</span><br><span class="line">myFilter3=com.xiaoruiit.shiro.filter.MyPathMatchingFilter</span><br><span class="line">myFilter4=com.xiaoruiit.shiro.filter.MyAccessControlFilter</span><br><span class="line">formLogin=com.xiaoruiit.shiro.filter.FormLoginFilter</span><br><span class="line">anyRoles=com.xiaoruiit.shiro.filter.AnyRolesFilter</span><br><span class="line">[urls]</span><br><span class="line">/test.jsp=formLogin,anyRoles[admin,user]</span><br><span class="line">/login.jsp=formLogin</span><br><span class="line">/**=myFilter1,myFilter2,myFilter3[config],myFilter4</span><br><span class="line">#/**=myFilter1</span><br></pre></td></tr></table></figure></li>
<li><p>动态url拦截器</p>
<p>MyIniWebEnviroment.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.env;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.util.ClassUtils;</span><br><span class="line">import org.apache.shiro.web.env.IniWebEnvironment;</span><br><span class="line">import org.apache.shiro.web.filter.authc.FormAuthenticationFilter;</span><br><span class="line">import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.DefaultFilter;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.FilterChainResolver;</span><br><span class="line">import org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname MyIniWebEnviroment</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class MyIniWebEnviroment extends IniWebEnvironment &#123;</span><br><span class="line"></span><br><span class="line">    // 动态实现url-拦截器的注册。需要将其配置到web.xml中·</span><br><span class="line">    @Override</span><br><span class="line">    protected FilterChainResolver createFilterChainResolver() &#123;</span><br><span class="line">        //在此处扩展自己的FilterChainResolver</span><br><span class="line">        //1、创建FilterChainResolver</span><br><span class="line">        PathMatchingFilterChainResolver filterChainResolver =</span><br><span class="line">                new PathMatchingFilterChainResolver();</span><br><span class="line">        //2、创建FilterChainManager</span><br><span class="line">        DefaultFilterChainManager filterChainManager = new DefaultFilterChainManager();</span><br><span class="line">        //3、注册Filter</span><br><span class="line">        for(DefaultFilter filter : DefaultFilter.values()) &#123;</span><br><span class="line">            filterChainManager.addFilter(filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass()));</span><br><span class="line">        &#125;</span><br><span class="line">        //4、注册URL-Filter的映射关系</span><br><span class="line">        filterChainManager.addToChain(&quot;/login.jsp&quot;, &quot;authc&quot;);</span><br><span class="line">        filterChainManager.addToChain(&quot;/unauthorized.jsp&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainManager.addToChain(&quot;/**&quot;, &quot;authc&quot;);</span><br><span class="line">        filterChainManager.addToChain(&quot;/**&quot;, &quot;roles&quot;, &quot;admin&quot;);</span><br><span class="line"></span><br><span class="line">        //5、设置Filter的属性</span><br><span class="line">        FormAuthenticationFilter authcFilter =</span><br><span class="line">                (FormAuthenticationFilter)filterChainManager.getFilter(&quot;authc&quot;);</span><br><span class="line">        authcFilter.setLoginUrl(&quot;/login.jsp&quot;);</span><br><span class="line">        RolesAuthorizationFilter rolesFilter = (RolesAuthorizationFilter)filterChainManager.getFilter(&quot;roles&quot;);</span><br><span class="line">        rolesFilter.setUnauthorizedUrl(&quot;/unauthorized.jsp&quot;);</span><br><span class="line"></span><br><span class="line">        filterChainResolver.setFilterChainManager(filterChainManager);</span><br><span class="line">        return filterChainResolver;</span><br><span class="line">//        return super.createFilterChainResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>form表单过滤器</p>
<p>FormLoginFilter.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.web.filter.PathMatchingFilter;</span><br><span class="line">import org.apache.shiro.web.util.WebUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname FormLoginFilter</span><br><span class="line"> * @Description ToDo</span><br><span class="line"> */</span><br><span class="line">public class FormLoginFilter extends PathMatchingFilter &#123;</span><br><span class="line">    private String loginUrl = &quot;/login.jsp&quot;;//跳转失败时的地址</span><br><span class="line">    private String successUrl = &quot;/&quot;;//成功后跳转的地址</span><br><span class="line"></span><br><span class="line">    // 请求预处理</span><br><span class="line">    // 这里处理登录</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        if(SecurityUtils.getSubject().isAuthenticated()) &#123;</span><br><span class="line">            return true;//已经登录过</span><br><span class="line">        &#125;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line">        if(isLoginRequest(req)) &#123;</span><br><span class="line">            if(&quot;post&quot;.equalsIgnoreCase(req.getMethod())) &#123;//form表单提交</span><br><span class="line">                boolean loginSuccess = login(req); //登录</span><br><span class="line">                if(loginSuccess) &#123;</span><br><span class="line">                    return redirectToSuccessUrl(req, resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;//继续过滤器链</span><br><span class="line">        &#125; else &#123;//保存当前地址并重定向到登录界面</span><br><span class="line">            saveRequestAndRedirectToLogin(req, resp);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean redirectToSuccessUrl(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;</span><br><span class="line">        WebUtils.redirectToSavedRequest(req, resp, successUrl);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveRequestAndRedirectToLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;</span><br><span class="line">        WebUtils.saveRequest(req);</span><br><span class="line">        WebUtils.issueRedirect(req, resp, loginUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean login(HttpServletRequest req) &#123;</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            SecurityUtils.getSubject().login(new UsernamePasswordToken(username, password));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            req.setAttribute(&quot;shiroLoginFailure&quot;, e.getClass());</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isLoginRequest(HttpServletRequest req) &#123;</span><br><span class="line">        return pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AnyRolesFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.StringUtils;</span><br><span class="line">import org.apache.shiro.web.filter.AccessControlFilter;</span><br><span class="line">import org.apache.shiro.web.util.WebUtils;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AnyRolesFilter extends AccessControlFilter &#123;</span><br><span class="line"></span><br><span class="line">    private String unauthorizedUrl = &quot;/unauthorized.jsp&quot;;</span><br><span class="line">    private String loginUrl = &quot;/login.jsp&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        String[] roles = (String[])mappedValue;</span><br><span class="line">        if(roles == null) &#123;</span><br><span class="line">            return true;//如果没有设置角色参数，默认成功</span><br><span class="line">        &#125;</span><br><span class="line">        for(String role : roles) &#123;</span><br><span class="line">            if(getSubject(request, response).hasRole(role)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;//跳到onAccessDenied处理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        Subject subject = getSubject(request, response);</span><br><span class="line">        if (subject.getPrincipal() == null) &#123;//表示没有登录，重定向到登录页面</span><br><span class="line">            saveRequest(request);</span><br><span class="line">            WebUtils.issueRedirect(request, response, loginUrl);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (StringUtils.hasText(unauthorizedUrl)) &#123;//如果有未授权页面跳转过去</span><br><span class="line">                WebUtils.issueRedirect(request, response, unauthorizedUrl);</span><br><span class="line">            &#125; else &#123;//否则返回401未授权状态码</span><br><span class="line">                WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.servlet.OncePerRequestFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @Classname MyOncePerRequestFilter</span><br><span class="line"> * @Description</span><br><span class="line"> *          自定义的拦截器实现扩展功能</span><br><span class="line"> *              1.动态 url -角色/权限访问控制的实现</span><br><span class="line"> *              2.根据 Subject 身份信息获取用户信息绑定到 Request</span><br><span class="line"> *              3.验证码验证</span><br><span class="line"> *              4.在线用户信息的保存</span><br><span class="line"> *          OncePerRequestFilter 保证一次请求只调用一次 doFilterInternal</span><br><span class="line"> *          需要将其配置在ini中</span><br><span class="line"> */</span><br><span class="line">public class MyOncePerRequestFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;=========once per request filter&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyAdviceFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.servlet.AdviceFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &lt;p&gt;User: Zhang Kaitao</span><br><span class="line"> * &lt;p&gt;Date: 14-2-3</span><br><span class="line"> * &lt;p&gt;Version: 1.0</span><br><span class="line"> */</span><br><span class="line">public class MyAdviceFilter extends AdviceFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;====预处理/前置处理&quot;);</span><br><span class="line">        return true;//返回false将中断后续拦截器链的执行</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;====后处理/后置返回处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;====完成处理/后置最终处理&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>MyPathMatchingFilter</p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.filter.PathMatchingFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MyPathMatchingFilter extends PathMatchingFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;url matches,config is &quot; + Arrays.toString((String[])mappedValue));</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>MyAccessControlFilter</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.shiro.filter;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.web.filter.AccessControlFilter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyAccessControlFilter extends AccessControlFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;access allowed&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;访问拒绝也不自己处理，继续拦截器链的执行&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>前端</p>
<p>login.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;.error&#123;color:red;&#125;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;error&quot;&gt;$&#123;error&#125;&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>test.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">login success</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Console</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=========once per request filter</span><br><span class="line">====预处理/前置处理</span><br><span class="line">url matches,config is [config]</span><br><span class="line">access allowed</span><br><span class="line">====后处理/后置返回处理</span><br><span class="line">====完成处理/后置最终处理</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java框架</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>BigDecimal精度</title>
    <url>/2021/06/10/212Java%E8%AF%AD%E8%A8%80/JavaSE/BigDecimal%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<p>BigDecimal精度</p>
<span id="more"></span>
<h1 id="BigDecimal精度"><a href="#BigDecimal精度" class="headerlink" title="BigDecimal精度"></a>BigDecimal精度</h1><p>丢失精度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new BigDecimal(12.10)；</span><br></pre></td></tr></table></figure>

<p>不丢失精度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new BigDecimal(&quot;12.10&quot;)；</span><br></pre></td></tr></table></figure>

<p>错误使用：</p>
<p>double存储时已经丢失精度了。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/oWazuIEJ79BDpxC.png" alt="image-20210115142405701"></p>
<p>正确使用：</p>
<p>double转string</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Double d = new Double(5.1);</span><br><span class="line">String s = d.toString();</span><br><span class="line">BigDecimal b = new BigDecimal(s);</span><br></pre></td></tr></table></figure>

<p>保留1位小数，四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bigDecimal.setScale(1,BigDecimal.ROUND_HALF_UP)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java语言</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>Log4j-log4j2报错</title>
    <url>/2020/08/18/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/Log4j-log4j2%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>Log4j-log4j2报错</p>
<span id="more"></span>

<h1 id="log4j2报错"><a href="#log4j2报错" class="headerlink" title="log4j2报错"></a>log4j2报错</h1><p>报错内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at org.apache.logging.log4j.LogManager.getContext(LogManager.java:194)</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log4j2 与 spring-boot-starter-logging 模块中的 log4j </span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>排除spring-boot-starter-logging包,可能有多个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;&lt;!-- 去掉默认配置 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;&lt;!-- 去掉默认配置 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/NpuHa6jSows3K4y.png" alt="image-20200818191029138"></p>
]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>Log4j</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC-全面了解</title>
    <url>/2020/08/23/213Java%E6%A1%86%E6%9E%B6/SpringMVC-%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<p>参数绑定，RequestMapping、返回值处理、拦截器、RESTful支持、跨域</p>
<span id="more"></span>

<h1 id="SpringMVC-全面了解"><a href="#SpringMVC-全面了解" class="headerlink" title="SpringMVC-全面了解"></a>SpringMVC-全面了解</h1><p>处理请求映射，视图解析。对servlet做了封装。</p>
<p>执行流程：</p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet。</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>处理器映射器找到具体的处理器返回给DispatcherServlet。</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器。</li>
<li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</li>
<li>Controller执行完成返回ModelAndView。</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li>
<li>ViewReslover解析后返回具体View.</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SpringMVC是spring-web模块的一部分。</p>
<p>六大组件</p>
<p>对外的三大组件</p>
<p>​    前端控制器、处理器、视图</p>
<p>内部三大组件</p>
<p> 处理器映射器、处理器适配器、视图解析器</p>
<p>前后端分离只需要开发处理器。</p>
<h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p>接收前端传递的参数后，SpringMVC依据绑定规则转换参数后，传递给Controller的形参。</p>
<p>SpringMVC底层采用24种绑定解析器（ArgumentResolver）处理</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>请求参数格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key/value</span><br></pre></td></tr></table></figure>

<p>请求参数数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String</span><br></pre></td></tr></table></figure>

<p>请求参数要绑定的目标类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Controller类中的方法参数，比如简单类型、POJO类型、集合类型等。</span><br></pre></td></tr></table></figure>

<p>RequestParam注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value:参数名字，即入参的请求参数名字</span><br><span class="line">required:默认是true，表示请求中一定要有相应的参数</span><br><span class="line">defaultValue：请求中没有同名参数时的默认值,使用时，required失效</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ModelAndView test(@RequestParam(value=&quot;name&quot;,required=false)String name)&#123;</span><br></pre></td></tr></table></figure>

<h3 id="绑定类型"><a href="#绑定类型" class="headerlink" title="绑定类型"></a>绑定类型</h3><p>简单类型数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过HTTP请求批量传递简单类型数组，Controller方法中可以用String[]或者pojo的String[]属性接收 （两种方式任选其一），但是不能使用List集合接收。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&amp;id=2&amp;id=3</span><br></pre></td></tr></table></figure>

<p>POJO类型集合或数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">批量传递的请求参数，最终要使用List&lt;POJO&gt;来接收，List&lt;POJO&gt;必须放在另一个POJO类中</span><br></pre></td></tr></table></figure>

<p>自定义日期 参数绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于springmvc无法解析的参数绑定类型,需要自定义 [参数转换器]进行参数绑定。</span><br></pre></td></tr></table></figure>

<p>Converter代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DateConverter implements Converter&lt;String, Date&gt; &#123; </span><br><span class="line">	@Override </span><br><span class="line">	public Date convert(String source) &#123; </span><br><span class="line">		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); </span><br><span class="line">		try &#123;</span><br><span class="line">			return simpleDateFormat.parse(source); </span><br><span class="line">		&#125; catch (ParseException e) &#123; </span><br><span class="line">			e.printStackTrace(); </span><br><span class="line">		&#125;</span><br><span class="line">		return null; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Converter配置 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 转换器配置 --&gt; </span><br><span class="line">&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; 		&lt;property name=&quot;converters&quot;&gt; </span><br><span class="line">		&lt;set&gt;&lt;</span><br><span class="line">			bean class=&quot;com.kkb.ssm.controller.converter.DateConverter&quot;/&gt; </span><br><span class="line">		&lt;/set&gt; </span><br><span class="line">	&lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>文件类型绑定</p>
<p>1.加入依赖<code> commons-fileupload</code></p>
<p>2.前端配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSP中的form表单需要指定enctype=”multipart/form-data”</span><br></pre></td></tr></table></figure>

<p>3.配置Multipart解析器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- multipart类型解析器，文件上传 --&gt; </span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; </span><br><span class="line">	&lt;!-- 上传文件的最大尺寸 5M--&gt; </span><br><span class="line">	&lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;/&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>4.Cotroller类代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;fileupload&quot;) </span><br><span class="line">public String findUserById(MultipartFile uploadFile) throws Exception &#123;</span><br><span class="line">    if (uploadFile != null) &#123;</span><br><span class="line">        System.out.println(uploadFile.getOriginalFilename());</span><br><span class="line">        // 原始图片名称 </span><br><span class="line">        String originalFilename = uploadFile.getOriginalFilename();</span><br><span class="line">        // 如果没有图片名称，则上传不成功 </span><br><span class="line">        if (originalFilename != null &amp;&amp; originalFilename.length() &gt; 0) &#123;</span><br><span class="line">            // 存放图片的物理路径 </span><br><span class="line">            String picPath = &quot;E:\\&quot;;</span><br><span class="line">            // 获取上传文件的扩展名 </span><br><span class="line">            String extName = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));</span><br><span class="line">            // 新文件的名称 </span><br><span class="line">            String newFileName = UUID.randomUUID() + extName;</span><br><span class="line">            // 新的文件 </span><br><span class="line">            File newFile = new File(picPath + newFileName);</span><br><span class="line">            // 把上传的文件保存成一个新的文件 </span><br><span class="line">            uploadFile.transferTo(newFile);</span><br><span class="line">            // 同时需要把新的文件名更新到数据库中 </span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;文件上传成功&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h2><p>value属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用于映射URL和HandlerMethod方法</span><br><span class="line">@RequestMapping(value=&quot;test&quot;)</span><br></pre></td></tr></table></figure>

<p>method属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 限定请求URL使用指定的method请求方式</span><br><span class="line">@RequestMapping(value=&quot;/test&quot;,method=RequestMethod.GET)</span><br><span class="line">@RequestMapping(value=&quot;/test&quot;,method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure>

<p>params属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 访问HandlerMethod 的限制</span><br><span class="line">@RequestMapping(value=&quot;test&quot;,params= &#123;&quot;name&quot;,&quot;price&gt;5000&quot;&#125;) </span><br><span class="line">public String test(Model model) &#123; </span><br><span class="line">	model.addAttribute(&quot;msg&quot;, &quot;test方法执行了&quot;); </span><br><span class="line">	return &quot;success&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>@ResponseBody</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对Controller返回值类型，使用内置的9种HttpMessageConverter进行匹配，找 到合适HttpMessageConverter进行处理。</span><br></pre></td></tr></table></figure>

<p>@RequestBody 处理请求参数的http消息转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping()</span><br><span class="line">public Message test(@RequestBody json)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非注解"><a href="#非注解" class="headerlink" title="非注解"></a>非注解</h3><p>1.ModelAndView </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ModelAndView test()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>ModelAndView 可添加model数据、指定view。</p>
<p>2.void</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test(HttpServletRequest request, HttpServletResponse response)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>request转发向页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</span><br></pre></td></tr></table></figure>

<p>过response页面重定向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(&quot;url&quot;)</span><br></pre></td></tr></table></figure>

<p>response指定响应结果，例如响应json数据如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;json串&quot;);</span><br></pre></td></tr></table></figure>

<p>3.String</p>
<p>forward转发 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return “forward:testForward&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相当于“ request.getRequestDispatcher().forward(request,response) ”</span><br><span class="line"></span><br><span class="line">浏览器URL不发送改变</span><br><span class="line"></span><br><span class="line">Request 域可以共享</span><br></pre></td></tr></table></figure>



<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>Spring MVC 的拦截器做了三次拦截。请求拦截一次，返回拦截两次。</p>
<p>请求拦截可做登录认证。</p>
<p>返回拦截中视图处理，前后端分离后不需要了</p>
<p>返回拦截中**，可用统一日志、统一异常处理。</p>
<h3 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h3><p>实现SpringMVC的HandlerIntercepter 接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyHandlerIntercepter implements HandlerInterceptor&#123;</span><br><span class="line"></span><br><span class="line">	//Handler执行前调用 </span><br><span class="line">	//应用场景：登录认证、身份授权 </span><br><span class="line">	//返回值为true则是放行，为false是不放行 </span><br><span class="line">	@Override </span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; </span><br><span class="line">		return false; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//进入Handler开始执行，并且在返回ModelAndView之前调用 </span><br><span class="line">	//应用场景：对ModelAndView对象操作，可以把公共模型数据传到前台，可以统一指定视图 </span><br><span class="line">	@Override </span><br><span class="line">	public void postHandle(HttpServletRequest request,HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; </span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//执行完Handler之后调用 </span><br><span class="line">	//应用场景：统一异常处理、统一日志处理 </span><br><span class="line">	@Override </span><br><span class="line">	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; </span><br><span class="line">	</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h3><p>SpringMVC 拦截器是绑定在 HandlerMapping 中的，即：如果某个 HandlerMapping 中配置拦截，则该HandlerMapping 映射成功的 Handler 会使用该拦截器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置全局mapping的拦截器 --&gt; </span><br><span class="line">&lt;mvc:interceptors&gt; </span><br><span class="line">	&lt;!-- 公共拦截器可以拦截所有请求，而且可以有多个 --&gt; </span><br><span class="line">	&lt;bean class=&quot;com.ssm.interceptor.MyHandlerInterceptor&quot; /&gt; </span><br><span class="line">	&lt;bean class=&quot;com.ssm.interceptor.MyHandlerInterceptor2&quot; /&gt; </span><br><span class="line">	&lt;!-- 如果有针对特定URL的拦截器，则进行以下配置 --&gt; </span><br><span class="line">	&lt;mvc:interceptor&gt; </span><br><span class="line">		&lt;!-- /**表示所有URL和子URL路径 --&gt; </span><br><span class="line">		&lt;mvc:mapping path=&quot;/orders/**&quot; /&gt; </span><br><span class="line">		&lt;!-- 特定请求的拦截器只能有一个 --&gt; </span><br><span class="line">		&lt;bean class=&quot;com.ssm.interceptor.MyHandlerInterceptor3&quot; /&gt; </span><br><span class="line">	&lt;/mvc:interceptor&gt; </span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果有多个拦截器，那么配置到`springmvc.xml`中最上面的拦截器，拦截优先级最高。 --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Restful支持"><a href="#Restful支持" class="headerlink" title="Restful支持"></a>Restful支持</h2><h3 id="rest介绍"><a href="#rest介绍" class="headerlink" title="rest介绍"></a>rest介绍</h3><p>REST（英文：Representational State Transfer，意思是：（资源）表述性状态转化)</p>
<p>rest是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。</p>
<p>基于rest风格设计的软件更简洁，有层次，更易于实现缓存等机制。</p>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网络上的一个实体，例如：一段文本、一张图片、一首歌曲、一种服务。</span><br><span class="line">可以用URI（统一资源定位符）指向它，每种资源对应一个特定的URI。</span><br></pre></td></tr></table></figure>

<h4 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把资源呈现出来的形式，叫做表现层。</span><br><span class="line">格式：html、xml、json，二级制。</span><br></pre></td></tr></table></figure>

<h4 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每发出一个HTTP请求，就代表了客户端和服务器的一次交互过程。</span><br><span class="line">HTTP协议，是一个无状态协议，即所有的【状态】 都保存在服务器端。因此，如果客户端想要操作服务器， 必须通过某种手段，让服务器端发生“状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。</span><br><span class="line"></span><br><span class="line">HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT 、DELETE 。它们分别对应四种 基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</span><br></pre></td></tr></table></figure>

<h3 id="如何设计RESTful应用程序的API"><a href="#如何设计RESTful应用程序的API" class="headerlink" title="如何设计RESTful应用程序的API"></a>如何设计RESTful应用程序的API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">路径设计：数据库设计完毕之后，基本上就可以确定有哪些资源要进行操作，相对于资源的路径也可以设计出来 </span><br><span class="line">动词设计：也就是针对资源的具体操作类型，由HTTP动词表示，常用的HTTP动词如下：POST、DELETE、PUT、GET</span><br></pre></td></tr></table></figure>

<p>RESTful的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/account/1 HTTP GET ： 得到 id = 1 的 account </span><br><span class="line">/account/1 HTTP DELETE： 删除 id = 1 的 account </span><br><span class="line">/account/1 HTTP PUT： 更新 id = 1 的 account</span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC如何支持Restful"><a href="#SpringMVC如何支持Restful" class="headerlink" title="SpringMVC如何支持Restful"></a>SpringMVC如何支持Restful</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 拦截RESTful请求</span><br><span class="line">&lt;servlet-mapping&gt; </span><br><span class="line">	&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; </span><br><span class="line">	&lt;url-pattern&gt;/&lt;/url-pattern&gt; </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">// 设置为/ ,前后端不分离时，需要处理静态资源路径。</span><br></pre></td></tr></table></figure>



<h4 id="url与参数绑定"><a href="#url与参数绑定" class="headerlink" title="url与参数绑定"></a>url与参数绑定</h4><p>@PathVariable</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求URL http://localhost:8080/ssm/item/1/lisi</span><br><span class="line"></span><br><span class="line">// Controller</span><br><span class="line">@RequestMapping(“&#123;id&#125;/&#123;name&#125;”) </span><br><span class="line">@ResponseBody </span><br><span class="line">public Item queryItemById(@PathVariable Integer id, @PathVariable String name)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源的表现形式"><a href="#资源的表现形式" class="headerlink" title="资源的表现形式"></a>资源的表现形式</h4><p>SpringMVC中可以使用 ContentNegotiatingManager这个内容协商管理器来控制表现形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展名：比如.json表示我要JSON格式数据、.xml表示我要XML格式数据</span><br><span class="line">请求参数：默认是”format”</span><br><span class="line">请求头设置Accept参数：比如设置Accept为application/json表示要JSON格式数据</span><br></pre></td></tr></table></figure>



<h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping：通过设置method属性值</span><br><span class="line">@GetMapping、@PostMapping、@PutMapping、@DeleteMapping注解等同@RequestMapping注解配置method属性。</span><br></pre></td></tr></table></figure>



<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>浏览器为了安全有这么一个规定：同源策略，即只用同源才可以访问浏览器的数据，非同源不可访问。</p>
<p>同源：相同的http协议、相同的域名、相同的端口号。</p>
<p>前后端分离后，前端和后端不是同源。这种情况我们要实现前后的非同源访问，就是跨域访问。</p>
<table>
<thead>
<tr>
<th>跨域情况</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>主域相同子域不同</td>
<td><a href="http://www.baidu.com/a.js">http://www.baidu.com/a.js</a></td>
<td><a href="http://blog.baidu.com/b.js">http://blog.baidu.com/b.js</a></td>
</tr>
<tr>
<td>协议不同</td>
<td><a href="http://www.baidu.com/a.js">http://www.baidu.com/a.js</a></td>
<td><a href="https://www.baidu.com/b.js">https://www.baidu.com/b.js</a></td>
</tr>
<tr>
<td>域名对应真实ip</td>
<td><a href="http://www.baidu.com/a.js">http://www.baidu.com/a.js</a></td>
<td><a href="http://192.168.2.2/b.js">http://192.168.2.2/b.js</a></td>
</tr>
</tbody></table>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>三种方式：基于JavaScript标签的src方式，基于JQuery的JSONP方式，基于CORS的方式。</p>
<p>JSONP只能解决get方式。CORS可解决GET、POST。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><h5 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h5><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（ Cross-origin resource sharing ）。</p>
<p>它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能， IE 浏览器不能低于 IE10 </p>
<p>请求信息：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/4oOue7PfNEI9C3s.png" alt="image-20200823082701342"></p>
<p>响应信息：</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Q1OcS5LPMiTCZ4j.png" alt="image-20200823082826743"></p>
<p>前端设置请求头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动向请求头 header 中注入 Origin 。</span><br></pre></td></tr></table></figure>

<p>后端对响应拦截，设置响应头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器端需要向响应头 header 中注入 Access-Control-Allow-Origin</span><br></pre></td></tr></table></figure>

<h5 id="CORS实现跨域"><a href="#CORS实现跨域" class="headerlink" title="CORS实现跨域"></a>CORS实现跨域</h5><h6 id="CORS通过拦截器实现"><a href="#CORS通过拦截器实现" class="headerlink" title="CORS通过拦截器实现"></a>CORS通过拦截器实现</h6><p>跨域不提交cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AllowOriginInterceptor implements HandlerInterceptor &#123; </span><br><span class="line">	@Override</span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123; </span><br><span class="line">		// 跨域行为参考网址 http://www.cnblogs.com/renhaisong/p/6892341.html</span><br><span class="line">		if (request.getHeader(&quot;Origin&quot;) != null) &#123; </span><br><span class="line">            response.setContentType(&quot;text/html;charset=UTF-8&quot;); </span><br><span class="line">            // 允许哪一个URL </span><br><span class="line">            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); </span><br><span class="line">            // 允许那种请求方法 </span><br><span class="line">            response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE, PUT&quot;); </span><br><span class="line">            response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;); </span><br><span class="line">            System.out.println(&quot;正在跨域&quot;); </span><br><span class="line">		&#125;</span><br><span class="line">		return true; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跨域提交Cookie</p>
<p>注意：</p>
<ul>
<li><code>Access-Control-Allow-Credentials</code> 为 true 的时候， <code>Access-Control-Allow-Origin</code> 不能设置为”*”，否则报错。</li>
<li>如果有多个拦截器，把处理跨域请求的拦截器放到首位</li>
</ul>
<p>前端JQuery代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123; </span><br><span class="line">	url: &#x27;url&#x27;, </span><br><span class="line">	method:&#x27;请求方式&#x27;, //GET POST PUT DELETE </span><br><span class="line">	xhrFields:&#123; </span><br><span class="line">		withCredentials:true </span><br><span class="line">	&#125;,</span><br><span class="line">	success:function(data)&#123; </span><br><span class="line">		// do something </span><br><span class="line">	&#125;,</span><br><span class="line">	error:function()&#123; </span><br><span class="line">		// do something  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后端JAVA代码，采用springMVC拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AllowOriginInterceptor implements HandlerInterceptor &#123; </span><br><span class="line">	@Override </span><br><span class="line">	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123; </span><br><span class="line">		// 有跨域行为时参考网址 http://namezhou.iteye.com/blog/2384434 </span><br><span class="line">		if (request.getHeader(&quot;Origin&quot;) != null) &#123; </span><br><span class="line">			response.setContentType(&quot;text/html;charset=UTF-8&quot;); </span><br><span class="line">			// 允许哪一个URL访问 request.getHeader(&quot;Origin&quot;) 动态获取请求来的url</span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); </span><br><span class="line">			// 允许那种请求方法 </span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,HEAD&quot;); </span><br><span class="line">			// 本次预检请求的有效期 (&quot;0&quot;:每次异步请求都发起预检请求，允许跨域，再发出正式请求。&quot;3600&quot;：有效期1小时)</span><br><span class="line">			response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;0&quot;); </span><br><span class="line">			// 允许请求头里的参数列表 </span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, No-Cache, X-Requested-With, If-Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M-With,userId,token&quot;); </span><br><span class="line">			// 允许对方带cookie访问 </span><br><span class="line">			response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); </span><br><span class="line">			response.setHeader(&quot;XDomainRequestAllowed&quot;, &quot;1&quot;); </span><br><span class="line">			System.out.println(&quot;可接待cookie跨域&quot;); </span><br><span class="line">		&#125;</span><br><span class="line">		return true; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端JAVA代码，采用过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component // 表示这是配置类，注入到Spring容器中。（不属于@Controller、@Services、@repository)</span><br><span class="line">public class CorsFilter implements Filter &#123;</span><br><span class="line"> </span><br><span class="line">     @Override</span><br><span class="line">     public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     @Override</span><br><span class="line">     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">         HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">         HttpServletRequest httpRequest = (HttpServletRequest) request;</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, httpRequest.getHeader(&quot;Origin&quot;)!=null ? httpRequest.getHeader(&quot;Origin&quot;):&quot;&quot;);</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, httpRequest.getMethod());</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">         httpResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, httpRequest.getHeader(&quot;Access-Control-Request-Headers&quot;));</span><br><span class="line">         chain.doFilter(request, response);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     @Override</span><br><span class="line">     public void destroy() &#123;</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="CORS通过注解方式"><a href="#CORS通过注解方式" class="headerlink" title="CORS通过注解方式"></a>CORS通过注解方式</h6><p>springMVC4.x以上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CrossOrigin</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>操作日志</title>
    <url>/2021/05/15/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>记录操作日志</p>
<span id="more"></span>

<h1 id="记录操作日志"><a href="#记录操作日志" class="headerlink" title="记录操作日志"></a>记录操作日志</h1><h2 id="1-反射获取swagger日志，并插入到redis"><a href="#1-反射获取swagger日志，并插入到redis" class="headerlink" title="1.反射获取swagger日志，并插入到redis"></a>1.反射获取swagger日志，并插入到redis</h2><h2 id="2-Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ"><a href="#2-Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ" class="headerlink" title="2.Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ"></a>2.Gatway过滤器收集接口访问记录，并拼接swagger插入到RabbitMQ</h2><h2 id="3-获取RabbitMQ数据，并插入到mysql"><a href="#3-获取RabbitMQ数据，并插入到mysql" class="headerlink" title="3.获取RabbitMQ数据，并插入到mysql"></a>3.获取RabbitMQ数据，并插入到mysql</h2><h2 id="4-从库中查询日志到页面"><a href="#4-从库中查询日志到页面" class="headerlink" title="4.从库中查询日志到页面"></a>4.从库中查询日志到页面</h2>]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>操作日志</tag>
      </tags>
  </entry>
  <entry>
    <title>获取RabbitMQ数据，并插入到mysql</title>
    <url>/2021/05/22/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97_3.%E8%8E%B7%E5%8F%96RabbitMQ%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E6%8F%92%E5%85%A5%E5%88%B0mysql/</url>
    <content><![CDATA[<p>获取RabbitMQ数据，并插入到mysql</p>
<span id="more"></span>

<h1 id="获取RabbitMQ数据，并插入到mysql"><a href="#获取RabbitMQ数据，并插入到mysql" class="headerlink" title="获取RabbitMQ数据，并插入到mysql"></a>获取RabbitMQ数据，并插入到mysql</h1><ol>
<li>从RabbitMQ中取数据</li>
<li>获取用户信息，分为登录接口与非登录接口<ol>
<li>登录接口<ol>
<li>对账号解密，通过远程接口查出userId、userCode、userName。</li>
</ol>
</li>
<li>非登录接口<ol>
<li>通过userId去Redis中查询userCode和userName</li>
<li>redis中没有，调用远程接口查询并将结果插入到redis</li>
</ol>
</li>
</ol>
</li>
<li>将 模块+接口 作为key获取redis中key对应的swagger注释</li>
<li>获取其他参数，设置主键值。</li>
<li>每10个插入到mysql库中。（缓解插入压力）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.logmanager.queue;</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.xiaoruiit.common.constant.RabbitQueueConstant;</span><br><span class="line">import com.xiaoruiit.common.service.RedisService;</span><br><span class="line">import com.xiaoruiit.common.utils.*;</span><br><span class="line">import com.xiaoruiit.logmanager.constant.LogMgrIdConstants;</span><br><span class="line">import com.xiaoruiit.logmanager.dao.MyLogHistoryMapper;</span><br><span class="line">import com.xiaoruiit.logmanager.entity.auto.LogmgrLogHistory;</span><br><span class="line">import com.xiaoruiit.logmanager.entity.vo.UserVO;</span><br><span class="line">import com.xiaoruiit.logmanager.service.MdmService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.bouncycastle.crypto.InvalidCipherTextException;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class QueueMessageListener &#123;</span><br><span class="line">    private static final String LOG_USER_INFO_HASH_KEY = &quot;logmgr:user_info&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 合并插入值</span><br><span class="line">     */</span><br><span class="line">    private final static int INSERT_CNT = 10;</span><br><span class="line">    /**</span><br><span class="line">     * 合并插入超时</span><br><span class="line">     */</span><br><span class="line">    private final static int INSERT_TIME_OUT = 5000;</span><br><span class="line">    /**</span><br><span class="line">     * 合并插入集合</span><br><span class="line">     */</span><br><span class="line">    private static final List&lt;LogmgrLogHistory&gt; LIST = new ArrayList&lt;&gt;();</span><br><span class="line">    private long lastInsert;</span><br><span class="line">    private final Lock lock = new ReentrantLock(); //可重入的互斥锁</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogHistoryMapper myHistoryMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MdmService userService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监听器单线程执行</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = RabbitQueueConstant.QUEUE_LOG)</span><br><span class="line">    public void logListener(String msg) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 优化点：批量插入</span><br><span class="line">            LogmgrLogHistory history = JSON.parseObject(msg, LogmgrLogHistory.class);</span><br><span class="line">            if (StrUtil.isEmpty(history.getModel()) || history.getUserId() == null || StrUtil.isEmpty(history.getUserId() + &quot;&quot;)) &#123;</span><br><span class="line">                if (!(&quot;/oauth/token&quot;.equals(history.getFunc())))&#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // TODO 登录日志入库 登录时获取不到userId单独处理</span><br><span class="line">                String url = history.getUrl();</span><br><span class="line">                Map&lt;String, String&gt; params = URLUtils.getParamsByUrl(url);</span><br><span class="line">                signInParameterHandle(params);</span><br><span class="line">                String userPhone = params.get(&quot;username&quot;);</span><br><span class="line">                // 通过手机号获取用户信息  用户id，code，名称</span><br><span class="line">                Result&lt;UserVO&gt; userByMobile = userService.getUserByMobile(userPhone);</span><br><span class="line">                if (userByMobile.getData()!= null)&#123;</span><br><span class="line">                    history.setUserId(userByMobile.getData().getUserId());</span><br><span class="line">                    history.setUserCode(userByMobile.getData().getUserCode());</span><br><span class="line">                    history.setUserName(userByMobile.getData().getUserName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                setUserInfo(history);</span><br><span class="line">            &#125;</span><br><span class="line">            if (StrUtil.isNotEmpty(history.getModel()) &amp;&amp; StrUtil.isNotEmpty(history.getFunc())) &#123;</span><br><span class="line">                Object o = redisService.hGet(Constant.SWAGGER_HASH_KEY, history.getModel() + history.getFunc());</span><br><span class="line">                if (o == null) &#123;</span><br><span class="line">                    o = redisService.hGet(Constant.SWAGGER_HASH_KEY, history.getModel() + deleteLastSlash(history.getFunc()));</span><br><span class="line">                &#125;</span><br><span class="line">                history.setDescription(o == null ? &quot;&quot; : o.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            if (history.getUrl() != null &amp;&amp; history.getUrl().length() &gt; 800) &#123;</span><br><span class="line">                history.setUrl(history.getUrl().substring(0, 790));</span><br><span class="line">            &#125;</span><br><span class="line">            if (history.getFunc() != null &amp;&amp; history.getFunc().length() &gt; 250) &#123;</span><br><span class="line">                history.setFunc(history.getFunc().substring(0, 250));</span><br><span class="line">            &#125;</span><br><span class="line">            if (StrUtil.isNotEmpty(history.getBody()) &amp;&amp; history.getBody().length() &gt;= 4000) &#123;</span><br><span class="line">                history.setBody(history.getBody().substring(0, 4000));</span><br><span class="line">            &#125;</span><br><span class="line">            history.setLogHisId(IdWorker.nextId(LogMgrIdConstants.LOG_HIS_ID_PREFIX));</span><br><span class="line">            LIST.add(history);</span><br><span class="line">            if (LIST.size() &gt;= INSERT_CNT) &#123;</span><br><span class="line">                insertAndReset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setUserInfo(LogmgrLogHistory history) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object o = redisService.hGet(LOG_USER_INFO_HASH_KEY, history.getUserId() + &quot;&quot;);</span><br><span class="line">            if (o != null) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) o;</span><br><span class="line">                history.setUserName(map.get(&quot;userName&quot;) + &quot;&quot;);</span><br><span class="line">                history.setUserCode(map.get(&quot;userCode&quot;) + &quot;&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Result result = userService.getUserInfoById(history.getUserId());</span><br><span class="line">            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) result.getData();</span><br><span class="line">            if (map != null) &#123;</span><br><span class="line">                history.setUserName(map.get(&quot;userName&quot;) + &quot;&quot;);</span><br><span class="line">                history.setUserCode(map.get(&quot;userCode&quot;) + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            redisService.hSet(LOG_USER_INFO_HASH_KEY, history.getUserId() + &quot;&quot;, map);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String deleteLastSlash(String src) &#123;</span><br><span class="line">        int i = src.lastIndexOf(&quot;/&quot;);</span><br><span class="line">        if (i != -1) &#123;</span><br><span class="line">            return src.substring(0, i);</span><br><span class="line">        &#125;</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监听不满足合并要求的数据</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(fixedDelay = 10000)</span><br><span class="line">    public void listListener() &#123;</span><br><span class="line">        if (lock.tryLock()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!LIST.isEmpty() &amp;&amp; System.currentTimeMillis() - lastInsert &gt; INSERT_TIME_OUT) &#123;</span><br><span class="line">                    insertAndReset();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void insertAndReset() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;myHistoryMapper.insertList(LIST) size = &#123;&#125;&quot;, LIST.size());</span><br><span class="line">            myHistoryMapper.insertList(LIST);</span><br><span class="line">            LIST.clear();</span><br><span class="line">            lastInsert = System.currentTimeMillis();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LIST.forEach(lh -&gt; lh.setLogHisId(IdWorker.nextId(LogMgrIdConstants.LOG_HIS_ID_PREFIX)));</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 解密</span><br><span class="line">    public void signInParameterHandle(Map&lt;String, String&gt; parameters) throws InvalidCipherTextException &#123;</span><br><span class="line">        String usernamePlaintext;</span><br><span class="line"></span><br><span class="line">        String username = parameters.get(&quot;username&quot;);</span><br><span class="line">        String signInType = parameters.get(&quot;signInType&quot;);</span><br><span class="line">        if (&quot;1&quot;.equals(signInType)) &#123;</span><br><span class="line">            String sm2PublicKeyHex = parameters.get(&quot;公钥字符串&quot;);</span><br><span class="line"></span><br><span class="line">            String sm2PrivateKeyHex = (String) redisService.get(&quot;私钥redis中key&quot; + sm2PublicKeyHex);</span><br><span class="line">            // 还原私钥 私钥16进制格式</span><br><span class="line">            BigInteger privateKeyD = new BigInteger(sm2PrivateKeyHex, 16);</span><br><span class="line"></span><br><span class="line">            usernamePlaintext = Sm2Utils.sm2PrivateKeyDecrypt(privateKeyD, username);</span><br><span class="line">            parameters.put(&quot;username&quot;, usernamePlaintext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>反射获取swagger描述，并插入到redis</title>
    <url>/2021/05/15/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97_1.%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96swagger%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%B9%B6%E6%8F%92%E5%85%A5%E5%88%B0redis/</url>
    <content><![CDATA[<p>反射获取swagger描述，并插入到redis</p>
<span id="more"></span>

<h1 id="反射获取swagger描述，并插入到redis"><a href="#反射获取swagger描述，并插入到redis" class="headerlink" title="反射获取swagger描述，并插入到redis"></a>反射获取swagger描述，并插入到redis</h1><ol>
<li>redis序列化配置</li>
<li>实现SpringBoot的CommandLineRunner接口，作用：项目启动时执行run方法</li>
<li>反射获取所有的Controller类</li>
<li>获取Controller类上的swagger注解，取需要的值</li>
<li>遍历所有的Controller类，获取每个类的所有方法</li>
<li>获取每个方法上的swagger注解，取需要的值</li>
<li>插入到redis中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line">import org.springframework.data.redis.core.*;</span><br><span class="line">import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;</span><br><span class="line">import org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Redis序列化配置</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.common.config;</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import com.hanxxiaorui.common.constant.SwaggerConstant;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.CommandLineRunner;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.util.ClassUtils;</span><br><span class="line">import org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class BaseSwaggerCache implements CommandLineRunner &#123;// 实现SpringBoot的CommandLineRunner接口，项目启动时执行run方法</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">    private String appName;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    WebApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getAllUrlAndSetRedisForLogManger();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取swagger注解并放入redis</span><br><span class="line">     */</span><br><span class="line">    public void getAllUrlAndSetRedisForLogManger() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        // 获取带有Controller注解的类</span><br><span class="line">        Map&lt;String, Object&gt; beansMap = applicationContext.getBeansWithAnnotation(Controller.class);</span><br><span class="line">        for (String key : beansMap.keySet()) &#123;</span><br><span class="line">            // 反射获取每个controller类</span><br><span class="line">            Class&lt;?&gt; clazz = beansMap.get(key).getClass();</span><br><span class="line">            // 获取因@Validated注解，导致Cglib代理过的父类。 @Validated会在原类上生成子类，子类不继承父类注解。</span><br><span class="line">            Class&lt;?&gt; userClass = ClassUtils.getUserClass(clazz);</span><br><span class="line"></span><br><span class="line">            String classPath = this.getRequestMappingPath(userClass);</span><br><span class="line">            String apiValue = this.getApiValue(userClass);</span><br><span class="line">            // 获取类的所有方法</span><br><span class="line">            Method[] methods = userClass.getMethods();</span><br><span class="line">            for (Method method : methods) &#123;</span><br><span class="line">                String methodPath = this.getMethodRequestMappingPath(method);</span><br><span class="line">                String apiOperationPath = this.getApiOperationValue(method);</span><br><span class="line"></span><br><span class="line">                if (StrUtil.isNotEmpty(methodPath)</span><br><span class="line">                        &amp;&amp; StrUtil.isNotEmpty(apiValue)</span><br><span class="line">                        &amp;&amp; StrUtil.isNotEmpty(apiOperationPath)) &#123;</span><br><span class="line">                    apiValue = apiValue.replace(&quot;接口&quot;, &quot;&quot;);</span><br><span class="line">                    result.put(this.deleteBrackets(appName + &quot;/&quot; + classPath + methodPath), apiValue + &quot;|&quot; + apiOperationPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 插入到redis中</span><br><span class="line">        redisTemplate.opsForHash().putAll(SwaggerConstant.SWAGGER_HASH_KEY, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取类上注解@RequestMapping中的value的值  如：&quot;/back/management&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getRequestMappingPath(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        RequestMapping annotation = clazz.getAnnotation(RequestMapping.class);</span><br><span class="line">        if (annotation == null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] values = annotation.value();</span><br><span class="line">        String path = &quot;&quot;;</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            if (StrUtil.isNotEmpty(value)) &#123;</span><br><span class="line">                path = value;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取类上注解@Api中tags的值 如：&quot;后台管理&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getApiValue(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        Api api = clazz.getAnnotation(Api.class);</span><br><span class="line">        if (api == null) &#123;</span><br><span class="line">            String clazzSimpleName = clazz.getSimpleName();</span><br><span class="line">            return clazzSimpleName;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] tags = api.tags();</span><br><span class="line">        String apiValue = &quot;&quot;;</span><br><span class="line">        for (String tag : tags) &#123;</span><br><span class="line">            if (StrUtil.isNotEmpty(tag)) &#123;</span><br><span class="line">                apiValue = tag;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StrUtil.isEmpty(apiValue)) &#123;</span><br><span class="line">            String value = api.value();</span><br><span class="line">            if (StrUtil.isNotEmpty(value)) &#123;</span><br><span class="line">                apiValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return apiValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取方法上注解@RequestMapping、@GetMapping等里边value的值 如：&quot;/add&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getMethodRequestMappingPath(Method method) &#123;</span><br><span class="line">        GetMapping getMapping = method.getAnnotation(GetMapping.class);</span><br><span class="line">        PostMapping postMapping = method.getAnnotation(PostMapping.class);</span><br><span class="line">        DeleteMapping deleteMapping = method.getAnnotation(DeleteMapping.class);</span><br><span class="line">        RequestMapping requestMapping = method.getAnnotation(RequestMapping.class);</span><br><span class="line"></span><br><span class="line">        String[] values = getMapping != null ? getMapping.value()</span><br><span class="line">                : postMapping != null ? postMapping.value()</span><br><span class="line">                : requestMapping != null ? requestMapping.value() : deleteMapping != null ? deleteMapping.value()</span><br><span class="line">                : new String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        String path = &quot;&quot;;</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            if (StrUtil.isNotEmpty(value)) &#123;</span><br><span class="line">                path = value;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取方法上注解@ApiOperation里边value的值 如：&quot;新增&quot;</span><br><span class="line">     */</span><br><span class="line">    private String getApiOperationValue(Method method) &#123;</span><br><span class="line">        ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);</span><br><span class="line">        if (apiOperation == null) &#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            return methodName;</span><br><span class="line">        &#125;</span><br><span class="line">        String value = apiOperation.value();</span><br><span class="line">        if (StrUtil.isEmpty(value)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将RESTful风格/&#123;id&#125;，记录为/*</span><br><span class="line">     */</span><br><span class="line">    private String deleteBrackets(String src) &#123;</span><br><span class="line">        if (StrUtil.isEmpty(src)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        src = src.replace(&quot;//&quot;, &quot;/&quot;);</span><br><span class="line">        int i = src.indexOf(&quot;/&#123;&quot;);</span><br><span class="line">        if (i != -1) &#123;</span><br><span class="line">            return src.substring(0, i) + &quot;/*&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>swagger</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Gatway过滤器收集接口访问记录，插入到RabbitMQ</title>
    <url>/2021/05/19/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97_2.Gatway%E8%BF%87%E6%BB%A4%E5%99%A8%E6%94%B6%E9%9B%86%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%8F%92%E5%85%A5%E5%88%B0RabbitMQ/</url>
    <content><![CDATA[<p>Gatway过滤器收集接口访问记录，插入到RabbitMQ</p>
<span id="more"></span>

<h1 id="2-Gatway过滤器收集接口访问记录，插入到RabbitMQ"><a href="#2-Gatway过滤器收集接口访问记录，插入到RabbitMQ" class="headerlink" title="2.Gatway过滤器收集接口访问记录，插入到RabbitMQ"></a>2.Gatway过滤器收集接口访问记录，插入到RabbitMQ</h1><ol>
<li>RabbitMQ交换机和队列项目启动时初始化配置</li>
<li>Gatway过滤器拦截所有请求，对表单请求和非表单请求分别处理，获取url和body参数。</li>
<li>将参数组装起来，发送到RabbitMQ。（过滤不记录日志的请求）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.amqp.core.TopicExchange;</span><br><span class="line">import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitAdmin;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: hxr</span><br><span class="line"> * @Description: 操作日志交换机和队列初始化</span><br><span class="line"> * @date: 2021/05/19</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    public final static String EXCH_LOG = &quot;exch_log&quot;;</span><br><span class="line"></span><br><span class="line">    public final static String QUEUE_LOG = &quot;queue_log&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TopicExchange exchLog() &#123;</span><br><span class="line">        return new TopicExchange(this.EXCH_LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueLog() &#123;</span><br><span class="line">        return new Queue(this.QUEUE_LOG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeOrderDicQueue() &#123;</span><br><span class="line">        return BindingBuilder.bind(queueLog()).to(exchLog()).with(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建初始化RabbitAdmin对象</span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitAdmin rabbitAdmin(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RabbitAdmin rabbitAdmin = new RabbitAdmin(connectionFactory);</span><br><span class="line">        // 只有设置为 true，spring 才会加载 RabbitAdmin 这个类</span><br><span class="line">        rabbitAdmin.setAutoStartup(true);</span><br><span class="line">        return rabbitAdmin;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建交换机和对列</span><br><span class="line">    @Bean</span><br><span class="line">    public void createExchangeQueue ()&#123;</span><br><span class="line">        rabbitAdmin.declareExchange(exchLog());</span><br><span class="line">        rabbitAdmin.declareQueue(queueLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.filter;</span><br><span class="line"></span><br><span class="line">import cn.hutool.json.JSONUtil;</span><br><span class="line">import com.xiaoruiit.common.constant.AuthConstant;</span><br><span class="line">import com.xiaoruiit.common.domain.UserSignDTO;</span><br><span class="line">import com.xiaoruiit.common.utils.IPUtils;</span><br><span class="line">import com.xiaoruiit.queue.LogHistory;</span><br><span class="line">import com.xiaoruiit.queue.MessageService;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line">import org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line">import org.springframework.cloud.gateway.filter.factory.rewrite.CachedBodyOutputMessage;</span><br><span class="line">import org.springframework.cloud.gateway.route.Route;</span><br><span class="line">import org.springframework.cloud.gateway.support.BodyInserterContext;</span><br><span class="line">import org.springframework.cloud.gateway.support.DefaultServerRequest;</span><br><span class="line">import org.springframework.core.io.buffer.DataBuffer;</span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.http.HttpMethod;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line">import org.springframework.http.server.reactive.ServerHttpRequestDecorator;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.util.MultiValueMap;</span><br><span class="line">import org.springframework.web.reactive.function.BodyInserter;</span><br><span class="line">import org.springframework.web.reactive.function.BodyInserters;</span><br><span class="line">import org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line">import org.springframework.web.server.ServerWebExchange;</span><br><span class="line">import reactor.core.publisher.Flux;</span><br><span class="line">import reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">import static org.springframework.cloud.gateway.support.ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author hxr</span><br><span class="line"> * @date 2020/05/11</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class GatewayLoggingFilter implements GlobalFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MessageService messageService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);</span><br><span class="line"></span><br><span class="line">        // 获取用户传来的数据类型</span><br><span class="line">        MediaType mediaType = exchange.getRequest().getHeaders().getContentType();</span><br><span class="line">        ServerRequest serverRequest = new DefaultServerRequest(exchange);</span><br><span class="line">        HttpMethod method = exchange.getRequest().getMethod();</span><br><span class="line">        // 如果是表单请求</span><br><span class="line">        if (method == HttpMethod.POST &amp;&amp; MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) &#123;</span><br><span class="line">            Mono&lt;String&gt; modifiedBody = serverRequest.bodyToMono(String.class)</span><br><span class="line">                    // .log(&quot;modify_request_mono&quot;, Level.INFO)</span><br><span class="line">                    .flatMap(body -&gt; &#123;</span><br><span class="line">                        assert route != null;</span><br><span class="line">                        recordLog(exchange.getRequest(), body, route);</span><br><span class="line"></span><br><span class="line">                        return Mono.just(body);</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            return getVoidMono(exchange, chain, String.class, modifiedBody);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert route != null;</span><br><span class="line">        recordLog(exchange.getRequest(), &quot;&quot;, route);</span><br><span class="line">        return chain.filter(exchange.mutate().request(exchange.getRequest()).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参照 ModifyRequestBodyGatewayFilterFactory.java 截取的方法</span><br><span class="line">     */</span><br><span class="line">    private Mono&lt;Void&gt; getVoidMono(ServerWebExchange exchange, GatewayFilterChain chain, Class outClass, Mono&lt;?&gt; modifiedBody) &#123;</span><br><span class="line">        BodyInserter bodyInserter = BodyInserters.fromPublisher(modifiedBody, outClass);</span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        headers.putAll(exchange.getRequest().getHeaders());</span><br><span class="line"></span><br><span class="line">        // the new content type will be computed by bodyInserter</span><br><span class="line">        // and then set in the request decorator</span><br><span class="line">        headers.remove(HttpHeaders.CONTENT_LENGTH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CachedBodyOutputMessage outputMessage = new CachedBodyOutputMessage(exchange, headers);</span><br><span class="line">        return bodyInserter.insert(outputMessage, new BodyInserterContext()).then(Mono.defer(() -&gt; &#123;</span><br><span class="line">            ServerHttpRequestDecorator decorator = new ServerHttpRequestDecorator(</span><br><span class="line">                    exchange.getRequest()) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public HttpHeaders getHeaders() &#123;</span><br><span class="line">                    long contentLength = headers.getContentLength();</span><br><span class="line">                    HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">                    httpHeaders.putAll(super.getHeaders());</span><br><span class="line">                    if (contentLength &gt; 0) &#123;</span><br><span class="line">                        httpHeaders.setContentLength(contentLength);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // TODO: this causes a &#x27;HTTP/1.1 411 Length Required&#x27; on httpbin.org</span><br><span class="line">                        httpHeaders.set(HttpHeaders.TRANSFER_ENCODING, &quot;chunked&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return httpHeaders;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public Flux&lt;DataBuffer&gt; getBody() &#123;</span><br><span class="line">                    return outputMessage.getBody();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            return chain.filter(exchange.mutate().request(decorator).build());</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 组装日志需要的字段信息，并发送到RabbitMQ</span><br><span class="line">     *</span><br><span class="line">     * @param request request</span><br><span class="line">     * @param body    请求的body内容</span><br><span class="line">     */</span><br><span class="line">    private void recordLog(ServerHttpRequest request, Object body, Route route) &#123;</span><br><span class="line">        InetSocketAddress address = request.getRemoteAddress();</span><br><span class="line"></span><br><span class="line">        String ip = IPUtils.getIpAddrForGateWay(request);</span><br><span class="line"></span><br><span class="line">        assert address != null;</span><br><span class="line">        // 心跳不记录操作日志 TODO 实现可配置不记录日志</span><br><span class="line">        if (&quot;/message/heartbeats&quot;.equals(request.getURI().getRawPath()))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HttpMethod method = request.getMethod();</span><br><span class="line">        HttpHeaders headers = request.getHeaders();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        URI uri = request.getURI();</span><br><span class="line"></span><br><span class="line">        LogHistory history = new LogHistory();</span><br><span class="line">        history.setIp(ip);</span><br><span class="line">        history.setUrl(uri.toString());</span><br><span class="line">        history.setFunc(request.getURI().getRawPath());</span><br><span class="line">        history.setModel(route.getUri().getHost());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            history.setParams(queryParams.toString().length() &gt; 900 ? &quot;&quot; : queryParams.toString());</span><br><span class="line">            if (method == HttpMethod.POST) &#123;</span><br><span class="line">                history.setBody(body.toString().length() &gt; 900 ? &quot;&quot; : body.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            String userStr = headers.getFirst(AuthConstant.USER_TOKEN_HEADER);</span><br><span class="line">            UserSignDTO userSignDto = JSONUtil.toBean(userStr, UserSignDTO.class);</span><br><span class="line">            if (userSignDto != null) &#123;</span><br><span class="line">                history.setUserId(userSignDto.getUserId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        history.setOptTime(LocalDateTime.now());</span><br><span class="line">        try &#123;</span><br><span class="line">        	// 发送到RabbitMQ</span><br><span class="line">            messageService.sendTestMessage(history);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送到RabbitMQ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.xiaoruiit.queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.xiaoruiit.common.constant.RabbitQueueConstant;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author xhr</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MessageService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法被controller调用是多线程执行。</span><br><span class="line">     * rabbitTemplate 执行时间是一个递增的过程</span><br><span class="line">     */</span><br><span class="line">    public void sendTestMessage(LogHistory history) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitQueueConstant.EXCH_LOG, &quot;&quot;, JSON.toJSONString(history));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Gatway</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署开发环境</title>
    <url>/2023/03/28/CICD/docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Docker部署</p>
<span id="more"></span>

<h1 id="Docker部署应用"><a href="#Docker部署应用" class="headerlink" title="Docker部署应用"></a>Docker部署应用</h1><h2 id="涉及Docker命令"><a href="#涉及Docker命令" class="headerlink" title="涉及Docker命令"></a>涉及Docker命令</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看本地镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除镜像</span></span><br><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>

<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker  exec  -it  mysql  /bash</span><br><span class="line">docker  exec  -it  openjdk  /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop &lt;CONTAINER ID|NAME&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line">docker rm &lt;CONTAINER ID|NAME&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死运行中的容器</span></span><br><span class="line">docker kill -s KILL eladmin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h4 id="镜像运行到容器"><a href="#镜像运行到容器" class="headerlink" title="镜像运行到容器"></a>镜像运行到容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 镜像运行到容器    /bin/bash 指定容器内目录</span></span><br><span class="line">docker  run  -d  -it  --name myopenjdk  openjdk  /bin/bash</span><br><span class="line">-d # 后台运行</span><br><span class="line">-p 3306:3306 # 将容器的3306端口映射到主机的3306端口</span><br><span class="line">-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d #将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 # 初始化root用户的密码</span><br><span class="line">imageID # mysql镜像ID</span><br></pre></td></tr></table></figure>

<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker logs [OPTIONS] CONTAINER</span></span><br><span class="line">Options:</span><br><span class="line">--details 显示更多的信息</span><br><span class="line">-f, --follow 跟踪实时日志</span><br><span class="line">--since string 显示自某个timestamp之后的日志，或相对时间，如40m（即40分钟）</span><br><span class="line">--tail string 从日志末尾显示多少行日志， 默认是all</span><br><span class="line">-t, --timestamps 显示时间戳</span><br><span class="line">--until string 显示自某个timestamp之前的日志，或相对时间，如40m（即40分钟）</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">docker logs eladmin</span><br><span class="line">docker logs -f eladmin</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><h3 id="第一种：挨个部署"><a href="#第一种：挨个部署" class="headerlink" title="第一种：挨个部署"></a>第一种：挨个部署</h3><h4 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h4><ol>
<li>购买服务器</li>
<li>安装docker</li>
<li>部署后端<ol>
<li>准备后端基础运行环境<ol>
<li>jdk</li>
<li>redis</li>
<li>mysql<ol>
<li>拉镜像</li>
<li>启动mysql</li>
<li>服务器开放对外mysql端口</li>
<li>navicat连接服务器，执行初始化sql脚本</li>
</ol>
</li>
</ol>
</li>
<li>制作后端应用镜像<ol>
<li>maven install 打包</li>
<li>编写Docfile</li>
<li>两者都上传到服务器同一目录下</li>
<li>进入该目录，制作镜像</li>
</ol>
</li>
<li>后端启动脚本<ol>
<li>脚本内容</li>
<li>编写为应用启动脚本</li>
</ol>
</li>
<li>启动后端应用</li>
<li>验证<ol>
<li>查看启动日志</li>
<li>开放服务器端口号</li>
<li>PostMan测试接口</li>
<li>关闭服务器端口号</li>
</ol>
</li>
</ol>
</li>
<li>部署前端<ol>
<li>前端基础运行环境</li>
<li>前端代码打包</li>
<li>配置nginx</li>
<li>启动nginx</li>
</ol>
</li>
</ol>
<h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><h5 id="后端基础运行环境"><a href="#后端基础运行环境" class="headerlink" title="后端基础运行环境"></a>后端基础运行环境</h5><p>jdk,redis,mysql</p>
<ol>
<li><p>jdk</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker  search  jdk  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取openjdk最新镜像</span></span><br><span class="line">docker  pull  openjdk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">docker  run  -d  -it  --name openjdk  openjdk  /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">docker  exec  -it  openjdk  /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取redis最新镜像</span></span><br><span class="line">docker pull redis:latest</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行到容器中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</span></span><br><span class="line">docker run -itd --name redis-hxr -p 6379:6379 redis</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试连接redis</span></span><br><span class="line">docker exec -it redis-hxr /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>mysql</p>
<ol>
<li><p>拉取镜像并运行到容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看mysql版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 看不到版本？</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取指定版本镜像</span></span><br><span class="line">docker pull mysql:8.0.19</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=*** mysql：8.0.19</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -it mysql bash</span><br></pre></td></tr></table></figure></li>
<li><p>开放服务器端口</p>
</li>
<li><p>连接mysql</p>
</li>
<li><p>执行初始化SQL脚本</p>
</li>
</ol>
</li>
</ol>
<h5 id="制作后端应用镜像"><a href="#制作后端应用镜像" class="headerlink" title="制作后端应用镜像"></a>制作后端应用镜像</h5><ol>
<li><p>maven install 打包</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JxvhLnfA4V2ZR7t.png" alt="image-20220301112453557"></p>
</li>
<li><p>编写Docfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">ARG JAR_FILE=./*.jar</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p>两者都上传到服务器同一目录下</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/W46CqAGBmdVe9rL.png" alt="image-20220301112638520"></p>
</li>
<li><p>制作镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t eladmin /home/eladmin</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/eladmin</span><br><span class="line"></span><br><span class="line">docker build -t eladmin . # .代表Docfile所在目录是当前目录</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="后端启动脚本"><a href="#后端启动脚本" class="headerlink" title="后端启动脚本"></a>后端启动脚本</h5><ol>
<li><p>内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name eladmin \</span><br><span class="line">--restart always \</span><br><span class="line">-p 8000:8000 \</span><br><span class="line">-e &quot;TZ=Asia/Shanghai&quot; \</span><br><span class="line">-e DB_HOST=172.17.0.1 \</span><br><span class="line">-e DB_PWD=*** \</span><br><span class="line">-e REDIS_HOST=172.17.0.1 \</span><br><span class="line">-v /home/data/:/home/eladmin/ \</span><br><span class="line">eladmin</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \  # -d后台启动</span><br><span class="line">--name eladmin \ # 镜像启动为容器的名称</span><br><span class="line">--restart always \ # 随docker重启而重启；失败重启？</span><br><span class="line">-p 8000:8000 \	# 指定端口映射</span><br><span class="line">-e &quot;TZ=Asia/Shanghai&quot; \</span><br><span class="line">-e DB_HOST=172.17.0.1 \ # mysql地址是docker地址 宿主机ifconfig查看</span><br><span class="line">-e DB_PWD=*** \ # todo</span><br><span class="line">-e REDIS_HOST=172.17.0.1 \ # redis地址是docker地址</span><br><span class="line">-v /home/data/:/home/eladmin/ \ # docker内指定目录挂载到与宿主机</span><br><span class="line">eladmin		# 镜像名称</span><br></pre></td></tr></table></figure></li>
<li><p>脚本</p>
<ol>
<li><p>编写</p>
<p>新建文件<code>start.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name eladmin \</span><br><span class="line">--restart always \</span><br><span class="line">-p 8000:8000 \</span><br><span class="line">-e &quot;TZ=Asia/Shanghai&quot; \</span><br><span class="line">-e DB_HOST=172.17.0.1 \</span><br><span class="line">-e DB_PWD=*** \</span><br><span class="line">-e REDIS_HOST=172.17.0.1 \</span><br><span class="line">-v /home/data/:/home/eladmin/ \</span><br><span class="line">eladmin</span><br></pre></td></tr></table></figure></li>
<li><p>添加执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x start.sh</span><br></pre></td></tr></table></figure></li>
<li><p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/eladmin/start.sh</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h4><h5 id="前端运行环境"><a href="#前端运行环境" class="headerlink" title="前端运行环境"></a>前端运行环境</h5><ol>
<li><p>nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="前端项目"><a href="#前端项目" class="headerlink" title="前端项目"></a>前端项目</h5><ol>
<li><p>检查生产配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/KtQDCzg93cNa7YM.png" alt="image-20220301114645266"></p>
</li>
<li><p>打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure>



<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/t1PwqXUb2RToaQ5.png" alt="image-20220301114730178"></p>
</li>
<li><p>上传</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/nginx/html/eladmin</span><br></pre></td></tr></table></figure>

<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/xp9zWlRL6dearOk.png" alt="image-20220301151357030"></p>
</li>
<li><p>nginx配置</p>
<p><code>/home/nginx</code>目录创建<code>nginx.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf; # server单独配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/home/nginx/conf.d</code>目录创建<code>eladmin.conf</code>，配置 server </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name 域名/外网IP;</span><br><span class="line">        index index.html;</span><br><span class="line">        root  /usr/share/nginx/html/eladmin/dist;  #dist上传的路径</span><br><span class="line"></span><br><span class="line">        # 避免访问出现 404 错误</span><br><span class="line">        location / &#123;</span><br><span class="line">          try_files $uri $uri/ @router;</span><br><span class="line">          index  index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location @router &#123;</span><br><span class="line">          rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 接口</span><br><span class="line">        location /api &#123;</span><br><span class="line">          proxy_pass http://172.17.0.1:8000;</span><br><span class="line">          proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">          proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">          proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 授权接口</span><br><span class="line">        location /auth &#123;</span><br><span class="line">          proxy_pass http://172.17.0.1:8000;</span><br><span class="line">          proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">          proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">          proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # WebSocket 服务</span><br><span class="line">        location /webSocket &#123;</span><br><span class="line">          proxy_pass http://172.17.0.1:8000;</span><br><span class="line">          proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">          proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">          proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 头像</span><br><span class="line">        location /avatar &#123;</span><br><span class="line">          proxy_pass http://172.17.0.1:8000;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 文件</span><br><span class="line">        location /file &#123;</span><br><span class="line">          proxy_pass http://172.17.0.1:8000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前端启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nginx --restart always \</span><br><span class="line">-p 80:80 -p 443:443 \</span><br><span class="line">-e &quot;TZ=Asia/Shanghai&quot; \</span><br><span class="line">-v /home/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /home/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /home/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /home/nginx/cert:/etc/nginx/cert \</span><br><span class="line">-v /home/nginx/html:/usr/share/nginx/html \</span><br><span class="line">nginx:alpine</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="第二种：componse编排"><a href="#第二种：componse编排" class="headerlink" title="第二种：componse编排"></a>第二种：componse编排</h3><p>用配置文件一次编排应用所需所有镜像。</p>
]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins</title>
    <url>/2023/03/28/CICD/Jenkins/</url>
    <content><![CDATA[<p>Jenkins</p>
<span id="more"></span>

<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>持续部署</p>
<h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><p>需要jdk</p>
<ol>
<li><p>docker镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull jenkins/jenkins:lts</span><br></pre></td></tr></table></figure></li>
<li><p>启动jenkins</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载目录准备</span></span><br><span class="line">mkdir -p /apps/devops/jenkins</span><br><span class="line">chmod 777 /apps/devops/jenkins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动docker</span></span><br><span class="line">docker run -itd -p 9003:8080 -p 9004:50000  --restart always -v /apps/devops/jenkins:/var/jenkins_home --name jenkins  jenkins/jenkins:lts</span><br></pre></td></tr></table></figure></li>
<li><p>进入jenkins</p>
<p>浏览器输入: <a href="http://127.0.0.1:9003/">http://127.0.0.1:9003</a></p>
<p>密码：docker logs jenkins</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/glNbftdkysaVuY2.png" alt="image-20220314194941302"></p>
</li>
<li><p>创建用户</p>
<p>jenkins管理员账号密码</p>
</li>
<li><p>实例配置</p>
<p>默认</p>
</li>
<li><p>成功进入jenkins首页</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/7mQJhXK2EpR6SBj.png" alt="image-20220314195154556"></p>
</li>
<li><p>jenkins配置</p>
<p>时间:北京</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/pv1N4izDYxkmBd6.png" alt="image-20220314195550437"></p>
</li>
<li><p>插件安装</p>
<ol>
<li><p>maven</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/e4VJjMIyvp5XmYr.png" alt="image-20220314195947773"></p>
</li>
<li><p>ssh</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/LTt6HVao3zwNEXl.png" alt="image-20220314200445058"></p>
</li>
</ol>
</li>
</ol>
<h2 id="部署前端项目"><a href="#部署前端项目" class="headerlink" title="部署前端项目"></a>部署前端项目</h2><ol>
<li><p>新建任务</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wDUmyg9FkEQP4VJ.png" alt="image-20220320223713022"></p>
</li>
<li><p>General生成配置</p>
<ol>
<li><p>先去安装gitee插件</p>
<ol>
<li>gitee插件</li>
<li>jersey 2 API插件</li>
</ol>
</li>
<li><p>配置gitee</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/h1OUxsBX4tIFCD8.png" alt="image-20220320224126969"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/wiOG9kgmUbBD7Tt.png" alt="image-20220320224253327"></p>
<p>gitee 凭证管理</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Aq92Ix75QwWZucU.png" alt="image-20220320230009685"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/iXzJxDC8AravGYg.png" alt="image-20220320224459195"></p>
</li>
<li><p>General生成配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/6PRMgfNc5Cbi8oA.png" alt="image-20220320223919522"></p>
</li>
</ol>
</li>
<li><p>源码管理</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/JhKPrOxzYUanHXA.png" alt="image-20220320225058144"></p>
</li>
<li><p>构建触发</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/fPiMuEeJvxr3RNQ.png" alt="image-20220320225428468"></p>
<p>gitee仓库配置</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/Hj6n9X1emfDW23q.png" alt="image-20220320225558363"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/YLUpNk68bKXJQBZ.png" alt="image-20220320225639436"></p>
</li>
<li><p>构建环境</p>
<ol>
<li><p>node插件</p>
</li>
<li><p>node环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /apps/devops/jenkins/plugins</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">wget https://npm.taobao.org/mirrors/node/v14.14.0/node-v14.14.0-linux-x64.tar.xz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">xz -d node-v14.14.0.1-linux-x64.tar.xz</span><br><span class="line">tar -xf nodev14.14.0-linux-x64.tar</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">ln -s /apps/devops/jenkins/plugins/node-v14.14.0-linux-x64/bin/npm /usr/local/bin/</span><br><span class="line"></span><br><span class="line">ln -s /apps/devops/jenkins/plugins/node-v14.14.0-linux-x64/bin/npm /usr/local/bin/</span><br><span class="line"></span><br><span class="line">ln -s /apps/devops/jenkins/plugins/node-v14.14.0-linux-x64/bin/npx /usr/local/bin/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>构建-编译打包</p>
</li>
<li><p>构建后-复制打包的东西到nginx的dist目录，重启docker中的nginx容器</p>
</li>
</ol>
<h2 id="部署后端项目"><a href="#部署后端项目" class="headerlink" title="部署后端项目"></a>部署后端项目</h2>]]></content>
      <categories>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Burp抓包</title>
    <url>/2022/09/21/%E5%B7%A5%E5%85%B7/burp%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>Burp抓包</p>
<span id="more"></span>

<h1 id="Burp抓包"><a href="#Burp抓包" class="headerlink" title="Burp抓包"></a>Burp抓包</h1><h2 id="1-抓android包配置"><a href="#1-抓android包配置" class="headerlink" title="1.抓android包配置"></a>1.抓android包配置</h2><p><a href="http://burp/">http://burp</a></p>
<h2 id="2-查看请求介绍"><a href="#2-查看请求介绍" class="headerlink" title="2.查看请求介绍"></a>2.查看请求介绍</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20220921181835272.png" alt="image-20220921181835272"></p>
<h2 id="3-对请求操作"><a href="#3-对请求操作" class="headerlink" title="3.对请求操作"></a>3.对请求操作</h2><h3 id="3-1发送前拦截并修改请求"><a href="#3-1发送前拦截并修改请求" class="headerlink" title="3.1发送前拦截并修改请求"></a>3.1发送前拦截并修改请求</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20220921181125587.png" alt="image-20220921181125587"></p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20220921175541950.png" alt="image-20220921175541950"></p>
<h3 id="3-2-修改host，请求到不同环境"><a href="#3-2-修改host，请求到不同环境" class="headerlink" title="3.2 修改host，请求到不同环境"></a>3.2 修改host，请求到不同环境</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20220921175347845.png" alt="image-20220921175347845"></p>
<h3 id="3-3-复制curl"><a href="#3-3-复制curl" class="headerlink" title="3.3 复制curl"></a>3.3 复制curl</h3><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20220921182647473.png" alt="image-20220921182647473"></p>
<h3 id="3-4-重放-Repeater"><a href="#3-4-重放-Repeater" class="headerlink" title="3.4 重放 Repeater"></a>3.4 重放 Repeater</h3><h3 id="3-5-对比请求-Comparer"><a href="#3-5-对比请求-Comparer" class="headerlink" title="3.5 对比请求 Comparer"></a>3.5 对比请求 Comparer</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>拦截https，无法正常请求。</p>
<ul>
<li><p>描述</p>
<p>第三方钉钉登录使用https，拦截https可能出错，无法正常请求。</p>
</li>
<li><p>解决</p>
<p>从android代理配置过滤。</p>
<p>或者burp上配置过滤不代理-未验证</p>
</li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Burp</tag>
        <tag>抓包</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Clean Code-读书笔记</title>
    <url>/2022/09/21/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Clean%20Code/</url>
    <content><![CDATA[<p>Clean Code-读书笔记</p>
<span id="more"></span>

<h1 id="Clean-Code-读书笔记"><a href="#Clean-Code-读书笔记" class="headerlink" title="Clean Code-读书笔记"></a>Clean Code-读书笔记</h1><h2 id="本书"><a href="#本书" class="headerlink" title="本书"></a>本书</h2><p>如何提高代码质量。简洁代码，代码重构</p>
<h2 id="书内容安排"><a href="#书内容安排" class="headerlink" title="书内容安排"></a>书内容安排</h2><ol>
<li>代码规范</li>
<li>重构案例</li>
<li>重构总结</li>
</ol>
<h2 id="阅读建议"><a href="#阅读建议" class="headerlink" title="阅读建议"></a>阅读建议</h2><p>可以看多种整洁代码流派，吸纳优点。<br>书中很多建议都存在争议。可能会强烈反对其中的一些建议。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="1-整洁代码-记录"><a href="#1-整洁代码-记录" class="headerlink" title="1.整洁代码-记录"></a>1.整洁代码-记录</h3><h4 id="1-3-5什么是整洁代码"><a href="#1-3-5什么是整洁代码" class="headerlink" title="1.3.5什么是整洁代码"></a>1.3.5什么是整洁代码</h4><p>减少重复代码，只做一件事，表达力，小规模抽象。</p>
<h4 id="1-4-思想流派"><a href="#1-4-思想流派" class="headerlink" title="1.4 思想流派"></a>1.4 思想流派</h4><p>整洁代码有多种流派的规则。</p>
<h4 id="1-6-童子军军规"><a href="#1-6-童子军军规" class="headerlink" title="1.6 童子军军规"></a>1.6 童子军军规</h4><p>时时保持代码整洁，让代码比来时更整洁。</p>
<h4 id="1-8小结"><a href="#1-8小结" class="headerlink" title="1.8小结"></a>1.8小结</h4><p>本书只能告诉我们优秀程序员编码的思维过程，使用的技巧、技术和工具。不能直接让我们有好的”代码感“。<br>可以从本书中看到好代码，糟糕的代码，糟糕的代码如何转化为好代码。<br>可以看到启发、规条、技巧。</p>
<h3 id="2-有意义的命名-记录"><a href="#2-有意义的命名-记录" class="headerlink" title="2.有意义的命名-记录"></a>2.有意义的命名-记录</h3><p>需要命名的地方：变量、函数、参数、类、封包命名、目录、jar、war</p>
<h4 id="2-2名副其实"><a href="#2-2名副其实" class="headerlink" title="2.2名副其实"></a>2.2名副其实</h4><p>代码的模糊性：名称、判断<br>判断可以用函数取代，函数名称说明判断的意思</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(scan == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isScan(scan))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isScan</span><span class="params">(Integer scan)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> scan == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3避免误导"><a href="#2-3避免误导" class="headerlink" title="2.3避免误导"></a>2.3避免误导</h4><p>名称避免歧义。</p>
<p>大写字符O 和小写字符l 不要用。</p>
<h4 id="2-4有意义的区分"><a href="#2-4有意义的区分" class="headerlink" title="2.4有意义的区分"></a>2.4有意义的区分</h4><p>User 与 UserData 没区别</p>
<h4 id="2-9类名"><a href="#2-9类名" class="headerlink" title="2.9类名"></a>2.9类名</h4><p>类名和对象应该是名词而非动词。</p>
<h4 id="2-10方法名"><a href="#2-10方法名" class="headerlink" title="2.10方法名"></a>2.10方法名</h4><p>方法名应该是动词或动词短语</p>
<h4 id="2-14使用解决方案领域名称"><a href="#2-14使用解决方案领域名称" class="headerlink" title="2.14使用解决方案领域名称"></a>2.14使用解决方案领域名称</h4><p>依据问题所涉领域来命名没有用本计算机领域命名好。本计算机领域命名可减少认知负担。</p>
<h4 id="2-15使用源自所涉问题领域的名称"><a href="#2-15使用源自所涉问题领域的名称" class="headerlink" title="2.15使用源自所涉问题领域的名称"></a>2.15使用源自所涉问题领域的名称</h4><p>如果不 能用 程序员 熟悉 的 术语 来给 手头 的 工作 命名， 就 采用 从 所 涉 问题 领域 而来 的 名称 吧。 至少， 负责 维护 代码 的 程序员 就能 去请 教 领域 专家 了。</p>
<p>优秀工程师应该能分离解决方案领域和问题领域的概念。</p>
<h4 id="2-16添加有意义的语境"><a href="#2-16添加有意义的语境" class="headerlink" title="2.16添加有意义的语境"></a>2.16添加有意义的语境</h4><h3 id="3-函数-记录"><a href="#3-函数-记录" class="headerlink" title="3.函数-记录"></a>3.函数-记录</h3><p>造成模糊：</p>
<ul>
<li>魔法值，魔法字符串，双重嵌套，标识控制的if语句<h4 id="3-1短小"><a href="#3-1短小" class="headerlink" title="3.1短小"></a>3.1短小</h4>内容短小。20行左右。<h4 id="3-2只做一件事"><a href="#3-2只做一件事" class="headerlink" title="3.2只做一件事"></a>3.2只做一件事</h4>只做一件事。函数名同一抽象层级内的一件事。不能再抽象出不同层级的函数。<h4 id="3-3每个函数一个抽象层级"><a href="#3-3每个函数一个抽象层级" class="headerlink" title="3.3每个函数一个抽象层级"></a>3.3每个函数一个抽象层级</h4>阅读顺序：自顶向下。<br>抽象层级：<br>如：<br>  高级：获取数据<br>  中级：处理数据中转换<br>  低级：判空<br>函数实现：自定向下：    </li>
<li>A函数后的B函数是顺序</li>
<li>A函数内的函数b的抽象层级比A低。</li>
<li>A函数内的语句包括每个函数（a、c、d）处于同一抽象层级，是在描速A</li>
</ul>
<h4 id="3-6函数参数"><a href="#3-6函数参数" class="headerlink" title="3.6函数参数"></a>3.6函数参数</h4><p>buildBean 需要用返回参数说明构建的实体是什么，而不是入参<br>两个参数比一个参数难懂。特殊：new Point(0,0);<br>二元函数转一元函数：将入参写成当前类的成员变量。outputStream.writeField(name);<br>三元函数的复杂性：排序，参数含义，是否需要忽略参数。<br>函数需要两个、三个、或三个以上参数，应该将部分参数封装为类。<br>函数名称和参数之间建立联系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">write(name)</span><br><span class="line">writeField(name) <span class="comment">// 说明name</span></span><br><span class="line"></span><br><span class="line">assertEqual(message, expected, actual)</span><br><span class="line">assertExpectedEqualsActual(message, expected, actual) <span class="comment">// 说明哪两个参数比较，以及参数顺序</span></span><br></pre></td></tr></table></figure>
<h4 id="3-7无副作用"><a href="#3-7无副作用" class="headerlink" title="3.7无副作用"></a>3.7无副作用</h4><p>函数名称需要体现函数作用。函数名称之外的代码效果不应该在函数中。<br>可以用成员变量调用方法来避免使用返回参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">appendFooter(StringBuffer report)</span><br><span class="line"></span><br><span class="line">appendFooter(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StringBuffer report;</span><br><span class="line">appendFooter()&#123;</span><br><span class="line">	report.add(<span class="string">&quot;footer&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">report.appendFooter();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-8函数分开做什么和询问"><a href="#3-8函数分开做什么和询问" class="headerlink" title="3.8函数分开做什么和询问"></a>3.8函数分开做什么和询问</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String attribute, String value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(attributeExists(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">	setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-9异常"><a href="#3-9异常" class="headerlink" title="3.9异常"></a>3.9异常</h4><p>抽离ry/catch块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(Excaption e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽离</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	doCreateRece(Rece rece);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Excaption e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doCreateRece</span><span class="params">(Rece rece)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误处理就是一件事，处理错误的函数不应该做其他事。</p>
<h4 id="3-12如何写出这样的函数"><a href="#3-12如何写出这样的函数" class="headerlink" title="3.12如何写出这样的函数"></a>3.12如何写出这样的函数</h4><p>写代码如同写文章、论文。一开始想到什么写什么，然后斟酌推敲重构，直到函数达到心中最好的样子。比如：一开始冗长复杂，嵌套循环，比较长的参数列表，名称随意，多处重复代码，但需要有配套单元测试。第二步：打磨代码。分解函数、修改名称、消除重复，同时保持测试通过。</p>
<h4 id="3-13"><a href="#3-13" class="headerlink" title="3.13"></a>3.13</h4><p>真正的目前是讲述系统故事。</p>
<h3 id="3函数-总结"><a href="#3函数-总结" class="headerlink" title="3函数-总结"></a>3函数-总结</h3><p>函数内容：方法名、入参、返回参数、内容。</p>
<ul>
<li>方法名：<ul>
<li>名称<ul>
<li>动词+名词</li>
<li>描述入参</li>
<li>名称需要体现实现内容，不要有实现了内容却不能通过名称看出来。</li>
</ul>
</li>
</ul>
</li>
<li>入参：<ul>
<li>参数少比较好</li>
<li>可以用成员变量减少入参</li>
<li>参数两个以上可以封装为对象</li>
</ul>
</li>
<li>返回参数</li>
<li>内容<ul>
<li>只做一件事</li>
<li>同一抽象层级，依代码顺序</li>
<li>将做什么和查询分开</li>
<li>抽离try/catch<br>一开始可以混乱，写出来之后逐步优化。<h3 id="4注释-记录"><a href="#4注释-记录" class="headerlink" title="4注释-记录"></a>4注释-记录</h3>注释可能提供错误信息。越陈旧的注释提供错误信息的可能性越大。<br>注释可能不随着代码实现功能的变化而变化描述。<br>注释是在弥补代码本身描述意图不清楚的失败。<h3 id="5格式-记录"><a href="#5格式-记录" class="headerlink" title="5格式-记录"></a>5格式-记录</h3></li>
</ul>
</li>
</ul>
<h4 id="5-1格式目的"><a href="#5-1格式目的" class="headerlink" title="5.1格式目的"></a>5.1格式目的</h4><p>代码格式和沟通相关。</p>
<h4 id="5-2垂直方向上的格式"><a href="#5-2垂直方向上的格式" class="headerlink" title="5.2垂直方向上的格式"></a>5.2垂直方向上的格式</h4><ol>
<li>向报纸学习</li>
<li>不同概念间用空行隔开，这样看一段内容时目光会停留到空白行之前。如导包与类声明，函数间</li>
<li>相同概念不要隔开<h4 id="5-3水平（横向）方向上的格式"><a href="#5-3水平（横向）方向上的格式" class="headerlink" title="5.3水平（横向）方向上的格式"></a>5.3水平（横向）方向上的格式</h4></li>
<li>代码长度</li>
<li>运算符两边加空格</li>
<li>缩进<h4 id="5-4团队规则"><a href="#5-4团队规则" class="headerlink" title="5.4团队规则"></a>5.4团队规则</h4>应该选用一套管理代码格式的简单规则，然后贯彻这些规则。<br>团队中管理代码格式也是这样。</li>
</ol>
<h3 id="6-对象和数据结构-记录"><a href="#6-对象和数据结构-记录" class="headerlink" title="6.对象和数据结构-记录"></a>6.对象和数据结构-记录</h3><h4 id="6-1数据抽象"><a href="#6-1数据抽象" class="headerlink" title="6.1数据抽象"></a>6.1数据抽象</h4><p>对象隐藏数据结构，暴露行为。<br>数据结构暴露数据，没有提供有意义的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; 　 </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> x; 　 </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> y; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Point</span> </span>&#123; 　 </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span></span>; 　 </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span></span>; 　 </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCartesian</span><span class="params">( <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; 　 </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getR</span><span class="params">()</span></span>; 　 </span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getTheta</span><span class="params">()</span></span>; 　 </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPolar</span><span class="params">( <span class="keyword">double</span> r, <span class="keyword">double</span> theta)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-5小结"><a href="#6-5小结" class="headerlink" title="6.5小结"></a>6.5小结</h4><p>面向过程更适合不改变其他类的情况下添加方法。<br>面向对象更适合不改变其他类的情况下添加新的类或数据类型。<br>如：形状类；矩形类，圆形类。</p>
<h3 id="10-类-笔记"><a href="#10-类-笔记" class="headerlink" title="10.类-笔记"></a>10.类-笔记</h3><h4 id="10-1类的组织"><a href="#10-1类的组织" class="headerlink" title="10.1类的组织"></a>10.1类的组织</h4><p>结构：</p>
<ol>
<li>类的公有静态变量</li>
<li>类的私有静态变量</li>
<li>私有实体变量</li>
<li>类的公共方法<h4 id="10-2类应该短小"><a href="#10-2类应该短小" class="headerlink" title="10.2类应该短小"></a>10.2类应该短小</h4>类的第一条规则：短小。<br> 短小的衡量：权责（responsibility)。<br> 类的名称应当描述其权责。类名包含模糊的词时会有多个权责聚集。如：processor，Manager，Super。<br> 类内容的描述不应该有，if、and、or、but<br>TODO 需要学权责的颗粒度，抽象一件事的层次<h5 id="10-2-1单一权责SRP（Single-Responsibility-Principle）"><a href="#10-2-1单一权责SRP（Single-Responsibility-Principle）" class="headerlink" title="10.2.1单一权责SRP（Single Responsibility Principle）"></a>10.2.1单一权责SRP（Single Responsibility Principle）</h5>判断方法：只有一条被修改的理由<br>单一权责容易被破坏的原因：<br> 写完能工作的代码后就完事了。<br> 写的时候可能没有实现单一权责。<br> 因为业务的变化，添加的代码破坏了单一权责。<br> 因为功能需要新增的复杂性，导致类的单一权责抽象层次太高了。<br> 实际编写功能只给了实现的时间，没有让代码有结构、整洁，重构的时间。<h5 id="10-2-2内聚"><a href="#10-2-2内聚" class="headerlink" title="10.2.2内聚"></a>10.2.2内聚</h5>类应该只有少数变量，每个方法使用的变量越多，内聚性越强。<br>保持函数和参数列表短小的策略， 导致实体变量数量增加时，应该创建新类，将变量和方法拆分到多个类中。让所有的类从整体上更内聚。</li>
</ol>
<h5 id="10-2-3保持内聚性就会得到许多短小的类"><a href="#10-2-3保持内聚性就会得到许多短小的类" class="headerlink" title="10.2.3保持内聚性就会得到许多短小的类"></a>10.2.3保持内聚性就会得到许多短小的类</h5><p>较大的函数切割成小函数，就会导致更多的类出现。<br>堆积类越来越多的少量函数使用的实体变量的类在一直丧失内聚性。<br>将大函数拆分为小函数，往往也是类拆分为小类的时机。</p>
<h4 id="10-3-为了修改而组织"><a href="#10-3-为了修改而组织" class="headerlink" title="10.3 为了修改而组织"></a>10.3 为了修改而组织</h4><p>大部分系统，会持续修改。每次每处修改都可能造成其他地方无法正常工作。<br>隔离修改，依赖细节可以改为依赖抽象。</p>
<h3 id="11-系统"><a href="#11-系统" class="headerlink" title="11.系统"></a>11.系统</h3><h4 id="11-1如何建造一个城市"><a href="#11-1如何建造一个城市" class="headerlink" title="11.1如何建造一个城市"></a>11.1如何建造一个城市</h4><p>一个人无法掌控所有细节。<br>城市中的一组组人管理不同的地方，供水系统、供电系统、交通、执法、立法。<br>一个城市有人负责全局（所有模块抽象层级高的内容），有更多的人负责细节（某一模块抽象层级低的内容）。<br>城市能运转，因为演化出恰当的抽象等级和模块。让人和其所管理的组件在不了解全局也能运转。<br>整洁的代码可以在较低的抽象层级模块化。较高的抽象层级-系统也需要模块化。</p>
<h4 id="11-2将系统的构造与使用分开"><a href="#11-2将系统的构造与使用分开" class="headerlink" title="11.2将系统的构造与使用分开"></a>11.2将系统的构造与使用分开</h4><p>构造和使用是完全不同的。不应该耦合在一起。<br><strong>分离构造和使用的方法</strong>：</p>
<ul>
<li>工厂模式隔离。</li>
<li>DI，依赖注入</li>
</ul>
<p><strong>延迟初始化缺点：</strong></p>
<ul>
<li>会把构造和使用耦合在一起。</li>
</ul>
<p><strong>延后初始化的优点：</strong></p>
<ul>
<li>多数 DI 容器 在 需要 对象 之前 并不 构造 对象。</li>
<li>许多DI容器 提供 调用 工厂 或 构造 代理 的 机制， 而这 种 机制 可为 延迟 赋值 或 类似 的 优化 处理 所用</li>
</ul>
<h4 id="11-3扩展性"><a href="#11-3扩展性" class="headerlink" title="11.3扩展性"></a>11.3扩展性</h4><h5 id="横贯式关注面"><a href="#横贯式关注面" class="headerlink" title="横贯式关注面"></a>横贯式关注面</h5><p>AOP，面向切面。按领域划分后，多个领域共同的东西用切面提取共性。比如：事务、日志</p>
<h3 id="12-迭进-笔记"><a href="#12-迭进-笔记" class="headerlink" title="12.迭进-笔记"></a>12.迭进-笔记</h3><h4 id="简单设计原则"><a href="#简单设计原则" class="headerlink" title="简单设计原则"></a>简单设计原则</h4><p>按重要性排列</p>
<ol>
<li>运行所有测试</li>
<li>消除重复</li>
<li>清晰表达作者的意图</li>
<li>尽量少的类和方法数量</li>
</ol>
<h4 id="简单设计规则1：运行所有测试"><a href="#简单设计规则1：运行所有测试" class="headerlink" title="简单设计规则1：运行所有测试"></a>简单设计规则1：运行所有测试</h4><h4 id="简单设计规则2-4：重构"><a href="#简单设计规则2-4：重构" class="headerlink" title="简单设计规则2-4：重构"></a>简单设计规则2-4：重构</h4><p>用测试保证代码正确的前提下，递增式的重构代码。</p>
<ol>
<li>思考设计</li>
<li>重构一小块</li>
<li>运行测试</li>
</ol>
<h5 id="优秀软件设计规则"><a href="#优秀软件设计规则" class="headerlink" title="优秀软件设计规则"></a>优秀软件设计规则</h5><ul>
<li>高内聚，低耦合</li>
<li>切分关注面？</li>
<li>模块化系统性关注面？</li>
<li>缩小函数和类的尺寸</li>
<li>用更好的名称</li>
<li>…</li>
</ul>
<h5 id="2消除重复"><a href="#2消除重复" class="headerlink" title="2消除重复"></a>2消除重复</h5><ul>
<li>类属性提取共性来切分为多个类</li>
<li>抽取共性，抽取后方法用途不属于本类时，新建一个类存放，提升可见性。</li>
<li>模板方法模式可以移出高层级重复</li>
</ul>
<h5 id="3表达力"><a href="#3表达力" class="headerlink" title="3表达力"></a>3表达力</h5><ul>
<li>好名称，可以借助idea多次重命名名称</li>
<li>保持函数和类尺寸短小，短小的类和函数易于命名，易于编写，易于理解。</li>
<li>标准命名法<h5 id="4尽可能少的类和方法数量"><a href="#4尽可能少的类和方法数量" class="headerlink" title="4尽可能少的类和方法数量"></a>4尽可能少的类和方法数量</h5></li>
</ul>
<h3 id="17-味道与启发（规则总结）"><a href="#17-味道与启发（规则总结）" class="headerlink" title="17 味道与启发（规则总结）"></a>17 味道与启发（规则总结）</h3><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h4><ol>
<li>不需要的注释，代码自身已经解释清楚</li>
<li>注释与代码含义不同</li>
<li>删除过期注释</li>
<li>注释应该说明代码无法表达的东西。作者和日期通过代码版本工具管理。<h4 id="2-环境？"><a href="#2-环境？" class="headerlink" title="2.环境？"></a>2.环境？</h4><h4 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h4></li>
<li>短小</li>
<li>只做一件事</li>
<li>函数内容的抽象层级是名称的下一级，函数内容的抽象层级在同一级。</li>
<li>函数个数尽量少<h4 id="4-一般性问题"><a href="#4-一般性问题" class="headerlink" title="4.一般性问题"></a>4.一般性问题</h4></li>
<li>小心不正确的边界行为，可以编写多个测试验证和调试</li>
<li>不要忽视安全，比如重构后不运行测试。</li>
<li>不要有重复代码。<br>解决：<ol>
<li>抽取公共函数</li>
<li>更隐蔽的重复，不同模块的检测同一组条件的switch/case，使用多态</li>
<li>更更隐蔽，类似算法，具体执行不同。使用模版方法模式或策略模式。</li>
<li>ID生成，上游调用者信息，给第三方发消息，如钉钉，抽出公共组件，达成springboot的jar包。</li>
</ol>
</li>
<li> 信息过多</li>
<li>去除死代码</li>
<li>前后规则一致，比如命名风格</li>
<li>用接口，函数做区分比用变量区分更容易理解？</li>
<li>不恰当的静态方法。需要使用多态时，函数不能时静态的。</li>
<li>解释性变量</li>
<li>函数名称需要表达其行为</li>
<li>理解算法，途径：编写测试还不够，就重构</li>
<li>逻辑依赖改为物理依赖，一个模块依赖另一个模块时，依赖者不要去假定（逻辑依赖）被依赖者，应该显示依赖</li>
<li>多态替代IF/ELSE和Switch/Case</li>
<li>遵守标准约定</li>
<li>用命名常量替代魔术数</li>
<li>准确<br>代码中的含糊和不准确要去除。意见不同和懒惰会影响准确</li>
<li>好结构甚于约定的次结构？待实践</li>
<li>封装条件，比如判断条件用描述性好的函数封装</li>
<li>肯定条件比否定条件好理解</li>
<li>必要的时序性耦合暴露出来</li>
<li>代码结构别随意</li>
<li>封装边界条件，边界难以追踪，难以理解</li>
<li>在较高层级放配置变量？</li>
<li>避免传递不需要的依赖？<h4 id="5-Java"><a href="#5-Java" class="headerlink" title="5.Java"></a>5.Java</h4>不要继承常量，应该导入常量所在的类<br>枚举比常量表达力更强<h4 id="6-名称"><a href="#6-名称" class="headerlink" title="6.名称"></a>6.名称</h4>表明意图<br>名称要与抽象层级相符。<br>反映类或函数抽象层级的名称比实现内容的名称更好。<br>较大作用范围选用较长的名称<h4 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h4>使用覆盖率工具<br>测试边界条件<br>全面测试相近的缺陷<br>合理顺序的测试用例，测试工具会直接标记出测试失败的位置。<h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h4><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3>内存模型保证的原子操作，32位 64位操作，一行代码对应多行字节码的非原子性，多个线程字节码执行路径指数级上升，锁syn，Executor。</li>
</ol>
<h3 id="1-整洁代码-感受"><a href="#1-整洁代码-感受" class="headerlink" title="1.整洁代码-感受"></a>1.整洁代码-感受</h3><p>整洁代码是让作者和每一个读者都能读懂代码，觉得代码本该如此。<br>如何实现：<br>    理想情况下：作者和读者对整洁代码的理解一致，认为的整洁代码规则一致。<br>    实践：自己知道的整洁代码规则，自己按照规则去写代码，能够给别人讲出来这一套规则。<br>    实践中会遇到的问题：<br>        1.别人不理解规则；<br>        2.别人理解规则，但不明白为什么这么做；<br>        3.别人理解为什么这么做，但不去做；<br>        4:和别人的规则冲突。<br>      如何解决实践中遇到的问题：TODO</p>
<h3 id="抽象层级总结"><a href="#抽象层级总结" class="headerlink" title="抽象层级总结"></a>抽象层级总结</h3><p>分离较高层级的一般性概念和较低层级的细节概念。<br>基类和派生类是高抽象层级和低抽象层级的关系。<br>抽像层级与单一原则。从高层次来看，符合单一原则，从低层次看，不符合单一原则。比如：提交收货，包括修改收货数据，提交到订单服务，库存服务，修改固定资产等。每个动作都属于提交收货处理，提交收货处理是单一的。</p>
<h4 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h4><p>包，类，函数，变量。</p>
<p>外部使用的类，内部使用的类<br>业务函数，工具函数<br>常量，临时变量</p>
<h4 id="业务和项目架构抽象层级"><a href="#业务和项目架构抽象层级" class="headerlink" title="业务和项目架构抽象层级"></a>业务和项目架构抽象层级</h4><h4 id="Java中的抽象层级"><a href="#Java中的抽象层级" class="headerlink" title="Java中的抽象层级"></a>Java中的抽象层级</h4><h5 id="高与低"><a href="#高与低" class="headerlink" title="高与低"></a>高与低</h5><p>基类           派生类<br>函数名称    函数内容</p>
<h3 id="拆分时机"><a href="#拆分时机" class="headerlink" title="拆分时机"></a>拆分时机</h3><p>内容过多，相关内容迭代。<br>函数超过50行？<br>类超过500行？类变量超过10个？</p>
<h3 id="没记住的条目-todo"><a href="#没记住的条目-todo" class="headerlink" title="没记住的条目 todo"></a>没记住的条目 todo</h3><ol>
<li>逻辑依赖改为物理依赖，一个模块依赖另一个模块时，依赖者不要去假定（逻辑依赖）被依赖者，应该显示依赖。 比如直接feign掉用和二方包依赖后feign掉用</li>
<li>理解算法，途径：编写测试还不够，就重构</li>
<li>封装边界条件，边界难以追踪，难以理解</li>
<li>抽象层级<ol>
<li>反映类或函数抽象层级的名称比实现内容的名称更好。–待实践</li>
</ol>
</li>
</ol>
<h2 id="其他书"><a href="#其他书" class="headerlink" title="其他书"></a>其他书</h2><p>Practices（ 中 译 版《 敏捷 软件 开发： 原则、 模式 与 实践》， 简称 PPP）</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Clean Code</tag>
        <tag>整洁代码</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2022/08/15/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>设计原则</p>
<span id="more"></span>

<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ol>
<li>在设计阶段，我们可以先从一个列表开始。最后调整性能的时候，再根据情况把它<br> 换成矢量。</li>
</ol>
<p>  例如：设计阶段，使用ArrayList；调整性能时，更换为LinkedList；使用的是抽象出来的List接口，更换的代价很小。<br>2.   程序开发是一个不断递增或者累积的过程<br>3. 先考虑可以满足当前情况的技术，无法满足时，再考虑复杂技术。  迁移的复杂性。</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
  </entry>
  <entry>
    <title>软件与现实</title>
    <url>/2022/08/15/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E4%B8%8E%E7%8E%B0%E5%AE%9E/</url>
    <content><![CDATA[<p>领域驱动战术模式代码结构</p>
<span id="more"></span>

<p>软件的本质就是对真实世界的模拟。</p>
<p>软件中业务逻辑与真实世界一致，则软件是 OK 的；不一致，则用户会提 Bug、提新需求。</p>
<p>问题：用户为什么总在改需求？</p>
<p>用户也不确定客观世界的规则，只有遇到问题了他们才能知道。</p>
<p>问题：为什么不按照真实世界开发软件？</p>
<p>真实世界是非常复杂的，要深刻理解真实世界中的这些业务逻辑是需要一个过程的。</p>
<p>一开始，只能认识真实世界中那些简单、清晰、易于理解的业务逻辑；将这些做出来第一个版本交给用户。</p>
<p>然后，用户根据第一个版本发现了不在版本中的很多不简单、不明了、不易于理解的业务逻辑。提 Bug、提新需求。</p>
<p>程序员不断地修复 Bug，实现新需求的过程中，软件的业务逻辑也会越来越接近真实世界。业务逻辑就会变得越来越复杂，软件规模也越来越庞大。</p>
<p>问题：为什么软件越来越难维护？</p>
<p>简单软件有简单软件的设计，复杂软件有复杂软件的设计。不断地修复 Bug，实现新需求的过程中，没有调整软件设计。</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动战术模式代码结构</title>
    <url>/2022/08/15/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%88%98%E6%9C%AF%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E6%8B%86%E8%A7%A3demo/</url>
    <content><![CDATA[<p>领域驱动战术模式代码结构</p>
<span id="more"></span>

<h1 id="领域驱动战术模式代码结构"><a href="#领域驱动战术模式代码结构" class="headerlink" title="领域驱动战术模式代码结构"></a>领域驱动战术模式代码结构</h1><p>领域驱动项目包结构四层。<br>一：对外接口<br>interface（api）：无业务逻辑。安全认证，参数校验，日志处理，统一返回值封装，异常抓取。<br>dto<br>vo</p>
<p>二：应用层<br>service：<br>根据use case 协调调用领域层。事务，事件监听，消息发送。</p>
<p>三：领域层<br>ddd<br>    model<br>    包装其他服务client<br>    对象初始化<br>四：基础设施层<br>mysql<br>    pojo<br>    mapper<br>redis</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>微信收藏-阿里云</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>领域驱动</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>实现领域驱动设计-笔记</title>
    <url>/2022/06/09/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>实现领域驱动设计-笔记</p>
<span id="more"></span>
<h1 id="实现领域驱动设计-笔记"><a href="#实现领域驱动设计-笔记" class="headerlink" title="实现领域驱动设计-笔记"></a>实现领域驱动设计-笔记</h1><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p><a href="http://www.vaughnvernon.com/">www.VaughnVernon.com</a><br>推特 @VaughnVernon</p>
<h2 id="本书"><a href="#本书" class="headerlink" title="本书"></a>本书</h2><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>领域模型一些概念。<br>    战略设计，通用语言，限界上下文，<br>    架构，六边形架构，rest，事件驱动，适配器<br>    战术设计，聚合，实体，值对象，资源库，领域服务，领域事件，模块</p>
<h2 id="书章节安排"><a href="#书章节安排" class="headerlink" title="书章节安排"></a>书章节安排</h2><h2 id="阅读建议"><a href="#阅读建议" class="headerlink" title="阅读建议"></a>阅读建议</h2><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="第一章-DDD入门"><a href="#第一章-DDD入门" class="headerlink" title="第一章 DDD入门"></a>第一章 DDD入门</h3><h4 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h4><p>领域专家：</p>
<p>统一建模语言UML(Unified Modeling Language)</p>
<p>核心域：最重要的、复杂的业务场景。</p>
<p>支撑子域：相对核心域次要的。</p>
<h4 id="DDD的好处"><a href="#DDD的好处" class="headerlink" title="DDD的好处"></a>DDD的好处</h4><p>帮助开发人员面向业务。</p>
<h4 id="为什么需要DDD"><a href="#为什么需要DDD" class="headerlink" title="为什么需要DDD"></a>为什么需要DDD</h4><p>梳理业务价值，集中业务知识；提升团队沟通、凝聚力；提升软件伸缩性；简化领域复杂性</p>
<h5 id="梳理业务价值"><a href="#梳理业务价值" class="headerlink" title="梳理业务价值"></a>梳理业务价值</h5><h5 id="处理领域复杂性"><a href="#处理领域复杂性" class="headerlink" title="处理领域复杂性"></a>处理领域复杂性</h5><h5 id="系统复杂性评分"><a href="#系统复杂性评分" class="headerlink" title="系统复杂性评分"></a>系统复杂性评分</h5><h5 id="贫血对象"><a href="#贫血对象" class="headerlink" title="贫血对象"></a>贫血对象</h5><h4 id="DDD做了什么"><a href="#DDD做了什么" class="headerlink" title="DDD做了什么"></a>DDD做了什么</h4><ol>
<li>将领域专家和开发人员聚集到一起。<ul>
<li>所开发的软件能够反映出领域专家的思维模型。不是将精力花在了对“真实世界”的建模上，而是交付最具业务价值的软件。</li>
<li>领域专家和开发人员一起创建适用于领域建模的通用语言。有助于沟通，有助于促使原本存在分歧的领域专家达成一致。团队更有凝聚力。</li>
</ul>
</li>
<li>DDD关注业务战略</li>
<li>战术设计建模后，满足了软件设计的技术需求。DDD的最佳时间包含了高层的架构性实践和底层设计实践。关注业务规则和数据不变形。技术优点：可测试，伸缩性强，允许分布式计算。</li>
</ol>
<h4 id="如何DDD"><a href="#如何DDD" class="headerlink" title="如何DDD"></a>如何DDD</h4><p>通用语言和限界上下文共同构成了DDD的两大支柱。</p>
<p>步骤：建立通用语言，建立限界上下文</p>
<h5 id="通用语言"><a href="#通用语言" class="headerlink" title="通用语言"></a>通用语言</h5><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul>
<li>同一个限界上下文中使用的语言；不同限界上下文中同一词语含义可能不同</li>
<li>团队中使用相同的通用语言。</li>
<li>通用语言是关于如何思考和运作业务本身的。</li>
<li>通用语言是持续演化改变成长壮大的。</li>
<li>领域专家和开发人员共同创建。<ul>
<li>通用语言最初来自领域专家，他们最了解业务，并且深受工业标准的影响。</li>
<li>不同领域专家会在概念和术语上产生分歧，甚至犯错。</li>
<li>团队成员对于通用语言有时会做出妥协，妥协的是概念、术语、定义，而不是质量。质量？</li>
</ul>
</li>
</ul>
<h5 id="通用语言建模-amp-根据建模编写的代码案例"><a href="#通用语言建模-amp-根据建模编写的代码案例" class="headerlink" title="通用语言建模&amp;根据建模编写的代码案例"></a>通用语言建模&amp;根据建模编写的代码案例</h5><p>patient 病人</p>
<p>Shot 注射</p>
<p>flu 流感</p>
<p>dose 一剂</p>
<p>Nurse 护士</p>
<p>Vaccine 疫苗</p>
<p>Adult 成人</p>
<table>
<thead>
<tr>
<th>业务描述</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>“谁管呢？写代码就行了”</td>
<td>patient.setShotType(ShotTypes.TYPE_FLU); patient.setDose (dose); patient.setNurse (nurse);</td>
</tr>
<tr>
<td>我们给病人注射流感疫苗</td>
<td>patient.giveFluShot();</td>
</tr>
<tr>
<td>护士给病人打了标准剂量的流感疫苗</td>
<td>Vaccine vaccine = vaccines.standardAdultFluDose (); nurse.administerFluVaccine (patient, vaccine);</td>
</tr>
</tbody></table>
<h5 id="如何建立通用语言"><a href="#如何建立通用语言" class="headerlink" title="如何建立通用语言"></a>如何建立通用语言</h5><ul>
<li><p>最初来自领域专家。</p>
</li>
<li><p>创建一个包含简单定义的术语表，或者文档。罗列术语，包括好的和不好的，并注明好与不好的原因。</p>
</li>
<li><p>找团队其他人员检查成果。对于分歧做一些准备。</p>
</li>
<li><p>面对分歧。</p>
<ul>
<li>团队成员讨论</li>
<li>查阅参考资料，词典</li>
<li>引用标准</li>
</ul>
</li>
<li><p>绘制物理模型图和概念模型图，并标注名字和行为。</p>
</li>
<li><p>经过一段时间，通用语言文档将过时，只有团队交流和代码持续到最后。慢慢抛弃模型图、术语表和文档。</p>
</li>
</ul>
<h5 id="通用语言的局限性"><a href="#通用语言的局限性" class="headerlink" title="通用语言的局限性"></a>通用语言的局限性</h5><h4 id="使用DDD的业务价值-详细-原书总结-自己的观点"><a href="#使用DDD的业务价值-详细-原书总结-自己的观点" class="headerlink" title="使用DDD的业务价值-详细-原书总结+自己的观点"></a>使用DDD的业务价值-详细-原书总结+自己的观点</h4><ol>
<li>区分核心域、支撑子域，来帮助区分业务重要与次要，进而帮助公司把重点放在重要的业务上。</li>
<li>通过业务模型完善，明确业务模型内细节，掌握更多业务价值。</li>
<li>让各个领域专家就分歧达成一致；</li>
<li>让掌握业务的人数更多；</li>
<li>将分散在各个业务人员上的业务知识集中到领域模型、软件中。</li>
<li>更贴合用户，减少使用系统培训。</li>
<li>项目人员对上下文边界、关系明晰的过程可以了解企业架构。</li>
<li>辅助持续迭代业务。敏捷可应用到DDD中，持续迭代领域模型，迭代业务。</li>
</ol>
<h4 id="团队中DDD的使用"><a href="#团队中DDD的使用" class="headerlink" title="团队中DDD的使用"></a>团队中DDD的使用</h4><p>在 单个 限界 上下 文中 团队 成员 共享 一套 通用 语言。 </p>
<p>不同 的 团队 有时 各自 负责 一个 限界 上下文，</p>
<p>团队之间对接限界上下文</p>
<p>一个上下文中，使用战术建模工具： 聚合（ Aggregate， 10）、 实体（ Entity， 5）、 值 对象（ Value Object， 6）、 领域 服务（ Domain Service， 7）和领域 事件（ Domain Event， 8） 等。</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>建模：列出建模元素，分组，找出语言边界</p>
<h3 id="第三章-上下文映射图"><a href="#第三章-上下文映射图" class="headerlink" title="第三章 上下文映射图"></a>第三章 上下文映射图</h3><p>介绍：业务方面：属于解决方案空间的一部分，帮助梳理清楚一个解决方案对外界的依赖。<br>用途：可以让团队成员知道自己做的内容范围。</p>
<p>上下文之间的映射关系种类：</p>
<pre><code> 客户方供应方

 遵奉者

 另谋他路，即无关系

 大泥球

 共享内核
</code></pre>
<p>团队关系：合作关系<br>限界上下文接口之间：防腐层，开放主机服务（http），发布语言（json，xml）。</p>
<p>上下文映射图首先用来表示当前的项目状态。边界和关系。</p>
<p>不是系统拓扑图，不是企业架构。</p>
<p>图中的元素：</p>
<p>  U：上游</p>
<p>  D：下游</p>
<p>建议：上下文映射图贴在项目组墙上；放在wiki中并不会去看。</p>
<p>为不同限界上下文中的Dsicusion采用强类型？</p>
<h3 id="第四章-架构"><a href="#第四章-架构" class="headerlink" title="第四章 架构"></a>第四章 架构</h3><p>DDD无需绑定特定的架构。<br>核心域位于限界上下中，可以采用多种架构。</p>
<p>架构风格受到功能需求的限制。<br>DDD无需结合分层架构。<br>一个项目无需采用所有的架构。</p>
<h4 id="名词-1"><a href="#名词-1" class="headerlink" title="名词"></a>名词</h4><ul>
<li>架构风格：阐述如何实现某种架构</li>
<li>应用架构：</li>
<li>架构模式：关注一种架构的某个方面，比设计模式更宽泛。</li>
<li>六边形架构：端口和适配器。 也称Onion架构。</li>
<li>defect：缺陷</li>
</ul>
<h4 id="项目回顾"><a href="#项目回顾" class="headerlink" title="项目回顾"></a>项目回顾</h4><ol>
<li>因为桌面应用程序的应用层+中央数据库；采用了分层架构中的客户端-服务器风格。</li>
<li>募集了充足资金后，在开发敏捷项目管理系统前，先开发了协作工具。协作工具的好处：加入了火热的协作工具市场，为敏捷项目提供了附加功能（提高敏捷+协作提供支付能力）。</li>
<li>增加了单元测试和功能测试保证软件质量。在分层架构中使用了依赖倒置，方便的替换UI层和基础设施层。</li>
<li>开始盈利，增加移动端；软件使用REST，提供联合身份验证，项目和时间管理工具。</li>
<li>转向六边形架构来应对新需求，增加NoSQL，增加消息机制。</li>
<li>每个月新增几百个租户，添加了一个服务将协作工具中的遗留数据迁移到云上。</li>
<li>增加功能，如：TeackOvation，defect。客户要求分布式处理功能，引入CRES架构模式。使用了Pipe and Filter（管道和过滤器）完成CRES。</li>
<li>被RoaringCloud收购，突增了大量的订阅用户；将管道和过滤器分部化和并行化，加入长时处理过程和Sagas(分布式事务)</li>
</ol>
<h4 id="依赖注入-amp-六边形架构对分层架构的改进"><a href="#依赖注入-amp-六边形架构对分层架构的改进" class="headerlink" title="依赖注入&amp;六边形架构对分层架构的改进"></a>依赖注入&amp;六边形架构对分层架构的改进</h4><h4 id="REST-todo"><a href="#REST-todo" class="headerlink" title="REST todo"></a>REST todo</h4><h4 id="六边形架构对SOA和REST的支持-todo"><a href="#六边形架构对SOA和REST的支持-todo" class="headerlink" title="六边形架构对SOA和REST的支持 todo"></a>六边形架构对SOA和REST的支持 todo</h4><h4 id="cqrs架构"><a href="#cqrs架构" class="headerlink" title="cqrs架构"></a>cqrs架构</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>命令与查询分离。修改不返回数据，只有查询返回数据</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>解决数据显示复杂性</p>
<ul>
<li>缺点：编写更多的代码</li>
<li>优点：查询与命令隔离的优点：查询与命令占用资源不同，可以优化查询。<h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5>mapper的查询与增删改分离；<br>聚合的查询也与增删改分离<pre><code> 命令（写）模型：增删改+通过ID查询
 查询（读）模型：其他查询
</code></pre>
</li>
</ul>
<h5 id="cqrs各个方面的联系"><a href="#cqrs各个方面的联系" class="headerlink" title="cqrs各个方面的联系"></a>cqrs各个方面的联系</h5><h6 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h6><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/avNS5BEYPDeJKFz.png" alt="CQRS各个方面之间的联系"></p>
<p>查询模型不反映领域行为，只用于数据显示。视图对于查询模型有帮助</p>
<h6 id="客户端驱动命令"><a href="#客户端驱动命令" class="headerlink" title="客户端驱动命令"></a>客户端驱动命令</h6><p>  客户端向服务器发送命令，服务器在聚合上执行相应的行为。<br>  用户界面需要：1.收集足够的信息；2.演绎式的引导用户正确提交命令。</p>
<h6 id="命令处理器"><a href="#命令处理器" class="headerlink" title="命令处理器"></a>命令处理器</h6><ul>
<li>风格种类：<br>   分类。一个类，多个方法。<pre><code>      简单，易于理解
</code></pre>
   专属；一个类，一个方法<pre><code>     职责单一，处理器直接独立。
</code></pre>
   消息风格；<pre><code>     异步。复杂。伸缩性强
</code></pre>
一个处理器不应该依赖另一个处理器</li>
</ul>
<p>使用事件源时，修改Java内存中的聚合实例后，发布领域事件。然后消费领域事件，持久化聚合实例。</p>
<p>发布领域事件，可以用sping的事件或mq。</p>
<p>事件源与cqrs一块？ 事件日志包含在业务需求。</p>
<h6 id="命令修改对查询模型的影响"><a href="#命令修改对查询模型的影响" class="headerlink" title="命令修改对查询模型的影响"></a>命令修改对查询模型的影响</h6><ul>
<li><p>同步。</p>
<ul>
<li>方式：需要在一个事务中修改，命令和查询的存储位置需要一致（同一个数据库，同一缓存）</li>
<li>优点：用户看到的东西一致；</li>
<li>缺点：长事务耗费系统资源，命令和查询的存储位置需要一致。</li>
</ul>
</li>
<li><p>异步。</p>
<ul>
<li><p>方式：@Async;MQ</p>
</li>
<li><p>缺点：更新延迟时间不可预测。MQ提升系统复杂性</p>
</li>
<li><p>优点：</p>
<ol>
<li>满足其他的服务层协议。</li>
<li>利用MQ存储历史事件，则可以回放事件。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>异步数据一致性：</p>
<ol>
<li>前端提前展示未来修改后的内容。</li>
<li>展示数据的来源时间，让用户自己判断数据的实时性，用户可刷新。</li>
<li>通知用户请求已经正在处理，全部处理完还需时间。</li>
</ol>
<h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><h5 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h5><p>处理事件的生成，发现，处理的软件架构。</p>
<ul>
<li><p>六边形架构，遵循AMQP，不同于http的接收返回</p>
</li>
<li><p>事件驱动结合六边形架构：输入事件，输出事件，不同接口</p>
</li>
<li><p>事件类型：</p>
<ol>
<li>领域事件</li>
<li>日志事件</li>
<li>系统监控事件</li>
</ol>
</li>
<li><p>事件驱动架构带来的问题：<br> 长时处理过程，过程如何开始？如何分布在整个企业范围内？如何跟踪处理进度？</p>
<h5 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h5></li>
</ul>
<ul>
<li><p>Linux命令示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在 phone_ numbers. txt 文件 中统 计 含有 电话 区号“ 303” 的 所有 文本 行的 数量。</span></span><br><span class="line">cat phone_numbers.txt | grep 303 | wc -l # cat:向标准输出流输出文本内容 |：管道； grep 303：过滤得到含有 电话 区号“ 303”的文本行； wc -l:统计文本行数量</span><br></pre></td></tr></table></figure></li>
<li><p>示例转为Java事件驱动</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%AE%A1%E9%81%93%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="事件驱动管道和过滤器"></p>
</li>
</ul>
<h5 id="长时处理过程-saga"><a href="#长时处理过程-saga" class="headerlink" title="长时处理过程 saga"></a>长时处理过程 saga</h5><p>长时并行处理流程图</p>
<ul>
<li>三种设计方法</li>
</ul>
<p>1.组合任务，每一步持久化<br>2.一组聚合？<br>3.无状态，每一步都对消息扩充</p>
<p>引入的问题：无法知道两个不同流程的事件是同一个处理过程。需引入事件唯一标识</p>
<h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><ul>
<li>跟踪领域对象的修改；</li>
<li>审计日志；</li>
<li>方便调试；</li>
<li>方便对系统bug进行补偿；</li>
<li>辅助业务做：如果……会怎么样？</li>
</ul>
<p>与事件源类似的东西，例如：git跟踪对文件的修改</p>
<h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h6><p>每次操作，至少发布一个领域事件，每个领域事件都进行存储。<br>如何消除成百上千事件重放对系统的压力：每隔50-100个事件进行一次聚合的快照存储。<br>查询模型的数据源可以在事件存储更新之后得到静默更新？</p>
<h5 id="数据网织和基于网格的分布式计算"><a href="#数据网织和基于网格的分布式计算" class="headerlink" title="数据网织和基于网格的分布式计算"></a>数据网织和基于网格的分布式计算</h5><p>数据网织定义？聚合是基于图的缓存中的值部分</p>
<h6 id="存"><a href="#存" class="headerlink" title="存"></a>存</h6><p>分布式缓存可以容易的对领域模型进行持久化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">String key = product.productId().id();</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">byte</span>[] value = Serializer.serialize(product);</span><br><span class="line"><span class="comment">// region(GemFire) or cache(Coherence)</span></span><br><span class="line">region.put(key,value);</span><br></pre></td></tr></table></figure>
<h6 id="高性能，高可用"><a href="#高性能，高可用" class="headerlink" title="高性能，高可用"></a>高性能，高可用</h6><p>多节点部署.<br><strong>缓存冗余性的工作机制</strong>: 这里 有一个 例子： 其中 一个 节点 作为 主 缓存， 其他 节点 作为 二级 缓存。 如果 主 缓存 失效， 其中 一个 二级 缓存 将会 成为 新的 主 缓存。 当先 前 失效 的 主 缓存 恢复 之后， 新 主 缓存 中的 数据 将被 复制 到 恢复 后的 缓存 中， 此时 该 恢复 后的 缓存 将 变为 二级 缓存。</p>
<h6 id="结合领域事件？"><a href="#结合领域事件？" class="headerlink" title="结合领域事件？"></a>结合领域事件？</h6><p>大多数数据网 织可 以对 <strong>缓存 层面</strong> 和 <strong>入口 层面</strong> 上 所发 生的 操作 自动 地 <strong>发出 事件 通知</strong>。 这些 事件 不应该 和 领域 事件 产生 混淆。<br><strong>从 聚合 中直 接 发布 领域 事件</strong>， 领域 事件 可能 需要 继承 框架 中的 某种 事件 类型， 比如 GemFire 中的 EntryEvent， 但是 相比 起 这些 领域 事件 所 提供 的 强大 功能 来说， 这种 继承 只是 很小 的 代价。继承有什么代价？谁继承谁？<br><strong>如何 在数据网织 中 使用 领域 事件 呢？</strong> 聚合使用一个简单的DomainEventPublisher组件。对于数据网织的缓存来说，这个发布组件只是将事件放在某个特定的缓存中。<br>此后，数据网织将缓存事件通过同步或异步的方式发送给订阅方。为了不浪费内存，可以在得到所有订阅方的应答后，将缓存事件从缓存图移除。</p>
<h6 id="如何支持持续查询"><a href="#如何支持持续查询" class="headerlink" title="如何支持持续查询"></a>如何支持持续查询</h6><p>查询模型在领域事件存储后静默更新？<br>前端对可能发生的更改进行监听。</p>
<h3 id="第五章-实体"><a href="#第五章-实体" class="headerlink" title="第五章 实体"></a>第五章 实体</h3><h4 id="为什么使用实体"><a href="#为什么使用实体" class="headerlink" title="为什么使用实体"></a>为什么使用实体</h4><h6 id="名词-2"><a href="#名词-2" class="headerlink" title="名词"></a>名词</h6><p><strong>实体</strong>：<br>作用：衡量一个对象的个性特征，区分不同对象，找到相同对象。<br>同一个实体对象：一段时间内持续变化的对象拥有相同的唯一标识。<br>实体对象和值对象的区别：实体对象又唯一的身份标识和可变性特征。</p>
<p>有时，值对象比实体对象更适合建模。DDD并不总能满足我们的业务需求。</p>
<p>我们 通过 标识 对对 象 进行 区分， 而 不是 属性， 此时 我们 应该 将 标识 作为 主要 的 模型 定义。 同时 我们 需要 保持 简单 的 类 定义， 并且 关注 对象 在 其生 命 周期 中的 连续性 和 唯一 标识 性。 我们 不应该 通过 对象 的 状态 形式 和 历史 来 区分 不同 的 实体 对象…… 对于 什么 是 相同 的 东西， 模型 应该 给出 定义。？</p>
<h4 id="如何生成实体唯一标识"><a href="#如何生成实体唯一标识" class="headerlink" title="如何生成实体唯一标识"></a>如何生成实体唯一标识</h4><p>实体 设计 早期， 我们将 刻意 地 把 关注 点 放在能 体现 实体 身份 唯一 性的 主要 属性 和 行为 上， 同时 还将 关注 如何 对 实体 进行 查询。 另外， 我们 还会 刻意 地 忽略 掉 那些 次要 的 属性 和 行为。</p>
<p>在 设计 实体 时， 我们 首先 需要 考虑 实体 的 本质 特征， 特别是 实体 的 唯一 标识 和 对 实体 的 查找， 而 不是 一 开始 便 关注 实体 的 属性 和 行为。 只有 在 对 实体 的 本质 特征 有用 的 情况下， 才 加入 相应 的 属性 和 行为。</p>
<p>值 对象 可以 用于 存放 实体 的 唯一 标识。 值 对象 是 不变（ immutable） 的， 这可 以 保证 实体 身份 的 稳定性， 并且 与 身份 标识 相关 的 行为 也可以 得到 集中 处理。 这样， 我们 便 可以避免 将 身份 标识 相关 的 行为 泄漏 到 模型 的 其他 部分 或者 客户 端 中。?</p>
<h5 id="创建-实体-身份-标识-的-策略"><a href="#创建-实体-身份-标识-的-策略" class="headerlink" title="创建 实体 身份 标识 的 策略"></a>创建 实体 身份 标识 的 策略</h5><ol>
<li>用户提供一个或多个初始唯一值作为程序输入，程序保证这些初始值是唯一的。</li>
<li>程序内部通过某种算法生成身份标识</li>
<li>依赖持久化存储，比如数据库来生成唯一标识。</li>
<li>另一个限界上下文已经决定了唯一标识，这作为程序输入。<h5 id="对创建唯一标识策略副作用的衡量"><a href="#对创建唯一标识策略副作用的衡量" class="headerlink" title="对创建唯一标识策略副作用的衡量"></a>对创建唯一标识策略副作用的衡量</h5>将 关系 型 数据库 用于 对象 持久 化时，泄漏到领域模型。<br>标识 生成 的 时间、<br>关系 型 数据 的 引用 标识<br>ORM 在 标识 创建 过程 中的 作用，<br>唯一标识的稳定性。<h5 id="用户提供唯一标识策略"><a href="#用户提供唯一标识策略" class="headerlink" title="用户提供唯一标识策略"></a>用户提供唯一标识策略</h5>直接，看起来简单。<br>复杂性：</li>
</ol>
<ul>
<li>需要用户生成高质量的标识，标识唯一，不可变。<h5 id="程序生成唯一标识策略"><a href="#程序生成唯一标识策略" class="headerlink" title="程序生成唯一标识策略"></a>程序生成唯一标识策略</h5>如果 应用 程序 处于 集群 环境 或者 分布 在 不同 的 计算 节点 中需要注意。<br>衡量唯一标识：可读性，递增性，严格递增性，标识生成与实体生成的早晚<h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6></li>
</ul>
<ol>
<li>计算节点的当前时间，以毫秒记</li>
<li>计算节点的IP地址</li>
<li>虚拟机中工厂对象实例的对象标识</li>
<li>虚拟机中由同一个随机数生成器生成的随机数<h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6>java. util. UUID。<h6 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h6>自己实现，mysql+redis<h5 id="标识的维护"><a href="#标识的维护" class="headerlink" title="标识的维护"></a>标识的维护</h5>用值对象维护更好<h5 id="数据库生成唯一标识策略"><a href="#数据库生成唯一标识策略" class="headerlink" title="数据库生成唯一标识策略"></a>数据库生成唯一标识策略</h5></li>
</ol>
<h5 id="其他限界上下文提供唯一标识策略"><a href="#其他限界上下文提供唯一标识策略" class="headerlink" title="其他限界上下文提供唯一标识策略"></a>其他限界上下文提供唯一标识策略</h5><h4 id="如何从实体设计中捕获通用语言"><a href="#如何从实体设计中捕获通用语言" class="headerlink" title="如何从实体设计中捕获通用语言"></a>如何从实体设计中捕获通用语言</h4><h4 id="实体本质特征"><a href="#实体本质特征" class="headerlink" title="实体本质特征"></a>实体本质特征</h4><p>实体：<br>关注数据库，表，列，和对象映射，得到的是贫血模型。<br>通用语言：<br>       名词：概念<br>       形容词：描述概念<br>       动词：可以完成的操作</p>
<pre><code>   简单的通用语言：术语+用例
   通用语言不只包括术语和用例。
   通用语言应该直接反映在代码中。
</code></pre>
<p>一个领域场景今后还要使用，可以用轻量化的文档记录下来。<br>领域模型：不只是组类和类上定义的操作。</p>
<h4 id="如何表达实体的角色和职责"><a href="#如何表达实体的角色和职责" class="headerlink" title="如何表达实体的角色和职责"></a>如何表达实体的角色和职责</h4><h4 id="如何对实体进行验证和持久化"><a href="#如何对实体进行验证和持久化" class="headerlink" title="如何对实体进行验证和持久化"></a>如何对实体进行验证和持久化</h4><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="系统复杂性"><a href="#系统复杂性" class="headerlink" title="系统复杂性"></a>系统复杂性</h3><ol>
<li>dto和dto组装器会增加系统复杂性。</li>
</ol>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>领域驱动</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-limit设计</title>
    <url>/2023/09/22/214%E6%95%B0%E6%8D%AE%E5%BA%93/limit%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>Mysql-limit设计</p>
<span id="more"></span>

<h1 id="limit设计"><a href="#limit设计" class="headerlink" title="limit设计"></a>limit设计</h1><h3 id="Innodb为什么不实现limit"><a href="#Innodb为什么不实现limit" class="headerlink" title="Innodb为什么不实现limit"></a>Innodb为什么不实现limit</h3><p>InnoDB是MySQL数据库的一种存储引擎，它是一种支持事务和行级锁定的存储引擎。InnoDB并没有直接实现LIMIT功能，而是通过索引和扫描来实现查询结果的限制。<br>InnoDB的查询执行过程中，首先会根据查询条件进行索引扫描，找到满足条件的记录。然后，InnoDB会根据查询语句中的LIMIT子句来确定返回的记录数量。这个过程是在MySQL服务器层进行的，而不是在InnoDB存储引擎内部实现的。<br>由于InnoDB是基于索引的存储引擎，它的查询性能主要依赖于索引的使用。因此，通过合理地设计和使用索引，可以在查询过程中限制返回的记录数量，达到类似LIMIT的效果。<br>需要注意的是，InnoDB并不是通过跳过不符合条件的记录来实现LIMIT，而是在找到满足条件的记录后，将其返回给MySQL服务器层，然后由MySQL服务器层进行结果集的限制。这种设计可以保证查询结果的准确性和一致性。<br>总结起来，InnoDB并没有直接实现LIMIT功能，而是通过索引和扫描来实现查询结果的限制。通过合理地设计和使用索引，可以在查询过程中限制返回的记录数量。</p>
<h3 id="如果InnoDB直接实现LIMIT功能，可能会引发以下问题："><a href="#如果InnoDB直接实现LIMIT功能，可能会引发以下问题：" class="headerlink" title="如果InnoDB直接实现LIMIT功能，可能会引发以下问题："></a>如果InnoDB直接实现LIMIT功能，可能会引发以下问题：</h3><ol>
<li>数据不一致性：InnoDB是一个支持事务的存储引擎，它的设计目标是保证数据的一致性。如果InnoDB在内部实现LIMIT功能，可能会导致查询结果的不一致性。因为LIMIT是用于限制返回的记录数量，如果在查询过程中直接跳过不符合条件的记录，可能会导致某些记录被错误地排除在结果集之外，从而导致数据不一致。</li>
<li>锁定冲突：InnoDB使用行级锁定来实现并发控制，这意味着在查询过程中只有涉及到的行会被锁定，其他行仍然可以被其他事务访问。如果InnoDB在内部实现LIMIT功能，可能会导致锁定冲突的问题。因为在跳过不符合条件的记录时，需要对这些记录进行锁定，而这可能会与其他事务的操作产生冲突，导致性能下降和并发性能问题。</li>
<li>查询性能下降：InnoDB的设计目标是提供高性能的事务处理和并发控制。如果InnoDB在内部实现LIMIT功能，可能会增加查询的复杂性和开销，导致查询性能下降。因为LIMIT功能需要在查询过程中跳过不符合条件的记录，这可能会增加额外的计算和IO操作，从而影响查询性能。</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>limit</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql大表问题处理</title>
    <url>/2023/11/17/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E5%A4%A7%E8%A1%A8%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Mysql大表问题处理</p>
<span id="more"></span>

<h2 id="删蜍大量数据导致慢查询"><a href="#删蜍大量数据导致慢查询" class="headerlink" title="删蜍大量数据导致慢查询"></a>删蜍大量数据导致慢查询</h2><ul>
<li><p>原因：<br>数据一直在删除，查询SQL会不断扫描删除sql标记为删除的大量数据,删除千万数据，会查询千万数据，导致慢查询。  </p>
</li>
<li><p>解决方案：  </p>
</li>
</ul>
<ol>
<li>禁止在业务高峰期运行，数据清理全部放在凌晨执  </li>
<li>直接kill那个正在删千万级数据的长事务，所有SQL很快恢复正常  </li>
</ol>
<ul>
<li><p>大表业务示例</p>
<p>卡券业务来说，每个月产生的优惠券数量都在6000万左右，导致现在需要运维每两个月就要对表做瘦身，并且前端用户也只能查询两个月内的卡券。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>大表</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql表设计规范</title>
    <url>/2021/11/17/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>Mysql表设计规范</p>
<span id="more"></span>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>海量互联网架构设计，主键，推荐字符串类型；</p>
<p>自增整型缺点：</p>
<ul>
<li>MySQL 8.0 版本前自增值并不持久化，重启时可能会有回溯现象；</li>
<li>暴露业务数据量</li>
</ul>
<h2 id="资金字段设计"><a href="#资金字段设计" class="headerlink" title="资金字段设计"></a>资金字段设计</h2><p>推荐使用 BIG INT 来存储金额相关的字段；小数点交由前端处理展示，数据库按分存储。</p>
<p>优点：</p>
<ul>
<li>定长字段，占用 8 个字节，存储高效。</li>
<li>直接通过整型计算，效率更高。</li>
</ul>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>MySQL 要求 unsigned 数值相减之后依然为 unsigned，否则就会报错。</p>
<p>数据库参数 sql_mode 设置为 NO_UNSIGNED_SUBTRACTION，允许相减的结果为 signed</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MySQL 优化器是 CBO（Cost-based Optimizer），所有查询基于成本而不是规则，若发现 SQL 执行计划发生变化，不要怀疑 MySQL 出错，请先分析数据特点、索引创建是否合理，是否可以通过直方图校准数据。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>sql脚本</title>
    <url>/2020/01/07/214%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>sql脚本</p>
<span id="more"></span>

<h1 id="sql使用-高级"><a href="#sql使用-高级" class="headerlink" title="sql使用-高级"></a>sql使用-高级</h1><h2 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h2><p>information_schema库的COLUMNS表，里面记录了mysql所有库中所有表的字段信息</p>
<p>字段信息解释：<a href="https://blog.csdn.net/lkforce/article/details/79557482">https://blog.csdn.net/lkforce/article/details/79557482</a></p>
<h3 id="查看某个库所有表的注释"><a href="#查看某个库所有表的注释" class="headerlink" title="查看某个库所有表的注释"></a>查看某个库所有表的注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	table_name 表名,</span><br><span class="line">	table_comment 表说明 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	table_schema <span class="operator">=</span> <span class="string">&#x27;要查询的库&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	table_name;</span><br></pre></td></tr></table></figure>



<h2 id="rank"><a href="#rank" class="headerlink" title="rank"></a>rank</h2><h3 id="某个库所有表添加共同列"><a href="#某个库所有表添加共同列" class="headerlink" title="某个库所有表添加共同列"></a>某个库所有表添加共同列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	concat( <span class="string">&#x27;ALTER TABLE &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, table_name, <span class="string">&#x27; ADD COLUMN te_id varchar(64) COMMENT &quot;租户id&quot;, </span></span><br><span class="line"><span class="string">	ADD COLUMN bran_id varchar(64) COMMENT &quot;品牌id&quot;;</span></span><br><span class="line"><span class="string">	&#x27;</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	table_schema <span class="operator">=</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="某个库的所有表共同列初始化值"><a href="#某个库的所有表共同列初始化值" class="headerlink" title="某个库的所有表共同列初始化值"></a>某个库的所有表共同列初始化值</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	concat( <span class="string">&#x27;update &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, table_name, <span class="string">&#x27; set te_id = &quot;C001&quot;,bran_id = 100;&#x27;</span> ) s</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES t </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	table_schema <span class="operator">=</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="根据值-条件）查不同字段（列）"><a href="#根据值-条件）查不同字段（列）" class="headerlink" title="根据值(条件）查不同字段（列）"></a>根据值(条件）查不同字段（列）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   </span><br><span class="line">	sbi.goods_code,  </span><br><span class="line">	sbi.goods_name,  </span><br><span class="line">	<span class="keyword">case</span> sbi.is_review_stock <span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> sbi.review_theoretical_count <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">then</span> sbi.theoretical_count <span class="keyword">end</span> theoretical_count</span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">	sexytea_pss.t_item sbi   </span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">	<span class="keyword">AND</span> sb.`status` <span class="operator">=</span> &quot;FINISHED&quot;   </span><br><span class="line">	<span class="keyword">AND</span> sb.commit_time <span class="operator">&gt;</span> &quot;2022-10-31 12:00:00&quot;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对比两列值差集（A-B）"><a href="#对比两列值差集（A-B）" class="headerlink" title="对比两列值差集（A-B）"></a>对比两列值差集（A-B）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  a.code</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  a</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span> a.code <span class="operator">=</span> b.code </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  b.code <span class="keyword">IS</span> <span class="keyword">NULL</span>；</span><br></pre></td></tr></table></figure>



<h3 id="查询所有非系统库的表的注释"><a href="#查询所有非系统库的表的注释" class="headerlink" title="查询所有非系统库的表的注释"></a>查询所有非系统库的表的注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	table_schema 库名,</span><br><span class="line">	table_name 表名,</span><br><span class="line">	table_comment 表说明 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;mysql&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>,<span class="string">&#x27;performance_schema&#x27;</span>,<span class="string">&#x27;sys&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	table_name;</span><br></pre></td></tr></table></figure>



<h3 id="查询某个库所有表及字段的注释"><a href="#查询某个库所有表及字段的注释" class="headerlink" title="查询某个库所有表及字段的注释"></a>查询某个库所有表及字段的注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	a.table_name 表名,</span><br><span class="line">	a.table_comment 表说明,</span><br><span class="line">	b.COLUMN_NAME 字段名,</span><br><span class="line">	b.column_comment 字段说明,</span><br><span class="line">	b.column_type 字段类型,</span><br><span class="line">	b.column_key 约束 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES a</span><br><span class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> information_schema.COLUMNS b <span class="keyword">ON</span> a.table_name <span class="operator">=</span> b.TABLE_NAME </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	a.table_schema <span class="operator">=</span> <span class="string">&#x27;要查询的库&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	a.table_name</span><br></pre></td></tr></table></figure>

<h3 id="查询某表的所有字段的注释，按照字段顺序排列"><a href="#查询某表的所有字段的注释，按照字段顺序排列" class="headerlink" title="查询某表的所有字段的注释，按照字段顺序排列"></a>查询某表的所有字段的注释，按照字段顺序排列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	COLUMN_NAME 列名,</span><br><span class="line">	COLUMN_COMMENT 描述,</span><br><span class="line">	COLUMN_TYPE 数据类型,</span><br><span class="line">	if(IS_NULLABLE <span class="operator">=</span> <span class="string">&#x27;NO&#x27;</span>, <span class="string">&#x27;NO&#x27;</span>,<span class="string">&#x27;&#x27;</span>) <span class="keyword">AS</span> <span class="string">&#x27;是否为空&#x27;</span>,</span><br><span class="line">	COLUMN_KEY <span class="keyword">AS</span> <span class="string">&#x27;约束条件&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.COLUMNS </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	TABLE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;要查询的库&#x27;</span></span><br><span class="line">	<span class="keyword">AND</span> table_name <span class="operator">=</span> <span class="string">&#x27;要查询的表&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDINAL_POSITION;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><h3 id="插入另一张的内容"><a href="#插入另一张的内容" class="headerlink" title="插入另一张的内容"></a>插入另一张的内容</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span>	mdm_post_post_type;</span><br><span class="line"># 插入另一张表</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mdm_post_post_type ( post_post_type_id, post_code, type_id, is_del )</span><br><span class="line"> <span class="keyword">SELECT</span> post_id, p.post_code, p.type_id, <span class="number">0</span> <span class="keyword">FROM</span> mdm_post p <span class="keyword">WHERE</span> p.type_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ;</span><br><span class="line"># 修改雪花id前缀</span><br><span class="line">update mdm_post_post_type ppt1, mdm_post_post_type ppt2 <span class="keyword">set</span> ppt1.post_post_type_id <span class="operator">=</span> (concat(<span class="string">&#x27;PPTY&#x27;</span>,<span class="built_in">substring</span>(ppt1.post_post_type_id, <span class="number">4</span>) ) ) <span class="keyword">where</span> ppt1.post_post_type_id <span class="operator">=</span> ppt2.post_post_type_id;</span><br></pre></td></tr></table></figure>



<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><h3 id="修改表字段-名称和类型"><a href="#修改表字段-名称和类型" class="headerlink" title="修改表字段 名称和类型"></a>修改表字段 名称和类型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名  <span class="type">VARCHAR</span> ( <span class="number">64</span> ) comment <span class="string">&#x27;主键&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改数据表字符集和排序规则"><a href="#修改数据表字符集和排序规则" class="headerlink" title="修改数据表字符集和排序规则"></a>修改数据表字符集和排序规则</h3><p>– 使用方法：先执行如下脚本生成修改数据表和表字段的脚本，然后再执行这些生成的脚本。<br>– 修改指定数据库中所有数据表的字符集为 utf8mb4，并将排序规则修改为 utf8mb4_unicode_ci</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	CONCAT( <span class="string">&#x27;ALTER TABLE &#x27;</span>, table_name, <span class="string">&#x27; CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;&#x27;</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	TABLE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;库名&#x27;</span> </span><br><span class="line">	<span class="keyword">AND</span> table_name <span class="keyword">IN</span> (</span><br><span class="line">		<span class="string">&#x27;hr_test&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;hr_test2&#x27;</span> </span><br><span class="line">	)</span><br></pre></td></tr></table></figure>


<h3 id="修改字段的字符集和排序规则"><a href="#修改字段的字符集和排序规则" class="headerlink" title="修改字段的字符集和排序规则"></a>修改字段的字符集和排序规则</h3><p>– 使用方法：先执行如下脚本生成修改数据表和表字段的脚本，然后再执行这些生成的脚本。</p>
<p>– 修改指定数据库中所有varchar类型的表字段的字符集为 utf8mb4，并将排序规则修改为utf8mb4_unicode_ci</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	CONCAT(</span><br><span class="line">		<span class="string">&#x27;ALTER TABLE `&#x27;</span>,</span><br><span class="line">		table_name,</span><br><span class="line">		<span class="string">&#x27;` MODIFY `&#x27;</span>,</span><br><span class="line">		column_name,</span><br><span class="line">		<span class="string">&#x27;` &#x27;</span>,</span><br><span class="line">		DATA_TYPE,</span><br><span class="line">		<span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">		CHARACTER_MAXIMUM_LENGTH,</span><br><span class="line">		<span class="string">&#x27;) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci&#x27;</span>,</span><br><span class="line">		( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> IS_NULLABLE <span class="operator">=</span> <span class="string">&#x27;NO&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27; NOT NULL&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">END</span> ),</span><br><span class="line">		<span class="string">&#x27; comment &quot;&#x27;</span>, column_comment,<span class="string">&#x27;&quot;;&#x27;</span> </span><br><span class="line">) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.COLUMNS </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	TABLE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;库名&#x27;</span> </span><br><span class="line">	<span class="keyword">AND</span> DATA_TYPE <span class="operator">=</span> <span class="string">&#x27;varchar&#x27;</span> </span><br><span class="line">	<span class="keyword">AND</span> ( CHARACTER_SET_NAME <span class="operator">!=</span> <span class="string">&#x27;utf8mb4&#x27;</span> <span class="keyword">OR</span> COLLATION_NAME <span class="operator">!=</span> <span class="string">&#x27;utf8mb4_unicode_ci&#x27;</span> ) </span><br><span class="line">	<span class="keyword">AND</span> table_name <span class="keyword">in</span>( <span class="string">&#x27;test&#x27;</span> );</span><br></pre></td></tr></table></figure>

<h3 id="修改某个字段中的某些内容"><a href="#修改某个字段中的某些内容" class="headerlink" title="修改某个字段中的某些内容"></a>修改某个字段中的某些内容</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 将字段body_content_name中的,替换为<span class="operator">|</span></span><br><span class="line">update bpm_matrix_body <span class="keyword">set</span> body_content_name <span class="operator">=</span> replace(body_content_name,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;|&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="用一张表的字段更新另一张表的字段"><a href="#用一张表的字段更新另一张表的字段" class="headerlink" title="用一张表的字段更新另一张表的字段"></a>用一张表的字段更新另一张表的字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE mdm_uat.mdm_dept d1,</span><br><span class="line">test.mdm_dept d2 </span><br><span class="line"><span class="keyword">SET</span> d1.wx_dept_id <span class="operator">=</span> d2.wx_dept_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	d1.dept_code <span class="operator">=</span> d2.dept_code</span><br></pre></td></tr></table></figure>
<h3 id="用一张表的数据修改另一张表的数据逐条生成sql语句"><a href="#用一张表的数据修改另一张表的数据逐条生成sql语句" class="headerlink" title="用一张表的数据修改另一张表的数据逐条生成sql语句"></a>用一张表的数据修改另一张表的数据逐条生成sql语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 角色id生成关闭用户<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	concat( <span class="string">&#x27;update mds.user user u set u.status = 3 where u.id = &quot;&#x27;</span>, temp.u_id, <span class="string">&#x27;&quot;;&#x27;</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	(</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		r.u_id </span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		role r</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		r.id <span class="keyword">IN</span> ( &quot;12&quot; ) </span><br><span class="line">	) temp;</span><br></pre></td></tr></table></figure>

<h2 id="batch-update"><a href="#batch-update" class="headerlink" title="batch update"></a>batch update</h2><table>
<thead>
<tr>
<th></th>
<th>update set when then</th>
<th>insert into values on duplicate key update</th>
<th>replace into values</th>
<th>临时表 or 分区表</th>
<th>for 循环</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>灵活性高，不会重置自增ID</td>
<td></td>
<td></td>
<td></td>
<td>SQL简单</td>
</tr>
<tr>
<td>缺点</td>
<td>sql复杂，速度比insert into 慢</td>
<td>速度快</td>
<td>1.唯一索引相同时，先删除再插入，重置自增ID 2.速度比insert略慢</td>
<td>可能会增加查询复杂度</td>
<td>速度慢</td>
</tr>
<tr>
<td>场景</td>
<td>更新字段少</td>
<td></td>
<td></td>
<td>大型表或需要高效批量更新</td>
<td>？</td>
</tr>
</tbody></table>
<ol>
<li><p>update set when then, set when then  where</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE users</span><br><span class="line"><span class="keyword">SET</span> last_name <span class="operator">=</span> <span class="keyword">CASE</span></span><br><span class="line">  <span class="keyword">WHEN</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">  <span class="keyword">WHEN</span> user_id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;Smith&#x27;</span></span><br><span class="line">  <span class="keyword">WHEN</span> user_id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">&#x27;Johnson&#x27;</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">update t_item</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;actual_receive = case&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;end,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;item.actualReceive != null&quot;</span>&gt;</span></span><br><span class="line">                when sku_code = #&#123;item.skuCode&#125; then #&#123;item.actualReceive&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">where</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">    order_id = #&#123;item.orderId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>insert into values … on duplicate key update</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchUpdateUsers&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO user (id, name, age) VALUES </span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;item.id&#125;, #&#123;item.name&#125;, #&#123;item.age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    ON DUPLICATE KEY UPDATE name=VALUES(name), age=VALUES(age)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>REPLACE INTO … VALUES</p>
<p>是一个删除和插入的组合操作，当新记录与现有记录具有相同的唯一键值时，它会删除现有记录并插入新记录。</p>
<p>在插入新记录时重置自增ID的值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchReplaceUsers&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    REPLACE INTO user (id, name, age) VALUES </span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;item.id&#125;, #&#123;item.name&#125;, #&#123;item.age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>临时表</p>
<p>减少原始表上的连接和过滤操作，从而提高效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_users</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line">UPDATE users</span><br><span class="line"><span class="keyword">SET</span> last_name <span class="operator">=</span> <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> temp_users);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> TEMPORARY <span class="keyword">TABLE</span> temp_users;</span><br></pre></td></tr></table></figure></li>
<li><p>for循环</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserAge&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET age = #&#123;user.age&#125; WHERE id = #&#123;user.id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="WITH-RECURSIVE递归"><a href="#WITH-RECURSIVE递归" class="headerlink" title="WITH RECURSIVE递归"></a>WITH RECURSIVE递归</h3><p>通过 dept_id 获取 dept_id下的所有dept_id</p>
<p>表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for dept</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `dept`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept`  (</span><br><span class="line">  `dept_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门唯一标识&#x27;</span>,</span><br><span class="line">  `dept_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span>,</span><br><span class="line">  `parent_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父部门id&#x27;</span>,</span><br><span class="line">  `is_del` tinyint(<span class="number">1</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0未删除；1：已删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`dept_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_unicode_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;部门&#x27;</span> ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of dept</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `dept` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;总部&#x27;</span>, <span class="string">&#x27;-1&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `dept` <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `dept` <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `dept` <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;昌平区&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> sys_dept_sub <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		dept_id <span class="keyword">AS</span> rootId </span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		dept </span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		dept_id <span class="operator">=</span> #&#123;deptId&#125; <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		dept_id </span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		dept r,</span><br><span class="line">		sys_dept_sub d </span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		r.parent_id <span class="operator">=</span> d.rootId </span><br><span class="line">		<span class="keyword">AND</span> is_del <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line">	) <span class="keyword">SELECT</span></span><br><span class="line">	dept_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	dept </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">EXISTS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		rootId </span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		sys_dept_sub t </span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">	rootId <span class="operator">=</span> dept_id </span><br><span class="line">	)</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> temp <span class="keyword">AS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">        <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        mdm_post</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        post_code <span class="operator">=</span> #&#123;postCode&#125;</span><br><span class="line">        <span class="keyword">AND</span> is_del <span class="operator">=</span> <span class="number">0</span> <span class="keyword">UNION</span></span><br><span class="line">        <span class="keyword">DISTINCT</span> <span class="keyword">SELECT</span></span><br><span class="line">        d.<span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        mdm_post d</span><br><span class="line">        <span class="keyword">INNER</span> <span class="keyword">JOIN</span> temp t <span class="keyword">ON</span> d.parent_code <span class="operator">=</span> t.post_code</span><br><span class="line">        <span class="keyword">AND</span> d.is_del <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        ) <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">        post_code</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        temp</span><br></pre></td></tr></table></figure>



<h3 id="local实现递归"><a href="#local实现递归" class="headerlink" title="local实现递归"></a>local实现递归</h3><ul>
<li><p>local函数介绍</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 如果字符串 string 包含 subStr</span><br><span class="line">locate(subStr,string) <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>递归地实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表中定义部门路径字段。dept_path</span><br></pre></td></tr></table></figure>

<p>数据</p>
<table>
<thead>
<tr>
<th>dept_path</th>
</tr>
</thead>
<tbody><tr>
<td>集团总部/人力资源</td>
</tr>
<tr>
<td>集团总部/人力资源/财务</td>
</tr>
</tbody></table>
<p>查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询部门a和部门a下的所有部门。</span><br><span class="line">locate(a.name,dept_path)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="某张表卡死"><a href="#某张表卡死" class="headerlink" title="某张表卡死"></a>某张表卡死</h2><ul>
<li><p>原因：因事务未提交锁表。例如：alter 表字段</p>
</li>
<li><p>解决：</p>
<ol>
<li><p>直接 -杀死未提交事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">root权限下：</span><br><span class="line"># 查看未提交事务</span><br><span class="line"><span class="keyword">select</span> trx_state, trx_started, trx_mysql_thread_id, trx_query <span class="keyword">from</span> information_schema.innodb_trx;</span><br><span class="line"># 杀死未提交事务</span><br><span class="line">kill <span class="number">989465</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>根本 - 调整锁超时阈值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># lock_wait_timeout 表示获取metadata lock的超时（单位为秒），允许的值范围为<span class="number">1</span>到<span class="number">31536000</span>（<span class="number">1</span>年）。 默认值为<span class="number">31536000</span>。</span><br><span class="line"><span class="keyword">set</span> session lock_wait_timeout <span class="operator">=</span> <span class="number">1800</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> lock_wait_timeout <span class="operator">=</span> <span class="number">1800</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="逆向工程生成的实体类与表不一致"><a href="#逆向工程生成的实体类与表不一致" class="headerlink" title="逆向工程生成的实体类与表不一致"></a>逆向工程生成的实体类与表不一致</h2><ul>
<li><p>原因</p>
<ol>
<li>逆向工程使用<code>information_schema.COLUMNS</code>，此表在某些情况下会有实际的表不一致。</li>
<li>不同的库下有相同的表，另一个表中与本表不一致</li>
</ol>
</li>
<li><p>解决</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># generatorConfig.xml 中配置忽视某列</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">table</span> tableName<span class="operator">=</span>&quot;bpm_matrix_body&quot;<span class="operator">&gt;</span></span><br><span class="line">            <span class="operator">&lt;</span>ignoreColumn <span class="keyword">column</span><span class="operator">=</span>&quot;header_code&quot;<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="operator">/</span>ignoreColumn<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">table</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql查询优化</title>
    <url>/2023/01/03/214%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Mysql大表问题处理</p>
<span id="more"></span>

<h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="为什么慢？"><a href="#为什么慢？" class="headerlink" title="为什么慢？"></a>为什么慢？</h2><ol>
<li><p>确定目标数据时，扫描行数太多</p>
</li>
<li><p>业务查询范围过大。</p>
</li>
<li><p>库本身数据量大</p>
</li>
<li><p>硬件</p>
</li>
<li><p>mysql配置</p>
</li>
<li><p>offset大</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2></li>
<li><p>确定目标数据时，扫描行数太多</p>
<ol>
<li><p>无索引</p>
<ul>
<li>常用</li>
</ul>
<ol>
<li>条件，排序，分组字段。</li>
</ol>
<ul>
<li>其他</li>
</ul>
<ol>
<li>唯一索引使用了普通索引</li>
<li>关联字段类型不同，一个是int，一个是varchar</li>
</ol>
</li>
<li><p>业务查询范围过大。</p>
<ol>
<li><p>时间范围大</p>
</li>
<li><p>名称模糊查询和时间范围在一块</p>
<p>前端门店模糊确定出门店编码，后端用branchCode精确查</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据量大，传输慢。</p>
<ol>
<li>网络带宽</li>
<li>分批</li>
</ol>
</li>
<li><p>库本身数据量大</p>
<ol>
<li>分库分表</li>
</ol>
</li>
<li><p>硬件</p>
</li>
<li><p>mysql配置</p>
</li>
<li><p>offset大</p>
<ol>
<li><p>不用offset，改为id</p>
</li>
<li><p>延迟关联或者子查询优化</p>
<p>阿里巴巴编码规范-说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回前放弃前面的offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。<br>正例：先快谏定位需要获取的id段，然后再关联：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.<span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span><span class="keyword">as</span> t1，(<span class="keyword">select</span> id <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 条件 limit <span class="number">100000</span>, <span class="number">20</span>）<span class="keyword">as</span> t2 <span class="keyword">where</span> t1.id<span class="operator">=</span>t2.id</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;list&quot; parameterType=&quot;com.xxx.OrderPageQuery&quot; resultType=&quot;com.xxx.OrderDO&quot;&gt;</span><br><span class="line">    SELECT</span><br><span class="line">        &lt;include refid=&quot;all_columns&quot;/&gt;</span><br><span class="line">    FROM t_order a</span><br><span class="line">    INNER JOIN (</span><br><span class="line">        SELECT id AS bid</span><br><span class="line">        FROM t_order</span><br><span class="line">            &lt;include refid=&quot;listConditions&quot;/&gt;</span><br><span class="line">        ORDER BY id DESC</span><br><span class="line">        LIMIT #&#123;offset&#125;,#&#123;pageSize&#125;</span><br><span class="line">    ) b ON a.id = b.bid</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[[Mysql性能分析和优化]]</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>报错</title>
    <url>/2021/11/01/219%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>各类框架工具报错</p>
<span id="more"></span>

<h1 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h1><h2 id="线上问题"><a href="#线上问题" class="headerlink" title="线上问题"></a>线上问题</h2><p>[[线上问题总结-茶颜供应链]]</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol>
<li>空指针异常 NullException<ul>
<li>场景<ol>
<li>新增字段直接判断 newFiled == 1。应该 newFiled == null || newFiled == 1</li>
<li>查询外部接口返回了null</li>
</ol>
</li>
</ul>
</li>
<li></li>
</ol>
<h2 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a>Java框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><h5 id="Transactional事务失效"><a href="#Transactional事务失效" class="headerlink" title="Transactional事务失效"></a>Transactional事务失效</h5><ol>
<li><p>本类调用，不走代理。</p>
<ul>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result update <span class="title">User</span><span class="params">(User user, SubmitInfo submitInfo)</span></span>&#123;</span><br><span class="line">    UserDetail userDetail = buildUserDetail(user);</span><br><span class="line">    <span class="keyword">this</span>.updateUser(userDetail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doUpdateUser</span><span class="params">(userDetail)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>原因</p>
<p>本类调用，不走代理。</p>
<p>@Transactional 生效，需要走代理。</p>
<p>走代理需要注入到spring容器中，并且他类调用</p>
</li>
<li><p>解决</p>
<p>新写一个类，或者自己注入自己</p>
</li>
</ul>
</li>
<li><p>不在同一个线程中，如@Async导致失效。</p>
</li>
<li><p>手动抛出Exception，又没有指定回滚异常为Exception；spring只会在RunException和error回滚事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">           saveData(userModel);</span><br><span class="line">           updateData(userModel);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(e.getMessage(), e);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="4">
<li><p>多数据源，事务管理器不是默认名称，事务注解没有配置管理器名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事务管理器配置</span></span><br><span class="line"><span class="meta">@Bean(name = &quot;dataSourceTransactionManager3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">mainTransactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSource3&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class,transactionManager = &quot;dataSourceTransactionManager3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异常被吞了，没有手动回滚，或者再抛出异常</p>
</li>
<li><p>异常类型错误</p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/qdhxhz/p/15435483.html">参考</a> </p>
<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><ul>
<li><p>问题</p>
<p>调接口报错400</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result&lt;UserMatrixDTO&gt; getUserByUserAndDept(@RequestParam(value = &quot;userName&quot;) String userName, @RequestParam(value = &quot;deptName&quot;,required = false) String deptName) &#123;</span><br></pre></td></tr></table></figure></li>
<li><p>原因</p>
<p>默认required = true。 不传时报400</p>
</li>
<li><p>解决</p>
<p>增加<code>required = false</code></p>
</li>
</ul>
<h3 id="swagger-knife4j"><a href="#swagger-knife4j" class="headerlink" title="swagger knife4j"></a>swagger knife4j</h3><p>问题：接口文档请求异常</p>
<p>原因：响应的swagger的接口JSON是一个非法JSON。例如：后端给List集合的属性赋予了<code>example</code>属性</p>
<p>解决：List去除<code>example</code>属性</p>
<ul>
<li><p>问题</p>
<p>swagger文档中响应参数显示错误</p>
</li>
<li><p>原因</p>
<p>@ApiModel(“”)中的值与其他值相同，swagger取了其他的@ApiModel注解得类</p>
</li>
<li><p>例子</p>
<p>有两个 @ApiModel(“测试”) 标注的类，swagger文档只会取其中一个</p>
</li>
<li><p>解决</p>
<p>改变其中一个 @ApiModel 中的值。</p>
</li>
</ul>
<h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><ul>
<li><p>问题</p>
<p>junit启动报错，Caught exception while allowing TestExecutionListener</p>
<p>Caught exception while allowing TestExecutionListener [org.springframework.boot.test.autoconfigure.SpringBootDependencyInjectionTestExecutionListener@7582ff54] to prepare test instance [com.sexytea.pss.receiving.AutoCodeTest@2766ca9d]<br>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘com.sexytea.pss.receiving.AutoCodeTest’: Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘com.*.mapper.**Mapper</p>
</li>
<li><p>原因</p>
<p>*Mapper.java没有注解@Mapper时，报错。BootAppcation上有@MapperScan也没用</p>
</li>
<li><p>例子</p>
</li>
<li><p>解决</p>
<p>Mapper.java类上添加注解@Mapper</p>
</li>
</ul>
<h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><ol>
<li><p>项目无法启动</p>
<ul>
<li><p>错误信息：Process finished with exit code 1</p>
</li>
<li><p>代码环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MapperScan(&#123;&quot;com.xiaoruiit.mapper.*&quot;&#125;)</span><br><span class="line">xiaoruiit/mapper/manual 下有手动dao</span><br><span class="line">xiaoruiit/mapper 下有自动生成的dao</span><br></pre></td></tr></table></figure></li>
<li><p>原因：@Autowired 无法注入dao,报错</p>
</li>
<li><p>排错</p>
<p>Throwable抓报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    SpringApplication.run(BootApplication.class, args);</span><br><span class="line">&#125;catch (Throwable e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解决：删除manual包</p>
</li>
</ul>
</li>
<li><p>mapper参数绑定异常</p>
<ul>
<li><p>错误信息</p>
<p>本地idea启动没问题。</p>
<p>容器中运行报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter &#x27;skuName&#x27; not found.</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; getReviewStockList(String userCode, String userName);</span><br></pre></td></tr></table></figure></li>
<li><p>解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; getReviewStockList(@Param(&quot;userCode&quot;)String userCode,@Param(&quot;userName&quot;)String userName);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
</ol>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><ul>
<li><p>问题：set、get报错，参数接不到</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240124140400708.png" alt="image-20240124140400708"></p>
</li>
<li><p>原因：第二个字母大写的属性，lombok生成的get，set方法不符合java bean规范</p>
</li>
<li><p>解决</p>
<p>修改属性，或者手动生成set、get方法</p>
</li>
</ul>
<h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><ul>
<li><p>问题</p>
<p>springboot + mybatis分页插件 pageHelper不能正确的获取到total</p>
</li>
<li><p>原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanUtils复制List&lt;bean&gt;信息到List&lt;beanVo&gt;时丢失了PageInfo中的total信息</span><br></pre></td></tr></table></figure></li>
<li><p>解决</p>
<p>第一种：直接查出为VO，不要转换；第二种：BeanUtils时，手写对PageInfo的total赋值。</p>
</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ol>
<li><p>order by 字段值为空，分页数据重复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by diffMoney desc limit 0,10;</span><br><span class="line">order by diffMoney limit 10,10;</span><br><span class="line">diffMoney字段的值大部分为null,查出的部分分页数据会重复</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决</p>
<p>增加id排序字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by diffMoney desc, id desc limit 10,10;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
</ol>
<h2 id="日志SLS"><a href="#日志SLS" class="headerlink" title="日志SLS"></a>日志SLS</h2><ol>
<li><p>无法识别中文符号”：”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志是  创建消息：</span><br><span class="line">创建消息 查不到，需要查 创建消息：</span><br><span class="line">如果是 创建消息:, 创建消息可以查到</span><br></pre></td></tr></table></figure></li>
<li><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="Cannot-resolve-class-or-package"><a href="#Cannot-resolve-class-or-package" class="headerlink" title="Cannot resolve class or package"></a>Cannot resolve class or package</h3></li>
</ol>
<ul>
<li><p>问题描述</p>
<p>Cannot resolve class or package ‘jspxcms’，即找不到包jspxcms</p>
</li>
<li><p>原因</p>
<p>改变了目录结构</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240124115720268.png" alt="image-20240124115720268"></p>
</li>
<li><p>解决</p>
<p>恢复目录结构</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/image-20240124115804575.png" alt="image-20240124115804575"></p>
</li>
</ul>
<h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><ul>
<li><p>问题</p>
</li>
<li><p>原因</p>
</li>
<li><p>解决</p>
</li>
</ul>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><h3 id="未分页"><a href="#未分页" class="headerlink" title="未分页"></a>未分页</h3><ul>
<li><p>问题：接口报错</p>
</li>
<li><p>原因：未分页多次循环调用Feign来组装数据，hystrix起作用。</p>
</li>
<li><p>实例</p>
<p>未分页调用薪资配置list接口，7000多条数据用Feign远程调用MdmUserService组装员工基本数据。</p>
</li>
<li><p>解决</p>
</li>
</ul>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><h3 id="无法推送"><a href="#无法推送" class="headerlink" title="无法推送"></a>无法推送</h3><ul>
<li><p>背景</p>
<p>配置了github ssh key 和本地key</p>
</li>
<li><p>问题</p>
<p>一直都成功，某次推送，idea报错：ssh: connect to host github.com port 22: Connection timed out</p>
</li>
<li><p>解决</p>
<p>C:\Users\LENOVO.ssh 增加文件 config</p>
<p>内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure></li>
<li><p>参考<br><a href="https://blog.csdn.net/weixin_45637036/article/details/106560217">https://blog.csdn.net/weixin_45637036/article/details/106560217</a></p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="UAT环境不可用"><a href="#UAT环境不可用" class="headerlink" title="UAT环境不可用"></a>UAT环境不可用</h3><ul>
<li>问题描述</li>
</ul>
<p>需验证生产问题时</p>
<ol>
<li>发现鸳央登录后点击供应链内容提示无法登录。</li>
<li>发现茶颜登录后，点击供应链内容无反应。</li>
<li>PDA无法登录</li>
</ol>
<ul>
<li><p>事件发展：</p>
</li>
<li><p>排查</p>
<p>PDA</p>
<ol>
<li>查日志，有报错。重发服务</li>
<li>重发服务后，只有心跳日志，接口日志。想起半个月前环境迁移，可能没配置路由</li>
<li>容器配置检查路由，缺少路由，配置路由。依然无接口日志</li>
<li>抓包到报错的接口，是钉钉扫码接口报错，前端本地调试可以登录，随即发现uat环境迁移，域名改变，即钉钉回调地址发生变化。改变回调地址，重新打包。</li>
</ol>
<p>IPAD</p>
<ol>
<li>抓包，请求到固定域名 uat.baidu.com，但返回404</li>
<li>找前端改nginx中uat配置的后端地址并发版时，发现流水线配置没有改集群地址。</li>
</ol>
</li>
<li><p>具体问题点</p>
</li>
</ul>
<ol>
<li>容器缺少服务配置</li>
<li>容器缺少路由配置</li>
<li>部分服务配置错误</li>
<li>pda未切换域名</li>
<li>iPad未切换域名</li>
<li>部分服务未切换数据库</li>
<li>前端流水线配置没有选新的集群地址</li>
</ol>
<ul>
<li>知识</li>
</ul>
<ol>
<li>服务（svc）配置影响内部互相调用。</li>
<li>路由ingress配置影响外部访问。入口服务必须配置，一般配置映射到80端口。其他服务不配置时，接口文档无法访问。</li>
<li>需要DNS配置</li>
<li>nginx和后端服务同在阿里云集群，nginx配置了后端服务名，test-svc</li>
</ol>
<ul>
<li>复杂性：<ol>
<li>我手里有定好排期的开发任务</li>
<li>我不知道整个链路,没人知道整个链路</li>
<li>没有人知道整个链路</li>
<li>事件已发生一段时间，相关人员忘记了东西</li>
<li>相关人员多。前端两位，其中以为是另一个组的；后端5位，各自服务未改数据库地址；运维一位，不是专职，还会做别的事；测试两位，其中一位做了部分容器配置；领导，忘了之前的配置；</li>
<li>没有prod权限对照检查，uat环境与其他配置不同</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>错误总结</category>
      </categories>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql性能分析和优化</title>
    <url>/2020/05/31/214%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>查询慢查询日志</p>
<span id="more"></span>
<h1 id="Mysql性能分析和优化"><a href="#Mysql性能分析和优化" class="headerlink" title="Mysql性能分析和优化"></a>Mysql性能分析和优化</h1><p>性能分析，优化，监控工具</p>
<h2 id="1-性能分析"><a href="#1-性能分析" class="headerlink" title="1.性能分析"></a>1.性能分析</h2><p>慢查询日志，profile性能监控，performance_schema性能监控</p>
<h3 id="1-1慢查询日志"><a href="#1-1慢查询日志" class="headerlink" title="1.1慢查询日志"></a>1.1慢查询日志</h3><p>分析：</p>
<ol>
<li>通过慢查询日志获取查询时间较长的SQL</li>
<li>查看SQL的执行计划explain</li>
<li>使用show profile[s] 查看SQL的性能使用情况</li>
</ol>
<p>注意：开启慢查询日志影响mysql性能，排查问题时再开启。</p>
<h4 id="1-1-1开启慢查询日志"><a href="#1-1-1开启慢查询日志" class="headerlink" title="1.1.1开启慢查询日志"></a>1.1.1开启慢查询日志</h4><ol>
<li><p>连接服务器</p>
<p>工具：FinalShell</p>
</li>
<li><p>登录mysql</p>
</li>
<li><p>慢查询日志</p>
<ol>
<li>开启</li>
<li>设置参数</li>
</ol>
</li>
<li><p>查看慢查询日志</p>
</li>
</ol>
<h5 id="查看慢查询信息"><a href="#查看慢查询信息" class="headerlink" title="查看慢查询信息"></a>查看慢查询信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 登录mysql</span><br><span class="line">show variables like &#x27;%slow%&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="慢查询设置（开启、收集条件）"><a href="#慢查询设置（开启、收集条件）" class="headerlink" title="慢查询设置（开启、收集条件）"></a>慢查询设置（开启、收集条件）</h5><h6 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h6><p>重启失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 开启</span><br><span class="line">set global slow_query_log=&#x27;ON&#x27;;</span><br><span class="line">## 设置慢查询日志存放位置</span><br><span class="line">set global slow_query_log_file=&#x27;/usr/local/mysql/data/slow.log&#x27;;</span><br><span class="line">## 设置收集慢查询SQL时间</span><br><span class="line">set global long_query_time= 1;</span><br><span class="line"></span><br><span class="line">## 查看收集慢查询SQL时间</span><br><span class="line">show global variables like &#x27;long_query_time&#x27;;</span><br></pre></td></tr></table></figure>

<h6 id="永久"><a href="#永久" class="headerlink" title="永久"></a>永久</h6><p>修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /var/lib/mysql/slow.log</span><br><span class="line">long_query_time = 1</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2分析慢查询日志"><a href="#1-1-2分析慢查询日志" class="headerlink" title="1.1.2分析慢查询日志"></a>1.1.2分析慢查询日志</h4><h5 id="mysqldumpslow工具"><a href="#mysqldumpslow工具" class="headerlink" title="mysqldumpslow工具"></a>mysqldumpslow工具</h5><p>mysql自带</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照查询时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/slow.log</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s 表示按照何种方式排序</span><br><span class="line">    c 访问次数</span><br><span class="line">    l 锁定时间</span><br><span class="line">    r 返回记录</span><br><span class="line">    t 查询时间</span><br><span class="line">    al 平均锁定时间</span><br><span class="line">    ar 平均返回记录数</span><br><span class="line">    at  平均查询时间</span><br><span class="line">-t 返回前面多少条数据</span><br><span class="line">-g 搭配正则匹配模式，大小写不敏感</span><br></pre></td></tr></table></figure>

<h5 id="percona-toolkit工具"><a href="#percona-toolkit工具" class="headerlink" title="percona-toolkit工具"></a>percona-toolkit工具</h5><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install perl-DBD-MySQL</span><br><span class="line"># 安装perl-Digest-MD5工具</span><br><span class="line">yum -y install perl-Digest-MD5</span><br><span class="line"></span><br><span class="line">yum -y install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</span><br><span class="line"></span><br><span class="line">cd /usr/local/src</span><br><span class="line"># 下载percona-toolkit 工具包</span><br><span class="line">wget percona.com/get/percona-toolkit.tar.gz</span><br><span class="line">tar zxf percona-toolkit.tar.gz</span><br><span class="line">cd /usr/local/src/percona-toolkit-3.1.0</span><br><span class="line"></span><br><span class="line"># 安装perl模块，制定依赖路径</span><br><span class="line">perl Makefile.PL PREFIX=/usr/local/percona-toolkit</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行工具pt-query-digest</span><br><span class="line">cd /usr/local/percona-toolkit/bin</span><br><span class="line">./pt-query-digest /usr/local/src/slowsqlExample/slow0312.log </span><br><span class="line"># 下载文件到本地</span><br><span class="line">sz slow0312.log </span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<ol>
<li><p>分析慢查询文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pt-query-digest  slow.log &gt; slow_report.log</span><br></pre></td></tr></table></figure>

<p>报告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一部分</span><br><span class="line">该工具执行日志分析的用户时间，系统时间，物理内存占用大小，虚拟内存占用大小</span><br><span class="line"># 95.2s user time, 1.9s system time, 1.09G rss, 1.17G vsz</span><br><span class="line">工具执行时间</span><br><span class="line"># Current date: Thu Jun 10 16:45:43 2021</span><br><span class="line">运行分析工具的主机名    </span><br><span class="line"># Hostname: iZbp15xr4imyrogpz1216f9Z</span><br><span class="line">被分析的文件名</span><br><span class="line"># Files: /usr/lib/mysql/slow.log</span><br><span class="line">语句总数量，唯一的语句数量，QPS，并发数</span><br><span class="line"># Overall: 38.97k total, 321 unique, 0.03 QPS, 0.06x concurrency _________</span><br><span class="line">日志记录的时间范围</span><br><span class="line"># Time range: 2021-05-25T07:31:57 to 2021-06-10T08:45:02</span><br><span class="line"># Attribute          total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============     ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># Exec time         76953s      1s    467s      2s      3s      9s      1s</span><br><span class="line"># Lock time           729s       0     29s    19ms   214us   546ms   119us</span><br><span class="line"># Rows sent         98.47M       0   1.68M   2.59k    0.99  46.83k    0.99</span><br><span class="line"># Rows examine      57.71G       0   1.69M   1.52M   1.61M 303.67k   1.53M</span><br><span class="line"># Query size         1.34G       6  29.15M  35.96k   84.10 477.84k   84.10</span><br><span class="line"></span><br><span class="line">第二部分</span><br><span class="line"># Profile</span><br><span class="line">Rank：所有语句的排名，默认按查询时间降序排列，通过--order-by指定</span><br><span class="line">Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</span><br><span class="line">Response：总的响应时间</span><br><span class="line">time：该查询在本次分析中总的时间占比</span><br><span class="line">calls：执行次数，即本次分析总共有多少条这种类型的查询语句</span><br><span class="line">R/Call：平均每次执行的响应时间</span><br><span class="line">V/M：响应时间Variance-to-mean的比率</span><br><span class="line">Item：查询对象</span><br><span class="line"># Rank Query ID                        Response time   Calls R/Call V/M   </span><br><span class="line"># ==== =============================== =============== ===== ====== ===== </span><br><span class="line">#    1 0xABD1DCCCCD5AA5128E10C27B34... 1246.6948 41.7%   283 4.4053  0.04 UPDATE ziweidashi_deviceinfo</span><br><span class="line">#    2 0x6914B81AAD1785E50708ABD113...  877.6900 29.3%   339 2.5891  0.09 SELECT birthDay_notify</span><br><span class="line">#    3 0x44D9474C6D5C58DD07B5FEEA0D...  299.4193 10.0%    71 4.2172  0.05 SELECT tmall_product_orders</span><br><span class="line">#    4 0xA9BE84CBE3DAA9B1CDD9B5A9EC...  127.0137  4.2%    46 2.7612  0.04 SELECT daily_user_action_log</span><br><span class="line">#    5 0xCF0E12117C971C3013142E3717...  118.3138  4.0%    49 2.4146  0.05 SELECT tmall_user_take_coupon_record</span><br><span class="line">#    6 0x94263184D24186330B13193534...   97.0805  3.2%    35 2.7737  0.56 SELECT tgg_users</span><br><span class="line">#    7 0xC51165F1287A2ECDA221AC1F54...   52.5870  1.8%    22 2.3903  0.04 SELECT util_user_task_log</span><br><span class="line">#    8 0xB8004D6D8A7A7967E04CD81E26...   43.7895  1.5%    16 2.7368  0.08 SELECT daily_user_action_log</span><br><span class="line">#    9 0x910E19224F33DAA6391927B8E8...   41.3720  1.4%    15 2.7581  1.17 SELECT qifugong_tianbi_record</span><br><span class="line"># MISC 0xMISC                            86.7871  2.9%    30 2.8929   0.0 &lt;12 ITEMS&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三及后续部分，第一条查询语句 query id：0xABD1DCCCCD5AA5128E10C27B34BC04E7</span><br><span class="line"># Query 1: 0.01 QPS, 0.03x concurrency, ID 0xABD1DCCCCD5AA5128E10C27B34BC04E7 at byte 355748</span><br><span class="line"># Scores: V/M = 0.04</span><br><span class="line"># Time range: 2020-03-11 12:24:03 to 2020-03-12 00:16:13</span><br><span class="line"># Attribute    pct   total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============ === ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># Count         31     283</span><br><span class="line"># Exec time     41   1247s      4s      8s      4s      5s   437ms      4s</span><br><span class="line"># Lock time     69   386ms    24us   371ms     1ms    93us    21ms    44us</span><br><span class="line"># Rows sent      0       0       0       0       0       0       0       0</span><br><span class="line"># Rows examine  18 180.00M 651.14k 651.45k 651.29k 650.62k       0 650.62k</span><br><span class="line"># Query size    10  27.64k     100     100     100     100       0     100</span><br><span class="line"># String:</span><br><span class="line">数据库名</span><br><span class="line"># Databases    taxen_ziweidashi</span><br><span class="line">执行主机</span><br><span class="line"># Hosts        118.190.93.166</span><br><span class="line">执行用户</span><br><span class="line"># Users        devAccount</span><br><span class="line">查询时间占比</span><br><span class="line"># Query_time distribution</span><br><span class="line">#   1us</span><br><span class="line">#  10us</span><br><span class="line"># 100us</span><br><span class="line">#   1ms</span><br><span class="line">#  10ms</span><br><span class="line"># 100ms</span><br><span class="line">#    1s  ################################################################</span><br><span class="line">#  10s+</span><br><span class="line"># Tables</span><br><span class="line">#    SHOW TABLE STATUS FROM `taxen_ziweidashi` LIKE &#x27;ziweidashi_deviceinfo&#x27;</span><br><span class="line">#    SHOW CREATE TABLE `taxen_ziweidashi`.`ziweidashi_deviceinfo`</span><br><span class="line">UPDATE ziweidashi_deviceinfo</span><br><span class="line">         SET expired = 1 </span><br><span class="line">        WHERE createTime   &lt;=   1583942580685\G</span><br><span class="line"># Converted for EXPLAIN</span><br><span class="line"># EXPLAIN /*!50100 PARTITIONS*/</span><br><span class="line">select  expired = 1 from ziweidashi_deviceinfo where  createTime   &lt;=   1583942580685\G</span><br><span class="line"></span><br><span class="line"># Query 2: 0.03 QPS, 0.07x concurrency, ID 0x6914B81AAD1785E50708ABD11319E02E at byte 13829</span><br><span class="line"># Scores: V/M = 0.09</span><br><span class="line"># Time range: 2020-03-11 12:22:13 to 16:05:47</span><br><span class="line"># Attribute    pct   total     min     max     avg     95%  stddev  median</span><br><span class="line"># ============ === ======= ======= ======= ======= ======= ======= =======</span><br><span class="line"># Count         37     339</span><br><span class="line"># Exec time     29    878s      2s      4s      3s      4s   472ms      2s</span><br><span class="line"># Lock time      5    29ms    31us     4ms    86us    98us   229us    66us</span><br><span class="line"># Rows sent      0      24       0       2    0.07       0    0.32       0</span><br><span class="line"># Rows examine  67 665.20M   1.96M   1.96M   1.96M   1.96M       0   1.96M</span><br><span class="line"># Query size    59 154.47k     462     467  466.60  463.90    2.07  463.90</span><br><span class="line"># String:</span><br><span class="line"># Hosts        10.66.186.115</span><br><span class="line"># Users        root</span><br><span class="line"># Query_time distribution</span><br><span class="line">#   1us</span><br><span class="line">#  10us</span><br><span class="line"># 100us</span><br><span class="line">#   1ms</span><br><span class="line">#  10ms</span><br><span class="line"># 100ms</span><br><span class="line">#    1s  ################################################################</span><br><span class="line">#  10s+</span><br><span class="line"># Tables</span><br><span class="line">#    SHOW TABLE STATUS LIKE &#x27;birthDay_notify&#x27;</span><br><span class="line">#    SHOW CREATE TABLE `birthDay_notify`</span><br><span class="line"># EXPLAIN /*!50100 PARTITIONS*/</span><br><span class="line">select birthdayno0_.id as id1_1_, birthdayno0_.index_card_show_date as index_ca2_1_, birthdayno0_.userId as userId3_1_, birthdayno0_.push_content as push_con4_1_, birthdayno0_.card_content as card_con5_1_, birthdayno0_.birthday_userId as birthday6_1_, birthdayno0_.birthday_contactId as birthday7_1_, birthdayno0_.need_push as need_pus8_1_ from birthDay_notify birthdayno0_ where birthdayno0_.userId=1304747 and birthdayno0_.index_card_show_date=&#x27;2020-03-11 00:00:00&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>分析最近12小时内的查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pt-query-digest  --since=12h  slow.log &gt; slow_report_last12.log</span><br></pre></td></tr></table></figure></li>
<li><p>分析制定时间范围内的查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pt-query-digest slow.log --since &#x27;2017-02-07 09:30:00&#x27; --until &#x27;2017-02-07 10:00:00&#x27;&gt; &gt; slow_report_time.log</span><br></pre></td></tr></table></figure></li>
<li><p>分析bin log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sql</span><br><span class="line">pt-query-digest --type=binlog mysql-bin000093.sql &gt; slow_report_bin.log</span><br></pre></td></tr></table></figure></li>
<li><p>分析general log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pt-query-digest --type=genlog localhost.log &gt; slow_report_general.log</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2profile性能监控"><a href="#1-2profile性能监控" class="headerlink" title="1.2profile性能监控"></a>1.2profile性能监控</h3><p>MySQL5.6中已过时，使用performance_schema代替。<a href="https://dev.mysql.com/doc/refman/5.6/en/show-profile.html">13.7.5.31 SHOW PROFILE Statement</a></p>
<h3 id="1-3performance-schema性能监控"><a href="#1-3performance-schema性能监控" class="headerlink" title="1.3performance_schema性能监控"></a>1.3performance_schema性能监控</h3><p>参考：MySql8.0<a href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-query-profiling.html">27.19.1 Query Profiling Using Performance Schema</a></p>
<p>SQL在各阶段的耗时分析，默认开启</p>
<h4 id="查看是否开启"><a href="#查看是否开启" class="headerlink" title="查看是否开启"></a>查看是否开启</h4><p>SHOW VARIABLES LIKE ‘performance_schema’;</p>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">performance_schema=ON</span><br></pre></td></tr></table></figure>

<h4 id="修改performance-schema监控配置，并分析一个测试SQL"><a href="#修改performance-schema监控配置，并分析一个测试SQL" class="headerlink" title="修改performance_schema监控配置，并分析一个测试SQL"></a>修改performance_schema监控配置，并分析一个测试SQL</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看performance_schema是否开启</span><br><span class="line">SHOW VARIABLES LIKE &#x27;performance_schema&#x27;;</span><br><span class="line"></span><br><span class="line"># setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能</span><br><span class="line">select * from `performance_schema`.setup_actors;</span><br><span class="line"></span><br><span class="line"># 更新setup_actors表中的默认行，以禁用对所有前台线程的历史事件收集和监视，并插入一个新行，为运行查询的用户启用监视和历史事件收集:</span><br><span class="line">UPDATE performance_schema.setup_actors</span><br><span class="line">       SET ENABLED = &#x27;NO&#x27;, HISTORY = &#x27;NO&#x27;</span><br><span class="line">       WHERE HOST = &#x27;%&#x27; AND USER = &#x27;%&#x27;;</span><br><span class="line">			 </span><br><span class="line">INSERT INTO performance_schema.setup_actors</span><br><span class="line">       (HOST,USER,ROLE,ENABLED,HISTORY)</span><br><span class="line">       VALUES(&#x27;localhost&#x27;,&#x27;test_user&#x27;,&#x27;%&#x27;,&#x27;YES&#x27;,&#x27;YES&#x27;);</span><br><span class="line"># 收集者</span><br><span class="line"># ​ instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</span><br><span class="line">select * from performance_schema.setup_instruments;</span><br><span class="line">		</span><br><span class="line"># 开启收集者		</span><br><span class="line">UPDATE performance_schema.setup_instruments</span><br><span class="line">       SET ENABLED = &#x27;YES&#x27;, TIMED = &#x27;YES&#x27;</span><br><span class="line">       WHERE NAME LIKE &#x27;%stage/%&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line"># ​ consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</span><br><span class="line">select * from performance_schema.setup_consumers;</span><br><span class="line"></span><br><span class="line"># 开启消费者</span><br><span class="line">UPDATE PERFORMANCE_SCHEMA.setup_consumers </span><br><span class="line">SET ENABLED = &#x27;YES&#x27; </span><br><span class="line">WHERE</span><br><span class="line">	NAME LIKE &#x27;%events_statements_%&#x27;;</span><br><span class="line">	</span><br><span class="line">UPDATE performance_schema.setup_consumers</span><br><span class="line">SET ENABLED = &#x27;YES&#x27;</span><br><span class="line">WHERE</span><br><span class="line">	NAME LIKE &#x27;%events_stages_%&#x27;;		 </span><br><span class="line"></span><br><span class="line"># 测试SQL语句</span><br><span class="line">select * from dept;</span><br><span class="line"></span><br><span class="line"># 查询测试SQL语句在events_statements_history_long中的id</span><br><span class="line">SELECT EVENT_ID, TRUNCATE(TIMER_WAIT/1000000000000,6) as Duration, SQL_TEXT</span><br><span class="line">       FROM performance_schema.events_statements_history_long WHERE SQL_TEXT like &#x27;%select * from dept%&#x27;;</span><br><span class="line"># 查询测试SQL语句各模块执行耗时		 </span><br><span class="line">SELECT event_name AS Stage, TRUNCATE(TIMER_WAIT/1000000000000,6) AS Duration</span><br><span class="line">       FROM performance_schema.events_stages_history_long WHERE NESTING_EVENT_ID=258;</span><br></pre></td></tr></table></figure>



<h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h2><p>表和字段结构设计，索引，SQL语句，Mysql配置，操作系统配置，硬件，内存预热</p>
<p>开发人员关注表结构设计、索引和SQL语句方面的优化。</p>
<p>DBA学习Mysql配置，操作系统配置，硬件</p>
<h3 id="2-1表和字段结构设计"><a href="#2-1表和字段结构设计" class="headerlink" title="2.1表和字段结构设计"></a>2.1表和字段结构设计</h3><ul>
<li><p>减少关联查询，创建合理的冗余字段</p>
</li>
<li><p>字段太多的大表，拆表</p>
</li>
<li><p>表中不常用的字段或者存储数据比较多的字段，拆表。（商品表中的商品介绍字段单独拆解到另一个表中，使用ID关联）</p>
</li>
<li><p>每张表都要有主键，主键最好是int类型。</p>
</li>
<li><p>字段数据类型优先选用较小的数据结构。</p>
<p>例如：年龄使用TINYINT，而不是INT</p>
</li>
<li><p>日期类型使用int类型，日期排序以及对比等操作的效率会更高</p>
</li>
</ul>
<h3 id="2-2索引"><a href="#2-2索引" class="headerlink" title="2.2索引"></a>2.2索引</h3><p>数量不要超过6个。通过索引返回的数据量需要小于1/3才有效。</p>
<h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><ul>
<li>on两边，where字段</li>
<li>组合索引（最左前缀）</li>
<li>order排序</li>
<li>group by分组统计</li>
</ul>
<h4 id="避免失效"><a href="#避免失效" class="headerlink" title="避免失效"></a>避免失效</h4><ul>
<li>or，is null,is not null</li>
<li>between右边</li>
<li>where 子句中的“=”左边进行函数、算术运算或其他表达式运算</li>
<li>不遵循组合索引最左前缀</li>
<li>字符串不加’’(单引号)</li>
<li>like (%abc)，可通过组合索引解决</li>
</ul>
<h3 id="2-3SQL语句"><a href="#2-3SQL语句" class="headerlink" title="2.3SQL语句"></a>2.3SQL语句</h3><p>SQL分析，SQL注意点</p>
<h4 id="2-3-1SQL分析"><a href="#2-3-1SQL分析" class="headerlink" title="2.3.1SQL分析"></a>2.3.1SQL分析</h4><p>SQL的执行计划explain，使用show profile[s] 查看SQL的性能使用情况</p>
<p>explian 详见Mysql索引</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ol>
<li>asdf<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Count: 36240  Time=1.20s (43521s)  Lock=0.00s (4s)  Rows=1.0 (36240), root[root]@4hosts</span><br><span class="line">select IFNULL(max(zkkq_id), 1) from attendance_card;</span><br><span class="line"># attendance_card本身是有序的，从小到大</span><br><span class="line"># 优化 速度：1.2→0.1</span><br><span class="line">select ifnull( zkkq_id,1) from attendance_card order by id desc limit 1;</span><br><span class="line"></span><br><span class="line"># 判断表是否为空</span><br><span class="line"># 100万 0.6s</span><br><span class="line">select count(*) from table</span><br><span class="line"># 100万 0.01s</span><br><span class="line">select 1 from logmgr_log_history limit 1</span><br></pre></td></tr></table></figure></li>
<li>索引失效。or、order by id limit<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE (branch_code = ? OR branch_name LIKE concat(?, ?, ?)) AND create_time &gt;= ? AND create_time &lt;= ? ORDER BY id DESC LIMIT ?</span><br></pre></td></tr></table></figure>
or 导致branch_code失效。<br>order by id desc limit 20 使create_time失效，而使用了id</li>
</ol>
<h4 id="2-3-2SQL优化"><a href="#2-3-2SQL优化" class="headerlink" title="2.3.2SQL优化"></a>2.3.2SQL优化</h4><ol>
<li><p>避免select *</p>
</li>
<li><p>日期条件字段使用bigint，存储时间戳</p>
</li>
<li><p>left join on 后不加and, where 后加and</p>
</li>
<li><p>表索引多，没有走正确的索引时，user index(index_user_id) ,强制走索引</p>
</li>
<li><p>左连接注意SQL执行顺序，mysql会做优化，小表驱动大表，也可自己优化</p>
</li>
<li><p>limit</p>
<p>有截断效果（停止全表扫描），但还是在server层处理数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 一千万条数据</span><br><span class="line"># 速度很慢 10</span><br><span class="line">select * from user limit 9000000 for 10</span><br><span class="line"># 速度很快 0.03</span><br><span class="line">select * from user where id &gt; 9000000 limit 10</span><br></pre></td></tr></table></figure></li>
<li><p>count<br>count（*）找普通索引，即去最小的索引树遍历，包含null</p>
<p>count（字段） ，走缓存，不包含null</p>
<p>count（1） 包含null</p>
</li>
<li><p>exists<br>  尽量使用NOT EXISTS替代NOT IN，使用EXISTS替代DISTINCT。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> r.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> task r</span><br><span class="line">         <span class="keyword">LEFT</span> JOINtask_sku_box box <span class="keyword">ON</span> r.rece_id <span class="operator">=</span> box.rece_id</span><br><span class="line"><span class="keyword">WHERE</span> box.sku_code <span class="operator">=</span> <span class="string">&#x27;1111&#x27;</span>;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">SELECT</span> r.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> task r</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">        <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> task_sku_box box <span class="keyword">where</span> r.rece_id <span class="operator">=</span> box.rece_id <span class="keyword">and</span> sku_code <span class="operator">=</span> <span class="string">&#x27;1111&#x27;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

</li>
<li><p>sql索引字段上尽量不要使用函数，在Java中计算好，直接传入。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> now() <span class="number">-1</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间前三个月</span></span><br><span class="line">LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

</li>
<li></li>
</ol>
<h3 id="2-4Mysql配置"><a href="#2-4Mysql配置" class="headerlink" title="2.4Mysql配置"></a>2.4Mysql配置</h3><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>默认128M，修改为系统内存的4/5，尽量从内存中读取。</p>
<p>buffer pool越大和存储引擎I/O次数越少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_buffer_pool_pages_%&#x27;; </span><br><span class="line">| Innodb_buffer_pool_pages_free | 0 | 0 表示已经被用光</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改配置 my.cnf</span><br><span class="line">innodb_buffffer_pool_size =3000M</span><br></pre></td></tr></table></figure>

<h4 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h4><p>默认8M,修改为Buffer的1/4.降低磁盘写入次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_log_file_size = 750M</span><br></pre></td></tr></table></figure>

<h3 id="2-5操作系统设置"><a href="#2-5操作系统设置" class="headerlink" title="2.5操作系统设置"></a>2.5操作系统设置</h3><h3 id="2-6硬件"><a href="#2-6硬件" class="headerlink" title="2.6硬件"></a>2.6硬件</h3><p>固态硬盘</p>
<h3 id="2-7内存预热"><a href="#2-7内存预热" class="headerlink" title="2.7内存预热"></a>2.7内存预热</h3><h2 id="mysql监控工具"><a href="#mysql监控工具" class="headerlink" title="mysql监控工具"></a>mysql监控工具</h2><p>收费：阿里云</p>
<p>免费：druid连接池</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能分析</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>动态列的实现</title>
    <url>/2020/06/03/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/table%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>动态列的实现</p>
<span id="more"></span>

<h1 id="table中动态列的实现"><a href="#table中动态列的实现" class="headerlink" title="table中动态列的实现"></a>table中动态列的实现</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/DPk5ohdXMtRFQp3.png" alt="image-20210104183203013"></p>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ol>
<li>mysql行存储，取出时多行转1行。</li>
<li>MongoDB</li>
<li>存为json</li>
<li>动态修改表字段</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="mysql行存储"><a href="#mysql行存储" class="headerlink" title="mysql行存储"></a>mysql行存储</h3><p>优点：统一数据库，InnoDB有事务支持</p>
<p>缺点：增删改都是批量操作，复杂。</p>
<h3 id="后端逻辑"><a href="#后端逻辑" class="headerlink" title="后端逻辑"></a>后端逻辑</h3><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新增</span><br><span class="line">List&lt;HrSalaryStandardConfigurationAddVO&gt; listAdd = new ArrayList&lt;HrSalaryStandardConfigurationAddVO&gt;();</span><br><span class="line">// 修改</span><br><span class="line">List&lt;HrSalaryStandardConfigurationUpdateVO&gt; listUpdate = new ArrayList&lt;HrSalaryStandardConfigurationUpdateVO&gt;();</span><br><span class="line">// 删除</span><br><span class="line">List&lt;String&gt; listLogialDelete = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 确定 money = null值是否传了薪档id</span><br><span class="line">// 修改前查询库中的薪资标准配置</span><br><span class="line">List&lt;String&gt; previousList =  hrSalaryStandardConfigurationMapper.getByDeptAndPost(data.get(0).getDeptId(), data.get(0).getPostId());</span><br><span class="line">// 库中与页面对比出 1.新增集合  2.修改集合  3.删除集合</span><br><span class="line"></span><br><span class="line">// 执行新增、修改、删除</span><br></pre></td></tr></table></figure>

<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>单文档事务支持</p>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>优点：存储方便</p>
<p>缺点：无法用sql进行条件查询</p>
<h3 id="动态修改表字段"><a href="#动态修改表字段" class="headerlink" title="动态修改表字段"></a>动态修改表字段</h3><p>缺点：不安全</p>
]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>动态列</tag>
      </tags>
  </entry>
  <entry>
    <title>批量操作</title>
    <url>/2021/01/11/%E6%8A%80%E6%9C%AF%E5%8A%9F%E8%83%BD/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>批量操作</p>
<span id="more"></span>

<h1 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h1><p>批量保存数据</p>
<p>页面的10条数据是一个<code>List&lt;SalaryLevelConf&gt; newList</code>;</p>
<p>数据库的数据是一个<code>List&lt;SalaryLevelConf&gt; oldList</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   	&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;SalaryLevelConf&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 页面</span></span><br><span class="line">List&lt;SalaryLevelConf&gt; oldList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// 数据库</span></span><br><span class="line"><span class="comment">// 交集-更新</span></span><br><span class="line">List&lt;SalaryLevelConf&gt; intersectionUpdate = CollectionUtils.intersection(newList,oldList).stream().collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 新-旧 差集-新增</span></span><br><span class="line">List&lt;SalaryLevelConf&gt; subtractAdd = CollectionUtils.subtract(newList,oldList).stream().collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 旧-新 差集-删除</span></span><br><span class="line">List&lt;SalaryLevelConf&gt; subtractDelete = CollectionUtils.subtract(oldList,newList).stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>集合中的id字段求交集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;SalaryLevelConf&gt; newList = new ArrayList&lt;&gt;();// 页面数据</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    SalaryLevelConf salaryLevelConf = new SalaryLevelConf();</span><br><span class="line">    salaryLevelConf.setId(String.valueOf(i));</span><br><span class="line">    newList.add(salaryLevelConf);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;SalaryLevelConf&gt; oldList = new ArrayList&lt;&gt;();// 数据库数据</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    SalaryLevelConf salaryLevelConf = new SalaryLevelConf();</span><br><span class="line">    salaryLevelConf.setId(String.valueOf(i+2));</span><br><span class="line">    oldList.add(salaryLevelConf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 老ID集合</span><br><span class="line">List&lt;String&gt; oldIdList = oldList.stream().map(SalaryLevelConf::getId).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">// 交集-更新</span><br><span class="line">List&lt;SalaryLevelConf&gt; intersectionUpdate = newList.stream().filter(</span><br><span class="line">        salaryLevelConf -&gt; oldIdList.contains(salaryLevelConf.getId())</span><br><span class="line">).collect(Collectors.toList());</span><br><span class="line">System.out.println(intersectionUpdate);</span><br><span class="line">// 新-旧 差集-新增</span><br><span class="line">List&lt;SalaryLevelConf&gt; subtractAdd = newList.stream().filter(</span><br><span class="line">        salaryLevelConf -&gt; !oldIdList.contains(salaryLevelConf.getId())</span><br><span class="line">).collect(Collectors.toList());</span><br><span class="line">System.out.println(subtractAdd);</span><br><span class="line">// 旧-新 差集-删除</span><br><span class="line">List&lt;String&gt; newIdList = newList.stream().map(SalaryLevelConf::getId).collect(Collectors.toList());</span><br><span class="line">List&lt;SalaryLevelConf&gt; subtractDelete = oldList.stream().filter(</span><br><span class="line">        salaryLevelConf -&gt; !newIdList.contains(salaryLevelConf.getId())</span><br><span class="line">).collect(Collectors.toList());</span><br><span class="line">System.out.println(subtractDelete);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class SalaryLevelConf &#123;</span><br><span class="line">    private String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术功能</category>
      </categories>
      <tags>
        <tag>批量&#39;</tag>
      </tags>
  </entry>
  <entry>
    <title>认知觉醒-笔记</title>
    <url>/2022/06/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5%E8%A7%89%E9%86%92-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>认知觉醒-笔记</p>
<span id="more"></span>

<h1 id="认知觉醒-读书笔记"><a href="#认知觉醒-读书笔记" class="headerlink" title="认知觉醒-读书笔记"></a>认知觉醒-读书笔记</h1><h2 id="其他书"><a href="#其他书" class="headerlink" title="其他书"></a>其他书</h2><h2 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h2><p>作者个人公众号：清脑，时间2018.5</p>
<h2 id="本书"><a href="#本书" class="headerlink" title="本书"></a>本书</h2><p>关于成长的原理、方法论，作者的实践。</p>
<p>将原理、方法论、实践之间建立了联系。<br>对原理的讲述不够准确。</p>
<h2 id="书内容安排"><a href="#书内容安排" class="headerlink" title="书内容安排"></a>书内容安排</h2><p>上篇<br>    一、二、三章，大脑、潜意识、元认知。<br>下篇<br>    四五六七，能力。专注能力、学习能力、行动能力、情绪能力<br>    八，早起、冥想、阅读、写作、跑步</p>
<h2 id="阅读建议"><a href="#阅读建议" class="headerlink" title="阅读建议"></a>阅读建议</h2><ol>
<li>对 书中 的 某个 主题 感兴趣， 拿到 书 后 便 直接 跳到 相关 章节。</li>
<li>若是 时间 充裕， 最 好还 是 从头开始 阅读， 因为 一些 基础 概念 会 像 插 塑 积木 一样 慢慢 呈现 具体 形态， 前文 的 一些 背景 信息 可能 会对 理解 后文 产生 影响。</li>
<li>时常 回顾本书，然后 思考 和 实践，</li>
</ol>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="自序-记录"><a href="#自序-记录" class="headerlink" title="自序-记录"></a>自序-记录</h3><p>人的智商、财富可以通过基因、基金传递给下一代。</p>
<p>心智：看待人的和事物的态度，以及做出的行为（包括判断和选择）。<br>人生下来，人生观、世界观、价值观从零开始。<br>人的习性、习惯、模式从人性的初始状态开始发展。<br>人的天性是追求简单、轻松、舒适、确定。<br>大部分人对心智了解很少。</p>
<p>作者认为人与人的根本差异是认知能力。<br>作者学习脑科学、认知科学、心理学、行为科学、社会学等学科，看到了自己成长的可能性。<br>方法论：包含大脑构造、潜意识、元认知、刻意练习等基本概念；包含自控力、专注力、行动力、学习力、情绪力等能力使用；包括早起、冥想、阅读、写作、运动等必备习惯养成。</p>
<p>真正 的 觉醒 是一 种 发自内心 的 渴望， 立足 长远， 保持 耐心， 运用 认知 的 力量 与 时间 做 朋友；？？？</p>
<p>如何 激发 和 保持 自我 提升 的 内在 动力， 如何 变苦 涩的 毅力 支撑 为 科学 的 认知 驱动。？？？</p>
<h3 id="自序-总结"><a href="#自序-总结" class="headerlink" title="自序-总结"></a>自序-总结</h3><p>外围命题逻辑性很差。<br>举例：<br>    想努力，却总是陷入低效的状态。<br>    因为 认知 影响 选择， 而 选择 改变 命运， 所以 成长 的 本质 就是 让 大脑 的 认知 变得 更加 清晰；</p>
<h3 id="第一章-大脑-一切问题的根源-记录"><a href="#第一章-大脑-一切问题的根源-记录" class="headerlink" title="第一章 大脑-一切问题的根源-记录"></a>第一章 大脑-一切问题的根源-记录</h3><h4 id="大脑"><a href="#大脑" class="headerlink" title="大脑"></a>大脑</h4><p>大脑的组成、各个部分作用、弊端，大脑与成长的联系</p>
<h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><p>本能脑：3.6亿年，爬行动物控制是否战斗、是否躲避；捕食；追求异性<br>情绪脑：2亿年，哺乳动物。恐惧，兴奋情绪让自己专注捕猎？愉悦增加同伴亲密度；伤心引来同情者关爱。<br>理智脑:250万年。大脑前额的新皮层。7万-20万年前成形。语言、艺术、富有远见、善于权衡，立足未来获得延时满足。</p>
<p>为什么理智脑的力量弱：</p>
<ol>
<li>出现的晚，进化时间短。本能脑出现了3.6亿年；情绪脑出现了2亿年；理智脑出现了250万年。</li>
<li>生长过程中发育成熟迟。</li>
<li>大脑中所占比例少。</li>
<li>运行速度慢。</li>
<li>耗能高</li>
</ol>
<h5 id="作用、决策弊端"><a href="#作用、决策弊端" class="headerlink" title="作用、决策弊端"></a>作用、决策弊端</h5><p>生活中的大部分决策是本能脑和情绪脑做出的。</p>
<p>本能脑、情绪脑的作用：生存至上，及时满足，远古社会中不被吃掉、饿死。<br>    举例：<br>        喜欢吃高糖食物<br>        排斥耗能高，如：剧烈运动、思考<br>        不动脑的娱乐消遣行为<br>本能脑、情绪脑的弊端：带来了一些成长的问题。<br>本能脑、情绪脑弊端总结：避难趋易、急于求成。<br>    避难趋易：只做简单和舒适的事，喜欢在核心区域周边打转，呆在舒适区，逃避困难。<br>    急于求成：凡事希望立刻看到结果、效果，对不能看到结果的事没有耐心，非常容易放弃。<br>本能脑、情绪脑与做不成事的联系：天性压倒了愿望和意志力。<br>理智脑明明知道，本能脑、情绪脑让我们做不到；理智脑特别想要，本能脑、情绪脑让我们得不到。</p>
<h5 id="大脑与成长的联系"><a href="#大脑与成长的联系" class="headerlink" title="大脑与成长的联系"></a>大脑与成长的联系</h5><p>成长需要克服本能脑和情绪脑缺点。成长需要强大理智脑。成长需要巧妙利用情绪的行动力、本能的计算能力。<br>理智脑如何变强：<br>    1. 知道理智脑需要变强，可以变强<br>    2. 遵守用进废退的原则<br>    3. 遵循科学的方法练习<br>习惯为什么难以改变：越用越强，越强越用。</p>
<h4 id="焦虑的根源"><a href="#焦虑的根源" class="headerlink" title="焦虑的根源"></a>焦虑的根源</h4><p>根源：<br>    想做事，并且想立刻看到效果。<br>    想少付出立即看到效果。<br>    欲望大于当前能力，并且没有耐心。</p>
<p>人类的安全感来源：自己在某一方面的独特优势。如：能力、财富、权力、影响力。<br>焦虑和我们大脑的生理结构有关。<br>焦虑的形式：</p>
<ol>
<li>事多完不成</li>
<li>定位高</li>
<li>面对不确定性（选择太多）</li>
<li>环境</li>
<li>事难<h4 id="耐心"><a href="#耐心" class="headerlink" title="耐心"></a>耐心</h4>婴儿→孩子→成人，耐心在增长。<br>认识事物发展的基本规律，可以提升耐心。</li>
</ol>
<p>规律：价值积累规律、舒适区边缘、成长权重对比、学习平台期。<br>价值积累规律：复利曲线，前期增长缓慢，拐点后飞速增长。<br>舒适区边缘规律：能力形式，舒适区→拉伸区→困难区<br>    高速成长需要在舒适区边缘，拉伸区内，不进入困难区。<br>    拉伸区既有挑战，又有成就。困难区容易因畏惧而逃避。<br>    <img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/YaSwZymMx8cdECe.png" alt="舒适区边缘"><br>成长权重对比。改变量（思维改变)、行动量、思考量、学习量。</p>
<p>改变量虽小，但效用最大，权重最高。</p>
<p>学习量虽大，权重最小。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/3WMRamlJ7FyUzrL.png" alt="成长权重"></p>
<p>学习平台期：学习进展和学习时间的关系是波浪式上升曲线，而不是线性上升。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/OJo2W5rdtG1uhER.png" alt="学习平台期"></p>
<p>耐心的构成：</p>
<ul>
<li><p>长远目光，知道的越多，越知道自己所处的位置、阶段，越能预测结果。</p>
</li>
<li><p>不放弃</p>
</li>
<li><p>是否了解做的事的意义和益处</p>
</li>
</ul>
<p>如何不被诱惑：</p>
<ul>
<li>思想上<ul>
<li>抵制娱乐。相信娱乐是短暂的，负面的？</li>
</ul>
</li>
<li>方法上<ul>
<li>将诱惑分层次。类别：看新闻，看短视频，玩游戏。时间：5分钟，30分钟，2小时。</li>
<li>先做事，后娱乐。</li>
</ul>
</li>
</ul>
<p>对我来说，很重的是娱乐消耗的精力小，学习消耗的精力大，身体支撑不了一直学习。</p>
<p>用本能脑和情绪脑解决困难。第五章第六节</p>
<h3 id="第一章-大脑-一切问题的根源-总结"><a href="#第一章-大脑-一切问题的根源-总结" class="headerlink" title="第一章 大脑-一切问题的根源-总结"></a>第一章 大脑-一切问题的根源-总结</h3><p>作者认为理智脑比本能脑、情绪脑高级，但只是某一方面比其他两个脑强。<br>是否在制造本能脑、情绪脑假想敌，并且提高理智脑重要性，来驱动人理智思考。</p>
<p>坏习惯改变：最好的方法不是用意志力；而是改变思维，提升好习惯重要性，制造假想敌。</p>
<h3 id="第二章-潜意识-总结"><a href="#第二章-潜意识-总结" class="headerlink" title="第二章 潜意识-总结"></a>第二章 潜意识-总结</h3><p>潜意识与人工智能对比</p>
<h4 id="潜意识与成长"><a href="#潜意识与成长" class="headerlink" title="潜意识与成长"></a>潜意识与成长</h4><p>成长需要消除潜意识中的模糊</p>
<h4 id="潜意识与模糊"><a href="#潜意识与模糊" class="headerlink" title="潜意识与模糊"></a>潜意识与模糊</h4><p>模糊种类：</p>
<ul>
<li>认知模糊</li>
<li>情绪模糊</li>
<li>行动模糊<br>  认知模糊：<br>  介绍：<br>  如何消除：学习知识<br>  情绪模糊：<br>  介绍：<br>  举例：心理师的工作就是在消除情绪对人的负面影响。童年 的 不幸 经历， 虽然 意识 早已 将其 淡忘， 但 潜意识 可能保留 着 这些 印记， 并 隐蔽 地 影响 着 我们 的 性格 和 行为。<br>  如何消除：<pre><code>  对于童年的隐藏，挖出来，面对它，看清它，拆解它，化解它。
  对于当下，心中有说不清道不明的感觉时，面对它，不让它进入潜意识。
</code></pre>
  消除时遇到的问题：<pre><code>  短时间可能加剧痛苦。
</code></pre>
  行动模糊：<br>  介绍：认知+情绪模糊。不确定结果（认知），不愿接受差结果（情绪）<br>  如何消除：<pre><code>  花费很多的脑力清晰目标，将目标细化，层级化。建立单行道。
</code></pre>
<h4 id="潜意识与感觉"><a href="#潜意识与感觉" class="headerlink" title="潜意识与感觉"></a>潜意识与感觉</h4><h4 id="感觉与学习"><a href="#感觉与学习" class="headerlink" title="感觉与学习"></a>感觉与学习</h4>用理性对要学的内容的难度分级。<br>用感觉分析哪个层级的内容的困难度对自己来说是拉伸区。</li>
</ul>
<h4 id="感觉与人生目标"><a href="#感觉与人生目标" class="headerlink" title="感觉与人生目标"></a>感觉与人生目标</h4><p>用感觉分析自己的需求，用理性分析外界需求对应的事物。两者不断结合。</p>
<h3 id="第三章-元认知-总结"><a href="#第三章-元认知-总结" class="headerlink" title="第三章 元认知-总结"></a>第三章 元认知-总结</h3><p>介绍：<br>    元认知是对自己认知的认知。<br>举例：学习认知觉醒是在认知。元认知是指对学习认知觉醒的过程的认知，对这个学习过程的监控、调节。监控学习进度，学习结果，学习时间。调节什么时候增加学习时间等。<br>    理性脑中的自我觉察、自我控制。即观察、反思、判断、选择能力。<br>    普通认知是理性脑中的学习、理解、记忆、运算等能力。<br>元认知<br>元认知意向性分类：</p>
<p>元认知主动性分类：<br>    主动元认知。如：走神时，提醒自己集中注意力；生气时，梳理情绪；<br>    被动元认知。被批评、指责时反思。处于顺境，依靠本性生活。<br>元认知和认知的区别：</p>
<ul>
<li>思考的对象不同。<ul>
<li>认知的对象是具体的。</li>
<li>元认知的对象是抽象的，变化的。</li>
</ul>
</li>
<li>内容不同。<ul>
<li>认知是掌握一个具体的知识。</li>
<li>元认知是控制监控和调节掌握具体知识的过程。</li>
</ul>
</li>
<li>作用方式<ul>
<li>认知使我们取得认知活动的进展。</li>
<li>元认知通过直接影响认知活动，间接的影响我们取得认知活动进展。</li>
</ul>
</li>
<li>发展速度<br>我们的年龄上，元认知远落后认知。<ul>
<li>婴儿出生后便有认知能力。</li>
<li>学前期，才获得一点元认知能力。<br>学校中提升的是我们的普通认知能力，我们还需要主动提升元认知能力。</li>
</ul>
</li>
</ul>
<p>元认知需要锻炼，元认知和肌肉一样，用进废退。每一次克制，都是一次锻炼。<br>锻炼元认知的方法：<br>    1. 冥想。<br>    2. 练习。监控、调节学习内容。</p>
<h5 id="自我觉察"><a href="#自我觉察" class="headerlink" title="自我觉察"></a>自我觉察</h5><h5 id="自我控制"><a href="#自我控制" class="headerlink" title="自我控制"></a>自我控制</h5><p>明确需要做的事。控制当下的时间、全天的形成、长远的目标中的关键节点。<br>    当下：有明确的主张。<br>    全天：一天中起床时、拿起手机前、睡觉前。一天做的事种类、数量、做事结果。<br>    长远目标：想清楚意义、动机，时间，结果。</p>
<p>消除模糊可以提升控制。<br>元认知策略：计划、监控、调节。</p>
<h3 id="第四章-专注力-情绪与理智的交集-总结"><a href="#第四章-专注力-情绪与理智的交集-总结" class="headerlink" title="第四章 专注力-情绪与理智的交集-总结"></a>第四章 专注力-情绪与理智的交集-总结</h3><p>专注：行动与脑子中想的一致。</p>
<p>专注的表现：</p>
<ul>
<li>主动选择信息。选择重要的事去做；</li>
<li>深度沉浸。做重要的事，不被次要的事打扰。<br>  专注例子：<br>  动物，狮子吃饱后，沐浴阳光，就只在关注阳光。<br>  人：<pre><code>  不专注的例子：工作中因为手机的消息，从思考中脱离去玩手机。
  专注的例子：专心工作，不被旁边的说话打扰。
</code></pre>
  如何专注：<ol>
<li>目标明确<br> 要达到的结果明确。如：理解这个知识点，记住这个知识点，可表达出这个知识点。<br> 次一级时间上的明确。如：学这个知识点半小时。<br> 目标过大时，细分目标。</li>
<li>感受当下，享受当下；不要分心。</li>
<li>有效的反馈。<br> 向他人讲授得到反馈，老师指导，反思</li>
<li>拉伸区练习。<br> 每天都要做那些让自己感到有些困难但又可以通过努力来完成的事情。<ul>
<li>容易的事，不需要调动很多心神，多余的心神容易引导自己走神。</li>
<li>困难的事，解决不了，容易逃避。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>灵感：做事时极度专注，在用意识思考问题，主动在特定区域寻找答案。休息时，完全不想，潜意识可能在别的区域找到了答案。</p>
<p>边界不清的习惯会降低专注能力。<br>边界不清的习惯举例：如果 在做 A 的 时候 想着 B， 在做 B 的 时候 又 想着 A， 那么 意识 工作 的 深度 不够，潜意识也无法顺利开启。</p>
<h3 id="第五章-学习力-记录"><a href="#第五章-学习力-记录" class="headerlink" title="第五章-学习力-记录"></a>第五章-学习力-记录</h3><p>找到适合自己的方法，适合自己的计划。<br>如何找到适合自己的目标与计划：<br>    先找到一个标准化的目标和计划。<br>    执行。<br>    执行过程中结合自己的实际情况，不断调整。<br>例如：读书，通过名人获取到了书单。自己读着觉得晦涩难懂，那就再去找入门的、有趣的读。<br>错误的例子：<br>    给 自己 设定 一个 很高 的 标准， 还会 经常 给 自己“ 打 鸡血”。</p>
<p>没有约束的生活，做 选择 是一 件 极为 耗能 的 事情， 如果 没有 与之 匹配 的 清醒 和 定力， 绝大多数 人 最终 都会 被 强大 的 天性 支配， 去 选择 娱乐 消遣。</p>
<p>学习金字塔：<br>    不同学习方法留存率<br>        被动学习：听 5% 阅读 10% 视听 20% 演示30%<br>        主动学习：讨论 50% 实践 75% 教授 90%<br>    我感觉不同方法所需时间和精力是不同的，不知道花费时间比例如何。</p>
<p><img src="https://xiaoruiit.oss-cn-beijing.aliyuncs.com/img/ok4a6EyPA51TvmH.png" alt="学习方式留存知识金字塔"></p>
<h3 id="个人成长-总结"><a href="#个人成长-总结" class="headerlink" title="个人成长-总结"></a>个人成长-总结</h3><ol>
<li>明确目标</li>
<li>克服本能脑、情绪脑急于求成、趋难避易，通过及时正向反馈利用本能脑、情绪脑强大之处</li>
<li>强大理智脑</li>
<li>消除潜意识中的各类模糊</li>
<li>提升元认知能力</li>
<li>强壮身体</li>
<li>通过冥想、行动和思想一致提升专注力</li>
<li>学习<ol>
<li>深度学习</li>
<li>符合成长权重</li>
<li>舒适区边缘和体系学习平衡</li>
<li>番茄钟</li>
<li>结合效率峰值</li>
<li>费曼技巧</li>
</ol>
</li>
<li>认清阻碍<ol>
<li>适应期</li>
<li>平台期</li>
<li>平台期<h2 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h2>用词准确性、逻辑性比较差。例子不恰当。<br>集结了很多成长底层规律（知识）。<br>底层规律（知识）、方法论、实践串到了一块，讲了规律、方法论、时间的一些联系。<br>适合了解成长规律（知识）、成长计划、成长实践入门。</li>
</ol>
</li>
</ol>
<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><p>无用知识：<br>    通用知识、深度知识</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>认知</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的逻辑学-读书笔记</title>
    <url>/2022/06/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%A6-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《渴望生活》即梵高传，描写了温森特·梵高青年到37岁时的生活。</p>
<span id="more"></span>

<h1 id="简单的逻辑学-读书笔记"><a href="#简单的逻辑学-读书笔记" class="headerlink" title="简单的逻辑学-读书笔记"></a>简单的逻辑学-读书笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>聪明伶俐只是逻辑思考的潜能高。</p>
<h2 id="本书"><a href="#本书" class="headerlink" title="本书"></a>本书</h2><p>逻辑学的基本原理和技巧。<br>第一次 遇到 严肃 的 逻辑 学问 题的 读者， 可能 会对 大量 的 专业 术语 和 频繁 使用 的 象征性 符号 反感。 我们没 必要 被 这种 第一 印象 吓倒。<br>为了 更好 地 服务于 日常 实践， 在 叙述 中， 有些 地方 我 采取 了 不是 那么 委婉 的 方式。 很多 时候， 我 更 像 一个 教练 或是 班主任， 用 教导 的 口吻 告诉 我的 读者 应该 怎么 做。</p>
<h2 id="书内容安排"><a href="#书内容安排" class="headerlink" title="书内容安排"></a>书内容安排</h2><ol>
<li>作为逻辑思考者搭建思想框架。</li>
<li>逻辑思维的基本原理</li>
<li>逻辑思维的具体表现形式</li>
<li>非逻辑思维的根源。</li>
<li>谬误（miu4wu4），非逻辑的表现形式</li>
</ol>
<h2 id="阅读建议"><a href="#阅读建议" class="headerlink" title="阅读建议"></a>阅读建议</h2><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="1-学习逻辑学的思想准备"><a href="#1-学习逻辑学的思想准备" class="headerlink" title="1.学习逻辑学的思想准备"></a>1.学习逻辑学的思想准备</h3><h4 id="1-全神贯注"><a href="#1-全神贯注" class="headerlink" title="1.全神贯注"></a>1.全神贯注</h4><p>许多错误的产生源自我们注意力不集中。<br>从严格意义上来讲，世界上没有两片相同的叶子。每个情景都有它的特殊性。<br>我们需要注意力帮助我们对所处的环境以及环境中的每个要素都作出敏捷主动的反应。<br>全神贯注和被动接受是不兼容的，对周边的事物要用心去看，用心去听。</p>
<h4 id="2-确认事实"><a href="#2-确认事实" class="headerlink" title="2.确认事实"></a>2.确认事实</h4><p>事实的客观表现形式是事物和事件。<br>有形的事物是客观存在，无形的事件基本构成是事物。<br>确认事件的真实性。</p>
<ul>
<li>最直接有效确认事物的方法是亲自实地去看。也可以从值得信赖的人口中证实，或者照片作为证据。</li>
<li>过去的事件，如林肯被杀，无法直接去看，那就得间接通过官方记录（警察案件记录）/当时的报纸/照片/国会档案等证实。<br>主观事实是指带有人的想法的事件。个人亲身经历或间接通过别人的经历确认的事实。<br>由于人脑中的自我错觉或理性化思维机制，人们可能无法确认关于自身的事实。<br>主观事实确认的基础是对其他当事人的完全信任。<h4 id="3-观念与对象"><a href="#3-观念与对象" class="headerlink" title="3.观念与对象"></a>3.观念与对象</h4>观念是我们对客观世界的描摹，被描摹的对象是客观存在的。<br>正确的观念反映其对象的客观秩序。<br>错误的观念是对客观世界的wai q歪曲表达。<br>观念与其对应的对象关系是扭曲脆弱的，那这个观念是错误的。<br>观念是了解外界的工具，观念不是目的，观念是桥梁。<br>我们不仅仅只能把握观念。<br>我们需要通过观念去观察其表现的对象。<h4 id="4-留意观念的本源"><a href="#4-留意观念的本源" class="headerlink" title="4.留意观念的本源"></a>4.留意观念的本源</h4>观念是大脑观察其对象在外部世界的机遇产生的。<br>与事物接触的越多，对其理解越深刻。<br>观念的客观根源是客观世界的对象。<h4 id="5-观念与事实"><a href="#5-观念与事实" class="headerlink" title="5.观念与事实"></a>5.观念与事实</h4></li>
</ul>
<p><strong>人类认知的组成</strong>：</p>
<ol>
<li>客观存在的事物</li>
<li>事物在大脑中的反映</li>
<li>我们为其创造的语言，介之，我们才能与他人交流。<br>先有事物，人根据事物形成观念，最后用语言表达观念。</li>
</ol>
<p><strong>简单观念</strong>：观念与事物之间的联系简单明了。例如：猫。简单观念容易验证，因为所对应的客观事物只有一个。包含的意思明确具体。<br><strong>复杂观念</strong>：指的是哪些与客观事物并非一一对应的观念。例如：民主，我们可以把它联系到客观世界。但民主的内涵有丰富的来源：人物、事件、宪法、立法行动、旧制度、新制度。讨论民主避免陷入主观主义，需要说现实中大家都明白的事物，必须不断涉及现实中的种种事件，这些事件都是民主内涵的现实土壤。</p>
<p><strong>错误观念如何产生：</strong><br>错误观念即对客观事物作出偏离其本源的错误反映。<br>没有任何观念可以完全脱离客观世界。<br>观念和客观世界的联系可以变得遥远而难以捉摸。<br>错误观念偏离了事物的本源，它或许不能提供客观事物的真实情况，但可以反映错误观念人的精神状态。</p>
<h4 id="6-将观念付诸语言（用语言表达观念）"><a href="#6-将观念付诸语言（用语言表达观念）" class="headerlink" title="6.将观念付诸语言（用语言表达观念）"></a>6.将观念付诸语言（用语言表达观念）</h4><p>观念必须与语言紧密结合，是顺畅交流的一个条件。<br>如何确认找到了合适的语言？重新审视观念的外在来源，理清思路。<br>语言要忠实表达出客观事物的本来面貌，从而使我们的沟通有坚实的事实基础。<br>主观事实不是现实得真实情况，主观事实揭示了思想状态。</p>
<h4 id="7-有效沟通"><a href="#7-有效沟通" class="headerlink" title="7.有效沟通"></a>7.有效沟通</h4><p>在逻辑学中，陈述只针对可以判断真假的命题。<br>词语是语言的基石，逻辑的基础是命题。</p>
<ol>
<li>观念清晰，思维有条理。思维混乱带不来有效沟通。</li>
<li>观念正确</li>
<li>语言准确表达观念</li>
<li>不要想当然地认为听众会领悟我们没有直接表达的意思。比如：背景信息。唠唠叨叨比挂一漏万强。</li>
<li>别人无法把握所要讨论的问题跑题时，得把话题往回收。</li>
<li>说完整的语句。</li>
<li>不要将主观事实当做客观事实。想让主观命题被大家接收，必须为它论证。</li>
<li>避免使用双重否定。容易有歧义。</li>
<li>根据对象选择合适的语言。讲述方与对象对讲述的语言理解相同。专业人士之间可讲名词，专业人士给普通人讲通俗语言。</li>
<li>避免使用模糊和多义的语言。范围不要过大。如：不喜欢那种音乐（摇滚），这个椅子（躺椅）挺好的。</li>
<li>避免使用闪避式语言<h4 id="10-真相"><a href="#10-真相" class="headerlink" title="10.真相"></a>10.真相</h4>有些情况下，真相难以捉摸。但我们不能放弃追寻真相。<br>真相有两种基本形态：</li>
</ol>
<ul>
<li>本体真相。本体真相更基础。指的是关乎存在的真相。</li>
<li>逻辑真相。逻辑学家直接关注的真相形式。仅仅是关乎命题的真理性。<br>命题的定义：可以做出真假判断的语言表述。<br>一个命题如果真实的反映了客观世界，那就为真。<br>真命题的作用：将大脑中的观念（主观事实）以语言为媒介，对应到相应事物的真实状态（客观事实）。</li>
</ul>
<p>在任 何 情况下， 对 真相 的 确认 都要 去 检查 别人 所 认定 或 推测 所得 的 真相 在 现实 中 是否 存在 依据。 确认 真相 就是 要 达到 主观 与 客观 的 统一。</p>
<p>语言描述是否与客观事实对应。对应即真相。<br><strong>谎言</strong>：脑子里清楚现实世界的真相，也能够用语言去表达，表述时却有意的欺瞒篡改。<br>符合论，语言是否与客观事实对应。<br>融贯学，语言描述是否与已被证明的思想、学说对应。<br>    即使已被证明，思想和学说仍可能是错的。<br>    可能某一理论已经过时，不符合现实世界。</p>
<h3 id="1-学习逻辑学的思想准备-总结"><a href="#1-学习逻辑学的思想准备-总结" class="headerlink" title="1.学习逻辑学的思想准备-总结"></a>1.学习逻辑学的思想准备-总结</h3><p>人与外界连接过程：<br>精神活动 ➡️  观念 ➡️  语言 ➡️   事物</p>
<h3 id="2-逻辑的基本原理"><a href="#2-逻辑的基本原理" class="headerlink" title="2.逻辑的基本原理"></a>2.逻辑的基本原理</h3><p>四个基本原理。</p>
<h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h4><p>同一律<br>排中律<br>充足理由律<br>矛盾律</p>
<h4 id="2-灰色地带及人为灰色地带"><a href="#2-灰色地带及人为灰色地带" class="headerlink" title="2.灰色地带及人为灰色地带"></a>2.灰色地带及人为灰色地带</h4><p>不要把灰色地带当成世界的全部。<br>灰色地带只是因为我们没有看清楚。<br>灰色地带是短暂的。</p>
<h4 id="3-万物终有其根源"><a href="#3-万物终有其根源" class="headerlink" title="3.万物终有其根源"></a>3.万物终有其根源</h4><p>原因和结果之间有一部分特性是相同的。</p>
<h4 id="4-对原因的探寻不要半途而废"><a href="#4-对原因的探寻不要半途而废" class="headerlink" title="4.对原因的探寻不要半途而废"></a>4.对原因的探寻不要半途而废</h4><h4 id="5-区分原因"><a href="#5-区分原因" class="headerlink" title="5.区分原因"></a>5.区分原因</h4><p>动力因。背景<br>目的因。即作用<br>质料因。组成原料<br>形式因。特性</p>
<h4 id="6-定义术语"><a href="#6-定义术语" class="headerlink" title="6.定义术语"></a>6.定义术语</h4><p>如何定义：</p>
<ol>
<li>先把其归类到最相近的分类。</li>
<li>再指出本类中与其他事物的不同。<h4 id="7-直言命题"><a href="#7-直言命题" class="headerlink" title="7.直言命题"></a>7.直言命题</h4></li>
</ol>
<h4 id="8-普遍命题"><a href="#8-普遍命题" class="headerlink" title="8.普遍命题"></a>8.普遍命题</h4><h3 id="3-逻辑表现形式"><a href="#3-逻辑表现形式" class="headerlink" title="3.逻辑表现形式"></a>3.逻辑表现形式</h3><h4 id="1-创建一个论证"><a href="#1-创建一个论证" class="headerlink" title="1.创建一个论证"></a>1.创建一个论证</h4><p>一个命题是前提，另一个是结论</p>
<h4 id="2-全称到特称"><a href="#2-全称到特称" class="headerlink" title="2.全称到特称"></a>2.全称到特称</h4><p>全称可以到特称。马都是脊椎动物。➡️   有些马是脊椎动物。</p>
<h4 id="3-特称到全称"><a href="#3-特称到全称" class="headerlink" title="3.特称到全称"></a>3.特称到全称</h4><p>特称不可以到全称。<br>特称到全称可以加模糊词。全村的人<strong>可能</strong>都是黄头发，蓝眼睛。</p>
<h4 id="4-断言"><a href="#4-断言" class="headerlink" title="4.断言"></a>4.断言</h4><p>断言描述事实关联性的过程。</p>
<h4 id="5-否定命题"><a href="#5-否定命题" class="headerlink" title="5.否定命题"></a>5.否定命题</h4><p>缺点：不够直观。<br>优点：委婉。 这个事不是不行。</p>
<h4 id="6-比较"><a href="#6-比较" class="headerlink" title="6.比较"></a>6.比较</h4><p>比较，判断，反映。<br>判断是一种精神活动，通过观念的链接，使我们对客观世界作出连贯的描述。<br>判断是命题的基础。<br>一个判断真实反映了客观世界事物之间的联系，这个判断是正确的。<br>反映在命题中是基础，将观念联结在一起反映事物之间联系。<br>比较任何两个事物，起决定作用的是特征的重要性，特征的数量次要一些。主要特性被遗漏，不能得出可靠结论。</p>
<h4 id="7-比较和论证"><a href="#7-比较和论证" class="headerlink" title="7.比较和论证"></a>7.比较和论证</h4><p>将论证放到比较中。<br>类比论<br>用在哪？<br>    - A与B，无法直接得出B；<br>    - 未来要发生的，如：根据越南战争推测美国怎样做也会发生战争。<br>定义：基于两个事物拥有大量相同特性的事实，当其中一个事物具有其他某个特性时，很可能另一个事物也同时具有。</p>
<h4 id="8-正确论证"><a href="#8-正确论证" class="headerlink" title="8.正确论证"></a>8.正确论证</h4><p>正确论证的两个基本要素：前提和结论。<br>论证提供给我们知识的可靠性远远高于权威。<br>正确论证，我们依靠自己知道了一些东西是正确的。我们知其然，也知其所以然。<br>正确论证依靠事实（内容）和形式（结构）。<br>真实性针对命题的内容，有效性针对命题的形式。</p>
<p>三种简单的论证形式：<br>联言论证、选言论证、条件论证。</p>
<ul>
<li>联言论证。<br>  A·B<br>  安娜是明尼苏达大学二年级的学生，主修生物学。</li>
<li>选言论证。<br>  AvB<br>  阿迪尔昨晚或者是坐火车去了华盛顿，或者是坐飞机。</li>
<li>条件论证<h4 id="9-条件论证"><a href="#9-条件论证" class="headerlink" title="9.条件论证"></a>9.条件论证</h4>条件论证又称假言论证。<br>A→B，A，所以B<br>A-&gt;B，-B，所以-A<br>大前提A→B告诉我们如果A（无论它是什么）成立，那么B也必然成立。</li>
</ul>
<p>现实生活中，严格逻辑学意义上的条件论证真的很少。在我们的论证中，鲜有在前提和结论之间存在必然联系的情况。这样造成的结果是，即使前提实现，我们也不一定能得到论证中的结论。但这并不意味着条件论证是没有意义的，即使它看起来并不总是带来必然的结果。在我们大量使用的条件论证中，结论只是众多可能性中的一个。我们的目标是尽可能严谨地建立我们的论证，保证结论出现的最大可能性。</p>
<p>条件论证是具有前瞻性的，可靠的预言来自于对过去事实的积累。</p>
<h4 id="10-三段论"><a href="#10-三段论" class="headerlink" title="10.三段论"></a>10.三段论</h4><p>每一个M都是P。每一个S都是M。所以，每一个S都是P。<br>第一个命题是大前提，第二个命题是小前提，第三个是结论。<br>M代表中项，P代表大项，S代表小项。<br>M是桥梁。</p>
<h4 id="11-前提的真实性"><a href="#11-前提的真实性" class="headerlink" title="11.前提的真实性"></a>11.前提的真实性</h4><p>错误的前提会带来错误的结论。</p>
<h4 id="12-前提的相关性"><a href="#12-前提的相关性" class="headerlink" title="12.前提的相关性"></a>12.前提的相关性</h4><p>前提与结论的相关性。前提不支持结论，前提会失去作用。</p>
<h4 id="13-事实命题，价值命题"><a href="#13-事实命题，价值命题" class="headerlink" title="13.事实命题，价值命题"></a>13.事实命题，价值命题</h4><p>音乐家是演奏音乐的人”，是个千真万确的命题。<br>音乐家都是杰出的人”，这个命题不是关于事实而是关于价值的，它反映了提出命题的人的观点（主观）。</p>
<h4 id="14-论证结构"><a href="#14-论证结构" class="headerlink" title="14.论证结构"></a>14.论证结构</h4><p>主项、谓项；周延性</p>
<h4 id="15-结论必须反映前提的量"><a href="#15-结论必须反映前提的量" class="headerlink" title="15.结论必须反映前提的量"></a>15.结论必须反映前提的量</h4><p>命题的量指的是它是全称还是特称。命题的量取决于它的主项。</p>
<p>在结论中，命题的量必须以更绝对的量展现出来。结论是全称，则前提必须是全称。<br>两个特称前提无法得出必然结果。中项无法联结大项和小项。</p>
<h4 id="16-结论必须反映前提的质"><a href="#16-结论必须反映前提的质" class="headerlink" title="16.结论必须反映前提的质"></a>16.结论必须反映前提的质</h4><p>命题的质指的是肯定还是否定。</p>
<p>两个否定前提无法得出肯定结论。<br>两个肯定前提无法得出否定结论。</p>
<h4 id="17-归纳论证-总结"><a href="#17-归纳论证-总结" class="headerlink" title="17.归纳论证-总结"></a>17.归纳论证-总结</h4><p>演绎论证：一般到个别。全称到特称；整体到部分；普遍的事实到组成等部分。<br>演绎论证的前提：通常是全称命题。<br>演绎论证结论：必然性结论。<br>演绎论证的基本原理：从一个我们知道的命题（大前提）开始，经过抽丝剥茧的分析（通过小前提得出结论）得出原始命题后隐含的是什么。</p>
<p>归纳论证：个别到一般。特称到全称；部分到整体。<br>归纳论证的前提：一系列特称命题。<br>归纳论证的结论：可能性结论。</p>
<p>归纳论证的步骤：<br>    1.假设，假设事物是什么样子的推测。假设来源：1.某次偶然观察；2.长期研究测算<br>    2.以整体中的某一部分作为样本研究，以此代替整体。样本范围的大小决定了它的代表性。<br>归纳论证作用（目的）：举一反三，对大量的事物做出可信的一般性结论。</p>
<h4 id="18-评定论证-记录"><a href="#18-评定论证-记录" class="headerlink" title="18.评定论证-记录"></a>18.评定论证-记录</h4><p>？前提：证据不充足的前提只是观点。<br>实体生活中的前提：经常会遇到部分为真。</p>
<h4 id="18-评定论证-总结"><a href="#18-评定论证-总结" class="headerlink" title="18.评定论证-总结"></a>18.评定论证-总结</h4><p>评定步骤：</p>
<ol>
<li>是否有明确的前提和结论</li>
<li>前提是否证据充足</li>
<li>前提是否正确</li>
<li>前提与结论是否强相关</li>
<li>论证结构是否合理<ol>
<li>必然性结论</li>
<li>可能性结论。可靠性评定：前提信息的可靠程度。</li>
</ol>
</li>
<li>论证力量评定：论证对客观规律的反映程度<h4 id="19-构造一个论证-记录"><a href="#19-构造一个论证-记录" class="headerlink" title="19.构造一个论证-记录"></a>19.构造一个论证-记录</h4>论证的目的：得出正确的结论，说服听众接受。<br>说服听众接受，在论证时，需要选择适合于听众的方式。<h3 id="3-逻辑学的语言总结"><a href="#3-逻辑学的语言总结" class="headerlink" title="3.逻辑学的语言总结"></a>3.逻辑学的语言总结</h3>思维导图位置：有道云笔记-430思维-简单的逻辑学<h4 id="19-构造一个论证-总结"><a href="#19-构造一个论证-总结" class="headerlink" title="19.构造一个论证-总结"></a>19.构造一个论证-总结</h4>两个要素：前提和结论。<br>前提：<ul>
<li>真实性。是否可判断命题真假，命题是否为真</li>
<li>是否可被对方接受。<ul>
<li>语言描述。例如：我想告诉一个 老奶奶我是自由职业者，我说：“ 我是soho一族。”</li>
<li>逻辑描述。</li>
</ul>
</li>
<li>力度。<ul>
<li>对结论支持程度。</li>
<li>听众接收到的力度：<ul>
<li>如果几个前提同时支持一个结论，可能没必要全部用上。<br>   原因：前提多了会分散接收人的关注度。<pre><code>  - 去掉支持力度弱的前提，可让接收着关注支持力度强的前提，效果会更好。
  - 多个前提的相关度都很强，也最好不要全部使用，少量前提可让论证重点突出。
</code></pre>
</li>
<li>某些前提对某些特殊的听众有不同寻常的意义，这时候使用特殊前提。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-非逻辑思维的根源"><a href="#4-非逻辑思维的根源" class="headerlink" title="4.非逻辑思维的根源"></a>4.非逻辑思维的根源</h3><h4 id="1-怀疑论-记录"><a href="#1-怀疑论-记录" class="headerlink" title="1.怀疑论-记录"></a>1.怀疑论-记录</h4><p>积极作用：前提有争议时，不接受结论。<br>错误：<br>    极端怀疑论：世界没有真相<br>    中度怀疑论：世界有真相，但人无法探知真相</p>
<h4 id="2-逃避型不可知论-记录"><a href="#2-逃避型不可知论-记录" class="headerlink" title="2.逃避型不可知论-记录"></a>2.逃避型不可知论-记录</h4><p>没有足够的证据可以对某个事物作出确定的判断。<br>既不 否定 真相 的 存在 也不 认为 它可 望而 不可 即。<br>人们对任何确定的事物的真相都所知甚少。</p>
<h4 id="3-悲观和盲目乐观主义-记录"><a href="#3-悲观和盲目乐观主义-记录" class="headerlink" title="3.悲观和盲目乐观主义-记录"></a>3.悲观和盲目乐观主义-记录</h4><p>悲观者假设：<br>    （1） 要 辩论 的 问题是 荒谬 的；<br>    （2） 他的 对手 很 愚蠢；<br>    （3） 辩论 本身 不能 带来 任何 好处。</p>
<h4 id="5-情感和论证-记录"><a href="#5-情感和论证-记录" class="headerlink" title="5.情感和论证-记录"></a>5.情感和论证-记录</h4><p>情绪越紧张，越难有清晰的思维，冷静行动的难度越大。<br>在辩论中，我们必须使论证远离情绪的影响。但成功做到这点很难。事实上，即使我们成功 了， 这也不见得会是一件好事。</p>
<h4 id="6-推理的原因-记录"><a href="#6-推理的原因-记录" class="headerlink" title="6.推理的原因-记录"></a>6.推理的原因-记录</h4><p> 如果 一个 人的 思维 起点 本身 是 扭曲 的（ 即 不 反映 物质 世界 的 客观规律）， 那么 即使 推理 做到 了 和他 的 思维 保持 统一， 同样是 不合逻辑 的。</p>
<h4 id="7-论证不是争吵-记录"><a href="#7-论证不是争吵-记录" class="headerlink" title="7.论证不是争吵-记录"></a>7.论证不是争吵-记录</h4><p>论证 是 理性 的 探讨， 不要 将它 和 争吵 混为一谈。<br>论证 的 目的 是 发现 真相， 争吵 的 目的 是 击败 你的 对手。<br>    有 许多人， 虽然 他们 愿意 和你 争吵， 但却 不愿意 或者 没能 力 和你 进行 论证。 不要 浪费时间、 精力 和 这种 人进行 争论。</p>
<h4 id="9-常识-记录"><a href="#9-常识-记录" class="headerlink" title="9.常识-记录"></a>9.常识-记录</h4><p>逻辑， 生于 常识， 但又 高于 常识。 逻辑思维 的 出现 以及 对 非逻辑 思维 的 避免， 都 根植 于 常识 的 某 一面。 常识 是对 日常生活 中 显而易见 的 事物 的 敏锐 洞悉。 它以 可靠 的 辨别 力 为 标志， 以 语言 作为 首要 的 揭示 事物 的 方式， 不 欺瞒， 将 语言 的 作用 定位 于 表达 而 不是 炫耀。 常识 更 接近 本源， 服务于 推理 的 基本原则。</p>
<h3 id="5-非逻辑思维的主要形式"><a href="#5-非逻辑思维的主要形式" class="headerlink" title="5.非逻辑思维的主要形式"></a>5.非逻辑思维的主要形式</h3><p>错误推理可通过直接作用于人的情感的方式来战胜正确推理。</p>
<h4 id="1-否定前件"><a href="#1-否定前件" class="headerlink" title="1.否定前件"></a>1.否定前件</h4><p>条件论证中的无效形式：否定前件得出否定后件<br>举例：<br>    如果路易斯在跑步，那么他在移动。<br>    路易斯没有跑步。<br>    结论：他没有移动。</p>
<pre><code>路易斯跑步是他移动的充分非必要条件。否定A得不出否定B。
</code></pre>
<h4 id="2-肯定后件"><a href="#2-肯定后件" class="headerlink" title="2.肯定后件"></a>2.肯定后件</h4><p>条件论证中的无效形式：肯定后件得出肯定前件。<br>举例：<br>    如果路易斯在跑步，那么他在移动。<br>    路易斯在移动。<br>    结论：他在跑步。</p>
<pre><code>大前提是A → B，例子中却是 B → A。
</code></pre>
<h4 id="3-中项不周延"><a href="#3-中项不周延" class="headerlink" title="3.中项不周延"></a>3.中项不周延</h4><p>三段论中的大前提和小前提中的中项不是全称。<br>举例：<br>    几个纳粹党人是恺撒俱乐部的成员。<br>    张三是恺撒俱乐部的成员。<br>    结论：张三是纳粹党人。<br>    中项：恺撒俱乐部在大前提中的纳粹党人是特称，没有周延性</p>
<h4 id="4-偷换概念"><a href="#4-偷换概念" class="headerlink" title="4.偷换概念"></a>4.偷换概念</h4><p>三段论中的中项用了多义词、多义字、有广泛含义的词、有广泛含义的字。<br>举例：<br>    鬼是迷信的人所说的人死后的灵魂。<br>    他目标闪烁，心里有鬼。<br>    所以，他心里有人死后的灵魂。</p>
<pre><code>小前提心里有鬼的鬼的含义是不光明的事物，和大前提中的鬼的含义不同。
</code></pre>
<p>有意使用多义词不一定都是恶意的，可能只是为了幽默。</p>
<p>举例：<br>    关爱他人是利他主义的标志。<br>    唐璜是博爱者。<br>    所以，唐璜是利他主义者。</p>
<pre><code>爱的含义太广泛，此处小前提的爱是花花公子的意思。
</code></pre>
<h4 id="5-窃取论题"><a href="#5-窃取论题" class="headerlink" title="5.窃取论题"></a>5.窃取论题</h4><p>前提和结论意思相同。相当于用结论推导结论。<br>举例：<br>    因为雪梨撒过谎，<br>    所以，雪梨是个撒谎者。</p>
<h4 id="6-虚假假设"><a href="#6-虚假假设" class="headerlink" title="6.虚假假设"></a>6.虚假假设</h4><p>用假设推导结论，后来发现假设是错误的。</p>
<h4 id="7-稻草人谬误"><a href="#7-稻草人谬误" class="headerlink" title="7.稻草人谬误"></a>7.稻草人谬误</h4><p>与人争辩，为了削弱对方的论点而故意扭曲其论证过程。？？？</p>
<h4 id="8-误用传统"><a href="#8-误用传统" class="headerlink" title="8.误用传统"></a>8.误用传统</h4><p>以前的事情都是这么处理的，并不能成为强制后来者遵循老方法的充分理由。</p>
<p>但对于 传统， 如果 将 历史 悠久 作为 坚持 传统 的 唯一 原因 是 不合逻辑 的，那么 将 历史 悠久 作为 拒绝 传统 的 唯一 理由 同样 也 不合逻辑。</p>
<h4 id="9-以暴制暴"><a href="#9-以暴制暴" class="headerlink" title="9.以暴制暴"></a>9.以暴制暴</h4><p>他们先做了，我们应该以牙还牙。</p>
<h4 id="10-民主谬误"><a href="#10-民主谬误" class="headerlink" title="10.民主谬误"></a>10.民主谬误</h4><p>解释：一个给定的社会中，大多数人认为是正确的命题。自己也认为是正确的。<br>民主谬误在情感上有很强的说服力。</p>
<h4 id="11-对人不对事"><a href="#11-对人不对事" class="headerlink" title="11.对人不对事"></a>11.对人不对事</h4><p>解释：与他人辩论时，通过想观众传达对手与论证无关的信息，比如生活中的负面信息，以此达到击败对手的目的。</p>
<p>如果论证的目的只是为了获胜，对人不对事谬误将会有效地发挥作用。<br>这种胜利并非源于观点的价值，而是扰乱观众视听的能力。</p>
<h4 id="12-压制理性"><a href="#12-压制理性" class="headerlink" title="12.压制理性"></a>12.压制理性</h4><p>通过强制而不是理性说服他人，强迫别人想不愿去想的事情。<br>人只有在独立思考、独立判断的情况下才能确定什么是真。</p>
<h4 id="13-滥用专家意见"><a href="#13-滥用专家意见" class="headerlink" title="13.滥用专家意见"></a>13.滥用专家意见</h4><p>专家给了意见，我们需要追问给出意见的理由。<br>对于专家给的意见，我们需要论证。<br>如果 我们 仅仅 满足于 专家 的 话， 那么 本质上 就是：“ 不要 问 任何 问题， 按照 我们 的 话 去做。”<br>一个专家只有在其已经建立微信的领域内做出的主张，才是值得我们关注的。</p>
<h4 id="14-质的量化错误"><a href="#14-质的量化错误" class="headerlink" title="14.质的量化错误"></a>14.质的量化错误</h4><p>举例1：<br>    将体感温度量化，体感温度包含：温度、风力、湿度。<br>    假设昨天是39℃，今天是40℃。只以温度量化体感温度今天比昨天热，但实际因为别的因素，可能今天比昨天凉快。<br>举例2：<br>    对爱、美丽、善良、公正、自由、正义、和平量化是对它们的亵渎。</p>
<p>从严格意义上质无法准确量化。如果质量可以完美的被数量表示，那么数量和质量之间界限的基础就会消失。<br>我们 在 纵容 一种 关于 精度 的 假象， 似乎 只要 质量 被 量化 了， 我们 就能 更好 地 了解 它。</p>
<h4 id="15-以出身论英雄"><a href="#15-以出身论英雄" class="headerlink" title="15.以出身论英雄"></a>15.以出身论英雄</h4><p>某个学校出的学生大部分都不好。这个学校的学生投了简历给我，我认为学生不好。<br>这个学生不好不是必然成立。</p>
<p>实际情况下，我们应该认为的是，不值得判断这个学生好不好花费很多时间和精力。</p>
<h4 id="16-分析不到位"><a href="#16-分析不到位" class="headerlink" title="16.分析不到位"></a>16.分析不到位</h4><p>分解只能针对合成的产物，仅仅分解是不够的，还要能把他们重新组装成整体。</p>
<p>分析除了要分析出整体中的每一个部分，还要了解部分之间的相互作用、相互联系，最终组装成一个整体。</p>
<h4 id="17-简化主义"><a href="#17-简化主义" class="headerlink" title="17.简化主义"></a>17.简化主义</h4><p>一个整体大于其组成部分的和。<br>举例：<br>    人的身体可以根据化学元素被分解，生成称人的身体等同于一堆化学元素。<br>这种谬误发生于我们只对整体的一部分加以关注。</p>
<h4 id="18-分类错误"><a href="#18-分类错误" class="headerlink" title="18.分类错误"></a>18.分类错误</h4><p>举例：<br>    苹果当成橙子。<br>    图书馆中书的错误分类可能导致几年找不到。</p>
<h4 id="19-混淆视听"><a href="#19-混淆视听" class="headerlink" title="19.混淆视听"></a>19.混淆视听</h4><p>故意提出一些无关的情感信息来分散对方的注意力。<br>    1.直接诉诸情感，而不是推理。<br>    2.所提供的信息与所要进行的论证毫不相关。</p>
<h4 id="20-以笑饰非"><a href="#20-以笑饰非" class="headerlink" title="20.以笑饰非"></a>20.以笑饰非</h4><p>无法应对论证时，让人们嘲笑每个论证。</p>
<p>让人们嘲笑论证是反对论证强有力的方式。</p>
<h4 id="21-以泪掩过"><a href="#21-以泪掩过" class="headerlink" title="21.以泪掩过"></a>21.以泪掩过</h4><p>转移注意力到主论证的外围问题，并博取同情，达到听众支持主论证的目的</p>
<h4 id="22-无法反驳"><a href="#22-无法反驳" class="headerlink" title="22.无法反驳"></a>22.无法反驳</h4><p>无法反驳也无法证明的命题是猜想，而不是正确论点。</p>
<h4 id="23-两难陷阱"><a href="#23-两难陷阱" class="headerlink" title="23.两难陷阱"></a>23.两难陷阱</h4><h4 id="24-以先后论因果"><a href="#24-以先后论因果" class="headerlink" title="24.以先后论因果"></a>24.以先后论因果</h4><p>举例：<br>    鸟先唱歌，太阳后升起来。<br>    得出鸟唱歌是太阳升起的条件。</p>
<h4 id="25-情感误导"><a href="#25-情感误导" class="headerlink" title="25.情感误导"></a>25.情感误导</h4><p>忽略与我们的信仰或喜欢的东西负面的信息。</p>
<h4 id="26-功利误导"><a href="#26-功利误导" class="headerlink" title="26.功利误导"></a>26.功利误导</h4><p>为达目的，不择手段。仅仅关注一个方法对想要得到结果的作用，而不考虑其他方面。</p>
<h4 id="27-避免结论"><a href="#27-避免结论" class="headerlink" title="27.避免结论"></a>27.避免结论</h4><p>人们推理的目的，发现问题，研究其解决之道。<br>若果论证的目的只是为了使自己听到自己在说什么，那是将论证庸俗化的。</p>
<h4 id="28-简化推理-记录"><a href="#28-简化推理-记录" class="headerlink" title="28.简化推理-记录"></a>28.简化推理-记录</h4><p>同17简化主义<br>一部分人的接受能力只在自己想听的范围内。一部分人只想听自己喜欢的答案，这往往是愤世嫉俗者的特点。</p>
<h2 id="其他书"><a href="#其他书" class="headerlink" title="其他书"></a>其他书</h2><p>影响力。作者西奥迪尼将社会现象通过基础逻辑串联起来， 就解释了人们互相影响的基本 规律。<br>风格的要素-写作</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>简单的逻辑学</tag>
      </tags>
  </entry>
</search>
